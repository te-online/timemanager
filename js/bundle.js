(function () {
    'use strict';

    (function() {
        const env = {"NODE_ENV":"production"};
        try {
            if (process) {
                process.env = Object.assign({}, process.env);
                Object.assign(process.env, env);
                return;
            }
        } catch (e) {} // avoid ReferenceError: process is not defined
        globalThis.process = { env:env };
    })();

    function ownKeys$2(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {
          _defineProperty$x(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }

      return target;
    }

    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }

      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }

    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
            args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);

          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }

          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }

          _next(undefined);
        });
      };
    }

    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$1(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$1(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$1(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }

    function _defineProperty$x(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }

      return _assertThisInitialized(self);
    }

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;

          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return _possibleConstructorReturn(this, result);
      };
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _iterableToArrayLimit(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;

      var _s, _e;

      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;

          var F = function () {};

          return {
            s: F,
            n: function () {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function (e) {
              throw e;
            },
            f: F
          };
        }

        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      var normalCompletion = true,
          didErr = false,
          err;
      return {
        s: function () {
          it = it.call(o);
        },
        n: function () {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function (e) {
          didErr = true;
          err = e;
        },
        f: function () {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }

    var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule$1(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var check$1 = function (it) {
      return it && it.Math == Math && it;
    }; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


    var global_1 = // eslint-disable-next-line es-x/no-global-this -- safe
    check$1(typeof globalThis == 'object' && globalThis) || check$1(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check$1(typeof self == 'object' && self) || check$1(typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1) || // eslint-disable-next-line no-new-func -- fallback
    function () {
      return this;
    }() || Function('return this')();

    // eslint-disable-next-line es-x/no-object-defineproperty -- safe


    var defineProperty$7 = Object.defineProperty;

    var setGlobal$1 = function (key, value) {
      try {
        defineProperty$7(global_1, key, {
          value: value,
          configurable: true,
          writable: true
        });
      } catch (error) {
        global_1[key] = value;
      }

      return value;
    };

    var SHARED$1 = '__core-js_shared__';
    var store$3 = global_1[SHARED$1] || setGlobal$1(SHARED$1, {});
    var sharedStore$1 = store$3;

    var shared$1 = createCommonjsModule$1(function (module) {
    (module.exports = function (key, value) {
      return sharedStore$1[key] || (sharedStore$1[key] = value !== undefined ? value : {});
    })('versions', []).push({
      version: '3.22.4',
      mode: 'global',
      copyright: 'Â© 2014-2022 Denis Pushkarev (zloirock.ru)',
      license: 'https://github.com/zloirock/core-js/blob/v3.22.4/LICENSE',
      source: 'https://github.com/zloirock/core-js'
    });
    });

    var fails$1 = function (exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };

    var functionBindNative = !fails$1(function () {
      // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
      var test = function () {
        /* empty */
      }.bind(); // eslint-disable-next-line no-prototype-builtins -- safe


      return typeof test != 'function' || test.hasOwnProperty('prototype');
    });

    var FunctionPrototype$2 = Function.prototype;
    var bind$3 = FunctionPrototype$2.bind;
    var call$2 = FunctionPrototype$2.call;
    var uncurryThis = functionBindNative && bind$3.bind(call$2, call$2);
    var functionUncurryThis = functionBindNative ? function (fn) {
      return fn && uncurryThis(fn);
    } : function (fn) {
      return fn && function () {
        return call$2.apply(fn, arguments);
      };
    };

    var TypeError$h = global_1.TypeError; // `RequireObjectCoercible` abstract operation
    // https://tc39.es/ecma262/#sec-requireobjectcoercible

    var requireObjectCoercible$1 = function (it) {
      if (it == undefined) throw TypeError$h("Can't call method on " + it);
      return it;
    };

    var Object$5 = global_1.Object; // `ToObject` abstract operation
    // https://tc39.es/ecma262/#sec-toobject

    var toObject$1 = function (argument) {
      return Object$5(requireObjectCoercible$1(argument));
    };

    var hasOwnProperty$2 = functionUncurryThis({}.hasOwnProperty); // `HasOwnProperty` abstract operation
    // https://tc39.es/ecma262/#sec-hasownproperty
    // eslint-disable-next-line es-x/no-object-hasown -- safe

    var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty$2(toObject$1(it), key);
    };

    var id$1 = 0;
    var postfix$1 = Math.random();
    var toString$3 = functionUncurryThis(1.0.toString);

    var uid$1 = function (key) {
      return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$3(++id$1 + postfix$1, 36);
    };

    // `IsCallable` abstract operation
    // https://tc39.es/ecma262/#sec-iscallable
    var isCallable = function (argument) {
      return typeof argument == 'function';
    };

    var aFunction$2 = function (argument) {
      return isCallable(argument) ? argument : undefined;
    };

    var getBuiltIn$1 = function (namespace, method) {
      return arguments.length < 2 ? aFunction$2(global_1[namespace]) : global_1[namespace] && global_1[namespace][method];
    };

    var engineUserAgent$1 = getBuiltIn$1('navigator', 'userAgent') || '';

    var process$5 = global_1.process;
    var Deno$1 = global_1.Deno;
    var versions$1 = process$5 && process$5.versions || Deno$1 && Deno$1.version;
    var v8$1 = versions$1 && versions$1.v8;
    var match$9, version$1;

    if (v8$1) {
      match$9 = v8$1.split('.'); // in old Chrome, versions of V8 isn't V8 = Chrome / 10
      // but their correct versions are not interesting for us

      version$1 = match$9[0] > 0 && match$9[0] < 4 ? 1 : +(match$9[0] + match$9[1]);
    } // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
    // so check `userAgent` even if `.v8` exists, but 0


    if (!version$1 && engineUserAgent$1) {
      match$9 = engineUserAgent$1.match(/Edge\/(\d+)/);

      if (!match$9 || match$9[1] >= 74) {
        match$9 = engineUserAgent$1.match(/Chrome\/(\d+)/);
        if (match$9) version$1 = +match$9[1];
      }
    }

    var engineV8Version$1 = version$1;

    /* eslint-disable es-x/no-symbol -- required for testing */


     // eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing


    var nativeSymbol$1 = !!Object.getOwnPropertySymbols && !fails$1(function () {
      var symbol = Symbol(); // Chrome 38 Symbol has incorrect toString conversion
      // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances

      return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && engineV8Version$1 && engineV8Version$1 < 41;
    });

    /* eslint-disable es-x/no-symbol -- required for testing */


    var useSymbolAsUid$1 = nativeSymbol$1 && !Symbol.sham && typeof Symbol.iterator == 'symbol';

    var WellKnownSymbolsStore$1 = shared$1('wks');
    var Symbol$2 = global_1.Symbol;
    var symbolFor = Symbol$2 && Symbol$2['for'];
    var createWellKnownSymbol$1 = useSymbolAsUid$1 ? Symbol$2 : Symbol$2 && Symbol$2.withoutSetter || uid$1;

    var wellKnownSymbol$1 = function (name) {
      if (!hasOwnProperty_1(WellKnownSymbolsStore$1, name) || !(nativeSymbol$1 || typeof WellKnownSymbolsStore$1[name] == 'string')) {
        var description = 'Symbol.' + name;

        if (nativeSymbol$1 && hasOwnProperty_1(Symbol$2, name)) {
          WellKnownSymbolsStore$1[name] = Symbol$2[name];
        } else if (useSymbolAsUid$1 && symbolFor) {
          WellKnownSymbolsStore$1[name] = symbolFor(description);
        } else {
          WellKnownSymbolsStore$1[name] = createWellKnownSymbol$1(description);
        }
      }

      return WellKnownSymbolsStore$1[name];
    };

    var TO_STRING_TAG$7 = wellKnownSymbol$1('toStringTag');
    var test$1 = {};
    test$1[TO_STRING_TAG$7] = 'z';
    var toStringTagSupport$1 = String(test$1) === '[object z]';

    // Detect IE8's incomplete defineProperty implementation


    var descriptors$1 = !fails$1(function () {
      // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
      return Object.defineProperty({}, 1, {
        get: function () {
          return 7;
        }
      })[1] != 7;
    });

    var isObject$3 = function (it) {
      return typeof it == 'object' ? it !== null : isCallable(it);
    };

    var document$4 = global_1.document; // typeof document.createElement is 'object' in old IE

    var EXISTS$2 = isObject$3(document$4) && isObject$3(document$4.createElement);

    var documentCreateElement$1 = function (it) {
      return EXISTS$2 ? document$4.createElement(it) : {};
    };

    // Thanks to IE8 for its funny defineProperty


    var ie8DomDefine$1 = !descriptors$1 && !fails$1(function () {
      // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
      return Object.defineProperty(documentCreateElement$1('div'), 'a', {
        get: function () {
          return 7;
        }
      }).a != 7;
    });

    // V8 ~ Chrome 36-
    // https://bugs.chromium.org/p/v8/issues/detail?id=3334


    var v8PrototypeDefineBug = descriptors$1 && fails$1(function () {
      // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
      return Object.defineProperty(function () {
        /* empty */
      }, 'prototype', {
        value: 42,
        writable: false
      }).prototype != 42;
    });

    var String$5 = global_1.String;
    var TypeError$g = global_1.TypeError; // `Assert: Type(argument) is Object`

    var anObject$1 = function (argument) {
      if (isObject$3(argument)) return argument;
      throw TypeError$g(String$5(argument) + ' is not an object');
    };

    var call$1 = Function.prototype.call;
    var functionCall = functionBindNative ? call$1.bind(call$1) : function () {
      return call$1.apply(call$1, arguments);
    };

    var objectIsPrototypeOf = functionUncurryThis({}.isPrototypeOf);

    var Object$4 = global_1.Object;
    var isSymbol = useSymbolAsUid$1 ? function (it) {
      return typeof it == 'symbol';
    } : function (it) {
      var $Symbol = getBuiltIn$1('Symbol');
      return isCallable($Symbol) && objectIsPrototypeOf($Symbol.prototype, Object$4(it));
    };

    var String$4 = global_1.String;

    var tryToString = function (argument) {
      try {
        return String$4(argument);
      } catch (error) {
        return 'Object';
      }
    };

    var TypeError$f = global_1.TypeError; // `Assert: IsCallable(argument) is true`

    var aCallable = function (argument) {
      if (isCallable(argument)) return argument;
      throw TypeError$f(tryToString(argument) + ' is not a function');
    };

    // `GetMethod` abstract operation
    // https://tc39.es/ecma262/#sec-getmethod


    var getMethod = function (V, P) {
      var func = V[P];
      return func == null ? undefined : aCallable(func);
    };

    var TypeError$e = global_1.TypeError; // `OrdinaryToPrimitive` abstract operation
    // https://tc39.es/ecma262/#sec-ordinarytoprimitive

    var ordinaryToPrimitive = function (input, pref) {
      var fn, val;
      if (pref === 'string' && isCallable(fn = input.toString) && !isObject$3(val = functionCall(fn, input))) return val;
      if (isCallable(fn = input.valueOf) && !isObject$3(val = functionCall(fn, input))) return val;
      if (pref !== 'string' && isCallable(fn = input.toString) && !isObject$3(val = functionCall(fn, input))) return val;
      throw TypeError$e("Can't convert object to primitive value");
    };

    var TypeError$d = global_1.TypeError;
    var TO_PRIMITIVE = wellKnownSymbol$1('toPrimitive'); // `ToPrimitive` abstract operation
    // https://tc39.es/ecma262/#sec-toprimitive

    var toPrimitive$1 = function (input, pref) {
      if (!isObject$3(input) || isSymbol(input)) return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;

      if (exoticToPrim) {
        if (pref === undefined) pref = 'default';
        result = functionCall(exoticToPrim, input, pref);
        if (!isObject$3(result) || isSymbol(result)) return result;
        throw TypeError$d("Can't convert object to primitive value");
      }

      if (pref === undefined) pref = 'number';
      return ordinaryToPrimitive(input, pref);
    };

    // `ToPropertyKey` abstract operation
    // https://tc39.es/ecma262/#sec-topropertykey


    var toPropertyKey = function (argument) {
      var key = toPrimitive$1(argument, 'string');
      return isSymbol(key) ? key : key + '';
    };

    var TypeError$c = global_1.TypeError; // eslint-disable-next-line es-x/no-object-defineproperty -- safe

    var $defineProperty$1 = Object.defineProperty; // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe

    var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = 'enumerable';
    var CONFIGURABLE$1 = 'configurable';
    var WRITABLE = 'writable'; // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty

    var f$b = descriptors$1 ? v8PrototypeDefineBug ? function defineProperty(O, P, Attributes) {
      anObject$1(O);
      P = toPropertyKey(P);
      anObject$1(Attributes);

      if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor$2(O, P);

        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }

      return $defineProperty$1(O, P, Attributes);
    } : $defineProperty$1 : function defineProperty(O, P, Attributes) {
      anObject$1(O);
      P = toPropertyKey(P);
      anObject$1(Attributes);
      if (ie8DomDefine$1) try {
        return $defineProperty$1(O, P, Attributes);
      } catch (error) {
        /* empty */
      }
      if ('get' in Attributes || 'set' in Attributes) throw TypeError$c('Accessors not supported');
      if ('value' in Attributes) O[P] = Attributes.value;
      return O;
    };

    var objectDefineProperty$1 = {
    	f: f$b
    };

    var createPropertyDescriptor$1 = function (bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
      };
    };

    var createNonEnumerableProperty$1 = descriptors$1 ? function (object, key, value) {
      return objectDefineProperty$1.f(object, key, createPropertyDescriptor$1(1, value));
    } : function (object, key, value) {
      object[key] = value;
      return object;
    };

    var FunctionPrototype$1 = Function.prototype; // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe

    var getDescriptor = descriptors$1 && Object.getOwnPropertyDescriptor;
    var EXISTS$1 = hasOwnProperty_1(FunctionPrototype$1, 'name'); // additional protection from minified / mangled / dropped function names

    var PROPER = EXISTS$1 && function something() {
      /* empty */
    }.name === 'something';

    var CONFIGURABLE = EXISTS$1 && (!descriptors$1 || descriptors$1 && getDescriptor(FunctionPrototype$1, 'name').configurable);
    var functionName = {
      EXISTS: EXISTS$1,
      PROPER: PROPER,
      CONFIGURABLE: CONFIGURABLE
    };

    var functionToString$1 = functionUncurryThis(Function.toString); // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper

    if (!isCallable(sharedStore$1.inspectSource)) {
      sharedStore$1.inspectSource = function (it) {
        return functionToString$1(it);
      };
    }

    var inspectSource$1 = sharedStore$1.inspectSource;

    var WeakMap$3 = global_1.WeakMap;
    var nativeWeakMap$1 = isCallable(WeakMap$3) && /native code/.test(inspectSource$1(WeakMap$3));

    var keys$4 = shared$1('keys');

    var sharedKey$1 = function (key) {
      return keys$4[key] || (keys$4[key] = uid$1(key));
    };

    var hiddenKeys$3 = {};

    var OBJECT_ALREADY_INITIALIZED$1 = 'Object already initialized';
    var TypeError$b = global_1.TypeError;
    var WeakMap$2 = global_1.WeakMap;
    var set$2, get$1, has$2;

    var enforce$1 = function (it) {
      return has$2(it) ? get$1(it) : set$2(it, {});
    };

    var getterFor$1 = function (TYPE) {
      return function (it) {
        var state;

        if (!isObject$3(it) || (state = get$1(it)).type !== TYPE) {
          throw TypeError$b('Incompatible receiver, ' + TYPE + ' required');
        }

        return state;
      };
    };

    if (nativeWeakMap$1 || sharedStore$1.state) {
      var store$2 = sharedStore$1.state || (sharedStore$1.state = new WeakMap$2());
      var wmget$1 = functionUncurryThis(store$2.get);
      var wmhas$1 = functionUncurryThis(store$2.has);
      var wmset$1 = functionUncurryThis(store$2.set);

      set$2 = function (it, metadata) {
        if (wmhas$1(store$2, it)) throw new TypeError$b(OBJECT_ALREADY_INITIALIZED$1);
        metadata.facade = it;
        wmset$1(store$2, it, metadata);
        return metadata;
      };

      get$1 = function (it) {
        return wmget$1(store$2, it) || {};
      };

      has$2 = function (it) {
        return wmhas$1(store$2, it);
      };
    } else {
      var STATE$1 = sharedKey$1('state');
      hiddenKeys$3[STATE$1] = true;

      set$2 = function (it, metadata) {
        if (hasOwnProperty_1(it, STATE$1)) throw new TypeError$b(OBJECT_ALREADY_INITIALIZED$1);
        metadata.facade = it;
        createNonEnumerableProperty$1(it, STATE$1, metadata);
        return metadata;
      };

      get$1 = function (it) {
        return hasOwnProperty_1(it, STATE$1) ? it[STATE$1] : {};
      };

      has$2 = function (it) {
        return hasOwnProperty_1(it, STATE$1);
      };
    }

    var internalState$1 = {
      set: set$2,
      get: get$1,
      has: has$2,
      enforce: enforce$1,
      getterFor: getterFor$1
    };

    var makeBuiltIn_1 = createCommonjsModule$1(function (module) {
    var defineProperty = objectDefineProperty$1.f;

    var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;





    var enforceInternalState = internalState$1.enforce;
    var getInternalState = internalState$1.get;
    var CONFIGURABLE_LENGTH = !fails$1(function () {
      return defineProperty(function () {
        /* empty */
      }, 'length', {
        value: 8
      }).length !== 8;
    });
    var TEMPLATE = String(String).split('String');

    var makeBuiltIn = module.exports = function (value, name, options) {
      if (String(name).slice(0, 7) === 'Symbol(') {
        name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
      }

      if (options && options.getter) name = 'get ' + name;
      if (options && options.setter) name = 'set ' + name;

      if (!hasOwnProperty_1(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        defineProperty(value, 'name', {
          value: name,
          configurable: true
        });
      }

      if (CONFIGURABLE_LENGTH && options && hasOwnProperty_1(options, 'arity') && value.length !== options.arity) {
        defineProperty(value, 'length', {
          value: options.arity
        });
      }

      var state = enforceInternalState(value);

      if (!hasOwnProperty_1(state, 'source')) {
        state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
      }

      return value;
    }; // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
    // eslint-disable-next-line no-extend-native -- required


    Function.prototype.toString = makeBuiltIn(function toString() {
      return isCallable(this) && getInternalState(this).source || inspectSource$1(this);
    }, 'toString');
    });

    var defineBuiltIn = function (O, key, value, options) {
      var unsafe = options ? !!options.unsafe : false;
      var simple = options ? !!options.enumerable : false;
      var noTargetGet = options ? !!options.noTargetGet : false;
      var name = options && options.name !== undefined ? options.name : key;
      if (isCallable(value)) makeBuiltIn_1(value, name, options);

      if (O === global_1) {
        if (simple) O[key] = value;else setGlobal$1(key, value);
        return O;
      } else if (!unsafe) {
        delete O[key];
      } else if (!noTargetGet && O[key]) {
        simple = true;
      }

      if (simple) O[key] = value;else createNonEnumerableProperty$1(O, key, value);
      return O;
    };

    var toString$2 = functionUncurryThis({}.toString);
    var stringSlice$5 = functionUncurryThis(''.slice);

    var classofRaw$1 = function (it) {
      return stringSlice$5(toString$2(it), 8, -1);
    };

    var TO_STRING_TAG$6 = wellKnownSymbol$1('toStringTag');
    var Object$3 = global_1.Object; // ES3 wrong here

    var CORRECT_ARGUMENTS$1 = classofRaw$1(function () {
      return arguments;
    }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

    var tryGet$1 = function (it, key) {
      try {
        return it[key];
      } catch (error) {
        /* empty */
      }
    }; // getting tag from ES6+ `Object.prototype.toString`


    var classof$1 = toStringTagSupport$1 ? classofRaw$1 : function (it) {
      var O, tag, result;
      return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
      : typeof (tag = tryGet$1(O = Object$3(it), TO_STRING_TAG$6)) == 'string' ? tag // builtinTag case
      : CORRECT_ARGUMENTS$1 ? classofRaw$1(O) // ES3 arguments fallback
      : (result = classofRaw$1(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
    };

    // `Object.prototype.toString` method implementation
    // https://tc39.es/ecma262/#sec-object.prototype.tostring


    var objectToString$2 = toStringTagSupport$1 ? {}.toString : function toString() {
      return '[object ' + classof$1(this) + ']';
    };

    // `Object.prototype.toString` method
    // https://tc39.es/ecma262/#sec-object.prototype.tostring


    if (!toStringTagSupport$1) {
      defineBuiltIn(Object.prototype, 'toString', objectToString$2, {
        unsafe: true
      });
    }

    // iterable DOM collections
    // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
    var domIterables$1 = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };

    // in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`


    var classList = documentCreateElement$1('span').classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
    var domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;

    var bind$2 = functionUncurryThis(functionUncurryThis.bind); // optional / simple context binding

    var functionBindContext$1 = function (fn, that) {
      aCallable(fn);
      return that === undefined ? fn : functionBindNative ? bind$2(fn, that) : function
        /* ...args */
      () {
        return fn.apply(that, arguments);
      };
    };

    var Object$2 = global_1.Object;
    var split$1 = functionUncurryThis(''.split); // fallback for non-array-like ES3 and non-enumerable old V8 strings

    var indexedObject$1 = fails$1(function () {
      // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
      // eslint-disable-next-line no-prototype-builtins -- safe
      return !Object$2('z').propertyIsEnumerable(0);
    }) ? function (it) {
      return classofRaw$1(it) == 'String' ? split$1(it, '') : Object$2(it);
    } : Object$2;

    var ceil$1 = Math.ceil;
    var floor$2 = Math.floor; // `ToIntegerOrInfinity` abstract operation
    // https://tc39.es/ecma262/#sec-tointegerorinfinity

    var toIntegerOrInfinity = function (argument) {
      var number = +argument; // eslint-disable-next-line no-self-compare -- safe

      return number !== number || number === 0 ? 0 : (number > 0 ? floor$2 : ceil$1)(number);
    };

    var min$7 = Math.min; // `ToLength` abstract operation
    // https://tc39.es/ecma262/#sec-tolength

    var toLength$1 = function (argument) {
      return argument > 0 ? min$7(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
    };

    // `LengthOfArrayLike` abstract operation
    // https://tc39.es/ecma262/#sec-lengthofarraylike


    var lengthOfArrayLike = function (obj) {
      return toLength$1(obj.length);
    };

    // `IsArray` abstract operation
    // https://tc39.es/ecma262/#sec-isarray
    // eslint-disable-next-line es-x/no-array-isarray -- safe


    var isArray$3 = Array.isArray || function isArray(argument) {
      return classofRaw$1(argument) == 'Array';
    };

    var noop$2 = function () {
      /* empty */
    };

    var empty$1 = [];
    var construct = getBuiltIn$1('Reflect', 'construct');
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec$1 = functionUncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$2);

    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument)) return false;

      try {
        construct(noop$2, empty$1, argument);
        return true;
      } catch (error) {
        return false;
      }
    };

    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument)) return false;

      switch (classof$1(argument)) {
        case 'AsyncFunction':
        case 'GeneratorFunction':
        case 'AsyncGeneratorFunction':
          return false;
      }

      try {
        // we can't check .prototype since constructors produced by .bind haven't it
        // `Function#toString` throws on some built-it function in some legacy engines
        // (for example, `DOMQuad` and similar in FF41-)
        return INCORRECT_TO_STRING || !!exec$1(constructorRegExp, inspectSource$1(argument));
      } catch (error) {
        return true;
      }
    };

    isConstructorLegacy.sham = true; // `IsConstructor` abstract operation
    // https://tc39.es/ecma262/#sec-isconstructor

    var isConstructor = !construct || fails$1(function () {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;

    var SPECIES$b = wellKnownSymbol$1('species');
    var Array$4 = global_1.Array; // a part of `ArraySpeciesCreate` abstract operation
    // https://tc39.es/ecma262/#sec-arrayspeciescreate

    var arraySpeciesConstructor = function (originalArray) {
      var C;

      if (isArray$3(originalArray)) {
        C = originalArray.constructor; // cross-realm fallback

        if (isConstructor(C) && (C === Array$4 || isArray$3(C.prototype))) C = undefined;else if (isObject$3(C)) {
          C = C[SPECIES$b];
          if (C === null) C = undefined;
        }
      }

      return C === undefined ? Array$4 : C;
    };

    // `ArraySpeciesCreate` abstract operation
    // https://tc39.es/ecma262/#sec-arrayspeciescreate


    var arraySpeciesCreate$1 = function (originalArray, length) {
      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };

    var push$5 = functionUncurryThis([].push); // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation

    var createMethod$7 = function (TYPE) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var IS_FILTER_REJECT = TYPE == 7;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      return function ($this, callbackfn, that, specificCreate) {
        var O = toObject$1($this);
        var self = indexedObject$1(O);
        var boundFunction = functionBindContext$1(callbackfn, that);
        var length = lengthOfArrayLike(self);
        var index = 0;
        var create = specificCreate || arraySpeciesCreate$1;
        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
        var value, result;

        for (; length > index; index++) if (NO_HOLES || index in self) {
          value = self[index];
          result = boundFunction(value, index, O);

          if (TYPE) {
            if (IS_MAP) target[index] = result; // map
            else if (result) switch (TYPE) {
              case 3:
                return true;
              // some

              case 5:
                return value;
              // find

              case 6:
                return index;
              // findIndex

              case 2:
                push$5(target, value);
              // filter
            } else switch (TYPE) {
              case 4:
                return false;
              // every

              case 7:
                push$5(target, value);
              // filterReject
            }
          }
        }

        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };

    var arrayIteration$1 = {
      // `Array.prototype.forEach` method
      // https://tc39.es/ecma262/#sec-array.prototype.foreach
      forEach: createMethod$7(0),
      // `Array.prototype.map` method
      // https://tc39.es/ecma262/#sec-array.prototype.map
      map: createMethod$7(1),
      // `Array.prototype.filter` method
      // https://tc39.es/ecma262/#sec-array.prototype.filter
      filter: createMethod$7(2),
      // `Array.prototype.some` method
      // https://tc39.es/ecma262/#sec-array.prototype.some
      some: createMethod$7(3),
      // `Array.prototype.every` method
      // https://tc39.es/ecma262/#sec-array.prototype.every
      every: createMethod$7(4),
      // `Array.prototype.find` method
      // https://tc39.es/ecma262/#sec-array.prototype.find
      find: createMethod$7(5),
      // `Array.prototype.findIndex` method
      // https://tc39.es/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod$7(6),
      // `Array.prototype.filterReject` method
      // https://github.com/tc39/proposal-array-filtering
      filterReject: createMethod$7(7)
    };

    var arrayMethodIsStrict$1 = function (METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails$1(function () {
        // eslint-disable-next-line no-useless-call -- required for testing
        method.call(null, argument || function () {
          return 1;
        }, 1);
      });
    };

    var $forEach$1 = arrayIteration$1.forEach;



    var STRICT_METHOD$3 = arrayMethodIsStrict$1('forEach'); // `Array.prototype.forEach` method implementation
    // https://tc39.es/ecma262/#sec-array.prototype.foreach

    var arrayForEach$1 = !STRICT_METHOD$3 ? function forEach(callbackfn
    /* , thisArg */
    ) {
      return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); // eslint-disable-next-line es-x/no-array-prototype-foreach -- safe
    } : [].forEach;

    var handlePrototype$1 = function (CollectionPrototype) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach$1) try {
        createNonEnumerableProperty$1(CollectionPrototype, 'forEach', arrayForEach$1);
      } catch (error) {
        CollectionPrototype.forEach = arrayForEach$1;
      }
    };

    for (var COLLECTION_NAME$3 in domIterables$1) {
      if (domIterables$1[COLLECTION_NAME$3]) {
        handlePrototype$1(global_1[COLLECTION_NAME$3] && global_1[COLLECTION_NAME$3].prototype);
      }
    }

    handlePrototype$1(domTokenListPrototype);

    createCommonjsModule$1(function (module) {
    /**
     * Copyright (c) 2014-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var runtime = function (exports) {

      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1; // More compressible than void 0.

      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }

      try {
        // IE 8 has a broken Object.defineProperty that only works on DOM objects.
        define({}, "");
      } catch (err) {
        define = function (obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.

        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }

      exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.

      var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
      // don't natively support it.


      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
      }

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      define(Gp, "constructor", GeneratorFunctionPrototype);
      define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
      GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      exports.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      exports.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define(genFun, toStringTagSymbol, "GeneratorFunction");
        }

        genFun.prototype = Object.create(Gp);
        return genFun;
      }; // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `hasOwn.call(value, "__await")` to determine if the yielded value is
      // meant to be awaited.


      exports.awrap = function (arg) {
        return {
          __await: arg
        };
      };

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;

            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return PromiseImpl.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration.
              result.value = unwrapped;
              resolve(result);
            }, function (error) {
              // If a rejected Promise was yielded, throw the rejection back
              // into the async generator function so it can be handled there.
              return invoke("throw", error, resolve, reject);
            });
          }
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).


        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);
      define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      });
      exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.

      exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            } // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === "next") {
              // Setting context._sent for legacy support of Babel's
              // function.sent implementation.
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }

            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);

            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted; // Dispatch the exception by looping back around to the
              // context.dispatchException(context.arg) call above.

              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      } // Call delegate.iterator[context.method](context.arg) and handle the
      // result, either by returning a { value, done } result from the
      // delegate iterator, or by modifying context.method and context.arg,
      // setting context.delegate to null, and returning the ContinueSentinel.


      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (method === undefined$1) {
          // A .throw or .return when the delegate iterator has no .throw
          // method always terminates the yield* loop.
          context.delegate = null;

          if (context.method === "throw") {
            // Note: ["return"] must be used for ES3 parsing compatibility.
            if (delegate.iterator["return"]) {
              // If the delegate iterator has a return method, give it a
              // chance to clean up.
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);

              if (context.method === "throw") {
                // If maybeInvokeDelegate(context) changed context.method from
                // "return" to "throw", let that override the TypeError below.
                return ContinueSentinel;
              }
            }

            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        var info = record.arg;

        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          // Assign the result of the finished delegate to the temporary
          // variable specified by delegate.resultName (see delegateYield).
          context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

          context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
          // exception, let the outer generator proceed normally. If
          // context.method was "next", forget context.arg since it has been
          // "consumed" by the delegate iterator. If context.method was
          // "return", allow the original .return call to continue in the
          // outer generator.

          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined$1;
          }
        } else {
          // Re-yield the result returned by the delegate method.
          return info;
        } // The delegate iterator is finished, so forget it and continue with
        // the outer generator.


        context.delegate = null;
        return ContinueSentinel;
      } // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.


      defineIteratorMethods(Gp);
      define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
      // @@iterator function is called on it. Some browsers' implementations of the
      // iterator prototype chain incorrectly implement this, causing the Generator
      // object to not be returned from this call. This ensures that doesn't happen.
      // See https://github.com/facebook/regenerator/issues/274 for more details.

      define(Gp, iteratorSymbol, function () {
        return this;
      });
      define(Gp, "toString", function () {
        return "[object Generator]";
      });

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        keys.reverse(); // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.

        return function next() {
          while (keys.length) {
            var key = keys.pop();

            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          } // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.


          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];

          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined$1;
              next.done = true;
              return next;
            };

            return next.next = next;
          }
        } // Return an iterator with no values.


        return {
          next: doneResult
        };
      }

      exports.values = values;

      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }

      Context.prototype = {
        constructor: Context,
        reset: function (skipTempReset) {
          this.prev = 0;
          this.next = 0; // Resetting context._sent for legacy support of Babel's
          // function.sent implementation.

          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        },
        stop: function () {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;

          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },
        dispatchException: function (exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;

          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;

            if (caught) {
              // If the dispatched exception was caught by a catch block,
              // then let that catch block handle the exception normally.
              context.method = "next";
              context.arg = undefined$1;
            }

            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function (type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },
        complete: function (record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },
        finish: function (finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function (tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          } // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.


          throw new Error("illegal catch attempt");
        },
        delegateYield: function (iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          if (this.method === "next") {
            // Deliberately forget the last sent value so that we don't
            // accidentally pass it on to the delegate.
            this.arg = undefined$1;
          }

          return ContinueSentinel;
        }
      }; // Regardless of whether this script is executing as a CommonJS module
      // or not, return the runtime object so that we can declare the variable
      // regeneratorRuntime in the outer scope, which allows this module to be
      // injected easily by `bin/regenerator --include-runtime script.js`.

      return exports;
    }( // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    module.exports );

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      // This module should not be running in strict mode, so the above
      // assignment should always work unless something is misconfigured. Just
      // in case runtime.js accidentally runs in strict mode, in modern engines
      // we can explicitly access globalThis. In older engines we can escape
      // strict mode using a global Function call. This could conceivably fail
      // if a Content Security Policy forbids using Function, but in that case
      // the proper solution is to fix the accidental strict mode problem. If
      // you've misconfigured your bundler to force strict mode and applied a
      // CSP to forbid Function, and you're not willing to fix either of those
      // problems, please detail your unique predicament in a GitHub issue.
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
    });

    var $propertyIsEnumerable$2 = {}.propertyIsEnumerable; // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe

    var getOwnPropertyDescriptor$5 = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

    var NASHORN_BUG$1 = getOwnPropertyDescriptor$5 && !$propertyIsEnumerable$2.call({
      1: 2
    }, 1); // `Object.prototype.propertyIsEnumerable` method implementation
    // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable

    var f$a = NASHORN_BUG$1 ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor$5(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable$2;

    var objectPropertyIsEnumerable$1 = {
    	f: f$a
    };

    // toObject with fallback for non-array-like ES3 strings




    var toIndexedObject$1 = function (it) {
      return indexedObject$1(requireObjectCoercible$1(it));
    };

    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe


    var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

    var f$9 = descriptors$1 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject$1(O);
      P = toPropertyKey(P);
      if (ie8DomDefine$1) try {
        return $getOwnPropertyDescriptor$1(O, P);
      } catch (error) {
        /* empty */
      }
      if (hasOwnProperty_1(O, P)) return createPropertyDescriptor$1(!functionCall(objectPropertyIsEnumerable$1.f, O, P), O[P]);
    };

    var objectGetOwnPropertyDescriptor$1 = {
    	f: f$9
    };

    var max$5 = Math.max;
    var min$6 = Math.min; // Helper for a popular repeating case of the spec:
    // Let integer be ? ToInteger(index).
    // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

    var toAbsoluteIndex$1 = function (index, length) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max$5(integer + length, 0) : min$6(integer, length);
    };

    // `Array.prototype.{ indexOf, includes }` methods implementation


    var createMethod$6 = function (IS_INCLUDES) {
      return function ($this, el, fromIndex) {
        var O = toIndexedObject$1($this);
        var length = lengthOfArrayLike(O);
        var index = toAbsoluteIndex$1(fromIndex, length);
        var value; // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare -- NaN check

        if (IS_INCLUDES && el != el) while (length > index) {
          value = O[index++]; // eslint-disable-next-line no-self-compare -- NaN check

          if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
        } else for (; length > index; index++) {
          if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };

    var arrayIncludes$1 = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod$6(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod$6(false)
    };

    var indexOf$3 = arrayIncludes$1.indexOf;



    var push$4 = functionUncurryThis([].push);

    var objectKeysInternal$1 = function (object, names) {
      var O = toIndexedObject$1(object);
      var i = 0;
      var result = [];
      var key;

      for (key in O) !hasOwnProperty_1(hiddenKeys$3, key) && hasOwnProperty_1(O, key) && push$4(result, key); // Don't enum bug & hidden keys


      while (names.length > i) if (hasOwnProperty_1(O, key = names[i++])) {
        ~indexOf$3(result, key) || push$4(result, key);
      }

      return result;
    };

    // IE8- don't enum bug keys
    var enumBugKeys$1 = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

    var hiddenKeys$2 = enumBugKeys$1.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
    // https://tc39.es/ecma262/#sec-object.getownpropertynames
    // eslint-disable-next-line es-x/no-object-getownpropertynames -- safe

    var f$8 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return objectKeysInternal$1(O, hiddenKeys$2);
    };

    var objectGetOwnPropertyNames$1 = {
    	f: f$8
    };

    // eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
    var f$7 = Object.getOwnPropertySymbols;

    var objectGetOwnPropertySymbols$1 = {
    	f: f$7
    };

    var concat$1 = functionUncurryThis([].concat); // all object keys, includes non-enumerable and symbols

    var ownKeys$1 = getBuiltIn$1('Reflect', 'ownKeys') || function ownKeys(it) {
      var keys = objectGetOwnPropertyNames$1.f(anObject$1(it));
      var getOwnPropertySymbols = objectGetOwnPropertySymbols$1.f;
      return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;
    };

    var copyConstructorProperties$1 = function (target, source, exceptions) {
      var keys = ownKeys$1(source);
      var defineProperty = objectDefineProperty$1.f;
      var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor$1.f;

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (!hasOwnProperty_1(target, key) && !(exceptions && hasOwnProperty_1(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };

    var replacement$1 = /#|\.prototype\./;

    var isForced$1 = function (feature, detection) {
      var value = data$1[normalize$1(feature)];
      return value == POLYFILL$1 ? true : value == NATIVE$1 ? false : isCallable(detection) ? fails$1(detection) : !!detection;
    };

    var normalize$1 = isForced$1.normalize = function (string) {
      return String(string).replace(replacement$1, '.').toLowerCase();
    };

    var data$1 = isForced$1.data = {};
    var NATIVE$1 = isForced$1.NATIVE = 'N';
    var POLYFILL$1 = isForced$1.POLYFILL = 'P';
    var isForced_1$1 = isForced$1;

    var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor$1.f;










    /*
      options.target      - name of the target object
      options.global      - target is the global object
      options.stat        - export as static methods of target
      options.proto       - export as prototype methods of target
      options.real        - real prototype method for the `pure` version
      options.forced      - export even if the native feature is available
      options.bind        - bind methods to the target, required for the `pure` version
      options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
      options.unsafe      - use the simple assignment of property instead of delete + defineProperty
      options.sham        - add a flag to not completely full polyfills
      options.enumerable  - export as enumerable property
      options.noTargetGet - prevent calling a getter on target
      options.name        - the .name of the function if it does not match the key
    */


    var _export$1 = function (options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;

      if (GLOBAL) {
        target = global_1;
      } else if (STATIC) {
        target = global_1[TARGET] || setGlobal$1(TARGET, {});
      } else {
        target = (global_1[TARGET] || {}).prototype;
      }

      if (target) for (key in source) {
        sourceProperty = source[key];

        if (options.noTargetGet) {
          descriptor = getOwnPropertyDescriptor$4(target, key);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];

        FORCED = isForced_1$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

        if (!FORCED && targetProperty !== undefined) {
          if (typeof sourceProperty == typeof targetProperty) continue;
          copyConstructorProperties$1(sourceProperty, targetProperty);
        } // add a flag to not completely full polyfills


        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty$1(sourceProperty, 'sham', true);
        }

        defineBuiltIn(target, key, sourceProperty, options);
      }
    };

    var createProperty$1 = function (object, key, value) {
      var propertyKey = toPropertyKey(key);
      if (propertyKey in object) objectDefineProperty$1.f(object, propertyKey, createPropertyDescriptor$1(0, value));else object[propertyKey] = value;
    };

    var SPECIES$a = wellKnownSymbol$1('species');

    var arrayMethodHasSpeciesSupport$1 = function (METHOD_NAME) {
      // We can't use this feature detection in V8 since it causes
      // deoptimization and serious performance degradation
      // https://github.com/zloirock/core-js/issues/677
      return engineV8Version$1 >= 51 || !fails$1(function () {
        var array = [];
        var constructor = array.constructor = {};

        constructor[SPECIES$a] = function () {
          return {
            foo: 1
          };
        };

        return array[METHOD_NAME](Boolean).foo !== 1;
      });
    };

    var arraySlice = functionUncurryThis([].slice);

    var HAS_SPECIES_SUPPORT$4 = arrayMethodHasSpeciesSupport$1('slice');
    var SPECIES$9 = wellKnownSymbol$1('species');
    var Array$3 = global_1.Array;
    var max$4 = Math.max; // `Array.prototype.slice` method
    // https://tc39.es/ecma262/#sec-array.prototype.slice
    // fallback for not array-like ES3 strings and DOM objects

    _export$1({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT$4
    }, {
      slice: function slice(start, end) {
        var O = toIndexedObject$1(this);
        var length = lengthOfArrayLike(O);
        var k = toAbsoluteIndex$1(start, length);
        var fin = toAbsoluteIndex$1(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

        var Constructor, result, n;

        if (isArray$3(O)) {
          Constructor = O.constructor; // cross-realm fallback

          if (isConstructor(Constructor) && (Constructor === Array$3 || isArray$3(Constructor.prototype))) {
            Constructor = undefined;
          } else if (isObject$3(Constructor)) {
            Constructor = Constructor[SPECIES$9];
            if (Constructor === null) Constructor = undefined;
          }

          if (Constructor === Array$3 || Constructor === undefined) {
            return arraySlice(O, k, fin);
          }
        }

        result = new (Constructor === undefined ? Array$3 : Constructor)(max$4(fin - k, 0));

        for (n = 0; k < fin; k++, n++) if (k in O) createProperty$1(result, n, O[k]);

        result.length = n;
        return result;
      }
    });

    var iteratorClose$1 = function (iterator, kind, value) {
      var innerResult, innerError;
      anObject$1(iterator);

      try {
        innerResult = getMethod(iterator, 'return');

        if (!innerResult) {
          if (kind === 'throw') throw value;
          return value;
        }

        innerResult = functionCall(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }

      if (kind === 'throw') throw value;
      if (innerError) throw innerResult;
      anObject$1(innerResult);
      return value;
    };

    // call something on iterator step with safe closing on error


    var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
      try {
        return ENTRIES ? fn(anObject$1(value)[0], value[1]) : fn(value);
      } catch (error) {
        iteratorClose$1(iterator, 'throw', error);
      }
    };

    var iterators$1 = {};

    var ITERATOR$b = wellKnownSymbol$1('iterator');
    var ArrayPrototype$3 = Array.prototype; // check on default Array iterator

    var isArrayIteratorMethod$1 = function (it) {
      return it !== undefined && (iterators$1.Array === it || ArrayPrototype$3[ITERATOR$b] === it);
    };

    var ITERATOR$a = wellKnownSymbol$1('iterator');

    var getIteratorMethod$1 = function (it) {
      if (it != undefined) return getMethod(it, ITERATOR$a) || getMethod(it, '@@iterator') || iterators$1[classof$1(it)];
    };

    var TypeError$a = global_1.TypeError;

    var getIterator = function (argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
      if (aCallable(iteratorMethod)) return anObject$1(functionCall(iteratorMethod, argument));
      throw TypeError$a(tryToString(argument) + ' is not iterable');
    };

    var Array$2 = global_1.Array; // `Array.from` method implementation
    // https://tc39.es/ecma262/#sec-array.from

    var arrayFrom = function from(arrayLike
    /* , mapfn = undefined, thisArg = undefined */
    ) {
      var O = toObject$1(arrayLike);
      var IS_CONSTRUCTOR = isConstructor(this);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      if (mapping) mapfn = functionBindContext$1(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
      var iteratorMethod = getIteratorMethod$1(O);
      var index = 0;
      var length, result, step, iterator, next, value; // if the target is not iterable or it's an array with the default iterator - use a simple case

      if (iteratorMethod && !(this == Array$2 && isArrayIteratorMethod$1(iteratorMethod))) {
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        result = IS_CONSTRUCTOR ? new this() : [];

        for (; !(step = functionCall(next, iterator)).done; index++) {
          value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
          createProperty$1(result, index, value);
        }
      } else {
        length = lengthOfArrayLike(O);
        result = IS_CONSTRUCTOR ? new this(length) : Array$2(length);

        for (; length > index; index++) {
          value = mapping ? mapfn(O[index], index) : O[index];
          createProperty$1(result, index, value);
        }
      }

      result.length = index;
      return result;
    };

    var ITERATOR$9 = wellKnownSymbol$1('iterator');
    var SAFE_CLOSING$1 = false;

    try {
      var called$1 = 0;
      var iteratorWithReturn$1 = {
        next: function () {
          return {
            done: !!called$1++
          };
        },
        'return': function () {
          SAFE_CLOSING$1 = true;
        }
      };

      iteratorWithReturn$1[ITERATOR$9] = function () {
        return this;
      }; // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing


      Array.from(iteratorWithReturn$1, function () {
        throw 2;
      });
    } catch (error) {
      /* empty */
    }

    var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
      if (!SKIP_CLOSING && !SAFE_CLOSING$1) return false;
      var ITERATION_SUPPORT = false;

      try {
        var object = {};

        object[ITERATOR$9] = function () {
          return {
            next: function () {
              return {
                done: ITERATION_SUPPORT = true
              };
            }
          };
        };

        exec(object);
      } catch (error) {
        /* empty */
      }

      return ITERATION_SUPPORT;
    };

    var INCORRECT_ITERATION = !checkCorrectnessOfIteration$1(function (iterable) {
      // eslint-disable-next-line es-x/no-array-from -- required for testing
      Array.from(iterable);
    }); // `Array.from` method
    // https://tc39.es/ecma262/#sec-array.from

    _export$1({
      target: 'Array',
      stat: true,
      forced: INCORRECT_ITERATION
    }, {
      from: arrayFrom
    });

    var String$3 = global_1.String;

    var toString_1 = function (argument) {
      if (classof$1(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
      return String$3(argument);
    };

    var charAt$6 = functionUncurryThis(''.charAt);
    var charCodeAt = functionUncurryThis(''.charCodeAt);
    var stringSlice$4 = functionUncurryThis(''.slice);

    var createMethod$5 = function (CONVERT_TO_STRING) {
      return function ($this, pos) {
        var S = toString_1(requireObjectCoercible$1($this));
        var position = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
        first = charCodeAt(S, position);
        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$6(S, position) : first : CONVERT_TO_STRING ? stringSlice$4(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
      };
    };

    var stringMultibyte$1 = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod$5(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod$5(true)
    };

    // `Object.keys` method
    // https://tc39.es/ecma262/#sec-object.keys
    // eslint-disable-next-line es-x/no-object-keys -- safe


    var objectKeys$1 = Object.keys || function keys(O) {
      return objectKeysInternal$1(O, enumBugKeys$1);
    };

    // `Object.defineProperties` method
    // https://tc39.es/ecma262/#sec-object.defineproperties
    // eslint-disable-next-line es-x/no-object-defineproperties -- safe


    var f$6 = descriptors$1 && !v8PrototypeDefineBug ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject$1(O);
      var props = toIndexedObject$1(Properties);
      var keys = objectKeys$1(Properties);
      var length = keys.length;
      var index = 0;
      var key;

      while (length > index) objectDefineProperty$1.f(O, key = keys[index++], props[key]);

      return O;
    };

    var objectDefineProperties$1 = {
    	f: f$6
    };

    var html$1 = getBuiltIn$1('document', 'documentElement');

    /* global ActiveXObject -- old IE, WSH */














    var GT$1 = '>';
    var LT$1 = '<';
    var PROTOTYPE$1 = 'prototype';
    var SCRIPT$1 = 'script';
    var IE_PROTO$3 = sharedKey$1('IE_PROTO');

    var EmptyConstructor$1 = function () {
      /* empty */
    };

    var scriptTag$1 = function (content) {
      return LT$1 + SCRIPT$1 + GT$1 + content + LT$1 + '/' + SCRIPT$1 + GT$1;
    }; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


    var NullProtoObjectViaActiveX$1 = function (activeXDocument) {
      activeXDocument.write(scriptTag$1(''));
      activeXDocument.close();
      var temp = activeXDocument.parentWindow.Object;
      activeXDocument = null; // avoid memory leak

      return temp;
    }; // Create object with fake `null` prototype: use iframe Object with cleared prototype


    var NullProtoObjectViaIFrame$1 = function () {
      // Thrash, waste and sodomy: IE GC bug
      var iframe = documentCreateElement$1('iframe');
      var JS = 'java' + SCRIPT$1 + ':';
      var iframeDocument;
      iframe.style.display = 'none';
      html$1.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag$1('document.F=Object'));
      iframeDocument.close();
      return iframeDocument.F;
    }; // Check for document.domain and active x support
    // No need to use active x approach when document.domain is not set
    // see https://github.com/es-shims/es5-shim/issues/150
    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
    // avoid IE GC bug


    var activeXDocument$1;

    var NullProtoObject$1 = function () {
      try {
        activeXDocument$1 = new ActiveXObject('htmlfile');
      } catch (error) {
        /* ignore */
      }

      NullProtoObject$1 = typeof document != 'undefined' ? document.domain && activeXDocument$1 ? NullProtoObjectViaActiveX$1(activeXDocument$1) // old IE
      : NullProtoObjectViaIFrame$1() : NullProtoObjectViaActiveX$1(activeXDocument$1); // WSH

      var length = enumBugKeys$1.length;

      while (length--) delete NullProtoObject$1[PROTOTYPE$1][enumBugKeys$1[length]];

      return NullProtoObject$1();
    };

    hiddenKeys$3[IE_PROTO$3] = true; // `Object.create` method
    // https://tc39.es/ecma262/#sec-object.create
    // eslint-disable-next-line es-x/no-object-create -- safe

    var objectCreate$1 = Object.create || function create(O, Properties) {
      var result;

      if (O !== null) {
        EmptyConstructor$1[PROTOTYPE$1] = anObject$1(O);
        result = new EmptyConstructor$1();
        EmptyConstructor$1[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

        result[IE_PROTO$3] = O;
      } else result = NullProtoObject$1();

      return Properties === undefined ? result : objectDefineProperties$1.f(result, Properties);
    };

    var correctPrototypeGetter$1 = !fails$1(function () {
      function F() {
        /* empty */
      }

      F.prototype.constructor = null; // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing

      return Object.getPrototypeOf(new F()) !== F.prototype;
    });

    var IE_PROTO$2 = sharedKey$1('IE_PROTO');
    var Object$1 = global_1.Object;
    var ObjectPrototype$1 = Object$1.prototype; // `Object.getPrototypeOf` method
    // https://tc39.es/ecma262/#sec-object.getprototypeof

    var objectGetPrototypeOf$1 = correctPrototypeGetter$1 ? Object$1.getPrototypeOf : function (O) {
      var object = toObject$1(O);
      if (hasOwnProperty_1(object, IE_PROTO$2)) return object[IE_PROTO$2];
      var constructor = object.constructor;

      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }

      return object instanceof Object$1 ? ObjectPrototype$1 : null;
    };

    var ITERATOR$8 = wellKnownSymbol$1('iterator');
    var BUGGY_SAFARI_ITERATORS$3 = false; // `%IteratorPrototype%` object
    // https://tc39.es/ecma262/#sec-%iteratorprototype%-object

    var IteratorPrototype$5, PrototypeOfArrayIteratorPrototype$1, arrayIterator$1;
    /* eslint-disable es-x/no-array-prototype-keys -- safe */

    if ([].keys) {
      arrayIterator$1 = [].keys(); // Safari 8 has buggy iterators w/o `next`

      if (!('next' in arrayIterator$1)) BUGGY_SAFARI_ITERATORS$3 = true;else {
        PrototypeOfArrayIteratorPrototype$1 = objectGetPrototypeOf$1(objectGetPrototypeOf$1(arrayIterator$1));
        if (PrototypeOfArrayIteratorPrototype$1 !== Object.prototype) IteratorPrototype$5 = PrototypeOfArrayIteratorPrototype$1;
      }
    }

    var NEW_ITERATOR_PROTOTYPE$1 = IteratorPrototype$5 == undefined || fails$1(function () {
      var test = {}; // FF44- legacy iterators case

      return IteratorPrototype$5[ITERATOR$8].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE$1) IteratorPrototype$5 = {}; // `%IteratorPrototype%[@@iterator]()` method
    // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator

    if (!isCallable(IteratorPrototype$5[ITERATOR$8])) {
      defineBuiltIn(IteratorPrototype$5, ITERATOR$8, function () {
        return this;
      });
    }

    var iteratorsCore$1 = {
      IteratorPrototype: IteratorPrototype$5,
      BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$3
    };

    var defineProperty$6 = objectDefineProperty$1.f;





    var TO_STRING_TAG$5 = wellKnownSymbol$1('toStringTag');

    var setToStringTag$1 = function (target, TAG, STATIC) {
      if (target && !STATIC) target = target.prototype;

      if (target && !hasOwnProperty_1(target, TO_STRING_TAG$5)) {
        defineProperty$6(target, TO_STRING_TAG$5, {
          configurable: true,
          value: TAG
        });
      }
    };

    var IteratorPrototype$4 = iteratorsCore$1.IteratorPrototype;









    var returnThis$4 = function () {
      return this;
    };

    var createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + ' Iterator';
      IteratorConstructor.prototype = objectCreate$1(IteratorPrototype$4, {
        next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next)
      });
      setToStringTag$1(IteratorConstructor, TO_STRING_TAG, false);
      iterators$1[TO_STRING_TAG] = returnThis$4;
      return IteratorConstructor;
    };

    var String$2 = global_1.String;
    var TypeError$9 = global_1.TypeError;

    var aPossiblePrototype$1 = function (argument) {
      if (typeof argument == 'object' || isCallable(argument)) return argument;
      throw TypeError$9("Can't set " + String$2(argument) + ' as a prototype');
    };

    /* eslint-disable no-proto -- safe */




     // `Object.setPrototypeOf` method
    // https://tc39.es/ecma262/#sec-object.setprototypeof
    // Works with __proto__ only. Old v8 can't work with null proto objects.
    // eslint-disable-next-line es-x/no-object-setprototypeof -- safe


    var objectSetPrototypeOf$1 = Object.setPrototypeOf || ('__proto__' in {} ? function () {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;

      try {
        // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
        setter = functionUncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
        /* empty */
      }

      return function setPrototypeOf(O, proto) {
        anObject$1(O);
        aPossiblePrototype$1(proto);
        if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
        return O;
      };
    }() : undefined);

    var PROPER_FUNCTION_NAME = functionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
    var IteratorPrototype$3 = iteratorsCore$1.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS$2 = iteratorsCore$1.BUGGY_SAFARI_ITERATORS;
    var ITERATOR$7 = wellKnownSymbol$1('iterator');
    var KEYS$1 = 'keys';
    var VALUES$1 = 'values';
    var ENTRIES$1 = 'entries';

    var returnThis$3 = function () {
      return this;
    };

    var defineIterator$1 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor$1(IteratorConstructor, NAME, next);

      var getIterationMethod = function (KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS$2 && KIND in IterablePrototype) return IterablePrototype[KIND];

        switch (KIND) {
          case KEYS$1:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };

          case VALUES$1:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };

          case ENTRIES$1:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }

        return function () {
          return new IteratorConstructor(this);
        };
      };

      var TO_STRING_TAG = NAME + ' Iterator';
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR$7] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS$2 && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY; // fix native

      if (anyNativeIterator) {
        CurrentIteratorPrototype = objectGetPrototypeOf$1(anyNativeIterator.call(new Iterable()));

        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (objectGetPrototypeOf$1(CurrentIteratorPrototype) !== IteratorPrototype$3) {
            if (objectSetPrototypeOf$1) {
              objectSetPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype$3);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$7])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR$7, returnThis$3);
            }
          } // Set @@toStringTag to native iterators


          setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);
        }
      } // fix Array.prototype.{ values, @@iterator }.name in V8 / FF


      if (PROPER_FUNCTION_NAME && DEFAULT == VALUES$1 && nativeIterator && nativeIterator.name !== VALUES$1) {
        if (CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty$1(IterablePrototype, 'name', VALUES$1);
        } else {
          INCORRECT_VALUES_NAME = true;

          defaultIterator = function values() {
            return functionCall(nativeIterator, this);
          };
        }
      } // export additional methods


      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES$1),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS$1),
          entries: getIterationMethod(ENTRIES$1)
        };
        if (FORCED) for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS$2 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
          }
        } else _export$1({
          target: NAME,
          proto: true,
          forced: BUGGY_SAFARI_ITERATORS$2 || INCORRECT_VALUES_NAME
        }, methods);
      } // define iterator


      if (IterablePrototype[ITERATOR$7] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR$7, defaultIterator, {
          name: DEFAULT
        });
      }

      iterators$1[NAME] = defaultIterator;
      return methods;
    };

    var charAt$5 = stringMultibyte$1.charAt;







    var STRING_ITERATOR$1 = 'String Iterator';
    var setInternalState$5 = internalState$1.set;
    var getInternalState$4 = internalState$1.getterFor(STRING_ITERATOR$1); // `String.prototype[@@iterator]` method
    // https://tc39.es/ecma262/#sec-string.prototype-@@iterator

    defineIterator$1(String, 'String', function (iterated) {
      setInternalState$5(this, {
        type: STRING_ITERATOR$1,
        string: toString_1(iterated),
        index: 0
      }); // `%StringIteratorPrototype%.next` method
      // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
    }, function next() {
      var state = getInternalState$4(this);
      var string = state.string;
      var index = state.index;
      var point;
      if (index >= string.length) return {
        value: undefined,
        done: true
      };
      point = charAt$5(string, index);
      state.index += point.length;
      return {
        value: point,
        done: false
      };
    });

    var UNSCOPABLES$1 = wellKnownSymbol$1('unscopables');
    var ArrayPrototype$2 = Array.prototype; // Array.prototype[@@unscopables]
    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

    if (ArrayPrototype$2[UNSCOPABLES$1] == undefined) {
      objectDefineProperty$1.f(ArrayPrototype$2, UNSCOPABLES$1, {
        configurable: true,
        value: objectCreate$1(null)
      });
    } // add a key to Array.prototype[@@unscopables]


    var addToUnscopables$1 = function (key) {
      ArrayPrototype$2[UNSCOPABLES$1][key] = true;
    };

    var defineProperty$5 = objectDefineProperty$1.f;







    var ARRAY_ITERATOR$1 = 'Array Iterator';
    var setInternalState$4 = internalState$1.set;
    var getInternalState$3 = internalState$1.getterFor(ARRAY_ITERATOR$1); // `Array.prototype.entries` method
    // https://tc39.es/ecma262/#sec-array.prototype.entries
    // `Array.prototype.keys` method
    // https://tc39.es/ecma262/#sec-array.prototype.keys
    // `Array.prototype.values` method
    // https://tc39.es/ecma262/#sec-array.prototype.values
    // `Array.prototype[@@iterator]` method
    // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
    // `CreateArrayIterator` internal method
    // https://tc39.es/ecma262/#sec-createarrayiterator

    var es_array_iterator$1 = defineIterator$1(Array, 'Array', function (iterated, kind) {
      setInternalState$4(this, {
        type: ARRAY_ITERATOR$1,
        target: toIndexedObject$1(iterated),
        // target
        index: 0,
        // next index
        kind: kind // kind

      }); // `%ArrayIteratorPrototype%.next` method
      // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
    }, function () {
      var state = getInternalState$3(this);
      var target = state.target;
      var kind = state.kind;
      var index = state.index++;

      if (!target || index >= target.length) {
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      }

      if (kind == 'keys') return {
        value: index,
        done: false
      };
      if (kind == 'values') return {
        value: target[index],
        done: false
      };
      return {
        value: [index, target[index]],
        done: false
      };
    }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
    // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
    // https://tc39.es/ecma262/#sec-createmappedargumentsobject

    var values = iterators$1.Arguments = iterators$1.Array; // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

    addToUnscopables$1('keys');
    addToUnscopables$1('values');
    addToUnscopables$1('entries'); // V8 ~ Chrome 45- bug

    if (descriptors$1 && values.name !== 'values') try {
      defineProperty$5(values, 'name', {
        value: 'values'
      });
    } catch (error) {
      /* empty */
    }

    var ITERATOR$6 = wellKnownSymbol$1('iterator');
    var TO_STRING_TAG$4 = wellKnownSymbol$1('toStringTag');
    var ArrayValues$1 = es_array_iterator$1.values;

    var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
      if (CollectionPrototype) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype[ITERATOR$6] !== ArrayValues$1) try {
          createNonEnumerableProperty$1(CollectionPrototype, ITERATOR$6, ArrayValues$1);
        } catch (error) {
          CollectionPrototype[ITERATOR$6] = ArrayValues$1;
        }

        if (!CollectionPrototype[TO_STRING_TAG$4]) {
          createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG$4, COLLECTION_NAME);
        }

        if (domIterables$1[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator$1) {
          // some Chrome versions have non-configurable methods on DOMTokenList
          if (CollectionPrototype[METHOD_NAME] !== es_array_iterator$1[METHOD_NAME]) try {
            createNonEnumerableProperty$1(CollectionPrototype, METHOD_NAME, es_array_iterator$1[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = es_array_iterator$1[METHOD_NAME];
          }
        }
      }
    };

    for (var COLLECTION_NAME$2 in domIterables$1) {
      handlePrototype(global_1[COLLECTION_NAME$2] && global_1[COLLECTION_NAME$2].prototype, COLLECTION_NAME$2);
    }

    handlePrototype(domTokenListPrototype, 'DOMTokenList');

    var $map$1 = arrayIteration$1.map;



    var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$1('map'); // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    // with adding support of @@species

    _export$1({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT$3
    }, {
      map: function map(callbackfn
      /* , thisArg */
      ) {
        return $map$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });

    var IS_CONCAT_SPREADABLE$1 = wellKnownSymbol$1('isConcatSpreadable');
    var MAX_SAFE_INTEGER$3 = 0x1FFFFFFFFFFFFF;
    var MAXIMUM_ALLOWED_INDEX_EXCEEDED$1 = 'Maximum allowed index exceeded';
    var TypeError$8 = global_1.TypeError; // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/679

    var IS_CONCAT_SPREADABLE_SUPPORT$1 = engineV8Version$1 >= 51 || !fails$1(function () {
      var array = [];
      array[IS_CONCAT_SPREADABLE$1] = false;
      return array.concat()[0] !== array;
    });
    var SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1('concat');

    var isConcatSpreadable$1 = function (O) {
      if (!isObject$3(O)) return false;
      var spreadable = O[IS_CONCAT_SPREADABLE$1];
      return spreadable !== undefined ? !!spreadable : isArray$3(O);
    };

    var FORCED$2 = !IS_CONCAT_SPREADABLE_SUPPORT$1 || !SPECIES_SUPPORT$1; // `Array.prototype.concat` method
    // https://tc39.es/ecma262/#sec-array.prototype.concat
    // with adding support of @@isConcatSpreadable and @@species

    _export$1({
      target: 'Array',
      proto: true,
      arity: 1,
      forced: FORCED$2
    }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      concat: function concat(arg) {
        var O = toObject$1(this);
        var A = arraySpeciesCreate$1(O, 0);
        var n = 0;
        var i, k, length, len, E;

        for (i = -1, length = arguments.length; i < length; i++) {
          E = i === -1 ? O : arguments[i];

          if (isConcatSpreadable$1(E)) {
            len = lengthOfArrayLike(E);
            if (n + len > MAX_SAFE_INTEGER$3) throw TypeError$8(MAXIMUM_ALLOWED_INDEX_EXCEEDED$1);

            for (k = 0; k < len; k++, n++) if (k in E) createProperty$1(A, n, E[k]);
          } else {
            if (n >= MAX_SAFE_INTEGER$3) throw TypeError$8(MAXIMUM_ALLOWED_INDEX_EXCEEDED$1);
            createProperty$1(A, n++, E);
          }
        }

        A.length = n;
        return A;
      }
    });

    // `RegExp.prototype.flags` getter implementation
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags


    var regexpFlags$1 = function () {
      var that = anObject$1(this);
      var result = '';
      if (that.hasIndices) result += 'd';
      if (that.global) result += 'g';
      if (that.ignoreCase) result += 'i';
      if (that.multiline) result += 'm';
      if (that.dotAll) result += 's';
      if (that.unicode) result += 'u';
      if (that.sticky) result += 'y';
      return result;
    };

    // babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError


    var $RegExp$2 = global_1.RegExp;
    var UNSUPPORTED_Y$6 = fails$1(function () {
      var re = $RegExp$2('a', 'y');
      re.lastIndex = 2;
      return re.exec('abcd') != null;
    }); // UC Browser bug
    // https://github.com/zloirock/core-js/issues/1008

    var MISSED_STICKY = UNSUPPORTED_Y$6 || fails$1(function () {
      return !$RegExp$2('a', 'y').sticky;
    });
    var BROKEN_CARET$1 = UNSUPPORTED_Y$6 || fails$1(function () {
      // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
      var re = $RegExp$2('^r', 'gy');
      re.lastIndex = 2;
      return re.exec('str') != null;
    });
    var regexpStickyHelpers$1 = {
      BROKEN_CARET: BROKEN_CARET$1,
      MISSED_STICKY: MISSED_STICKY,
      UNSUPPORTED_Y: UNSUPPORTED_Y$6
    };

    // babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError


    var $RegExp$1 = global_1.RegExp;
    var regexpUnsupportedDotAll = fails$1(function () {
      var re = $RegExp$1('.', 's');
      return !(re.dotAll && re.exec('\n') && re.flags === 's');
    });

    // babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError


    var $RegExp = global_1.RegExp;
    var regexpUnsupportedNcg = fails$1(function () {
      var re = $RegExp('(?<a>b)', 'g');
      return re.exec('b').groups.a !== 'b' || 'b'.replace(re, '$<a>c') !== 'bc';
    });

    /* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */

    /* eslint-disable regexp/no-useless-quantifier -- testing */















    var getInternalState$2 = internalState$1.get;





    var nativeReplace$1 = shared$1('native-string-replace', String.prototype.replace);
    var nativeExec$1 = RegExp.prototype.exec;
    var patchedExec$1 = nativeExec$1;
    var charAt$4 = functionUncurryThis(''.charAt);
    var indexOf$2 = functionUncurryThis(''.indexOf);
    var replace$1 = functionUncurryThis(''.replace);
    var stringSlice$3 = functionUncurryThis(''.slice);

    var UPDATES_LAST_INDEX_WRONG$1 = function () {
      var re1 = /a/;
      var re2 = /b*/g;
      functionCall(nativeExec$1, re1, 'a');
      functionCall(nativeExec$1, re2, 'a');
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();

    var UNSUPPORTED_Y$5 = regexpStickyHelpers$1.BROKEN_CARET; // nonparticipating capturing group, copied from es5-shim's String#split patch.

    var NPCG_INCLUDED$1 = /()??/.exec('')[1] !== undefined;
    var PATCH$1 = UPDATES_LAST_INDEX_WRONG$1 || NPCG_INCLUDED$1 || UNSUPPORTED_Y$5 || regexpUnsupportedDotAll || regexpUnsupportedNcg;

    if (PATCH$1) {
      patchedExec$1 = function exec(string) {
        var re = this;
        var state = getInternalState$2(re);
        var str = toString_1(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match, i, object, group;

        if (raw) {
          raw.lastIndex = re.lastIndex;
          result = functionCall(patchedExec$1, raw, str);
          re.lastIndex = raw.lastIndex;
          return result;
        }

        var groups = state.groups;
        var sticky = UNSUPPORTED_Y$5 && re.sticky;
        var flags = functionCall(regexpFlags$1, re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;

        if (sticky) {
          flags = replace$1(flags, 'y', '');

          if (indexOf$2(flags, 'g') === -1) {
            flags += 'g';
          }

          strCopy = stringSlice$3(str, re.lastIndex); // Support anchored sticky behavior.

          if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$4(str, re.lastIndex - 1) !== '\n')) {
            source = '(?: ' + source + ')';
            strCopy = ' ' + strCopy;
            charsAdded++;
          } // ^(? + rx + ) is needed, in combination with some str slicing, to
          // simulate the 'y' flag.


          reCopy = new RegExp('^(?:' + source + ')', flags);
        }

        if (NPCG_INCLUDED$1) {
          reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
        }

        if (UPDATES_LAST_INDEX_WRONG$1) lastIndex = re.lastIndex;
        match = functionCall(nativeExec$1, sticky ? reCopy : re, strCopy);

        if (sticky) {
          if (match) {
            match.input = stringSlice$3(match.input, charsAdded);
            match[0] = stringSlice$3(match[0], charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
          } else re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG$1 && match) {
          re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
        }

        if (NPCG_INCLUDED$1 && match && match.length > 1) {
          // Fix browsers whose `exec` methods don't consistently return `undefined`
          // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
          functionCall(nativeReplace$1, match[0], reCopy, function () {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undefined) match[i] = undefined;
            }
          });
        }

        if (match && groups) {
          match.groups = object = objectCreate$1(null);

          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            object[group[0]] = match[group[1]];
          }
        }

        return match;
      };
    }

    var regexpExec$1 = patchedExec$1;

    // `RegExp.prototype.exec` method
    // https://tc39.es/ecma262/#sec-regexp.prototype.exec


    _export$1({
      target: 'RegExp',
      proto: true,
      forced: /./.exec !== regexpExec$1
    }, {
      exec: regexpExec$1
    });

    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call; // eslint-disable-next-line es-x/no-reflect -- safe

    var functionApply = typeof Reflect == 'object' && Reflect.apply || (functionBindNative ? call.bind(apply) : function () {
      return call.apply(apply, arguments);
    });

    var SPECIES$8 = wellKnownSymbol$1('species');
    var RegExpPrototype$2 = RegExp.prototype;

    var fixRegexpWellKnownSymbolLogic$1 = function (KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol$1(KEY);
      var DELEGATES_TO_SYMBOL = !fails$1(function () {
        // String methods call symbol-named RegEp methods
        var O = {};

        O[SYMBOL] = function () {
          return 7;
        };

        return ''[KEY](O) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function () {
        // Symbol-named RegExp methods call .exec
        var execCalled = false;
        var re = /a/;

        if (KEY === 'split') {
          // We can't use real regex here since it causes deoptimization
          // and serious performance degradation in V8
          // https://github.com/zloirock/core-js/issues/306
          re = {}; // RegExp[@@split] doesn't call the regex's exec method, but first creates
          // a new one. We need to return the patched regex when creating the new one.

          re.constructor = {};

          re.constructor[SPECIES$8] = function () {
            return re;
          };

          re.flags = '';
          re[SYMBOL] = /./[SYMBOL];
        }

        re.exec = function () {
          execCalled = true;
          return null;
        };

        re[SYMBOL]('');
        return !execCalled;
      });

      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var uncurriedNativeRegExpMethod = functionUncurryThis(/./[SYMBOL]);
        var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
          var uncurriedNativeMethod = functionUncurryThis(nativeMethod);
          var $exec = regexp.exec;

          if ($exec === regexpExec$1 || $exec === RegExpPrototype$2.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              // The native String method already delegates to @@method (this
              // polyfilled function), leasing to infinite recursion.
              // We avoid it by directly calling the native @@method method.
              return {
                done: true,
                value: uncurriedNativeRegExpMethod(regexp, str, arg2)
              };
            }

            return {
              done: true,
              value: uncurriedNativeMethod(str, regexp, arg2)
            };
          }

          return {
            done: false
          };
        });
        defineBuiltIn(String.prototype, KEY, methods[0]);
        defineBuiltIn(RegExpPrototype$2, SYMBOL, methods[1]);
      }

      if (SHAM) createNonEnumerableProperty$1(RegExpPrototype$2[SYMBOL], 'sham', true);
    };

    var MATCH$3 = wellKnownSymbol$1('match'); // `IsRegExp` abstract operation
    // https://tc39.es/ecma262/#sec-isregexp

    var isRegexp$1 = function (it) {
      var isRegExp;
      return isObject$3(it) && ((isRegExp = it[MATCH$3]) !== undefined ? !!isRegExp : classofRaw$1(it) == 'RegExp');
    };

    var TypeError$7 = global_1.TypeError; // `Assert: IsConstructor(argument) is true`

    var aConstructor = function (argument) {
      if (isConstructor(argument)) return argument;
      throw TypeError$7(tryToString(argument) + ' is not a constructor');
    };

    var SPECIES$7 = wellKnownSymbol$1('species'); // `SpeciesConstructor` abstract operation
    // https://tc39.es/ecma262/#sec-speciesconstructor

    var speciesConstructor$1 = function (O, defaultConstructor) {
      var C = anObject$1(O).constructor;
      var S;
      return C === undefined || (S = anObject$1(C)[SPECIES$7]) == undefined ? defaultConstructor : aConstructor(S);
    };

    var charAt$3 = stringMultibyte$1.charAt; // `AdvanceStringIndex` abstract operation
    // https://tc39.es/ecma262/#sec-advancestringindex


    var advanceStringIndex$1 = function (S, index, unicode) {
      return index + (unicode ? charAt$3(S, index).length : 1);
    };

    var Array$1 = global_1.Array;
    var max$3 = Math.max;

    var arraySliceSimple = function (O, start, end) {
      var length = lengthOfArrayLike(O);
      var k = toAbsoluteIndex$1(start, length);
      var fin = toAbsoluteIndex$1(end === undefined ? length : end, length);
      var result = Array$1(max$3(fin - k, 0));

      for (var n = 0; k < fin; k++, n++) createProperty$1(result, n, O[k]);

      result.length = n;
      return result;
    };

    var TypeError$6 = global_1.TypeError; // `RegExpExec` abstract operation
    // https://tc39.es/ecma262/#sec-regexpexec

    var regexpExecAbstract$1 = function (R, S) {
      var exec = R.exec;

      if (isCallable(exec)) {
        var result = functionCall(exec, R, S);
        if (result !== null) anObject$1(result);
        return result;
      }

      if (classofRaw$1(R) === 'RegExp') return functionCall(regexpExec$1, R, S);
      throw TypeError$6('RegExp#exec called on incompatible receiver');
    };

    var UNSUPPORTED_Y$4 = regexpStickyHelpers$1.UNSUPPORTED_Y;
    var MAX_UINT32$1 = 0xFFFFFFFF;
    var min$5 = Math.min;
    var $push = [].push;
    var exec = functionUncurryThis(/./.exec);
    var push$3 = functionUncurryThis($push);
    var stringSlice$2 = functionUncurryThis(''.slice); // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
    // Weex JS has frozen built-in prototypes, so use try / catch wrapper

    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC$1 = !fails$1(function () {
      // eslint-disable-next-line regexp/no-empty-group -- required for testing
      var re = /(?:)/;
      var originalExec = re.exec;

      re.exec = function () {
        return originalExec.apply(this, arguments);
      };

      var result = 'ab'.split(re);
      return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
    }); // @@split logic

    fixRegexpWellKnownSymbolLogic$1('split', function (SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit;

      if ('abbc'.split(/(b)*/)[1] == 'c' || // eslint-disable-next-line regexp/no-empty-group -- required for testing
      'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
      '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
        // based on es5-shim implementation, need to rework it
        internalSplit = function (separator, limit) {
          var string = toString_1(requireObjectCoercible$1(this));
          var lim = limit === undefined ? MAX_UINT32$1 : limit >>> 0;
          if (lim === 0) return [];
          if (separator === undefined) return [string]; // If `separator` is not a regex, use native split

          if (!isRegexp$1(separator)) {
            return functionCall(nativeSplit, string, separator, lim);
          }

          var output = [];
          var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
          var lastLastIndex = 0; // Make `global` and avoid `lastIndex` issues by working with a copy

          var separatorCopy = new RegExp(separator.source, flags + 'g');
          var match, lastIndex, lastLength;

          while (match = functionCall(regexpExec$1, separatorCopy, string)) {
            lastIndex = separatorCopy.lastIndex;

            if (lastIndex > lastLastIndex) {
              push$3(output, stringSlice$2(string, lastLastIndex, match.index));
              if (match.length > 1 && match.index < string.length) functionApply($push, output, arraySliceSimple(match, 1));
              lastLength = match[0].length;
              lastLastIndex = lastIndex;
              if (output.length >= lim) break;
            }

            if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
          }

          if (lastLastIndex === string.length) {
            if (lastLength || !exec(separatorCopy, '')) push$3(output, '');
          } else push$3(output, stringSlice$2(string, lastLastIndex));

          return output.length > lim ? arraySliceSimple(output, 0, lim) : output;
        }; // Chakra, V8

      } else if ('0'.split(undefined, 0).length) {
        internalSplit = function (separator, limit) {
          return separator === undefined && limit === 0 ? [] : functionCall(nativeSplit, this, separator, limit);
        };
      } else internalSplit = nativeSplit;

      return [// `String.prototype.split` method
      // https://tc39.es/ecma262/#sec-string.prototype.split
      function split(separator, limit) {
        var O = requireObjectCoercible$1(this);
        var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);
        return splitter ? functionCall(splitter, separator, O, limit) : functionCall(internalSplit, toString_1(O), separator, limit);
      }, // `RegExp.prototype[@@split]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function (string, limit) {
        var rx = anObject$1(this);
        var S = toString_1(string);
        var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
        if (res.done) return res.value;
        var C = speciesConstructor$1(rx, RegExp);
        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (UNSUPPORTED_Y$4 ? 'g' : 'y'); // ^(? + rx + ) is needed, in combination with some S slicing, to
        // simulate the 'y' flag.

        var splitter = new C(UNSUPPORTED_Y$4 ? '^(?:' + rx.source + ')' : rx, flags);
        var lim = limit === undefined ? MAX_UINT32$1 : limit >>> 0;
        if (lim === 0) return [];
        if (S.length === 0) return regexpExecAbstract$1(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];

        while (q < S.length) {
          splitter.lastIndex = UNSUPPORTED_Y$4 ? 0 : q;
          var z = regexpExecAbstract$1(splitter, UNSUPPORTED_Y$4 ? stringSlice$2(S, q) : S);
          var e;

          if (z === null || (e = min$5(toLength$1(splitter.lastIndex + (UNSUPPORTED_Y$4 ? q : 0)), S.length)) === p) {
            q = advanceStringIndex$1(S, q, unicodeMatching);
          } else {
            push$3(A, stringSlice$2(S, p, q));
            if (A.length === lim) return A;

            for (var i = 1; i <= z.length - 1; i++) {
              push$3(A, z[i]);
              if (A.length === lim) return A;
            }

            q = p = e;
          }
        }

        push$3(A, stringSlice$2(S, p));
        return A;
      }];
    }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC$1, UNSUPPORTED_Y$4);

    var engineIsNode$1 = classofRaw$1(global_1.process) == 'process';

    var SPECIES$6 = wellKnownSymbol$1('species');

    var setSpecies$1 = function (CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn$1(CONSTRUCTOR_NAME);
      var defineProperty = objectDefineProperty$1.f;

      if (descriptors$1 && Constructor && !Constructor[SPECIES$6]) {
        defineProperty(Constructor, SPECIES$6, {
          configurable: true,
          get: function () {
            return this;
          }
        });
      }
    };

    var TypeError$5 = global_1.TypeError;

    var anInstance$1 = function (it, Prototype) {
      if (objectIsPrototypeOf(Prototype, it)) return it;
      throw TypeError$5('Incorrect invocation');
    };

    var TypeError$4 = global_1.TypeError;

    var validateArgumentsLength = function (passed, required) {
      if (passed < required) throw TypeError$4('Not enough arguments');
      return passed;
    };

    var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(engineUserAgent$1);

    var set$1 = global_1.setImmediate;
    var clear = global_1.clearImmediate;
    var process$4 = global_1.process;
    var Dispatch = global_1.Dispatch;
    var Function$1 = global_1.Function;
    var MessageChannel = global_1.MessageChannel;
    var String$1 = global_1.String;
    var counter = 0;
    var queue$2 = {};
    var ONREADYSTATECHANGE = 'onreadystatechange';
    var location$1, defer, channel, port;

    try {
      // Deno throws a ReferenceError on `location` access without `--location` flag
      location$1 = global_1.location;
    } catch (error) {
      /* empty */
    }

    var run$1 = function (id) {
      if (hasOwnProperty_1(queue$2, id)) {
        var fn = queue$2[id];
        delete queue$2[id];
        fn();
      }
    };

    var runner = function (id) {
      return function () {
        run$1(id);
      };
    };

    var listener = function (event) {
      run$1(event.data);
    };

    var post = function (id) {
      // old engines have not location.origin
      global_1.postMessage(String$1(id), location$1.protocol + '//' + location$1.host);
    }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


    if (!set$1 || !clear) {
      set$1 = function setImmediate(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function$1(handler);
        var args = arraySlice(arguments, 1);

        queue$2[++counter] = function () {
          functionApply(fn, undefined, args);
        };

        defer(counter);
        return counter;
      };

      clear = function clearImmediate(id) {
        delete queue$2[id];
      }; // Node.js 0.8-


      if (engineIsNode$1) {
        defer = function (id) {
          process$4.nextTick(runner(id));
        }; // Sphere (JS game engine) Dispatch API

      } else if (Dispatch && Dispatch.now) {
        defer = function (id) {
          Dispatch.now(runner(id));
        }; // Browsers with MessageChannel, includes WebWorkers
        // except iOS - https://github.com/zloirock/core-js/issues/624

      } else if (MessageChannel && !engineIsIos) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listener;
        defer = functionBindContext$1(port.postMessage, port); // Browsers with postMessage, skip WebWorkers
        // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
      } else if (global_1.addEventListener && isCallable(global_1.postMessage) && !global_1.importScripts && location$1 && location$1.protocol !== 'file:' && !fails$1(post)) {
        defer = post;
        global_1.addEventListener('message', listener, false); // IE8-
      } else if (ONREADYSTATECHANGE in documentCreateElement$1('script')) {
        defer = function (id) {
          html$1.appendChild(documentCreateElement$1('script'))[ONREADYSTATECHANGE] = function () {
            html$1.removeChild(this);
            run$1(id);
          };
        }; // Rest old browsers

      } else {
        defer = function (id) {
          setTimeout(runner(id), 0);
        };
      }
    }

    var task$1 = {
      set: set$1,
      clear: clear
    };

    var engineIsIosPebble = /ipad|iphone|ipod/i.test(engineUserAgent$1) && global_1.Pebble !== undefined;

    var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent$1);

    var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor$1.f;

    var macrotask = task$1.set;









    var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
    var document$3 = global_1.document;
    var process$3 = global_1.process;
    var Promise$1 = global_1.Promise; // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`

    var queueMicrotaskDescriptor = getOwnPropertyDescriptor$3(global_1, 'queueMicrotask');
    var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
    var flush$1, head, last, notify$1, toggle, node, promise, then; // modern engines have queueMicrotask method

    if (!queueMicrotask) {
      flush$1 = function () {
        var parent, fn;
        if (engineIsNode$1 && (parent = process$3.domain)) parent.exit();

        while (head) {
          fn = head.fn;
          head = head.next;

          try {
            fn();
          } catch (error) {
            if (head) notify$1();else last = undefined;
            throw error;
          }
        }

        last = undefined;
        if (parent) parent.enter();
      }; // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
      // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898


      if (!engineIsIos && !engineIsNode$1 && !engineIsWebosWebkit && MutationObserver && document$3) {
        toggle = true;
        node = document$3.createTextNode('');
        new MutationObserver(flush$1).observe(node, {
          characterData: true
        });

        notify$1 = function () {
          node.data = toggle = !toggle;
        }; // environments with maybe non-completely correct, but existent Promise

      } else if (!engineIsIosPebble && Promise$1 && Promise$1.resolve) {
        // Promise.resolve without an argument throws an error in LG WebOS 2
        promise = Promise$1.resolve(undefined); // workaround of WebKit ~ iOS Safari 10.1 bug

        promise.constructor = Promise$1;
        then = functionBindContext$1(promise.then, promise);

        notify$1 = function () {
          then(flush$1);
        }; // Node.js without promises

      } else if (engineIsNode$1) {
        notify$1 = function () {
          process$3.nextTick(flush$1);
        }; // for other environments - macrotask based on:
        // - setImmediate
        // - MessageChannel
        // - window.postMessage
        // - onreadystatechange
        // - setTimeout

      } else {
        // strange IE + webpack dev server bug - use .bind(global)
        macrotask = functionBindContext$1(macrotask, global_1);

        notify$1 = function () {
          macrotask(flush$1);
        };
      }
    }

    var microtask = queueMicrotask || function (fn) {
      var task = {
        fn: fn,
        next: undefined
      };
      if (last) last.next = task;

      if (!head) {
        head = task;
        notify$1();
      }

      last = task;
    };

    var hostReportErrors = function (a, b) {
      var console = global_1.console;

      if (console && console.error) {
        arguments.length == 1 ? console.error(a) : console.error(a, b);
      }
    };

    var perform = function (exec) {
      try {
        return {
          error: false,
          value: exec()
        };
      } catch (error) {
        return {
          error: true,
          value: error
        };
      }
    };

    var Queue = function () {
      this.head = null;
      this.tail = null;
    };

    Queue.prototype = {
      add: function (item) {
        var entry = {
          item: item,
          next: null
        };
        if (this.head) this.tail.next = entry;else this.head = entry;
        this.tail = entry;
      },
      get: function () {
        var entry = this.head;

        if (entry) {
          this.head = entry.next;
          if (this.tail === entry) this.tail = null;
          return entry.item;
        }
      }
    };
    var queue$1 = Queue;

    var promiseNativeConstructor = global_1.Promise;

    var engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';

    promiseNativeConstructor && promiseNativeConstructor.prototype;
    var SPECIES$5 = wellKnownSymbol$1('species');
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable(global_1.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR$5 = isForced_1$1('Promise', function () {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource$1(promiseNativeConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(promiseNativeConstructor); // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // We can't detect it synchronously, so just check versions

      if (!GLOBAL_CORE_JS_PROMISE && engineV8Version$1 === 66) return true; // We need Promise#{ catch, finally } in the pure version for preventing prototype pollution
      // deoptimization and performance degradation
      // https://github.com/zloirock/core-js/issues/679

      if (engineV8Version$1 >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false; // Detect correctness of subclassing with @@species support

      var promise = new promiseNativeConstructor(function (resolve) {
        resolve(1);
      });

      var FakePromise = function (exec) {
        exec(function () {
          /* empty */
        }, function () {
          /* empty */
        });
      };

      var constructor = promise.constructor = {};
      constructor[SPECIES$5] = FakePromise;
      SUBCLASSING = promise.then(function () {
        /* empty */
      }) instanceof FakePromise;
      if (!SUBCLASSING) return true; // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test

      return !GLOBAL_CORE_JS_PROMISE && engineIsBrowser && !NATIVE_PROMISE_REJECTION_EVENT$1;
    });
    var promiseConstructorDetection = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
      SUBCLASSING: SUBCLASSING
    };

    var PromiseCapability = function (C) {
      var resolve, reject;
      this.promise = new C(function ($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable(resolve);
      this.reject = aCallable(reject);
    }; // `NewPromiseCapability` abstract operation
    // https://tc39.es/ecma262/#sec-newpromisecapability


    var f$5 = function (C) {
      return new PromiseCapability(C);
    };

    var newPromiseCapability$1 = {
    	f: f$5
    };

    var task = task$1.set;

















    var PROMISE = 'Promise';
    var FORCED_PROMISE_CONSTRUCTOR$4 = promiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = promiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = promiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = internalState$1.getterFor(PROMISE);
    var setInternalState$3 = internalState$1.set;
    var NativePromisePrototype$1 = promiseNativeConstructor && promiseNativeConstructor.prototype;
    var PromiseConstructor = promiseNativeConstructor;
    var PromisePrototype = NativePromisePrototype$1;
    var TypeError$3 = global_1.TypeError;
    var document$2 = global_1.document;
    var process$2 = global_1.process;
    var newPromiseCapability = newPromiseCapability$1.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
    var UNHANDLED_REJECTION = 'unhandledrejection';
    var REJECTION_HANDLED = 'rejectionhandled';
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen; // helpers

    var isThenable = function (it) {
      var then;
      return isObject$3(it) && isCallable(then = it.then) ? then : false;
    };

    var callReaction = function (reaction, state) {
      var value = state.value;
      var ok = state.state == FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // can throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError$3('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            functionCall(then, result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    };

    var notify = function (state, isReject) {
      if (state.notified) return;
      state.notified = true;
      microtask(function () {
        var reactions = state.reactions;
        var reaction;

        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }

        state.notified = false;
        if (isReject && !state.rejection) onUnhandled(state);
      });
    };

    var dispatchEvent = function (name, promise, reason) {
      var event, handler;

      if (DISPATCH_EVENT) {
        event = document$2.createEvent('Event');
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global_1.dispatchEvent(event);
      } else event = {
        promise: promise,
        reason: reason
      };

      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global_1['on' + name])) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
    };

    var onUnhandled = function (state) {
      functionCall(task, global_1, function () {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;

        if (IS_UNHANDLED) {
          result = perform(function () {
            if (engineIsNode$1) {
              process$2.emit('unhandledRejection', value, promise);
            } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
          }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

          state.rejection = engineIsNode$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error) throw result.value;
        }
      });
    };

    var isUnhandled = function (state) {
      return state.rejection !== HANDLED && !state.parent;
    };

    var onHandleUnhandled = function (state) {
      functionCall(task, global_1, function () {
        var promise = state.facade;

        if (engineIsNode$1) {
          process$2.emit('rejectionHandled', promise);
        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };

    var bind$1 = function (fn, state, unwrap) {
      return function (value) {
        fn(state, value, unwrap);
      };
    };

    var internalReject = function (state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };

    var internalResolve = function (state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;

      try {
        if (state.facade === value) throw TypeError$3("Promise can't be resolved itself");
        var then = isThenable(value);

        if (then) {
          microtask(function () {
            var wrapper = {
              done: false
            };

            try {
              functionCall(then, value, bind$1(internalResolve, wrapper, state), bind$1(internalReject, wrapper, state));
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({
          done: false
        }, error, state);
      }
    }; // constructor polyfill


    if (FORCED_PROMISE_CONSTRUCTOR$4) {
      // 25.4.3.1 Promise(executor)
      PromiseConstructor = function Promise(executor) {
        anInstance$1(this, PromisePrototype);
        aCallable(executor);
        functionCall(Internal, this);
        var state = getInternalPromiseState(this);

        try {
          executor(bind$1(internalResolve, state), bind$1(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };

      PromisePrototype = PromiseConstructor.prototype; // eslint-disable-next-line no-unused-vars -- required for `.length`

      Internal = function Promise(executor) {
        setInternalState$3(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new queue$1(),
          rejection: false,
          state: PENDING,
          value: undefined
        });
      }; // `Promise.prototype.then` method
      // https://tc39.es/ecma262/#sec-promise.prototype.then


      Internal.prototype = defineBuiltIn(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor$1(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable(onRejected) && onRejected;
        reaction.domain = engineIsNode$1 ? process$2.domain : undefined;
        if (state.state == PENDING) state.reactions.add(reaction);else microtask(function () {
          callReaction(reaction, state);
        });
        return reaction.promise;
      });

      OwnPromiseCapability = function () {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind$1(internalResolve, state);
        this.reject = bind$1(internalReject, state);
      };

      newPromiseCapability$1.f = newPromiseCapability = function (C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };

      if (isCallable(promiseNativeConstructor) && NativePromisePrototype$1 !== Object.prototype) {
        nativeThen = NativePromisePrototype$1.then;

        if (!NATIVE_PROMISE_SUBCLASSING) {
          // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
          defineBuiltIn(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function (resolve, reject) {
              functionCall(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected); // https://github.com/zloirock/core-js/issues/640
          }, {
            unsafe: true
          });
        } // make `.constructor === Promise` work for native promise-based APIs


        try {
          delete NativePromisePrototype$1.constructor;
        } catch (error) {
          /* empty */
        } // make `instanceof Promise` work for native promise-based APIs


        if (objectSetPrototypeOf$1) {
          objectSetPrototypeOf$1(NativePromisePrototype$1, PromisePrototype);
        }
      }
    }

    _export$1({
      global: true,
      wrap: true,
      forced: FORCED_PROMISE_CONSTRUCTOR$4
    }, {
      Promise: PromiseConstructor
    });
    setToStringTag$1(PromiseConstructor, PROMISE, false);
    setSpecies$1(PROMISE);

    var TypeError$2 = global_1.TypeError;

    var Result$1 = function (stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };

    var ResultPrototype = Result$1.prototype;

    var iterate$1 = function (iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = functionBindContext$1(unboundFunction, that);
      var iterator, iterFn, index, length, result, next, step;

      var stop = function (condition) {
        if (iterator) iteratorClose$1(iterator, 'normal', condition);
        return new Result$1(true, condition);
      };

      var callFn = function (value) {
        if (AS_ENTRIES) {
          anObject$1(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }

        return INTERRUPTED ? fn(value, stop) : fn(value);
      };

      if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod$1(iterable);
        if (!iterFn) throw TypeError$2(tryToString(iterable) + ' is not iterable'); // optimisation for array iterators

        if (isArrayIteratorMethod$1(iterFn)) {
          for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
            result = callFn(iterable[index]);
            if (result && objectIsPrototypeOf(ResultPrototype, result)) return result;
          }

          return new Result$1(false);
        }

        iterator = getIterator(iterable, iterFn);
      }

      next = iterator.next;

      while (!(step = functionCall(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose$1(iterator, 'throw', error);
        }

        if (typeof result == 'object' && result && objectIsPrototypeOf(ResultPrototype, result)) return result;
      }

      return new Result$1(false);
    };

    var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;

    var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration$1(function (iterable) {
      promiseNativeConstructor.all(iterable).then(undefined, function () {
        /* empty */
      });
    });

    // `Promise.all` method
    // https://tc39.es/ecma262/#sec-promise.all


    _export$1({
      target: 'Promise',
      stat: true,
      forced: promiseStaticsIncorrectIteration
    }, {
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability$1.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function () {
          var $promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate$1(iterable, function (promise) {
            var index = counter++;
            var alreadyCalled = false;
            remaining++;
            functionCall($promiseResolve, C, promise).then(function (value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              values[index] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });

    var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;









    var NativePromisePrototype = promiseNativeConstructor && promiseNativeConstructor.prototype; // `Promise.prototype.catch` method
    // https://tc39.es/ecma262/#sec-promise.prototype.catch

    _export$1({
      target: 'Promise',
      proto: true,
      forced: FORCED_PROMISE_CONSTRUCTOR$2,
      real: true
    }, {
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    }); // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`

    if (isCallable(promiseNativeConstructor)) {
      var method$1 = getBuiltIn$1('Promise').prototype['catch'];

      if (NativePromisePrototype['catch'] !== method$1) {
        defineBuiltIn(NativePromisePrototype, 'catch', method$1, {
          unsafe: true
        });
      }
    }

    // `Promise.race` method
    // https://tc39.es/ecma262/#sec-promise.race


    _export$1({
      target: 'Promise',
      stat: true,
      forced: promiseStaticsIncorrectIteration
    }, {
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability$1.f(C);
        var reject = capability.reject;
        var result = perform(function () {
          var $promiseResolve = aCallable(C.resolve);
          iterate$1(iterable, function (promise) {
            functionCall($promiseResolve, C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });

    var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR; // `Promise.reject` method
    // https://tc39.es/ecma262/#sec-promise.reject


    _export$1({
      target: 'Promise',
      stat: true,
      forced: FORCED_PROMISE_CONSTRUCTOR$1
    }, {
      reject: function reject(r) {
        var capability = newPromiseCapability$1.f(this);
        functionCall(capability.reject, undefined, r);
        return capability.promise;
      }
    });

    var promiseResolve = function (C, x) {
      anObject$1(C);
      if (isObject$3(x) && x.constructor === C) return x;
      var promiseCapability = newPromiseCapability$1.f(C);
      var resolve = promiseCapability.resolve;
      resolve(x);
      return promiseCapability.promise;
    };

    var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;



    getBuiltIn$1('Promise');
    // https://tc39.es/ecma262/#sec-promise.resolve

    _export$1({
      target: 'Promise',
      stat: true,
      forced: FORCED_PROMISE_CONSTRUCTOR
    }, {
      resolve: function resolve(x) {
        return promiseResolve(this, x);
      }
    });

    function noop$1() { }
    function assign$1(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function subscribe$1(store, ...callbacks) {
        if (store == null) {
            return noop$1;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe$1(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign$1($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function append_styles(target, style_sheet_id, styles) {
        const append_styles_to = get_root_for_style(target);
        if (!append_styles_to.getElementById(style_sheet_id)) {
            const style = element('style');
            style.id = style_sheet_id;
            style.textContent = styles;
            append_stylesheet(append_styles_to, style);
        }
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space$1() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.wholeText !== data)
            text.data = data;
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }
    class HtmlTag {
        constructor(is_svg = false) {
            this.is_svg = false;
            this.is_svg = is_svg;
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                if (this.is_svg)
                    this.e = svg_element(target.nodeName);
                else
                    this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$2(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$1,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$1;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function toInteger$1(dirtyNumber) {
      if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
        return NaN;
      }

      var number = Number(dirtyNumber);

      if (isNaN(number)) {
        return number;
      }

      return number < 0 ? Math.ceil(number) : Math.floor(number);
    }

    function requiredArgs(required, args) {
      if (args.length < required) {
        throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
      }
    }

    /**
     * @name toDate
     * @category Common Helpers
     * @summary Convert the given argument to an instance of Date.
     *
     * @description
     * Convert the given argument to an instance of Date.
     *
     * If the argument is an instance of Date, the function returns its clone.
     *
     * If the argument is a number, it is treated as a timestamp.
     *
     * If the argument is none of the above, the function returns Invalid Date.
     *
     * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
     *
     * @param {Date|Number} argument - the value to convert
     * @returns {Date} the parsed date in the local time zone
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Clone the date:
     * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
     * //=> Tue Feb 11 2014 11:30:30
     *
     * @example
     * // Convert the timestamp to date:
     * const result = toDate(1392098430000)
     * //=> Tue Feb 11 2014 11:30:30
     */

    function toDate(argument) {
      requiredArgs(1, arguments);
      var argStr = Object.prototype.toString.call(argument); // Clone the date

      if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new Date(argument.getTime());
      } else if (typeof argument === 'number' || argStr === '[object Number]') {
        return new Date(argument);
      } else {
        if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
          // eslint-disable-next-line no-console
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

          console.warn(new Error().stack);
        }

        return new Date(NaN);
      }
    }

    /**
     * @name addDays
     * @category Day Helpers
     * @summary Add the specified number of days to the given date.
     *
     * @description
     * Add the specified number of days to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} - the new date with the days added
     * @throws {TypeError} - 2 arguments required
     *
     * @example
     * // Add 10 days to 1 September 2014:
     * const result = addDays(new Date(2014, 8, 1), 10)
     * //=> Thu Sep 11 2014 00:00:00
     */

    function addDays(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var date = toDate(dirtyDate);
      var amount = toInteger$1(dirtyAmount);

      if (isNaN(amount)) {
        return new Date(NaN);
      }

      if (!amount) {
        // If 0 days, no-op to avoid changing times in the hour before end of DST
        return date;
      }

      date.setDate(date.getDate() + amount);
      return date;
    }

    /**
     * @name addMonths
     * @category Month Helpers
     * @summary Add the specified number of months to the given date.
     *
     * @description
     * Add the specified number of months to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the months added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 5 months to 1 September 2014:
     * const result = addMonths(new Date(2014, 8, 1), 5)
     * //=> Sun Feb 01 2015 00:00:00
     */

    function addMonths(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var date = toDate(dirtyDate);
      var amount = toInteger$1(dirtyAmount);

      if (isNaN(amount)) {
        return new Date(NaN);
      }

      if (!amount) {
        // If 0 months, no-op to avoid changing times in the hour before end of DST
        return date;
      }

      var dayOfMonth = date.getDate(); // The JS Date object supports date math by accepting out-of-bounds values for
      // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
      // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
      // want except that dates will wrap around the end of a month, meaning that
      // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
      // we'll default to the end of the desired month by adding 1 to the desired
      // month and using a date of 0 to back up one day to the end of the desired
      // month.

      var endOfDesiredMonth = new Date(date.getTime());
      endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
      var daysInMonth = endOfDesiredMonth.getDate();

      if (dayOfMonth >= daysInMonth) {
        // If we're already at the end of the month, then this is the correct date
        // and we're done.
        return endOfDesiredMonth;
      } else {
        // Otherwise, we now know that setting the original day-of-month value won't
        // cause an overflow, so set the desired day-of-month. Note that we can't
        // just set the date of `endOfDesiredMonth` because that object may have had
        // its time changed in the unusual case where where a DST transition was on
        // the last day of the month and its local time was in the hour skipped or
        // repeated next to a DST transition.  So we use `date` instead which is
        // guaranteed to still have the original time.
        date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
        return date;
      }
    }

    /**
     * @name addMilliseconds
     * @category Millisecond Helpers
     * @summary Add the specified number of milliseconds to the given date.
     *
     * @description
     * Add the specified number of milliseconds to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
     * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:30.750
     */

    function addMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var timestamp = toDate(dirtyDate).getTime();
      var amount = toInteger$1(dirtyAmount);
      return new Date(timestamp + amount);
    }

    var defaultOptions = {};
    function getDefaultOptions() {
      return defaultOptions;
    }

    /**
     * @name startOfWeek
     * @category Week Helpers
     * @summary Return the start of a week for the given date.
     *
     * @description
     * Return the start of a week for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @returns {Date} the start of a week
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     *
     * @example
     * // The start of a week for 2 September 2014 11:55:00:
     * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Sun Aug 31 2014 00:00:00
     *
     * @example
     * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
     * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
     * //=> Mon Sep 01 2014 00:00:00
     */

    function startOfWeek(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      var date = toDate(dirtyDate);
      var day = date.getDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setDate(date.getDate() - diff);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
     * They usually appear for dates that denote time before the timezones were introduced
     * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
     * and GMT+01:00:00 after that date)
     *
     * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
     * which would lead to incorrect calculations.
     *
     * This function returns the timezone offset in milliseconds that takes seconds in account.
     */
    function getTimezoneOffsetInMilliseconds(date) {
      var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      utcDate.setUTCFullYear(date.getFullYear());
      return date.getTime() - utcDate.getTime();
    }

    /**
     * @name startOfDay
     * @category Day Helpers
     * @summary Return the start of a day for the given date.
     *
     * @description
     * Return the start of a day for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a day
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a day for 2 September 2014 11:55:00:
     * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 02 2014 00:00:00
     */

    function startOfDay(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    var MILLISECONDS_IN_DAY$1 = 86400000;
    /**
     * @name differenceInCalendarDays
     * @category Day Helpers
     * @summary Get the number of calendar days between the given dates.
     *
     * @description
     * Get the number of calendar days between the given dates. This means that the times are removed
     * from the dates and then the difference in days is calculated.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of calendar days
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many calendar days are between
     * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
     * const result = differenceInCalendarDays(
     *   new Date(2012, 6, 2, 0, 0),
     *   new Date(2011, 6, 2, 23, 0)
     * )
     * //=> 366
     * // How many calendar days are between
     * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
     * const result = differenceInCalendarDays(
     *   new Date(2011, 6, 3, 0, 1),
     *   new Date(2011, 6, 2, 23, 59)
     * )
     * //=> 1
     */

    function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var startOfDayLeft = startOfDay(dirtyDateLeft);
      var startOfDayRight = startOfDay(dirtyDateRight);
      var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
      var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight); // Round the number of days to the nearest integer
      // because the number of milliseconds in a day is not constant
      // (e.g. it's different in the day of the daylight saving time clock shift)

      return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
    }

    /**
     * @name addWeeks
     * @category Week Helpers
     * @summary Add the specified number of weeks to the given date.
     *
     * @description
     * Add the specified number of week to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of weeks to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the weeks added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 4 weeks to 1 September 2014:
     * const result = addWeeks(new Date(2014, 8, 1), 4)
     * //=> Mon Sep 29 2014 00:00:00
     */

    function addWeeks(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger$1(dirtyAmount);
      var days = amount * 7;
      return addDays(dirtyDate, days);
    }

    /**
     * @name addYears
     * @category Year Helpers
     * @summary Add the specified number of years to the given date.
     *
     * @description
     * Add the specified number of years to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the years added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 5 years to 1 September 2014:
     * const result = addYears(new Date(2014, 8, 1), 5)
     * //=> Sun Sep 01 2019 00:00:00
     */

    function addYears(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger$1(dirtyAmount);
      return addMonths(dirtyDate, amount * 12);
    }

    /**
     * @name compareAsc
     * @category Common Helpers
     * @summary Compare the two dates and return -1, 0 or 1.
     *
     * @description
     * Compare the two dates and return 1 if the first date is after the second,
     * -1 if the first date is before the second or 0 if dates are equal.
     *
     * @param {Date|Number} dateLeft - the first date to compare
     * @param {Date|Number} dateRight - the second date to compare
     * @returns {Number} the result of the comparison
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Compare 11 February 1987 and 10 July 1989:
     * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
     * //=> -1
     *
     * @example
     * // Sort the array of dates:
     * const result = [
     *   new Date(1995, 6, 2),
     *   new Date(1987, 1, 11),
     *   new Date(1989, 6, 10)
     * ].sort(compareAsc)
     * //=> [
     * //   Wed Feb 11 1987 00:00:00,
     * //   Mon Jul 10 1989 00:00:00,
     * //   Sun Jul 02 1995 00:00:00
     * // ]
     */

    function compareAsc(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var diff = dateLeft.getTime() - dateRight.getTime();

      if (diff < 0) {
        return -1;
      } else if (diff > 0) {
        return 1; // Return 0 if diff is 0; return NaN if diff is NaN
      } else {
        return diff;
      }
    }

    /**
     * Milliseconds in 1 minute
     *
     * @name millisecondsInMinute
     * @constant
     * @type {number}
     * @default
     */

    var millisecondsInMinute = 60000;
    /**
     * Milliseconds in 1 hour
     *
     * @name millisecondsInHour
     * @constant
     * @type {number}
     * @default
     */

    var millisecondsInHour = 3600000;
    /**
     * Milliseconds in 1 second
     *
     * @name millisecondsInSecond
     * @constant
     * @type {number}
     * @default
     */

    var millisecondsInSecond = 1000;

    /**
     * @name isSameDay
     * @category Day Helpers
     * @summary Are the given dates in the same day (and year and month)?
     *
     * @description
     * Are the given dates in the same day (and year and month)?
     *
     * @param {Date|Number} dateLeft - the first date to check
     * @param {Date|Number} dateRight - the second date to check
     * @returns {Boolean} the dates are in the same day (and year and month)
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
     * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
     * //=> true
     *
     * @example
     * // Are 4 September and 4 October in the same day?
     * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
     * //=> false
     *
     * @example
     * // Are 4 September, 2014 and 4 September, 2015 in the same day?
     * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
     * //=> false
     */

    function isSameDay(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
      var dateRightStartOfDay = startOfDay(dirtyDateRight);
      return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
    }

    /**
     * @name isDate
     * @category Common Helpers
     * @summary Is the given value a date?
     *
     * @description
     * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
     *
     * @param {*} value - the value to check
     * @returns {boolean} true if the given value is a date
     * @throws {TypeError} 1 arguments required
     *
     * @example
     * // For a valid date:
     * const result = isDate(new Date())
     * //=> true
     *
     * @example
     * // For an invalid date:
     * const result = isDate(new Date(NaN))
     * //=> true
     *
     * @example
     * // For some value:
     * const result = isDate('2014-02-31')
     * //=> false
     *
     * @example
     * // For an object:
     * const result = isDate({})
     * //=> false
     */

    function isDate$1(value) {
      requiredArgs(1, arguments);
      return value instanceof Date || typeof value === 'object' && Object.prototype.toString.call(value) === '[object Date]';
    }

    /**
     * @name isValid
     * @category Common Helpers
     * @summary Is the given date valid?
     *
     * @description
     * Returns false if argument is Invalid Date and true otherwise.
     * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
     * Invalid Date is a Date, whose time value is NaN.
     *
     * Time value of Date: http://es5.github.io/#x15.9.1.1
     *
     * @param {*} date - the date to check
     * @returns {Boolean} the date is valid
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // For the valid date:
     * const result = isValid(new Date(2014, 1, 31))
     * //=> true
     *
     * @example
     * // For the value, convertable into a date:
     * const result = isValid(1393804800000)
     * //=> true
     *
     * @example
     * // For the invalid date:
     * const result = isValid(new Date(''))
     * //=> false
     */

    function isValid(dirtyDate) {
      requiredArgs(1, arguments);

      if (!isDate$1(dirtyDate) && typeof dirtyDate !== 'number') {
        return false;
      }

      var date = toDate(dirtyDate);
      return !isNaN(Number(date));
    }

    /**
     * @name differenceInCalendarMonths
     * @category Month Helpers
     * @summary Get the number of calendar months between the given dates.
     *
     * @description
     * Get the number of calendar months between the given dates.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of calendar months
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many calendar months are between 31 January 2014 and 1 September 2014?
     * const result = differenceInCalendarMonths(
     *   new Date(2014, 8, 1),
     *   new Date(2014, 0, 31)
     * )
     * //=> 8
     */

    function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
      var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
      return yearDiff * 12 + monthDiff;
    }

    /**
     * @name differenceInCalendarYears
     * @category Year Helpers
     * @summary Get the number of calendar years between the given dates.
     *
     * @description
     * Get the number of calendar years between the given dates.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of calendar years
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many calendar years are between 31 December 2013 and 11 February 2015?
     * const result = differenceInCalendarYears(
     *   new Date(2015, 1, 11),
     *   new Date(2013, 11, 31)
     * )
     * //=> 2
     */

    function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      return dateLeft.getFullYear() - dateRight.getFullYear();
    }

    // for accurate equality comparisons of UTC timestamps that end up
    // having the same representation in local time, e.g. one hour before
    // DST ends vs. the instant that DST ends.

    function compareLocalAsc(dateLeft, dateRight) {
      var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();

      if (diff < 0) {
        return -1;
      } else if (diff > 0) {
        return 1; // Return 0 if diff is 0; return NaN if diff is NaN
      } else {
        return diff;
      }
    }
    /**
     * @name differenceInDays
     * @category Day Helpers
     * @summary Get the number of full days between the given dates.
     *
     * @description
     * Get the number of full day periods between two dates. Fractional days are
     * truncated towards zero.
     *
     * One "full day" is the distance between a local time in one day to the same
     * local time on the next or previous day. A full day can sometimes be less than
     * or more than 24 hours if a daylight savings change happens between two dates.
     *
     * To ignore DST and only measure exact 24-hour periods, use this instead:
     * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
     *
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of full days according to the local timezone
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many full days are between
     * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
     * const result = differenceInDays(
     *   new Date(2012, 6, 2, 0, 0),
     *   new Date(2011, 6, 2, 23, 0)
     * )
     * //=> 365
     * // How many full days are between
     * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
     * const result = differenceInDays(
     *   new Date(2011, 6, 3, 0, 1),
     *   new Date(2011, 6, 2, 23, 59)
     * )
     * //=> 0
     * // How many full days are between
     * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
     * // Note: because local time is used, the
     * // result will always be 92 days, even in
     * // time zones where DST starts and the
     * // period has only 92*24-1 hours.
     * const result = differenceInDays(
     *   new Date(2020, 5, 1),
     *   new Date(2020, 2, 1)
     * )
    //=> 92
     */


    function differenceInDays(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var sign = compareLocalAsc(dateLeft, dateRight);
      var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
      dateLeft.setDate(dateLeft.getDate() - sign * difference); // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
      // If so, result must be decreased by 1 in absolute value

      var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);
      var result = sign * (difference - isLastDayNotFull); // Prevent negative zero

      return result === 0 ? 0 : result;
    }

    var roundingMap = {
      ceil: Math.ceil,
      round: Math.round,
      floor: Math.floor,
      trunc: function (value) {
        return value < 0 ? Math.ceil(value) : Math.floor(value);
      } // Math.trunc is not supported by IE

    };
    var defaultRoundingMethod = 'trunc';
    function getRoundingMethod(method) {
      return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
    }

    /**
     * @name endOfDay
     * @category Day Helpers
     * @summary Return the end of a day for the given date.
     *
     * @description
     * Return the end of a day for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the end of a day
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The end of a day for 2 September 2014 11:55:00:
     * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 02 2014 23:59:59.999
     */

    function endOfDay(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      date.setHours(23, 59, 59, 999);
      return date;
    }

    /**
     * @name endOfMonth
     * @category Month Helpers
     * @summary Return the end of a month for the given date.
     *
     * @description
     * Return the end of a month for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the end of a month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The end of a month for 2 September 2014 11:55:00:
     * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 30 2014 23:59:59.999
     */

    function endOfMonth(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var month = date.getMonth();
      date.setFullYear(date.getFullYear(), month + 1, 0);
      date.setHours(23, 59, 59, 999);
      return date;
    }

    /**
     * @name isLastDayOfMonth
     * @category Month Helpers
     * @summary Is the given date the last day of a month?
     *
     * @description
     * Is the given date the last day of a month?
     *
     * @param {Date|Number} date - the date to check
     * @returns {Boolean} the date is the last day of a month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Is 28 February 2014 the last day of a month?
     * const result = isLastDayOfMonth(new Date(2014, 1, 28))
     * //=> true
     */

    function isLastDayOfMonth(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      return endOfDay(date).getTime() === endOfMonth(date).getTime();
    }

    /**
     * @name differenceInMonths
     * @category Month Helpers
     * @summary Get the number of full months between the given dates.
     *
     * @description
     * Get the number of full months between the given dates using trunc as a default rounding method.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of full months
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many full months are between 31 January 2014 and 1 September 2014?
     * const result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
     * //=> 7
     */

    function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var sign = compareAsc(dateLeft, dateRight);
      var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
      var result; // Check for the difference of less than month

      if (difference < 1) {
        result = 0;
      } else {
        if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
          // This will check if the date is end of Feb and assign a higher end of month date
          // to compare it with Jan
          dateLeft.setDate(30);
        }

        dateLeft.setMonth(dateLeft.getMonth() - sign * difference); // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
        // If so, result must be decreased by 1 in absolute value

        var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign; // Check for cases of one full calendar month

        if (isLastDayOfMonth(toDate(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
          isLastMonthNotFull = false;
        }

        result = sign * (difference - Number(isLastMonthNotFull));
      } // Prevent negative zero


      return result === 0 ? 0 : result;
    }

    /**
     * @name differenceInWeeks
     * @category Week Helpers
     * @summary Get the number of full weeks between the given dates.
     *
     * @description
     * Get the number of full weeks between two dates. Fractional weeks are
     * truncated towards zero by default.
     *
     * One "full week" is the distance between a local time in one day to the same
     * local time 7 days earlier or later. A full week can sometimes be less than
     * or more than 7*24 hours if a daylight savings change happens between two dates.
     *
     * To ignore DST and only measure exact 7*24-hour periods, use this instead:
     * `Math.floor(differenceInHours(dateLeft, dateRight)/(7*24))|0`.
     *
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @param {Object} [options] - an object with options.
     * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
     * @returns {Number} the number of full weeks
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many full weeks are between 5 July 2014 and 20 July 2014?
     * const result = differenceInWeeks(new Date(2014, 6, 20), new Date(2014, 6, 5))
     * //=> 2
     *
     * // How many full weeks are between
     * // 1 March 2020 0:00 and 6 June 2020 0:00 ?
     * // Note: because local time is used, the
     * // result will always be 8 weeks (54 days),
     * // even if DST starts and the period has
     * // only 54*24-1 hours.
     * const result = differenceInWeeks(
     *   new Date(2020, 5, 1),
     *   new Date(2020, 2, 6)
     * )
     * //=> 8
     */

    function differenceInWeeks(dateLeft, dateRight, options) {
      requiredArgs(2, arguments);
      var diff = differenceInDays(dateLeft, dateRight) / 7;
      return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
    }

    /**
     * @name differenceInYears
     * @category Year Helpers
     * @summary Get the number of full years between the given dates.
     *
     * @description
     * Get the number of full years between the given dates.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of full years
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many full years are between 31 December 2013 and 11 February 2015?
     * const result = differenceInYears(new Date(2015, 1, 11), new Date(2013, 11, 31))
     * //=> 1
     */

    function differenceInYears(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var sign = compareAsc(dateLeft, dateRight);
      var difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight)); // Set both dates to a valid leap year for accurate comparison when dealing
      // with leap days

      dateLeft.setFullYear(1584);
      dateRight.setFullYear(1584); // Math.abs(diff in full years - diff in calendar years) === 1 if last calendar year is not full
      // If so, result must be decreased by 1 in absolute value

      var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign;
      var result = sign * (difference - Number(isLastYearNotFull)); // Prevent negative zero

      return result === 0 ? 0 : result;
    }

    /**
     * @name startOfMonth
     * @category Month Helpers
     * @summary Return the start of a month for the given date.
     *
     * @description
     * Return the start of a month for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a month for 2 September 2014 11:55:00:
     * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Mon Sep 01 2014 00:00:00
     */

    function startOfMonth(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * @name endOfYear
     * @category Year Helpers
     * @summary Return the end of a year for the given date.
     *
     * @description
     * Return the end of a year for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the end of a year
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The end of a year for 2 September 2014 11:55:00:
     * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))
     * //=> Wed Dec 31 2014 23:59:59.999
     */

    function endOfYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getFullYear();
      date.setFullYear(year + 1, 0, 0);
      date.setHours(23, 59, 59, 999);
      return date;
    }

    /**
     * @name startOfYear
     * @category Year Helpers
     * @summary Return the start of a year for the given date.
     *
     * @description
     * Return the start of a year for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a year
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a year for 2 September 2014 11:55:00:
     * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
     * //=> Wed Jan 01 2014 00:00:00
     */

    function startOfYear(dirtyDate) {
      requiredArgs(1, arguments);
      var cleanDate = toDate(dirtyDate);
      var date = new Date(0);
      date.setFullYear(cleanDate.getFullYear(), 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * @name endOfWeek
     * @category Week Helpers
     * @summary Return the end of a week for the given date.
     *
     * @description
     * Return the end of a week for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @returns {Date} the end of a week
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     *
     * @example
     * // The end of a week for 2 September 2014 11:55:00:
     * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Sat Sep 06 2014 23:59:59.999
     *
     * @example
     * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
     * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
     * //=> Sun Sep 07 2014 23:59:59.999
     */

    function endOfWeek(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      var date = toDate(dirtyDate);
      var day = date.getDay();
      var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
      date.setDate(date.getDate() + diff);
      date.setHours(23, 59, 59, 999);
      return date;
    }

    /**
     * @name subMilliseconds
     * @category Millisecond Helpers
     * @summary Subtract the specified number of milliseconds from the given date.
     *
     * @description
     * Subtract the specified number of milliseconds from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
     * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:29.250
     */

    function subMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger$1(dirtyAmount);
      return addMilliseconds(dirtyDate, -amount);
    }

    var MILLISECONDS_IN_DAY = 86400000;
    function getUTCDayOfYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var timestamp = date.getTime();
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
      var startOfYearTimestamp = date.getTime();
      var difference = timestamp - startOfYearTimestamp;
      return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
    }

    function startOfUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var weekStartsOn = 1;
      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    function getUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getUTCFullYear();
      var fourthOfJanuaryOfNextYear = new Date(0);
      fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
      var fourthOfJanuaryOfThisYear = new Date(0);
      fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    function startOfUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var year = getUTCISOWeekYear(dirtyDate);
      var fourthOfJanuary = new Date(0);
      fourthOfJanuary.setUTCFullYear(year, 0, 4);
      fourthOfJanuary.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCISOWeek(fourthOfJanuary);
      return date;
    }

    var MILLISECONDS_IN_WEEK$2 = 604800000;
    function getUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1;
    }

    function startOfUTCWeek(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    function getUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getUTCFullYear();
      var defaultOptions = getDefaultOptions();
      var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var firstWeekOfNextYear = new Date(0);
      firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
      var firstWeekOfThisYear = new Date(0);
      firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    function startOfUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      var year = getUTCWeekYear(dirtyDate, options);
      var firstWeek = new Date(0);
      firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCWeek(firstWeek, options);
      return date;
    }

    var MILLISECONDS_IN_WEEK$1 = 604800000;
    function getUTCWeek(dirtyDate, options) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
    }

    function addLeadingZeros(number, targetLength) {
      var sign = number < 0 ? '-' : '';
      var output = Math.abs(number).toString();

      while (output.length < targetLength) {
        output = '0' + output;
      }

      return sign + output;
    }

    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* |                                |
     * |  d  | Day of month                   |  D  |                                |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  m  | Minute                         |  M  | Month                          |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  y  | Year (abs)                     |  Y  |                                |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     */

    var formatters$2 = {
      // Year
      y: function (date, token) {
        // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
        // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
        // |----------|-------|----|-------|-------|-------|
        // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
        // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
        // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
        // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
        // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
        var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
      },
      // Month
      M: function (date, token) {
        var month = date.getUTCMonth();
        return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
      },
      // Day of the month
      d: function (date, token) {
        return addLeadingZeros(date.getUTCDate(), token.length);
      },
      // AM or PM
      a: function (date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
            return dayPeriodEnumValue.toUpperCase();

          case 'aaa':
            return dayPeriodEnumValue;

          case 'aaaaa':
            return dayPeriodEnumValue[0];

          case 'aaaa':
          default:
            return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
        }
      },
      // Hour [1-12]
      h: function (date, token) {
        return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H: function (date, token) {
        return addLeadingZeros(date.getUTCHours(), token.length);
      },
      // Minute
      m: function (date, token) {
        return addLeadingZeros(date.getUTCMinutes(), token.length);
      },
      // Second
      s: function (date, token) {
        return addLeadingZeros(date.getUTCSeconds(), token.length);
      },
      // Fraction of second
      S: function (date, token) {
        var numberOfDigits = token.length;
        var milliseconds = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros(fractionalSeconds, token.length);
      }
    };
    var formatters$3 = formatters$2;

    var dayPeriodEnum = {
      am: 'am',
      pm: 'pm',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    };
    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* | Milliseconds in day            |
     * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
     * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
     * |  d  | Day of month                   |  D  | Day of year                    |
     * |  e  | Local day of week              |  E  | Day of week                    |
     * |  f  |                                |  F* | Day of week in month           |
     * |  g* | Modified Julian day            |  G  | Era                            |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  i! | ISO day of week                |  I! | ISO week of year               |
     * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
     * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
     * |  l* | (deprecated)                   |  L  | Stand-alone month              |
     * |  m  | Minute                         |  M  | Month                          |
     * |  n  |                                |  N  |                                |
     * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
     * |  p! | Long localized time            |  P! | Long localized date            |
     * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
     * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
     * |  u  | Extended year                  |  U* | Cyclic year                    |
     * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
     * |  w  | Local week of year             |  W* | Week of month                  |
     * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
     * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
     * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     *
     * Letters marked by ! are non-standard, but implemented by date-fns:
     * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
     * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
     *   i.e. 7 for Sunday, 1 for Monday, etc.
     * - `I` is ISO week of year, as opposed to `w` which is local week of year.
     * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
     *   `R` is supposed to be used in conjunction with `I` and `i`
     *   for universal ISO week-numbering date, whereas
     *   `Y` is supposed to be used in conjunction with `w` and `e`
     *   for week-numbering date specific to the locale.
     * - `P` is long localized date format
     * - `p` is long localized time format
     */

    var formatters = {
      // Era
      G: function (date, token, localize) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;

        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return localize.era(era, {
              width: 'abbreviated'
            });
          // A, B

          case 'GGGGG':
            return localize.era(era, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ

          case 'GGGG':
          default:
            return localize.era(era, {
              width: 'wide'
            });
        }
      },
      // Year
      y: function (date, token, localize) {
        // Ordinal number
        if (token === 'yo') {
          var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize.ordinalNumber(year, {
            unit: 'year'
          });
        }

        return formatters$3.y(date, token);
      },
      // Local week-numbering year
      Y: function (date, token, localize, options) {
        var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

        if (token === 'YY') {
          var twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        } // Ordinal number


        if (token === 'Yo') {
          return localize.ordinalNumber(weekYear, {
            unit: 'year'
          });
        } // Padding


        return addLeadingZeros(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function (date, token) {
        var isoWeekYear = getUTCISOWeekYear(date); // Padding

        return addLeadingZeros(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function (date, token) {
        var year = date.getUTCFullYear();
        return addLeadingZeros(year, token.length);
      },
      // Quarter
      Q: function (date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'QQ':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'Qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'QQQ':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'QQQQQ':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...

          case 'QQQQ':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone quarter
      q: function (date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'qq':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'qqq':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'qqqqq':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...

          case 'qqqq':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Month
      M: function (date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          case 'M':
          case 'MM':
            return formatters$3.M(date, token);
          // 1st, 2nd, ..., 12th

          case 'Mo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'MMM':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // J, F, ..., D

          case 'MMMMM':
            return localize.month(month, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December

          case 'MMMM':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone month
      L: function (date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return String(month + 1);
          // 01, 02, ..., 12

          case 'LL':
            return addLeadingZeros(month + 1, 2);
          // 1st, 2nd, ..., 12th

          case 'Lo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'LLL':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // J, F, ..., D

          case 'LLLLL':
            return localize.month(month, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December

          case 'LLLL':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Local week of year
      w: function (date, token, localize, options) {
        var week = getUTCWeek(date, options);

        if (token === 'wo') {
          return localize.ordinalNumber(week, {
            unit: 'week'
          });
        }

        return addLeadingZeros(week, token.length);
      },
      // ISO week of year
      I: function (date, token, localize) {
        var isoWeek = getUTCISOWeek(date);

        if (token === 'Io') {
          return localize.ordinalNumber(isoWeek, {
            unit: 'week'
          });
        }

        return addLeadingZeros(isoWeek, token.length);
      },
      // Day of the month
      d: function (date, token, localize) {
        if (token === 'do') {
          return localize.ordinalNumber(date.getUTCDate(), {
            unit: 'date'
          });
        }

        return formatters$3.d(date, token);
      },
      // Day of year
      D: function (date, token, localize) {
        var dayOfYear = getUTCDayOfYear(date);

        if (token === 'Do') {
          return localize.ordinalNumber(dayOfYear, {
            unit: 'dayOfYear'
          });
        }

        return addLeadingZeros(dayOfYear, token.length);
      },
      // Day of week
      E: function (date, token, localize) {
        var dayOfWeek = date.getUTCDay();

        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'EEEEE':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'EEEEEE':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'EEEE':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Local day of week
      e: function (date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (Nth day of week with current locale or weekStartsOn)
          case 'e':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'ee':
            return addLeadingZeros(localDayOfWeek, 2);
          // 1st, 2nd, ..., 7th

          case 'eo':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'eee':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'eeeee':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'eeeeee':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'eeee':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone local day of week
      c: function (date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (same as in `e`)
          case 'c':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'cc':
            return addLeadingZeros(localDayOfWeek, token.length);
          // 1st, 2nd, ..., 7th

          case 'co':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'ccc':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // T

          case 'ccccc':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu

          case 'cccccc':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'standalone'
            });
          // Tuesday

          case 'cccc':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // ISO day of week
      i: function (date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

        switch (token) {
          // 2
          case 'i':
            return String(isoDayOfWeek);
          // 02

          case 'ii':
            return addLeadingZeros(isoDayOfWeek, token.length);
          // 2nd

          case 'io':
            return localize.ordinalNumber(isoDayOfWeek, {
              unit: 'day'
            });
          // Tue

          case 'iii':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'iiiii':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'iiiiii':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'iiii':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM or PM
      a: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'aaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            }).toLowerCase();

          case 'aaaaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaa':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM, PM, midnight, noon
      b: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
        }

        switch (token) {
          case 'b':
          case 'bb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'bbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            }).toLowerCase();

          case 'bbbbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbb':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }

        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'BBBBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBB':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Hour [1-12]
      h: function (date, token, localize) {
        if (token === 'ho') {
          var hours = date.getUTCHours() % 12;
          if (hours === 0) hours = 12;
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return formatters$3.h(date, token);
      },
      // Hour [0-23]
      H: function (date, token, localize) {
        if (token === 'Ho') {
          return localize.ordinalNumber(date.getUTCHours(), {
            unit: 'hour'
          });
        }

        return formatters$3.H(date, token);
      },
      // Hour [0-11]
      K: function (date, token, localize) {
        var hours = date.getUTCHours() % 12;

        if (token === 'Ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros(hours, token.length);
      },
      // Hour [1-24]
      k: function (date, token, localize) {
        var hours = date.getUTCHours();
        if (hours === 0) hours = 24;

        if (token === 'ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros(hours, token.length);
      },
      // Minute
      m: function (date, token, localize) {
        if (token === 'mo') {
          return localize.ordinalNumber(date.getUTCMinutes(), {
            unit: 'minute'
          });
        }

        return formatters$3.m(date, token);
      },
      // Second
      s: function (date, token, localize) {
        if (token === 'so') {
          return localize.ordinalNumber(date.getUTCSeconds(), {
            unit: 'second'
          });
        }

        return formatters$3.s(date, token);
      },
      // Fraction of second
      S: function (date, token) {
        return formatters$3.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        if (timezoneOffset === 0) {
          return 'Z';
        }

        switch (token) {
          // Hours and optional minutes
          case 'X':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XX`

          case 'XXXX':
          case 'XX':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XXX`

          case 'XXXXX':
          case 'XXX': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Hours and optional minutes
          case 'x':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xx`

          case 'xxxx':
          case 'xx':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xxx`

          case 'xxxxx':
          case 'xxx': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (GMT)
      O: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'O':
          case 'OO':
          case 'OOO':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'OOOO':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (specific non-location)
      z: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'z':
          case 'zz':
          case 'zzz':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'zzzz':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Seconds timestamp
      t: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1000);
        return addLeadingZeros(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return addLeadingZeros(timestamp, token.length);
      }
    };

    function formatTimezoneShort(offset, dirtyDelimiter) {
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = Math.floor(absOffset / 60);
      var minutes = absOffset % 60;

      if (minutes === 0) {
        return sign + String(hours);
      }

      var delimiter = dirtyDelimiter || '';
      return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
    }

    function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
      if (offset % 60 === 0) {
        var sign = offset > 0 ? '-' : '+';
        return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
      }

      return formatTimezone(offset, dirtyDelimiter);
    }

    function formatTimezone(offset, dirtyDelimiter) {
      var delimiter = dirtyDelimiter || '';
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
      var minutes = addLeadingZeros(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }

    var formatters$1 = formatters;

    var dateLongFormatter = function (pattern, formatLong) {
      switch (pattern) {
        case 'P':
          return formatLong.date({
            width: 'short'
          });

        case 'PP':
          return formatLong.date({
            width: 'medium'
          });

        case 'PPP':
          return formatLong.date({
            width: 'long'
          });

        case 'PPPP':
        default:
          return formatLong.date({
            width: 'full'
          });
      }
    };

    var timeLongFormatter = function (pattern, formatLong) {
      switch (pattern) {
        case 'p':
          return formatLong.time({
            width: 'short'
          });

        case 'pp':
          return formatLong.time({
            width: 'medium'
          });

        case 'ppp':
          return formatLong.time({
            width: 'long'
          });

        case 'pppp':
        default:
          return formatLong.time({
            width: 'full'
          });
      }
    };

    var dateTimeLongFormatter = function (pattern, formatLong) {
      var matchResult = pattern.match(/(P+)(p+)?/) || [];
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];

      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong);
      }

      var dateTimeFormat;

      switch (datePattern) {
        case 'P':
          dateTimeFormat = formatLong.dateTime({
            width: 'short'
          });
          break;

        case 'PP':
          dateTimeFormat = formatLong.dateTime({
            width: 'medium'
          });
          break;

        case 'PPP':
          dateTimeFormat = formatLong.dateTime({
            width: 'long'
          });
          break;

        case 'PPPP':
        default:
          dateTimeFormat = formatLong.dateTime({
            width: 'full'
          });
          break;
      }

      return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
    };

    var longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
    var longFormatters$1 = longFormatters;

    var protectedDayOfYearTokens = ['D', 'DD'];
    var protectedWeekYearTokens = ['YY', 'YYYY'];
    function isProtectedDayOfYearToken(token) {
      return protectedDayOfYearTokens.indexOf(token) !== -1;
    }
    function isProtectedWeekYearToken(token) {
      return protectedWeekYearTokens.indexOf(token) !== -1;
    }
    function throwProtectedError(token, format, input) {
      if (token === 'YYYY') {
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'YY') {
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'D') {
        throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'DD') {
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      }
    }

    var formatDistanceLocale$3 = {
      lessThanXSeconds: {
        one: 'less than a second',
        other: 'less than {{count}} seconds'
      },
      xSeconds: {
        one: '1 second',
        other: '{{count}} seconds'
      },
      halfAMinute: 'half a minute',
      lessThanXMinutes: {
        one: 'less than a minute',
        other: 'less than {{count}} minutes'
      },
      xMinutes: {
        one: '1 minute',
        other: '{{count}} minutes'
      },
      aboutXHours: {
        one: 'about 1 hour',
        other: 'about {{count}} hours'
      },
      xHours: {
        one: '1 hour',
        other: '{{count}} hours'
      },
      xDays: {
        one: '1 day',
        other: '{{count}} days'
      },
      aboutXWeeks: {
        one: 'about 1 week',
        other: 'about {{count}} weeks'
      },
      xWeeks: {
        one: '1 week',
        other: '{{count}} weeks'
      },
      aboutXMonths: {
        one: 'about 1 month',
        other: 'about {{count}} months'
      },
      xMonths: {
        one: '1 month',
        other: '{{count}} months'
      },
      aboutXYears: {
        one: 'about 1 year',
        other: 'about {{count}} years'
      },
      xYears: {
        one: '1 year',
        other: '{{count}} years'
      },
      overXYears: {
        one: 'over 1 year',
        other: 'over {{count}} years'
      },
      almostXYears: {
        one: 'almost 1 year',
        other: 'almost {{count}} years'
      }
    };

    var formatDistance$6 = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$3[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', count.toString());
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'in ' + result;
        } else {
          return result + ' ago';
        }
      }

      return result;
    };

    var formatDistance$7 = formatDistance$6;

    function buildFormatLongFn(args) {
      return function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // TODO: Remove String()

        var width = options.width ? String(options.width) : args.defaultWidth;
        var format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
      };
    }

    var dateFormats$3 = {
      full: 'EEEE, MMMM do, y',
      long: 'MMMM do, y',
      medium: 'MMM d, y',
      short: 'MM/dd/yyyy'
    };
    var timeFormats$3 = {
      full: 'h:mm:ss a zzzz',
      long: 'h:mm:ss a z',
      medium: 'h:mm:ss a',
      short: 'h:mm a'
    };
    var dateTimeFormats$3 = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$6 = {
      date: buildFormatLongFn({
        formats: dateFormats$3,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats$3,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$3,
        defaultWidth: 'full'
      })
    };
    var formatLong$7 = formatLong$6;

    var formatRelativeLocale$3 = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: 'P'
    };

    var formatRelative$6 = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$3[token];
    };

    var formatRelative$7 = formatRelative$6;

    function buildLocalizeFn(args) {
      return function (dirtyIndex, options) {
        var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
        var valuesArray;

        if (context === 'formatting' && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;

          var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;

          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }

        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

        return valuesArray[index];
      };
    }

    var eraValues$3 = {
      narrow: ['B', 'A'],
      abbreviated: ['BC', 'AD'],
      wide: ['Before Christ', 'Anno Domini']
    };
    var quarterValues$3 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
    }; // Note: in English, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.

    var monthValues$3 = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    };
    var dayValues$3 = {
      narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
      short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
      abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    };
    var dayPeriodValues$3 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      }
    };
    var formattingDayPeriodValues$2 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      }
    };

    var ordinalNumber$3 = function (dirtyNumber, _options) {
      var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
      // if they are different for different grammatical genders,
      // use `options.unit`.
      //
      // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
      // 'day', 'hour', 'minute', 'second'.

      var rem100 = number % 100;

      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + 'st';

          case 2:
            return number + 'nd';

          case 3:
            return number + 'rd';
        }
      }

      return number + 'th';
    };

    var localize$6 = {
      ordinalNumber: ordinalNumber$3,
      era: buildLocalizeFn({
        values: eraValues$3,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$3,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues$3,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues$3,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$3,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$2,
        defaultFormattingWidth: 'wide'
      })
    };
    var localize$7 = localize$6;

    function buildMatchFn(args) {
      return function (string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);

        if (!matchResult) {
          return null;
        }

        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
          return pattern.test(matchedString);
        }) : findKey(parsePatterns, function (pattern) {
          return pattern.test(matchedString);
        });
        var value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value: value,
          rest: rest
        };
      };
    }

    function findKey(object, predicate) {
      for (var key in object) {
        if (object.hasOwnProperty(key) && predicate(object[key])) {
          return key;
        }
      }

      return undefined;
    }

    function findIndex(array, predicate) {
      for (var key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }

      return undefined;
    }

    function buildMatchPatternFn(args) {
      return function (string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var matchResult = string.match(args.matchPattern);
        if (!matchResult) return null;
        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);
        if (!parseResult) return null;
        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value: value,
          rest: rest
        };
      };
    }

    var matchOrdinalNumberPattern$3 = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern$3 = /\d+/i;
    var matchEraPatterns$3 = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns$3 = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns$3 = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns$3 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$3 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns$3 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$3 = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns$3 = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns$3 = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns$3 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match$7 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$3,
        parsePattern: parseOrdinalNumberPattern$3,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$3,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$3,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$3,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$3,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$3,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$3,
        defaultParseWidth: 'any'
      })
    };
    var match$8 = match$7;

    /**
     * @type {Locale}
     * @category Locales
     * @summary English locale (United States).
     * @language English
     * @iso-639-2 eng
     * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
     * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
     */

    var locale$3 = {
      code: 'en-US',
      formatDistance: formatDistance$7,
      formatLong: formatLong$7,
      formatRelative: formatRelative$7,
      localize: localize$7,
      match: match$8,
      options: {
        weekStartsOn: 0
        /* Sunday */
        ,
        firstWeekContainsDate: 1
      }
    };
    var defaultLocale = locale$3;

    // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
    //   (one of the certain letters followed by `o`)
    // - (\w)\1* matches any sequences of the same letter
    // - '' matches two quote characters in a row
    // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
    //   except a single quote symbol, which ends the sequence.
    //   Two quote characters do not end the sequence.
    //   If there is no matching single quote
    //   then the sequence will continue until the end of the string.
    // - . matches any single character unmatched by previous parts of the RegExps

    var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
    // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

    var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp$1 = /^'([^]*?)'?$/;
    var doubleQuoteRegExp$1 = /''/g;
    var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
    /**
     * @name format
     * @category Common Helpers
     * @summary Format the date.
     *
     * @description
     * Return the formatted date string in the given format. The result may vary by locale.
     *
     * > â ï¸ Please note that the `format` tokens differ from Moment.js and other libraries.
     * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * The characters wrapped between two single quotes characters (') are escaped.
     * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
     * (see the last example)
     *
     * Format of the string is based on Unicode Technical Standard #35:
     * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * with a few additions (see note 7 below the table).
     *
     * Accepted patterns:
     * | Unit                            | Pattern | Result examples                   | Notes |
     * |---------------------------------|---------|-----------------------------------|-------|
     * | Era                             | G..GGG  | AD, BC                            |       |
     * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
     * |                                 | GGGGG   | A, B                              |       |
     * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
     * |                                 | yy      | 44, 01, 00, 17                    | 5     |
     * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
     * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
     * |                                 | yyyyy   | ...                               | 3,5   |
     * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
     * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
     * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
     * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
     * |                                 | YYYYY   | ...                               | 3,5   |
     * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
     * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
     * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
     * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
     * |                                 | RRRRR   | ...                               | 3,5,7 |
     * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
     * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
     * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
     * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
     * |                                 | uuuuu   | ...                               | 3,5   |
     * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
     * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | QQ      | 01, 02, 03, 04                    |       |
     * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
     * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
     * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | qq      | 01, 02, 03, 04                    |       |
     * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
     * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
     * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | MM      | 01, 02, ..., 12                   |       |
     * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
     * |                                 | MMMM    | January, February, ..., December  | 2     |
     * |                                 | MMMMM   | J, F, ..., D                      |       |
     * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
     * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | LL      | 01, 02, ..., 12                   |       |
     * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
     * |                                 | LLLL    | January, February, ..., December  | 2     |
     * |                                 | LLLLL   | J, F, ..., D                      |       |
     * | Local week of year              | w       | 1, 2, ..., 53                     |       |
     * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | ww      | 01, 02, ..., 53                   |       |
     * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
     * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | II      | 01, 02, ..., 53                   | 7     |
     * | Day of month                    | d       | 1, 2, ..., 31                     |       |
     * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
     * |                                 | dd      | 01, 02, ..., 31                   |       |
     * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
     * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
     * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
     * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
     * |                                 | DDDD    | ...                               | 3     |
     * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
     * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
     * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
     * |                                 | ii      | 01, 02, ..., 07                   | 7     |
     * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
     * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
     * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
     * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
     * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
     * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | ee      | 02, 03, ..., 01                   |       |
     * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
     * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
     * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | cc      | 02, 03, ..., 01                   |       |
     * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
     * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | AM, PM                          | a..aa   | AM, PM                            |       |
     * |                                 | aaa     | am, pm                            |       |
     * |                                 | aaaa    | a.m., p.m.                        | 2     |
     * |                                 | aaaaa   | a, p                              |       |
     * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
     * |                                 | bbb     | am, pm, noon, midnight            |       |
     * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
     * |                                 | bbbbb   | a, p, n, mi                       |       |
     * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
     * |                                 | BBBB    | at night, in the morning, ...     | 2     |
     * |                                 | BBBBB   | at night, in the morning, ...     |       |
     * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
     * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
     * |                                 | hh      | 01, 02, ..., 11, 12               |       |
     * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
     * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
     * |                                 | HH      | 00, 01, 02, ..., 23               |       |
     * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
     * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
     * |                                 | KK      | 01, 02, ..., 11, 00               |       |
     * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
     * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
     * |                                 | kk      | 24, 01, 02, ..., 23               |       |
     * | Minute                          | m       | 0, 1, ..., 59                     |       |
     * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | mm      | 00, 01, ..., 59                   |       |
     * | Second                          | s       | 0, 1, ..., 59                     |       |
     * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | ss      | 00, 01, ..., 59                   |       |
     * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
     * |                                 | SS      | 00, 01, ..., 99                   |       |
     * |                                 | SSS     | 000, 001, ..., 999                |       |
     * |                                 | SSSS    | ...                               | 3     |
     * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
     * |                                 | XX      | -0800, +0530, Z                   |       |
     * |                                 | XXX     | -08:00, +05:30, Z                 |       |
     * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
     * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
     * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
     * |                                 | xx      | -0800, +0530, +0000               |       |
     * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
     * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
     * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
     * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
     * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
     * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
     * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
     * | Seconds timestamp               | t       | 512969520                         | 7     |
     * |                                 | tt      | ...                               | 3,7   |
     * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
     * |                                 | TT      | ...                               | 3,7   |
     * | Long localized date             | P       | 04/29/1453                        | 7     |
     * |                                 | PP      | Apr 29, 1453                      | 7     |
     * |                                 | PPP     | April 29th, 1453                  | 7     |
     * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
     * | Long localized time             | p       | 12:00 AM                          | 7     |
     * |                                 | pp      | 12:00:00 AM                       | 7     |
     * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
     * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
     * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
     * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
     * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
     * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
     * Notes:
     * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
     *    are the same as "stand-alone" units, but are different in some languages.
     *    "Formatting" units are declined according to the rules of the language
     *    in the context of a date. "Stand-alone" units are always nominative singular:
     *
     *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
     *
     *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
     *
     * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
     *    the single quote characters (see below).
     *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
     *    the output will be the same as default pattern for this unit, usually
     *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
     *    are marked with "2" in the last column of the table.
     *
     *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
     *
     * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
     *    The output will be padded with zeros to match the length of the pattern.
     *
     *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
     *
     * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
     *    These tokens represent the shortest form of the quarter.
     *
     * 5. The main difference between `y` and `u` patterns are B.C. years:
     *
     *    | Year | `y` | `u` |
     *    |------|-----|-----|
     *    | AC 1 |   1 |   1 |
     *    | BC 1 |   1 |   0 |
     *    | BC 2 |   2 |  -1 |
     *
     *    Also `yy` always returns the last two digits of a year,
     *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
     *
     *    | Year | `yy` | `uu` |
     *    |------|------|------|
     *    | 1    |   01 |   01 |
     *    | 14   |   14 |   14 |
     *    | 376  |   76 |  376 |
     *    | 1453 |   53 | 1453 |
     *
     *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
     *    except local week-numbering years are dependent on `options.weekStartsOn`
     *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
     *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
     *
     * 6. Specific non-location timezones are currently unavailable in `date-fns`,
     *    so right now these tokens fall back to GMT timezones.
     *
     * 7. These patterns are not in the Unicode Technical Standard #35:
     *    - `i`: ISO day of week
     *    - `I`: ISO week of year
     *    - `R`: ISO week-numbering year
     *    - `t`: seconds timestamp
     *    - `T`: milliseconds timestamp
     *    - `o`: ordinal number modifier
     *    - `P`: long localized date
     *    - `p`: long localized time
     *
     * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
     *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
     *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * @param {Date|Number} date - the original date
     * @param {String} format - the string of tokens
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
     * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @returns {String} the formatted date string
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `date` must not be Invalid Date
     * @throws {RangeError} `options.locale` must contain `localize` property
     * @throws {RangeError} `options.locale` must contain `formatLong` property
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} format string contains an unescaped latin alphabet character
     *
     * @example
     * // Represent 11 February 2014 in middle-endian format:
     * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
     * //=> '02/11/2014'
     *
     * @example
     * // Represent 2 July 2014 in Esperanto:
     * import { eoLocale } from 'date-fns/locale/eo'
     * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
     *   locale: eoLocale
     * })
     * //=> '2-a de julio 2014'
     *
     * @example
     * // Escape string by single quote characters:
     * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
     * //=> "3 o'clock"
     */

    function format$2(dirtyDate, dirtyFormatStr, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

      requiredArgs(2, arguments);
      var formatStr = String(dirtyFormatStr);
      var defaultOptions = getDefaultOptions();
      var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
      var firstWeekContainsDate = toInteger$1((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var weekStartsOn = toInteger$1((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      if (!locale.localize) {
        throw new RangeError('locale must contain localize property');
      }

      if (!locale.formatLong) {
        throw new RangeError('locale must contain formatLong property');
      }

      var originalDate = toDate(dirtyDate);

      if (!isValid(originalDate)) {
        throw new RangeError('Invalid time value');
      } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
      // This ensures that when UTC functions will be implemented, locales will be compatible with them.
      // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


      var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
      var utcDate = subMilliseconds(originalDate, timezoneOffset);
      var formatterOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale,
        _originalDate: originalDate
      };
      var result = formatStr.match(longFormattingTokensRegExp$1).map(function (substring) {
        var firstCharacter = substring[0];

        if (firstCharacter === 'p' || firstCharacter === 'P') {
          var longFormatter = longFormatters$1[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }

        return substring;
      }).join('').match(formattingTokensRegExp$1).map(function (substring) {
        // Replace two single quote characters with one single quote character
        if (substring === "''") {
          return "'";
        }

        var firstCharacter = substring[0];

        if (firstCharacter === "'") {
          return cleanEscapedString$1(substring);
        }

        var formatter = formatters$1[firstCharacter];

        if (formatter) {
          if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
          }

          if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
          }

          return formatter(utcDate, substring, locale.localize, formatterOptions);
        }

        if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        }

        return substring;
      }).join('');
      return result;
    }

    function cleanEscapedString$1(input) {
      var matched = input.match(escapedStringRegExp$1);

      if (!matched) {
        return input;
      }

      return matched[1].replace(doubleQuoteRegExp$1, "'");
    }

    function assign(target, object) {
      if (target == null) {
        throw new TypeError('assign requires that input parameter not be null or undefined');
      }

      for (var property in object) {
        if (Object.prototype.hasOwnProperty.call(object, property)) {
          target[property] = object[property];
        }
      }

      return target;
    }

    /**
     * @name getWeekYear
     * @category Week-Numbering Year Helpers
     * @summary Get the local week-numbering year of the given date.
     *
     * @description
     * Get the local week-numbering year of the given date.
     * The exact calculation depends on the values of
     * `options.weekStartsOn` (which is the index of the first day of the week)
     * and `options.firstWeekContainsDate` (which is the day of January, which is always in
     * the first week of the week-numbering year)
     *
     * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
     *
     * @param {Date|Number} date - the given date
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
     * @returns {Number} the local week-numbering year
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     *
     * @example
     * // Which week numbering year is 26 December 2004 with the default settings?
     * const result = getWeekYear(new Date(2004, 11, 26))
     * //=> 2005
     *
     * @example
     * // Which week numbering year is 26 December 2004 if week starts on Saturday?
     * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
     * //=> 2004
     *
     * @example
     * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
     * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
     * //=> 2004
     */

    function getWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getFullYear();
      var defaultOptions = getDefaultOptions();
      var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var firstWeekOfNextYear = new Date(0);
      firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setHours(0, 0, 0, 0);
      var startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
      var firstWeekOfThisYear = new Date(0);
      firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setHours(0, 0, 0, 0);
      var startOfThisYear = startOfWeek(firstWeekOfThisYear, options);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    /**
     * @name startOfWeekYear
     * @category Week-Numbering Year Helpers
     * @summary Return the start of a local week-numbering year for the given date.
     *
     * @description
     * Return the start of a local week-numbering year.
     * The exact calculation depends on the values of
     * `options.weekStartsOn` (which is the index of the first day of the week)
     * and `options.firstWeekContainsDate` (which is the day of January, which is always in
     * the first week of the week-numbering year)
     *
     * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
     *
     * @param {Date|Number} date - the original date
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
     * @returns {Date} the start of a week-numbering year
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     *
     * @example
     * // The start of an a week-numbering year for 2 July 2005 with default settings:
     * const result = startOfWeekYear(new Date(2005, 6, 2))
     * //=> Sun Dec 26 2004 00:00:00
     *
     * @example
     * // The start of a week-numbering year for 2 July 2005
     * // if Monday is the first day of week
     * // and 4 January is always in the first week of the year:
     * const result = startOfWeekYear(new Date(2005, 6, 2), {
     *   weekStartsOn: 1,
     *   firstWeekContainsDate: 4
     * })
     * //=> Mon Jan 03 2005 00:00:00
     */

    function startOfWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      var year = getWeekYear(dirtyDate, options);
      var firstWeek = new Date(0);
      firstWeek.setFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setHours(0, 0, 0, 0);
      var date = startOfWeek(firstWeek, options);
      return date;
    }

    var MILLISECONDS_IN_WEEK = 604800000;
    /**
     * @name getWeek
     * @category Week Helpers
     * @summary Get the local week index of the given date.
     *
     * @description
     * Get the local week index of the given date.
     * The exact calculation depends on the values of
     * `options.weekStartsOn` (which is the index of the first day of the week)
     * and `options.firstWeekContainsDate` (which is the day of January, which is always in
     * the first week of the week-numbering year)
     *
     * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
     *
     * @param {Date|Number} date - the given date
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
     * @returns {Number} the week
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     *
     * @example
     * // Which week of the local week numbering year is 2 January 2005 with default options?
     * const result = getWeek(new Date(2005, 0, 2))
     * //=> 2
     *
     * // Which week of the local week numbering year is 2 January 2005,
     * // if Monday is the first day of the week,
     * // and the first week of the year always contains 4 January?
     * const result = getWeek(new Date(2005, 0, 2), {
     *   weekStartsOn: 1,
     *   firstWeekContainsDate: 4
     * })
     * //=> 53
     */

    function getWeek(dirtyDate, options) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfWeek(date, options).getTime() - startOfWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    }

    function _defineProperty$w(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    var TIMEZONE_UNIT_PRIORITY = 10;
    class Setter {
      constructor() {
        _defineProperty$w(this, "priority", void 0);

        _defineProperty$w(this, "subPriority", 0);
      }

      validate(_utcDate, _options) {
        return true;
      }

    }
    class ValueSetter extends Setter {
      constructor(value, validateValue, setValue, priority, subPriority) {
        super();
        this.value = value;
        this.validateValue = validateValue;
        this.setValue = setValue;
        this.priority = priority;

        if (subPriority) {
          this.subPriority = subPriority;
        }
      }

      validate(utcDate, options) {
        return this.validateValue(utcDate, this.value, options);
      }

      set(utcDate, flags, options) {
        return this.setValue(utcDate, flags, this.value, options);
      }

    }
    class DateToSystemTimezoneSetter extends Setter {
      constructor() {
        super(...arguments);

        _defineProperty$w(this, "priority", TIMEZONE_UNIT_PRIORITY);

        _defineProperty$w(this, "subPriority", -1);
      }

      set(date, flags) {
        if (flags.timestampIsSet) {
          return date;
        }

        var convertedDate = new Date(0);
        convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
        convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
        return convertedDate;
      }

    }

    function _defineProperty$v(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class Parser$1 {
      constructor() {
        _defineProperty$v(this, "incompatibleTokens", void 0);

        _defineProperty$v(this, "priority", void 0);

        _defineProperty$v(this, "subPriority", void 0);
      }

      run(dateString, token, match, options) {
        var result = this.parse(dateString, token, match, options);

        if (!result) {
          return null;
        }

        return {
          setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
          rest: result.rest
        };
      }

      validate(_utcDate, _value, _options) {
        return true;
      }

    }

    function _defineProperty$u(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class EraParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$u(this, "priority", 140);

        _defineProperty$u(this, "incompatibleTokens", ['R', 'u', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return match.era(dateString, {
              width: 'abbreviated'
            }) || match.era(dateString, {
              width: 'narrow'
            });
          // A, B

          case 'GGGGG':
            return match.era(dateString, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ

          case 'GGGG':
          default:
            return match.era(dateString, {
              width: 'wide'
            }) || match.era(dateString, {
              width: 'abbreviated'
            }) || match.era(dateString, {
              width: 'narrow'
            });
        }
      }

      set(date, flags, value) {
        flags.era = value;
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    var numericPatterns = {
      month: /^(1[0-2]|0?\d)/,
      // 0 to 12
      date: /^(3[0-1]|[0-2]?\d)/,
      // 0 to 31
      dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
      // 0 to 366
      week: /^(5[0-3]|[0-4]?\d)/,
      // 0 to 53
      hour23h: /^(2[0-3]|[0-1]?\d)/,
      // 0 to 23
      hour24h: /^(2[0-4]|[0-1]?\d)/,
      // 0 to 24
      hour11h: /^(1[0-1]|0?\d)/,
      // 0 to 11
      hour12h: /^(1[0-2]|0?\d)/,
      // 0 to 12
      minute: /^[0-5]?\d/,
      // 0 to 59
      second: /^[0-5]?\d/,
      // 0 to 59
      singleDigit: /^\d/,
      // 0 to 9
      twoDigits: /^\d{1,2}/,
      // 0 to 99
      threeDigits: /^\d{1,3}/,
      // 0 to 999
      fourDigits: /^\d{1,4}/,
      // 0 to 9999
      anyDigitsSigned: /^-?\d+/,
      singleDigitSigned: /^-?\d/,
      // 0 to 9, -0 to -9
      twoDigitsSigned: /^-?\d{1,2}/,
      // 0 to 99, -0 to -99
      threeDigitsSigned: /^-?\d{1,3}/,
      // 0 to 999, -0 to -999
      fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

    };
    var timezonePatterns = {
      basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
      basic: /^([+-])(\d{2})(\d{2})|Z/,
      basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
      extended: /^([+-])(\d{2}):(\d{2})|Z/,
      extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
    };

    function mapValue(parseFnResult, mapFn) {
      if (!parseFnResult) {
        return parseFnResult;
      }

      return {
        value: mapFn(parseFnResult.value),
        rest: parseFnResult.rest
      };
    }
    function parseNumericPattern(pattern, dateString) {
      var matchResult = dateString.match(pattern);

      if (!matchResult) {
        return null;
      }

      return {
        value: parseInt(matchResult[0], 10),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseTimezonePattern(pattern, dateString) {
      var matchResult = dateString.match(pattern);

      if (!matchResult) {
        return null;
      } // Input is 'Z'


      if (matchResult[0] === 'Z') {
        return {
          value: 0,
          rest: dateString.slice(1)
        };
      }

      var sign = matchResult[1] === '+' ? 1 : -1;
      var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
      var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
      var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
      return {
        value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseAnyDigitsSigned(dateString) {
      return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
    }
    function parseNDigits(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(numericPatterns.singleDigit, dateString);

        case 2:
          return parseNumericPattern(numericPatterns.twoDigits, dateString);

        case 3:
          return parseNumericPattern(numericPatterns.threeDigits, dateString);

        case 4:
          return parseNumericPattern(numericPatterns.fourDigits, dateString);

        default:
          return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
      }
    }
    function parseNDigitsSigned(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);

        case 2:
          return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);

        case 3:
          return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);

        case 4:
          return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);

        default:
          return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
      }
    }
    function dayPeriodEnumToHours(dayPeriod) {
      switch (dayPeriod) {
        case 'morning':
          return 4;

        case 'evening':
          return 17;

        case 'pm':
        case 'noon':
        case 'afternoon':
          return 12;

        case 'am':
        case 'midnight':
        case 'night':
        default:
          return 0;
      }
    }
    function normalizeTwoDigitYear(twoDigitYear, currentYear) {
      var isCommonEra = currentYear > 0; // Absolute number of the current year:
      // 1 -> 1 AC
      // 0 -> 1 BC
      // -1 -> 2 BC

      var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
      var result;

      if (absCurrentYear <= 50) {
        result = twoDigitYear || 100;
      } else {
        var rangeEnd = absCurrentYear + 50;
        var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
        var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
        result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
      }

      return isCommonEra ? result : 1 - result;
    }
    function isLeapYearIndex(year) {
      return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
    }

    function _defineProperty$t(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

    class YearParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$t(this, "priority", 130);

        _defineProperty$t(this, "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        var valueCallback = function (year) {
          return {
            year: year,
            isTwoDigitYear: token === 'yy'
          };
        };

        switch (token) {
          case 'y':
            return mapValue(parseNDigits(4, dateString), valueCallback);

          case 'yo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'year'
            }), valueCallback);

          default:
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
        }
      }

      validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }

      set(date, flags, value) {
        var currentYear = date.getUTCFullYear();

        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }

        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$s(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class LocalWeekYearParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$s(this, "priority", 130);

        _defineProperty$s(this, "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
      }

      parse(dateString, token, match) {
        var valueCallback = function (year) {
          return {
            year: year,
            isTwoDigitYear: token === 'YY'
          };
        };

        switch (token) {
          case 'Y':
            return mapValue(parseNDigits(4, dateString), valueCallback);

          case 'Yo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'year'
            }), valueCallback);

          default:
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
        }
      }

      validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }

      set(date, flags, value, options) {
        var currentYear = getUTCWeekYear(date, options);

        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
          date.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek(date, options);
        }

        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }

    }

    function _defineProperty$r(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class ISOWeekYearParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$r(this, "priority", 130);

        _defineProperty$r(this, "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token) {
        if (token === 'R') {
          return parseNDigitsSigned(4, dateString);
        }

        return parseNDigitsSigned(token.length, dateString);
      }

      set(_date, _flags, value) {
        var firstWeekOfYear = new Date(0);
        firstWeekOfYear.setUTCFullYear(value, 0, 4);
        firstWeekOfYear.setUTCHours(0, 0, 0, 0);
        return startOfUTCISOWeek(firstWeekOfYear);
      }

    }

    function _defineProperty$q(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class ExtendedYearParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$q(this, "priority", 130);

        _defineProperty$q(this, "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token) {
        if (token === 'u') {
          return parseNDigitsSigned(4, dateString);
        }

        return parseNDigitsSigned(token.length, dateString);
      }

      set(date, _flags, value) {
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$p(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class QuarterParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$p(this, "priority", 120);

        _defineProperty$p(this, "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
          case 'QQ':
            // 01, 02, 03, 04
            return parseNDigits(token.length, dateString);
          // 1st, 2nd, 3rd, 4th

          case 'Qo':
            return match.ordinalNumber(dateString, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'QQQ':
            return match.quarter(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'QQQQQ':
            return match.quarter(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...

          case 'QQQQ':
          default:
            return match.quarter(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.quarter(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 4;
      }

      set(date, _flags, value) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$o(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class StandAloneQuarterParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$o(this, "priority", 120);

        _defineProperty$o(this, "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          // 1, 2, 3, 4
          case 'q':
          case 'qq':
            // 01, 02, 03, 04
            return parseNDigits(token.length, dateString);
          // 1st, 2nd, 3rd, 4th

          case 'qo':
            return match.ordinalNumber(dateString, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'qqq':
            return match.quarter(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'qqqqq':
            return match.quarter(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...

          case 'qqqq':
          default:
            return match.quarter(dateString, {
              width: 'wide',
              context: 'standalone'
            }) || match.quarter(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 4;
      }

      set(date, _flags, value) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$n(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class MonthParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$n(this, "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

        _defineProperty$n(this, "priority", 110);
      }

      parse(dateString, token, match) {
        var valueCallback = function (value) {
          return value - 1;
        };

        switch (token) {
          // 1, 2, ..., 12
          case 'M':
            return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
          // 01, 02, ..., 12

          case 'MM':
            return mapValue(parseNDigits(2, dateString), valueCallback);
          // 1st, 2nd, ..., 12th

          case 'Mo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'month'
            }), valueCallback);
          // Jan, Feb, ..., Dec

          case 'MMM':
            return match.month(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // J, F, ..., D

          case 'MMMMM':
            return match.month(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December

          case 'MMMM':
          default:
            return match.month(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.month(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 11;
      }

      set(date, _flags, value) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$m(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class StandAloneMonthParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$m(this, "priority", 110);

        _defineProperty$m(this, "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        var valueCallback = function (value) {
          return value - 1;
        };

        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
          // 01, 02, ..., 12

          case 'LL':
            return mapValue(parseNDigits(2, dateString), valueCallback);
          // 1st, 2nd, ..., 12th

          case 'Lo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'month'
            }), valueCallback);
          // Jan, Feb, ..., Dec

          case 'LLL':
            return match.month(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // J, F, ..., D

          case 'LLLLL':
            return match.month(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December

          case 'LLLL':
          default:
            return match.month(dateString, {
              width: 'wide',
              context: 'standalone'
            }) || match.month(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 11;
      }

      set(date, _flags, value) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function setUTCWeek(dirtyDate, dirtyWeek, options) {
      requiredArgs(2, arguments);
      var date = toDate(dirtyDate);
      var week = toInteger$1(dirtyWeek);
      var diff = getUTCWeek(date, options) - week;
      date.setUTCDate(date.getUTCDate() - diff * 7);
      return date;
    }

    function _defineProperty$l(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class LocalWeekParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$l(this, "priority", 100);

        _defineProperty$l(this, "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'w':
            return parseNumericPattern(numericPatterns.week, dateString);

          case 'wo':
            return match.ordinalNumber(dateString, {
              unit: 'week'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 53;
      }

      set(date, _flags, value, options) {
        return startOfUTCWeek(setUTCWeek(date, value, options), options);
      }

    }

    function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
      requiredArgs(2, arguments);
      var date = toDate(dirtyDate);
      var isoWeek = toInteger$1(dirtyISOWeek);
      var diff = getUTCISOWeek(date) - isoWeek;
      date.setUTCDate(date.getUTCDate() - diff * 7);
      return date;
    }

    function _defineProperty$k(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class ISOWeekParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$k(this, "priority", 100);

        _defineProperty$k(this, "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'I':
            return parseNumericPattern(numericPatterns.week, dateString);

          case 'Io':
            return match.ordinalNumber(dateString, {
              unit: 'week'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 53;
      }

      set(date, _flags, value) {
        return startOfUTCISOWeek(setUTCISOWeek(date, value));
      }

    }

    function _defineProperty$j(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // Day of the month

    class DateParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$j(this, "priority", 90);

        _defineProperty$j(this, "subPriority", 1);

        _defineProperty$j(this, "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'd':
            return parseNumericPattern(numericPatterns.date, dateString);

          case 'do':
            return match.ordinalNumber(dateString, {
              unit: 'date'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(date, value) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);
        var month = date.getUTCMonth();

        if (isLeapYear) {
          return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
        } else {
          return value >= 1 && value <= DAYS_IN_MONTH[month];
        }
      }

      set(date, _flags, value) {
        date.setUTCDate(value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$i(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class DayOfYearParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$i(this, "priority", 90);

        _defineProperty$i(this, "subpriority", 1);

        _defineProperty$i(this, "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'D':
          case 'DD':
            return parseNumericPattern(numericPatterns.dayOfYear, dateString);

          case 'Do':
            return match.ordinalNumber(dateString, {
              unit: 'date'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(date, value) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex(year);

        if (isLeapYear) {
          return value >= 1 && value <= 366;
        } else {
          return value >= 1 && value <= 365;
        }
      }

      set(date, _flags, value) {
        date.setUTCMonth(0, value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function setUTCDay(dirtyDate, dirtyDay, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

      requiredArgs(2, arguments);
      var defaultOptions = getDefaultOptions();
      var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      var date = toDate(dirtyDate);
      var day = toInteger$1(dirtyDay);
      var currentDay = date.getUTCDay();
      var remainder = day % 7;
      var dayIndex = (remainder + 7) % 7;
      var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date;
    }

    function _defineProperty$h(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class DayParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$h(this, "priority", 90);

        _defineProperty$h(this, "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // T

          case 'EEEEE':
            return match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'EEEEEE':
            return match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday

          case 'EEEE':
          default:
            return match.day(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 6;
      }

      set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$g(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class LocalDayParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$g(this, "priority", 90);

        _defineProperty$g(this, "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);
      }

      parse(dateString, token, match, options) {
        var valueCallback = function (value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };

        switch (token) {
          // 3
          case 'e':
          case 'ee':
            // 03
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
          // 3rd

          case 'eo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'day'
            }), valueCallback);
          // Tue

          case 'eee':
            return match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // T

          case 'eeeee':
            return match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'eeeeee':
            return match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday

          case 'eeee':
          default:
            return match.day(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 6;
      }

      set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$f(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class StandAloneLocalDayParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$f(this, "priority", 90);

        _defineProperty$f(this, "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);
      }

      parse(dateString, token, match, options) {
        var valueCallback = function (value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };

        switch (token) {
          // 3
          case 'c':
          case 'cc':
            // 03
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
          // 3rd

          case 'co':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'day'
            }), valueCallback);
          // Tue

          case 'ccc':
            return match.day(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'short',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // T

          case 'ccccc':
            return match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu

          case 'cccccc':
            return match.day(dateString, {
              width: 'short',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tuesday

          case 'cccc':
          default:
            return match.day(dateString, {
              width: 'wide',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'short',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 6;
      }

      set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function setUTCISODay(dirtyDate, dirtyDay) {
      requiredArgs(2, arguments);
      var day = toInteger$1(dirtyDay);

      if (day % 7 === 0) {
        day = day - 7;
      }

      var weekStartsOn = 1;
      var date = toDate(dirtyDate);
      var currentDay = date.getUTCDay();
      var remainder = day % 7;
      var dayIndex = (remainder + 7) % 7;
      var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date;
    }

    function _defineProperty$e(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class ISODayParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$e(this, "priority", 90);

        _defineProperty$e(this, "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);
      }

      parse(dateString, token, match) {
        var valueCallback = function (value) {
          if (value === 0) {
            return 7;
          }

          return value;
        };

        switch (token) {
          // 2
          case 'i':
          case 'ii':
            // 02
            return parseNDigits(token.length, dateString);
          // 2nd

          case 'io':
            return match.ordinalNumber(dateString, {
              unit: 'day'
            });
          // Tue

          case 'iii':
            return mapValue(match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
          // T

          case 'iiiii':
            return mapValue(match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
          // Tu

          case 'iiiiii':
            return mapValue(match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
          // Tuesday

          case 'iiii':
          default:
            return mapValue(match.day(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 7;
      }

      set(date, _flags, value) {
        date = setUTCISODay(date, value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$d(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class AMPMParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$d(this, "priority", 80);

        _defineProperty$d(this, "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'a':
          case 'aa':
          case 'aaa':
            return match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaaa':
            return match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaa':
          default:
            return match.dayPeriod(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      set(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$c(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class AMPMMidnightParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$c(this, "priority", 80);

        _defineProperty$c(this, "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'b':
          case 'bb':
          case 'bbb':
            return match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbbb':
            return match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbb':
          default:
            return match.dayPeriod(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      set(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$b(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class DayPeriodParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$b(this, "priority", 80);

        _defineProperty$b(this, "incompatibleTokens", ['a', 'b', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBBB':
            return match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBB':
          default:
            return match.dayPeriod(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }

      set(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$a(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class Hour1to12Parser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$a(this, "priority", 70);

        _defineProperty$a(this, "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'h':
            return parseNumericPattern(numericPatterns.hour12h, dateString);

          case 'ho':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 12;
      }

      set(date, _flags, value) {
        var isPM = date.getUTCHours() >= 12;

        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else if (!isPM && value === 12) {
          date.setUTCHours(0, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }

        return date;
      }

    }

    function _defineProperty$9(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class Hour0to23Parser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$9(this, "priority", 70);

        _defineProperty$9(this, "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'H':
            return parseNumericPattern(numericPatterns.hour23h, dateString);

          case 'Ho':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 23;
      }

      set(date, _flags, value) {
        date.setUTCHours(value, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$8(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class Hour0To11Parser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$8(this, "priority", 70);

        _defineProperty$8(this, "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'K':
            return parseNumericPattern(numericPatterns.hour11h, dateString);

          case 'Ko':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 11;
      }

      set(date, _flags, value) {
        var isPM = date.getUTCHours() >= 12;

        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }

        return date;
      }

    }

    function _defineProperty$7(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class Hour1To24Parser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$7(this, "priority", 70);

        _defineProperty$7(this, "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'k':
            return parseNumericPattern(numericPatterns.hour24h, dateString);

          case 'ko':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 1 && value <= 24;
      }

      set(date, _flags, value) {
        var hours = value <= 24 ? value % 24 : value;
        date.setUTCHours(hours, 0, 0, 0);
        return date;
      }

    }

    function _defineProperty$6(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class MinuteParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$6(this, "priority", 60);

        _defineProperty$6(this, "incompatibleTokens", ['t', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 'm':
            return parseNumericPattern(numericPatterns.minute, dateString);

          case 'mo':
            return match.ordinalNumber(dateString, {
              unit: 'minute'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 59;
      }

      set(date, _flags, value) {
        date.setUTCMinutes(value, 0, 0);
        return date;
      }

    }

    function _defineProperty$5(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class SecondParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$5(this, "priority", 50);

        _defineProperty$5(this, "incompatibleTokens", ['t', 'T']);
      }

      parse(dateString, token, match) {
        switch (token) {
          case 's':
            return parseNumericPattern(numericPatterns.second, dateString);

          case 'so':
            return match.ordinalNumber(dateString, {
              unit: 'second'
            });

          default:
            return parseNDigits(token.length, dateString);
        }
      }

      validate(_date, value) {
        return value >= 0 && value <= 59;
      }

      set(date, _flags, value) {
        date.setUTCSeconds(value, 0);
        return date;
      }

    }

    function _defineProperty$4(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class FractionOfSecondParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$4(this, "priority", 30);

        _defineProperty$4(this, "incompatibleTokens", ['t', 'T']);
      }

      parse(dateString, token) {
        var valueCallback = function (value) {
          return Math.floor(value * Math.pow(10, -token.length + 3));
        };

        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }

      set(date, _flags, value) {
        date.setUTCMilliseconds(value);
        return date;
      }

    }

    function _defineProperty$3(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class ISOTimezoneWithZParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$3(this, "priority", 10);

        _defineProperty$3(this, "incompatibleTokens", ['t', 'T', 'x']);
      }

      parse(dateString, token) {
        switch (token) {
          case 'X':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);

          case 'XX':
            return parseTimezonePattern(timezonePatterns.basic, dateString);

          case 'XXXX':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);

          case 'XXXXX':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);

          case 'XXX':
          default:
            return parseTimezonePattern(timezonePatterns.extended, dateString);
        }
      }

      set(date, flags, value) {
        if (flags.timestampIsSet) {
          return date;
        }

        return new Date(date.getTime() - value);
      }

    }

    function _defineProperty$2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    class ISOTimezoneParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$2(this, "priority", 10);

        _defineProperty$2(this, "incompatibleTokens", ['t', 'T', 'X']);
      }

      parse(dateString, token) {
        switch (token) {
          case 'x':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);

          case 'xx':
            return parseTimezonePattern(timezonePatterns.basic, dateString);

          case 'xxxx':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);

          case 'xxxxx':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);

          case 'xxx':
          default:
            return parseTimezonePattern(timezonePatterns.extended, dateString);
        }
      }

      set(date, flags, value) {
        if (flags.timestampIsSet) {
          return date;
        }

        return new Date(date.getTime() - value);
      }

    }

    function _defineProperty$1(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class TimestampSecondsParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty$1(this, "priority", 40);

        _defineProperty$1(this, "incompatibleTokens", '*');
      }

      parse(dateString) {
        return parseAnyDigitsSigned(dateString);
      }

      set(_date, _flags, value) {
        return [new Date(value * 1000), {
          timestampIsSet: true
        }];
      }

    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    class TimestampMillisecondsParser extends Parser$1 {
      constructor() {
        super(...arguments);

        _defineProperty(this, "priority", 20);

        _defineProperty(this, "incompatibleTokens", '*');
      }

      parse(dateString) {
        return parseAnyDigitsSigned(dateString);
      }

      set(_date, _flags, value) {
        return [new Date(value), {
          timestampIsSet: true
        }];
      }

    }

    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* | Milliseconds in day            |
     * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
     * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
     * |  d  | Day of month                   |  D  | Day of year                    |
     * |  e  | Local day of week              |  E  | Day of week                    |
     * |  f  |                                |  F* | Day of week in month           |
     * |  g* | Modified Julian day            |  G  | Era                            |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  i! | ISO day of week                |  I! | ISO week of year               |
     * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
     * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
     * |  l* | (deprecated)                   |  L  | Stand-alone month              |
     * |  m  | Minute                         |  M  | Month                          |
     * |  n  |                                |  N  |                                |
     * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
     * |  p  |                                |  P  |                                |
     * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
     * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
     * |  u  | Extended year                  |  U* | Cyclic year                    |
     * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
     * |  w  | Local week of year             |  W* | Week of month                  |
     * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
     * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
     * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     *
     * Letters marked by ! are non-standard, but implemented by date-fns:
     * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
     * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
     *   i.e. 7 for Sunday, 1 for Monday, etc.
     * - `I` is ISO week of year, as opposed to `w` which is local week of year.
     * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
     *   `R` is supposed to be used in conjunction with `I` and `i`
     *   for universal ISO week-numbering date, whereas
     *   `Y` is supposed to be used in conjunction with `w` and `e`
     *   for week-numbering date specific to the locale.
     */

    var parsers = {
      G: new EraParser(),
      y: new YearParser(),
      Y: new LocalWeekYearParser(),
      R: new ISOWeekYearParser(),
      u: new ExtendedYearParser(),
      Q: new QuarterParser(),
      q: new StandAloneQuarterParser(),
      M: new MonthParser(),
      L: new StandAloneMonthParser(),
      w: new LocalWeekParser(),
      I: new ISOWeekParser(),
      d: new DateParser(),
      D: new DayOfYearParser(),
      E: new DayParser(),
      e: new LocalDayParser(),
      c: new StandAloneLocalDayParser(),
      i: new ISODayParser(),
      a: new AMPMParser(),
      b: new AMPMMidnightParser(),
      B: new DayPeriodParser(),
      h: new Hour1to12Parser(),
      H: new Hour0to23Parser(),
      K: new Hour0To11Parser(),
      k: new Hour1To24Parser(),
      m: new MinuteParser(),
      s: new SecondParser(),
      S: new FractionOfSecondParser(),
      X: new ISOTimezoneWithZParser(),
      x: new ISOTimezoneParser(),
      t: new TimestampSecondsParser(),
      T: new TimestampMillisecondsParser()
    };

    // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
    //   (one of the certain letters followed by `o`)
    // - (\w)\1* matches any sequences of the same letter
    // - '' matches two quote characters in a row
    // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
    //   except a single quote symbol, which ends the sequence.
    //   Two quote characters do not end the sequence.
    //   If there is no matching single quote
    //   then the sequence will continue until the end of the string.
    // - . matches any single character unmatched by previous parts of the RegExps

    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
    // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var notWhitespaceRegExp = /\S/;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    /**
     * @name parse
     * @category Common Helpers
     * @summary Parse the date.
     *
     * @description
     * Return the date parsed from string using the given format string.
     *
     * > â ï¸ Please note that the `format` tokens differ from Moment.js and other libraries.
     * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * The characters in the format string wrapped between two single quotes characters (') are escaped.
     * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
     *
     * Format of the format string is based on Unicode Technical Standard #35:
     * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * with a few additions (see note 5 below the table).
     *
     * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
     * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
     *
     * ```javascript
     * parse('23 AM', 'HH a', new Date())
     * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
     * ```
     *
     * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
     *
     * Accepted format string patterns:
     * | Unit                            |Prior| Pattern | Result examples                   | Notes |
     * |---------------------------------|-----|---------|-----------------------------------|-------|
     * | Era                             | 140 | G..GGG  | AD, BC                            |       |
     * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
     * |                                 |     | GGGGG   | A, B                              |       |
     * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
     * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
     * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
     * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
     * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
     * |                                 |     | yyyyy   | ...                               | 2,4   |
     * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
     * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
     * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
     * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
     * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
     * |                                 |     | YYYYY   | ...                               | 2,4   |
     * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
     * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
     * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
     * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
     * |                                 |     | RRRRR   | ...                               | 2,4,5 |
     * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
     * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
     * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
     * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
     * |                                 |     | uuuuu   | ...                               | 2,4   |
     * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
     * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
     * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
     * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
     * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
     * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
     * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
     * |                                 |     | qq      | 01, 02, 03, 04                    |       |
     * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
     * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
     * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
     * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
     * |                                 |     | MM      | 01, 02, ..., 12                   |       |
     * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
     * |                                 |     | MMMM    | January, February, ..., December  | 2     |
     * |                                 |     | MMMMM   | J, F, ..., D                      |       |
     * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
     * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
     * |                                 |     | LL      | 01, 02, ..., 12                   |       |
     * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
     * |                                 |     | LLLL    | January, February, ..., December  | 2     |
     * |                                 |     | LLLLL   | J, F, ..., D                      |       |
     * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
     * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
     * |                                 |     | ww      | 01, 02, ..., 53                   |       |
     * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
     * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
     * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
     * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
     * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
     * |                                 |     | dd      | 01, 02, ..., 31                   |       |
     * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
     * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
     * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
     * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
     * |                                 |     | DDDD    | ...                               | 2     |
     * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
     * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
     * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
     * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
     * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
     * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
     * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
     * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
     * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
     * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
     * |                                 |     | ee      | 02, 03, ..., 01                   |       |
     * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
     * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
     * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
     * |                                 |     | cc      | 02, 03, ..., 01                   |       |
     * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
     * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
     * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
     * |                                 |     | aaaaa   | a, p                              |       |
     * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
     * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
     * |                                 |     | bbbbb   | a, p, n, mi                       |       |
     * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
     * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
     * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
     * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
     * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
     * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
     * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
     * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
     * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
     * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
     * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
     * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
     * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
     * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
     * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
     * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
     * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
     * |                                 |     | mm      | 00, 01, ..., 59                   |       |
     * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
     * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
     * |                                 |     | ss      | 00, 01, ..., 59                   |       |
     * | Seconds timestamp               |  40 | t       | 512969520                         |       |
     * |                                 |     | tt      | ...                               | 2     |
     * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
     * |                                 |     | SS      | 00, 01, ..., 99                   |       |
     * |                                 |     | SSS     | 000, 001, ..., 999                |       |
     * |                                 |     | SSSS    | ...                               | 2     |
     * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
     * |                                 |     | TT      | ...                               | 2     |
     * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
     * |                                 |     | XX      | -0800, +0530, Z                   |       |
     * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
     * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
     * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
     * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
     * |                                 |     | xx      | -0800, +0530, +0000               |       |
     * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
     * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
     * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
     * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
     * |                                 |     | PP      | May 29, 1453                      |       |
     * |                                 |     | PPP     | May 29th, 1453                    |       |
     * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
     * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
     * |                                 |     | pp      | 12:00:00 AM                       |       |
     * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
     * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
     * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
     * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
     * Notes:
     * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
     *    are the same as "stand-alone" units, but are different in some languages.
     *    "Formatting" units are declined according to the rules of the language
     *    in the context of a date. "Stand-alone" units are always nominative singular.
     *    In `format` function, they will produce different result:
     *
     *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
     *
     *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
     *
     *    `parse` will try to match both formatting and stand-alone units interchangably.
     *
     * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
     *    the single quote characters (see below).
     *    If the sequence is longer than listed in table:
     *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
     *      as wide as the sequence
     *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
     *      These variations are marked with "2" in the last column of the table.
     *
     * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
     *    These tokens represent the shortest form of the quarter.
     *
     * 4. The main difference between `y` and `u` patterns are B.C. years:
     *
     *    | Year | `y` | `u` |
     *    |------|-----|-----|
     *    | AC 1 |   1 |   1 |
     *    | BC 1 |   1 |   0 |
     *    | BC 2 |   2 |  -1 |
     *
     *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
     *
     *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
     *
     *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
     *
     *    while `uu` will just assign the year as is:
     *
     *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
     *
     *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
     *
     *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
     *    except local week-numbering years are dependent on `options.weekStartsOn`
     *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
     *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
     *
     * 5. These patterns are not in the Unicode Technical Standard #35:
     *    - `i`: ISO day of week
     *    - `I`: ISO week of year
     *    - `R`: ISO week-numbering year
     *    - `o`: ordinal number modifier
     *    - `P`: long localized date
     *    - `p`: long localized time
     *
     * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
     *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
     *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
     *    on the given locale.
     *
     *    using `en-US` locale: `P` => `MM/dd/yyyy`
     *    using `en-US` locale: `p` => `hh:mm a`
     *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
     *    using `pt-BR` locale: `p` => `HH:mm`
     *
     * Values will be assigned to the date in the descending order of its unit's priority.
     * Units of an equal priority overwrite each other in the order of appearance.
     *
     * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
     * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
     *
     * `referenceDate` must be passed for correct work of the function.
     * If you're not sure which `referenceDate` to supply, create a new instance of Date:
     * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
     * In this case parsing will be done in the context of the current date.
     * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
     * then `Invalid Date` will be returned.
     *
     * The result may vary by locale.
     *
     * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
     *
     * If parsing failed, `Invalid Date` will be returned.
     * Invalid Date is a Date, whose time value is NaN.
     * Time value of Date: http://es5.github.io/#x15.9.1.1
     *
     * @param {String} dateString - the string to parse
     * @param {String} formatString - the string of tokens
     * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
     * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @returns {Date} the parsed date
     * @throws {TypeError} 3 arguments required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     * @throws {RangeError} `options.locale` must contain `match` property
     * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} format string contains an unescaped latin alphabet character
     *
     * @example
     * // Parse 11 February 2014 from middle-endian format:
     * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
     * //=> Tue Feb 11 2014 00:00:00
     *
     * @example
     * // Parse 28th of February in Esperanto locale in the context of 2010 year:
     * import eo from 'date-fns/locale/eo'
     * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
     *   locale: eo
     * })
     * //=> Sun Feb 28 2010 00:00:00
     */

    function parse$2(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

      requiredArgs(3, arguments);
      var dateString = String(dirtyDateString);
      var formatString = String(dirtyFormatString);
      var defaultOptions = getDefaultOptions();
      var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;

      if (!locale.match) {
        throw new RangeError('locale must contain match property');
      }

      var firstWeekContainsDate = toInteger$1((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var weekStartsOn = toInteger$1((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      if (formatString === '') {
        if (dateString === '') {
          return toDate(dirtyReferenceDate);
        } else {
          return new Date(NaN);
        }
      }

      var subFnOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale
      }; // If timezone isn't specified, it will be set to the system timezone

      var setters = [new DateToSystemTimezoneSetter()];
      var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
        var firstCharacter = substring[0];

        if (firstCharacter in longFormatters$1) {
          var longFormatter = longFormatters$1[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }

        return substring;
      }).join('').match(formattingTokensRegExp);
      var usedTokens = [];

      var _loop = function (_token) {
        if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(_token)) {
          throwProtectedError(_token, formatString, dirtyDateString);
        }

        if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(_token)) {
          throwProtectedError(_token, formatString, dirtyDateString);
        }

        var firstCharacter = _token[0];
        var parser = parsers[firstCharacter];

        if (parser) {
          var incompatibleTokens = parser.incompatibleTokens;

          if (Array.isArray(incompatibleTokens)) {
            var incompatibleToken = usedTokens.find(function (usedToken) {
              return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
            });

            if (incompatibleToken) {
              throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(_token, "` at the same time"));
            }
          } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
            throw new RangeError("The format string mustn't contain `".concat(_token, "` and any other token at the same time"));
          }

          usedTokens.push({
            token: firstCharacter,
            fullToken: _token
          });
          var parseResult = parser.run(dateString, _token, locale.match, subFnOptions);

          if (!parseResult) {
            token = _token;
            return {
              v: new Date(NaN)
            };
          }

          setters.push(parseResult.setter);
          dateString = parseResult.rest;
        } else {
          if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
            throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
          } // Replace two single quote characters with one single quote character


          if (_token === "''") {
            _token = "'";
          } else if (firstCharacter === "'") {
            _token = cleanEscapedString(_token);
          } // Cut token from string, or, if string doesn't match the token, return Invalid Date


          if (dateString.indexOf(_token) === 0) {
            dateString = dateString.slice(_token.length);
          } else {
            token = _token;
            return {
              v: new Date(NaN)
            };
          }
        }

        token = _token;
      };

      for (var token of tokens) {
        var _ret = _loop(token);

        if (typeof _ret === "object") return _ret.v;
      } // Check if the remaining input contains something other than whitespace


      if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
        return new Date(NaN);
      }

      var uniquePrioritySetters = setters.map(function (setter) {
        return setter.priority;
      }).sort(function (a, b) {
        return b - a;
      }).filter(function (priority, index, array) {
        return array.indexOf(priority) === index;
      }).map(function (priority) {
        return setters.filter(function (setter) {
          return setter.priority === priority;
        }).sort(function (a, b) {
          return b.subPriority - a.subPriority;
        });
      }).map(function (setterArray) {
        return setterArray[0];
      });
      var date = toDate(dirtyReferenceDate);

      if (isNaN(date.getTime())) {
        return new Date(NaN);
      } // Convert the date in system timezone to the same date in UTC+00:00 timezone.


      var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
      var flags = {};

      for (var setter of uniquePrioritySetters) {
        if (!setter.validate(utcDate, subFnOptions)) {
          return new Date(NaN);
        }

        var result = setter.set(utcDate, flags, subFnOptions); // Result is tuple (date, flags)

        if (Array.isArray(result)) {
          utcDate = result[0];
          assign(flags, result[1]); // Result is date
        } else {
          utcDate = result;
        }
      }

      return utcDate;
    }

    function cleanEscapedString(input) {
      return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
    }

    /**
     * @name subDays
     * @category Day Helpers
     * @summary Subtract the specified number of days from the given date.
     *
     * @description
     * Subtract the specified number of days from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of days to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the days subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 10 days from 1 September 2014:
     * const result = subDays(new Date(2014, 8, 1), 10)
     * //=> Fri Aug 22 2014 00:00:00
     */

    function subDays(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger$1(dirtyAmount);
      return addDays(dirtyDate, -amount);
    }

    /**
     * @name startOfToday
     * @category Day Helpers
     * @summary Return the start of today.
     * @pure false
     *
     * @description
     * Return the start of today.
     *
     * > â ï¸ Please note that this function is not present in the FP submodule as
     * > it uses `Date.now()` internally hence impure and can't be safely curried.
     *
     * @returns {Date} the start of today
     *
     * @example
     * // If today is 6 October 2014:
     * const result = startOfToday()
     * //=> Mon Oct 6 2014 00:00:00
     */

    function startOfToday() {
      return startOfDay(Date.now());
    }

    /**
     * @name startOfYesterday
     * @category Day Helpers
     * @summary Return the start of yesterday.
     * @pure false
     *
     * @description
     * Return the start of yesterday.
     *
     * > â ï¸ Please note that this function is not present in the FP submodule as
     * > it uses `new Date()` internally hence impure and can't be safely curried.
     *
     * @returns {Date} the start of yesterday
     *
     * @example
     * // If today is 6 October 2014:
     * const result = startOfYesterday()
     * //=> Sun Oct 5 2014 00:00:00
     */
    function startOfYesterday() {
      var now = new Date();
      var year = now.getFullYear();
      var month = now.getMonth();
      var day = now.getDate();
      var date = new Date(0);
      date.setFullYear(year, month, day - 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * @name subMonths
     * @category Month Helpers
     * @summary Subtract the specified number of months from the given date.
     *
     * @description
     * Subtract the specified number of months from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of months to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the months subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 5 months from 1 February 2015:
     * const result = subMonths(new Date(2015, 1, 1), 5)
     * //=> Mon Sep 01 2014 00:00:00
     */

    function subMonths(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger$1(dirtyAmount);
      return addMonths(dirtyDate, -amount);
    }

    /**
     * @name sub
     * @category Common Helpers
     * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
     *
     * @description
     * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Duration} duration - the object with years, months, weeks, days, hours, minutes and seconds to be subtracted
     *
     * | Key     | Description                        |
     * |---------|------------------------------------|
     * | years   | Amount of years to be subtracted   |
     * | months  | Amount of months to be subtracted  |
     * | weeks   | Amount of weeks to be subtracted   |
     * | days    | Amount of days to be subtracted    |
     * | hours   | Amount of hours to be subtracted   |
     * | minutes | Amount of minutes to be subtracted |
     * | seconds | Amount of seconds to be subtracted |
     *
     * All values default to 0
     *
     * @returns {Date} the new date with the seconds subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract the following duration from 15 June 2017 15:29:20
     * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
     *   years: 2,
     *   months: 9,
     *   weeks: 1,
     *   days: 7,
     *   hours: 5,
     *   minutes: 9,
     *   seconds: 30
     * })
     * //=> Mon Sep 1 2014 10:19:50
     */

    function sub(date, duration) {
      requiredArgs(2, arguments);
      if (!duration || typeof duration !== 'object') return new Date(NaN);
      var years = duration.years ? toInteger$1(duration.years) : 0;
      var months = duration.months ? toInteger$1(duration.months) : 0;
      var weeks = duration.weeks ? toInteger$1(duration.weeks) : 0;
      var days = duration.days ? toInteger$1(duration.days) : 0;
      var hours = duration.hours ? toInteger$1(duration.hours) : 0;
      var minutes = duration.minutes ? toInteger$1(duration.minutes) : 0;
      var seconds = duration.seconds ? toInteger$1(duration.seconds) : 0; // Subtract years and months

      var dateWithoutMonths = subMonths(date, months + years * 12); // Subtract weeks and days

      var dateWithoutDays = subDays(dateWithoutMonths, days + weeks * 7); // Subtract hours, minutes and seconds

      var minutestoSub = minutes + hours * 60;
      var secondstoSub = seconds + minutestoSub * 60;
      var mstoSub = secondstoSub * 1000;
      var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
      return finalDate;
    }

    /**
     * @name subWeeks
     * @category Week Helpers
     * @summary Subtract the specified number of weeks from the given date.
     *
     * @description
     * Subtract the specified number of weeks from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of weeks to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the weeks subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 4 weeks from 1 September 2014:
     * const result = subWeeks(new Date(2014, 8, 1), 4)
     * //=> Mon Aug 04 2014 00:00:00
     */

    function subWeeks(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger$1(dirtyAmount);
      return addWeeks(dirtyDate, -amount);
    }

    var defineProperty$4 = objectDefineProperty$1.f; // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty
    // eslint-disable-next-line es-x/no-object-defineproperty -- safe


    _export$1({
      target: 'Object',
      stat: true,
      forced: Object.defineProperty !== defineProperty$4,
      sham: !descriptors$1
    }, {
      defineProperty: defineProperty$4
    });

    var floor$1 = Math.floor;
    var charAt$2 = functionUncurryThis(''.charAt);
    var replace = functionUncurryThis(''.replace);
    var stringSlice$1 = functionUncurryThis(''.slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g; // `GetSubstitution` abstract operation
    // https://tc39.es/ecma262/#sec-getsubstitution

    var getSubstitution = function (matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

      if (namedCaptures !== undefined) {
        namedCaptures = toObject$1(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }

      return replace(replacement, symbols, function (match, ch) {
        var capture;

        switch (charAt$2(ch, 0)) {
          case '$':
            return '$';

          case '&':
            return matched;

          case '`':
            return stringSlice$1(str, 0, position);

          case "'":
            return stringSlice$1(str, tailPos);

          case '<':
            capture = namedCaptures[stringSlice$1(ch, 1, -1)];
            break;

          default:
            // \d\d?
            var n = +ch;
            if (n === 0) return match;

            if (n > m) {
              var f = floor$1(n / 10);
              if (f === 0) return match;
              if (f <= m) return captures[f - 1] === undefined ? charAt$2(ch, 1) : captures[f - 1] + charAt$2(ch, 1);
              return match;
            }

            capture = captures[n - 1];
        }

        return capture === undefined ? '' : capture;
      });
    };

    var REPLACE$1 = wellKnownSymbol$1('replace');
    var max$2 = Math.max;
    var min$4 = Math.min;
    var concat = functionUncurryThis([].concat);
    var push$2 = functionUncurryThis([].push);
    var stringIndexOf$1 = functionUncurryThis(''.indexOf);
    var stringSlice = functionUncurryThis(''.slice);

    var maybeToString = function (it) {
      return it === undefined ? it : String(it);
    }; // IE <= 11 replaces $0 with the whole match, as if it was $&
    // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0


    var REPLACE_KEEPS_$0$1 = function () {
      // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
      return 'a'.replace(/./, '$0') === '$0';
    }(); // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string


    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE$1 = function () {
      if (/./[REPLACE$1]) {
        return /./[REPLACE$1]('a', '$0') === '';
      }

      return false;
    }();

    var REPLACE_SUPPORTS_NAMED_GROUPS$1 = !fails$1(function () {
      var re = /./;

      re.exec = function () {
        var result = [];
        result.groups = {
          a: '7'
        };
        return result;
      }; // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive


      return ''.replace(re, '$<a>') !== '7';
    }); // @@replace logic

    fixRegexpWellKnownSymbolLogic$1('replace', function (_, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE$1 ? '$' : '$0';
      return [// `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible$1(this);
        var replacer = searchValue == undefined ? undefined : getMethod(searchValue, REPLACE$1);
        return replacer ? functionCall(replacer, searchValue, O, replaceValue) : functionCall(nativeReplace, toString_1(O), searchValue, replaceValue);
      }, // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function (string, replaceValue) {
        var rx = anObject$1(this);
        var S = toString_1(string);

        if (typeof replaceValue == 'string' && stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf$1(replaceValue, '$<') === -1) {
          var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
          if (res.done) return res.value;
        }

        var functionalReplace = isCallable(replaceValue);
        if (!functionalReplace) replaceValue = toString_1(replaceValue);
        var global = rx.global;

        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }

        var results = [];

        while (true) {
          var result = regexpExecAbstract$1(rx, S);
          if (result === null) break;
          push$2(results, result);
          if (!global) break;
          var matchStr = toString_1(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex$1(S, toLength$1(rx.lastIndex), fullUnicode);
        }

        var accumulatedResult = '';
        var nextSourcePosition = 0;

        for (var i = 0; i < results.length; i++) {
          result = results[i];
          var matched = toString_1(result[0]);
          var position = max$2(min$4(toIntegerOrInfinity(result.index), S.length), 0);
          var captures = []; // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

          for (var j = 1; j < result.length; j++) push$2(captures, maybeToString(result[j]));

          var namedCaptures = result.groups;

          if (functionalReplace) {
            var replacerArgs = concat([matched], captures, position, S);
            if (namedCaptures !== undefined) push$2(replacerArgs, namedCaptures);
            var replacement = toString_1(functionApply(replaceValue, undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }

          if (position >= nextSourcePosition) {
            accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }

        return accumulatedResult + stringSlice(S, nextSourcePosition);
      }];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS$1 || !REPLACE_KEEPS_$0$1 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE$1);

    var dist$2 = createCommonjsModule$1(function (module, exports) {



    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getCanonicalLocale = getCanonicalLocale;
    exports.getDayNames = getDayNames;
    exports.getDayNamesMin = getDayNamesMin;
    exports.getDayNamesShort = getDayNamesShort;
    exports.getFirstDay = getFirstDay;
    exports.getLanguage = getLanguage;
    exports.getLocale = getLocale;
    exports.getMonthNames = getMonthNames;
    exports.getMonthNamesShort = getMonthNamesShort;
    exports.translate = translate;
    exports.translatePlural = translatePlural;



     /// <reference types="@nextcloud/typings" />

    /**
     * Returns the user's locale
     */


    function getLocale() {
      return document.documentElement.dataset.locale || 'en';
    }

    function getCanonicalLocale() {
      return getLocale().replace(/_/g, '-');
    }
    /**
     * Returns the user's language
     */


    function getLanguage() {
      return document.documentElement.lang || 'en';
    }
    /**
     * Translate a string
     *
     * @param {string} app the id of the app for which to translate the string
     * @param {string} text the string to translate
     * @param {object} vars map of placeholder key to value
     * @param {number} number to replace %n with
     * @param {object} [options] options object
     * @return {string}
     */


    function translate(app, text, vars, count, options) {
      if (typeof OC === 'undefined') {
        console.warn('No OC found');
        return text;
      }

      return OC.L10N.translate(app, text, vars, count, options);
    }
    /**
     * Translate a plural string
     *
     * @param {string} app the id of the app for which to translate the string
     * @param {string} textSingular the string to translate for exactly one object
     * @param {string} textPlural the string to translate for n objects
     * @param {number} count number to determine whether to use singular or plural
     * @param {Object} vars of placeholder key to value
     * @param {object} options options object
     * @return {string}
     */


    function translatePlural(app, textSingular, textPlural, count, vars, options) {
      if (typeof OC === 'undefined') {
        console.warn('No OC found');
        return textSingular;
      }

      return OC.L10N.translatePlural(app, textSingular, textPlural, count, vars, options);
    }
    /**
     * Get the first day of the week
     *
     * @return {number}
     */


    function getFirstDay() {
      if (typeof window.firstDay === 'undefined') {
        console.warn('No firstDay found');
        return 1;
      }

      return window.firstDay;
    }
    /**
     * Get a list of day names (full names)
     *
     * @return {string[]}
     */


    function getDayNames() {
      if (typeof window.dayNames === 'undefined') {
        console.warn('No dayNames found');
        return ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      }

      return window.dayNames;
    }
    /**
     * Get a list of day names (short names)
     *
     * @return {string[]}
     */


    function getDayNamesShort() {
      if (typeof window.dayNamesShort === 'undefined') {
        console.warn('No dayNamesShort found');
        return ['Sun.', 'Mon.', 'Tue.', 'Wed.', 'Thu.', 'Fri.', 'Sat.'];
      }

      return window.dayNamesShort;
    }
    /**
     * Get a list of day names (minified names)
     *
     * @return {string[]}
     */


    function getDayNamesMin() {
      if (typeof window.dayNamesMin === 'undefined') {
        console.warn('No dayNamesMin found');
        return ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
      }

      return window.dayNamesMin;
    }
    /**
     * Get a list of month names (full names)
     *
     * @return {string[]}
     */


    function getMonthNames() {
      if (typeof window.monthNames === 'undefined') {
        console.warn('No monthNames found');
        return ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
      }

      return window.monthNames;
    }
    /**
     * Get a list of month names (short names)
     *
     * @return {string[]}
     */


    function getMonthNamesShort() {
      if (typeof window.monthNamesShort === 'undefined') {
        console.warn('No monthNamesShort found');
        return ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.'];
      }

      return window.monthNamesShort;
    }
    });

    unwrapExports(dist$2);
    dist$2.getCanonicalLocale;
    dist$2.getDayNames;
    dist$2.getDayNamesMin;
    dist$2.getDayNamesShort;
    var dist_5$1 = dist$2.getFirstDay;
    dist$2.getLanguage;
    var dist_7 = dist$2.getLocale;
    dist$2.getMonthNames;
    dist$2.getMonthNamesShort;
    var dist_10 = dist$2.translate;
    dist$2.translatePlural;

    var un$Join = functionUncurryThis([].join);
    var ES3_STRINGS$1 = indexedObject$1 != Object;
    var STRICT_METHOD$2 = arrayMethodIsStrict$1('join', ','); // `Array.prototype.join` method
    // https://tc39.es/ecma262/#sec-array.prototype.join

    _export$1({
      target: 'Array',
      proto: true,
      forced: ES3_STRINGS$1 || !STRICT_METHOD$2
    }, {
      join: function join(separator) {
        return un$Join(toIndexedObject$1(this), separator === undefined ? ',' : separator);
      }
    });

    var FAILS_ON_PRIMITIVES = fails$1(function () {
      objectKeys$1(1);
    }); // `Object.keys` method
    // https://tc39.es/ecma262/#sec-object.keys

    _export$1({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES
    }, {
      keys: function keys(it) {
        return objectKeys$1(toObject$1(it));
      }
    });

    var formatDistanceLocale$2 = {
      lessThanXSeconds: {
        standalone: {
          one: 'weniger als 1 Sekunde',
          other: 'weniger als {{count}} Sekunden'
        },
        withPreposition: {
          one: 'weniger als 1 Sekunde',
          other: 'weniger als {{count}} Sekunden'
        }
      },
      xSeconds: {
        standalone: {
          one: '1 Sekunde',
          other: '{{count}} Sekunden'
        },
        withPreposition: {
          one: '1 Sekunde',
          other: '{{count}} Sekunden'
        }
      },
      halfAMinute: {
        standalone: 'halbe Minute',
        withPreposition: 'halben Minute'
      },
      lessThanXMinutes: {
        standalone: {
          one: 'weniger als 1 Minute',
          other: 'weniger als {{count}} Minuten'
        },
        withPreposition: {
          one: 'weniger als 1 Minute',
          other: 'weniger als {{count}} Minuten'
        }
      },
      xMinutes: {
        standalone: {
          one: '1 Minute',
          other: '{{count}} Minuten'
        },
        withPreposition: {
          one: '1 Minute',
          other: '{{count}} Minuten'
        }
      },
      aboutXHours: {
        standalone: {
          one: 'etwa 1 Stunde',
          other: 'etwa {{count}} Stunden'
        },
        withPreposition: {
          one: 'etwa 1 Stunde',
          other: 'etwa {{count}} Stunden'
        }
      },
      xHours: {
        standalone: {
          one: '1 Stunde',
          other: '{{count}} Stunden'
        },
        withPreposition: {
          one: '1 Stunde',
          other: '{{count}} Stunden'
        }
      },
      xDays: {
        standalone: {
          one: '1 Tag',
          other: '{{count}} Tage'
        },
        withPreposition: {
          one: '1 Tag',
          other: '{{count}} Tagen'
        }
      },
      aboutXWeeks: {
        standalone: {
          one: 'etwa 1 Woche',
          other: 'etwa {{count}} Wochen'
        },
        withPreposition: {
          one: 'etwa 1 Woche',
          other: 'etwa {{count}} Wochen'
        }
      },
      xWeeks: {
        standalone: {
          one: '1 Woche',
          other: '{{count}} Wochen'
        },
        withPreposition: {
          one: '1 Woche',
          other: '{{count}} Wochen'
        }
      },
      aboutXMonths: {
        standalone: {
          one: 'etwa 1 Monat',
          other: 'etwa {{count}} Monate'
        },
        withPreposition: {
          one: 'etwa 1 Monat',
          other: 'etwa {{count}} Monaten'
        }
      },
      xMonths: {
        standalone: {
          one: '1 Monat',
          other: '{{count}} Monate'
        },
        withPreposition: {
          one: '1 Monat',
          other: '{{count}} Monaten'
        }
      },
      aboutXYears: {
        standalone: {
          one: 'etwa 1 Jahr',
          other: 'etwa {{count}} Jahre'
        },
        withPreposition: {
          one: 'etwa 1 Jahr',
          other: 'etwa {{count}} Jahren'
        }
      },
      xYears: {
        standalone: {
          one: '1 Jahr',
          other: '{{count}} Jahre'
        },
        withPreposition: {
          one: '1 Jahr',
          other: '{{count}} Jahren'
        }
      },
      overXYears: {
        standalone: {
          one: 'mehr als 1 Jahr',
          other: 'mehr als {{count}} Jahre'
        },
        withPreposition: {
          one: 'mehr als 1 Jahr',
          other: 'mehr als {{count}} Jahren'
        }
      },
      almostXYears: {
        standalone: {
          one: 'fast 1 Jahr',
          other: 'fast {{count}} Jahre'
        },
        withPreposition: {
          one: 'fast 1 Jahr',
          other: 'fast {{count}} Jahren'
        }
      }
    };

    var formatDistance$4 = function (token, count, options) {
      var result;
      var tokenValue = options !== null && options !== void 0 && options.addSuffix ? formatDistanceLocale$2[token].withPreposition : formatDistanceLocale$2[token].standalone;

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'in ' + result;
        } else {
          return 'vor ' + result;
        }
      }

      return result;
    };

    var formatDistance$5 = formatDistance$4;

    var dateFormats$2 = {
      full: 'EEEE, do MMMM y',
      // Montag, 7. Januar 2018
      long: 'do MMMM y',
      // 7. Januar 2018
      medium: 'do MMM y',
      // 7. Jan. 2018
      short: 'dd.MM.y' // 07.01.2018

    };
    var timeFormats$2 = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$2 = {
      full: "{{date}} 'um' {{time}}",
      long: "{{date}} 'um' {{time}}",
      medium: '{{date}} {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$4 = {
      date: buildFormatLongFn({
        formats: dateFormats$2,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats$2,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$2,
        defaultWidth: 'full'
      })
    };
    var formatLong$5 = formatLong$4;

    var formatRelativeLocale$2 = {
      lastWeek: "'letzten' eeee 'um' p",
      yesterday: "'gestern um' p",
      today: "'heute um' p",
      tomorrow: "'morgen um' p",
      nextWeek: "eeee 'um' p",
      other: 'P'
    };

    var formatRelative$4 = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$2[token];
    };

    var formatRelative$5 = formatRelative$4;

    var eraValues$2 = {
      narrow: ['v.Chr.', 'n.Chr.'],
      abbreviated: ['v.Chr.', 'n.Chr.'],
      wide: ['vor Christus', 'nach Christus']
    };
    var quarterValues$2 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1. Quartal', '2. Quartal', '3. Quartal', '4. Quartal']
    }; // Note: in German, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.

    var monthValues$2 = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'MÃ¤r', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
      wide: ['Januar', 'Februar', 'MÃ¤rz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']
    }; // https://st.unicode.org/cldr-apps/v#/de/Gregorian/

    var formattingMonthValues = {
      narrow: monthValues$2.narrow,
      abbreviated: ['Jan.', 'Feb.', 'MÃ¤rz', 'Apr.', 'Mai', 'Juni', 'Juli', 'Aug.', 'Sep.', 'Okt.', 'Nov.', 'Dez.'],
      wide: monthValues$2.wide
    };
    var dayValues$2 = {
      narrow: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
      short: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
      abbreviated: ['So.', 'Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.'],
      wide: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag']
    }; // https://www.unicode.org/cldr/charts/32/summary/de.html#1881

    var dayPeriodValues$2 = {
      narrow: {
        am: 'vm.',
        pm: 'nm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachm.',
        evening: 'Abend',
        night: 'Nacht'
      },
      abbreviated: {
        am: 'vorm.',
        pm: 'nachm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachmittag',
        evening: 'Abend',
        night: 'Nacht'
      },
      wide: {
        am: 'vormittags',
        pm: 'nachmittags',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachmittag',
        evening: 'Abend',
        night: 'Nacht'
      }
    };
    var formattingDayPeriodValues$1 = {
      narrow: {
        am: 'vm.',
        pm: 'nm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachm.',
        evening: 'abends',
        night: 'nachts'
      },
      abbreviated: {
        am: 'vorm.',
        pm: 'nachm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachmittags',
        evening: 'abends',
        night: 'nachts'
      },
      wide: {
        am: 'vormittags',
        pm: 'nachmittags',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachmittags',
        evening: 'abends',
        night: 'nachts'
      }
    };

    var ordinalNumber$2 = function (dirtyNumber) {
      var number = Number(dirtyNumber);
      return number + '.';
    };

    var localize$4 = {
      ordinalNumber: ordinalNumber$2,
      era: buildLocalizeFn({
        values: eraValues$2,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$2,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues$2,
        formattingValues: formattingMonthValues,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues$2,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$2,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$1,
        defaultFormattingWidth: 'wide'
      })
    };
    var localize$5 = localize$4;

    var matchOrdinalNumberPattern$2 = /^(\d+)(\.)?/i;
    var parseOrdinalNumberPattern$2 = /\d+/i;
    var matchEraPatterns$2 = {
      narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
      abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
      wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
    };
    var parseEraPatterns$2 = {
      any: [/^v/i, /^n/i]
    };
    var matchQuarterPatterns$2 = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](\.)? Quartal/i
    };
    var parseQuarterPatterns$2 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$2 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(j[aÃ¤]n|feb|mÃ¤r[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
      wide: /^(januar|februar|mÃ¤rz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
    };
    var parseMonthPatterns$2 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^j[aÃ¤]/i, /^f/i, /^mÃ¤r/i, /^ap/i, /^mai/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$2 = {
      narrow: /^[smdmf]/i,
      short: /^(so|mo|di|mi|do|fr|sa)/i,
      abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
      wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
    };
    var parseDayPatterns$2 = {
      any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns$2 = {
      narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
      abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
      wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
    };
    var parseDayPeriodPatterns$2 = {
      any: {
        am: /^v/i,
        pm: /^n/i,
        midnight: /^Mitte/i,
        noon: /^Mitta/i,
        morning: /morgens/i,
        afternoon: /nachmittags/i,
        // will never be matched. Afternoon is matched by `pm`
        evening: /abends/i,
        night: /nachts/i // will never be matched. Night is matched by `pm`

      }
    };
    var match$5 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$2,
        parsePattern: parseOrdinalNumberPattern$2,
        valueCallback: function (value) {
          return parseInt(value);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$2,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$2,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$2,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$2,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPeriodPatterns$2,
        defaultParseWidth: 'any'
      })
    };
    var match$6 = match$5;

    /**
     * @type {Locale}
     * @category Locales
     * @summary German locale.
     * @language German
     * @iso-639-2 deu
     * @author Thomas Eilmsteiner [@DeMuu]{@link https://github.com/DeMuu}
     * @author Asia [@asia-t]{@link https://github.com/asia-t}
     * @author Van Vuong Ngo [@vanvuongngo]{@link https://github.com/vanvuongngo}
     * @author RomanErnst [@pex]{@link https://github.com/pex}
     * @author Philipp Keck [@Philipp91]{@link https://github.com/Philipp91}
     */

    var locale$2 = {
      code: 'de',
      formatDistance: formatDistance$5,
      formatLong: formatLong$5,
      formatRelative: formatRelative$5,
      localize: localize$5,
      match: match$6,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };
    var de = locale$2;

    var formatDistanceLocale$1 = {
      lessThanXSeconds: {
        one: 'moins dâune seconde',
        other: 'moins de {{count}} secondes'
      },
      xSeconds: {
        one: '1 seconde',
        other: '{{count}} secondes'
      },
      halfAMinute: '30 secondes',
      lessThanXMinutes: {
        one: 'moins dâune minute',
        other: 'moins de {{count}} minutes'
      },
      xMinutes: {
        one: '1 minute',
        other: '{{count}} minutes'
      },
      aboutXHours: {
        one: 'environ 1 heure',
        other: 'environ {{count}} heures'
      },
      xHours: {
        one: '1 heure',
        other: '{{count}} heures'
      },
      xDays: {
        one: '1 jour',
        other: '{{count}} jours'
      },
      aboutXWeeks: {
        one: 'environ 1 semaine',
        other: 'environ {{count}} semaines'
      },
      xWeeks: {
        one: '1 semaine',
        other: '{{count}} semaines'
      },
      aboutXMonths: {
        one: 'environ 1 mois',
        other: 'environ {{count}} mois'
      },
      xMonths: {
        one: '1 mois',
        other: '{{count}} mois'
      },
      aboutXYears: {
        one: 'environ 1 an',
        other: 'environ {{count}} ans'
      },
      xYears: {
        one: '1 an',
        other: '{{count}} ans'
      },
      overXYears: {
        one: 'plus dâun an',
        other: 'plus de {{count}} ans'
      },
      almostXYears: {
        one: 'presquâun an',
        other: 'presque {{count}} ans'
      }
    };

    var formatDistance$2 = function (token, count, options) {
      var result;
      var form = formatDistanceLocale$1[token];

      if (typeof form === 'string') {
        result = form;
      } else if (count === 1) {
        result = form.one;
      } else {
        result = form.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'dans ' + result;
        } else {
          return 'il y a ' + result;
        }
      }

      return result;
    };

    var formatDistance$3 = formatDistance$2;

    var dateFormats$1 = {
      full: 'EEEE d MMMM y',
      long: 'd MMMM y',
      medium: 'd MMM y',
      short: 'dd/MM/y'
    };
    var timeFormats$1 = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$1 = {
      full: "{{date}} 'Ã ' {{time}}",
      long: "{{date}} 'Ã ' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$2 = {
      date: buildFormatLongFn({
        formats: dateFormats$1,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats$1,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1,
        defaultWidth: 'full'
      })
    };
    var formatLong$3 = formatLong$2;

    var formatRelativeLocale$1 = {
      lastWeek: "eeee 'dernier Ã ' p",
      yesterday: "'hier Ã ' p",
      today: "'aujourdâhui Ã ' p",
      tomorrow: "'demain Ã ' p'",
      nextWeek: "eeee 'prochain Ã ' p",
      other: 'P'
    };

    var formatRelative$2 = function (token, _date, _baseDate, _options) {
      return formatRelativeLocale$1[token];
    };

    var formatRelative$3 = formatRelative$2;

    var eraValues$1 = {
      narrow: ['av. J.-C', 'ap. J.-C'],
      abbreviated: ['av. J.-C', 'ap. J.-C'],
      wide: ['avant JÃ©sus-Christ', 'aprÃ¨s JÃ©sus-Christ']
    };
    var quarterValues$1 = {
      narrow: ['T1', 'T2', 'T3', 'T4'],
      abbreviated: ['1er trim.', '2Ã¨me trim.', '3Ã¨me trim.', '4Ã¨me trim.'],
      wide: ['1er trimestre', '2Ã¨me trimestre', '3Ã¨me trimestre', '4Ã¨me trimestre']
    };
    var monthValues$1 = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['janv.', 'fÃ©vr.', 'mars', 'avr.', 'mai', 'juin', 'juil.', 'aoÃ»t', 'sept.', 'oct.', 'nov.', 'dÃ©c.'],
      wide: ['janvier', 'fÃ©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'aoÃ»t', 'septembre', 'octobre', 'novembre', 'dÃ©cembre']
    };
    var dayValues$1 = {
      narrow: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
      short: ['di', 'lu', 'ma', 'me', 'je', 've', 'sa'],
      abbreviated: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
      wide: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi']
    };
    var dayPeriodValues$1 = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'minuit',
        noon: 'midi',
        morning: 'mat.',
        afternoon: 'ap.m.',
        evening: 'soir',
        night: 'mat.'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'minuit',
        noon: 'midi',
        morning: 'matin',
        afternoon: 'aprÃ¨s-midi',
        evening: 'soir',
        night: 'matin'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'minuit',
        noon: 'midi',
        morning: 'du matin',
        afternoon: 'de lâaprÃ¨s-midi',
        evening: 'du soir',
        night: 'du matin'
      }
    };

    var ordinalNumber$1 = function (dirtyNumber, options) {
      var number = Number(dirtyNumber);
      var unit = options === null || options === void 0 ? void 0 : options.unit;
      if (number === 0) return '0';
      var feminineUnits = ['year', 'week', 'hour', 'minute', 'second'];
      var suffix;

      if (number === 1) {
        suffix = unit && feminineUnits.includes(unit) ? 'Ã¨re' : 'er';
      } else {
        suffix = 'Ã¨me';
      }

      return number + suffix;
    };

    var localize$2 = {
      ordinalNumber: ordinalNumber$1,
      era: buildLocalizeFn({
        values: eraValues$1,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$1,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues$1,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues$1,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1,
        defaultWidth: 'wide'
      })
    };
    var localize$3 = localize$2;

    var matchOrdinalNumberPattern$1 = /^(\d+)(iÃ¨me|Ã¨re|Ã¨me|er|e)?/i;
    var parseOrdinalNumberPattern$1 = /\d+/i;
    var matchEraPatterns$1 = {
      narrow: /^(av\.J\.C|ap\.J\.C|ap\.J\.-C)/i,
      abbreviated: /^(av\.J\.-C|av\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
      wide: /^(avant JÃ©sus-Christ|aprÃ¨s JÃ©sus-Christ)/i
    };
    var parseEraPatterns$1 = {
      any: [/^av/i, /^ap/i]
    };
    var matchQuarterPatterns$1 = {
      narrow: /^T?[1234]/i,
      abbreviated: /^[1234](er|Ã¨me|e)? trim\.?/i,
      wide: /^[1234](er|Ã¨me|e)? trimestre/i
    };
    var parseQuarterPatterns$1 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$1 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(janv|fÃ©vr|mars|avr|mai|juin|juill|juil|aoÃ»t|sept|oct|nov|dÃ©c)\.?/i,
      wide: /^(janvier|fÃ©vrier|mars|avril|mai|juin|juillet|aoÃ»t|septembre|octobre|novembre|dÃ©cembre)/i
    };
    var parseMonthPatterns$1 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^av/i, /^ma/i, /^juin/i, /^juil/i, /^ao/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$1 = {
      narrow: /^[lmjvsd]/i,
      short: /^(di|lu|ma|me|je|ve|sa)/i,
      abbreviated: /^(dim|lun|mar|mer|jeu|ven|sam)\.?/i,
      wide: /^(dimanche|lundi|mardi|mercredi|jeudi|vendredi|samedi)/i
    };
    var parseDayPatterns$1 = {
      narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
      any: [/^di/i, /^lu/i, /^ma/i, /^me/i, /^je/i, /^ve/i, /^sa/i]
    };
    var matchDayPeriodPatterns$1 = {
      narrow: /^(a|p|minuit|midi|mat\.?|ap\.?m\.?|soir|nuit)/i,
      any: /^([ap]\.?\s?m\.?|du matin|de l'aprÃ¨s[-\s]midi|du soir|de la nuit)/i
    };
    var parseDayPeriodPatterns$1 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^min/i,
        noon: /^mid/i,
        morning: /mat/i,
        afternoon: /ap/i,
        evening: /soir/i,
        night: /nuit/i
      }
    };
    var match$3 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1,
        parsePattern: parseOrdinalNumberPattern$1,
        valueCallback: function (value) {
          return parseInt(value);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$1,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$1,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$1,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$1,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$1,
        defaultParseWidth: 'any'
      })
    };
    var match$4 = match$3;

    /**
     * @type {Locale}
     * @category Locales
     * @summary French locale.
     * @language French
     * @iso-639-2 fra
     * @author Jean Dupouy [@izeau]{@link https://github.com/izeau}
     * @author FranÃ§ois B [@fbonzon]{@link https://github.com/fbonzon}
     */

    var locale$1 = {
      code: 'fr',
      formatDistance: formatDistance$3,
      formatLong: formatLong$3,
      formatRelative: formatRelative$3,
      localize: localize$3,
      match: match$4,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };
    var fr = locale$1;

    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: 'menos de um segundo',
        other: 'menos de {{count}} segundos'
      },
      xSeconds: {
        one: '1 segundo',
        other: '{{count}} segundos'
      },
      halfAMinute: 'meio minuto',
      lessThanXMinutes: {
        one: 'menos de um minuto',
        other: 'menos de {{count}} minutos'
      },
      xMinutes: {
        one: '1 minuto',
        other: '{{count}} minutos'
      },
      aboutXHours: {
        one: 'aproximadamente 1 hora',
        other: 'aproximadamente {{count}} horas'
      },
      xHours: {
        one: '1 hora',
        other: '{{count}} horas'
      },
      xDays: {
        one: '1 dia',
        other: '{{count}} dias'
      },
      aboutXWeeks: {
        one: 'aproximadamente 1 semana',
        other: 'aproximadamente {{count}} semanas'
      },
      xWeeks: {
        one: '1 semana',
        other: '{{count}} semanas'
      },
      aboutXMonths: {
        one: 'aproximadamente 1 mÃªs',
        other: 'aproximadamente {{count}} meses'
      },
      xMonths: {
        one: '1 mÃªs',
        other: '{{count}} meses'
      },
      aboutXYears: {
        one: 'aproximadamente 1 ano',
        other: 'aproximadamente {{count}} anos'
      },
      xYears: {
        one: '1 ano',
        other: '{{count}} anos'
      },
      overXYears: {
        one: 'mais de 1 ano',
        other: 'mais de {{count}} anos'
      },
      almostXYears: {
        one: 'quase 1 ano',
        other: 'quase {{count}} anos'
      }
    };

    var formatDistance = function (token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale[token];

      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }

      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'daqui a ' + result;
        } else {
          return 'hÃ¡ ' + result;
        }
      }

      return result;
    };

    var formatDistance$1 = formatDistance;

    var dateFormats = {
      full: "EEEE, d 'de' MMMM 'de' y",
      long: "d 'de' MMMM 'de' y",
      medium: "d 'de' MMM 'de' y",
      short: 'dd/MM/y'
    };
    var timeFormats = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats = {
      full: "{{date}} 'Ã s' {{time}}",
      long: "{{date}} 'Ã s' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: 'full'
      })
    };
    var formatLong$1 = formatLong;

    var formatRelativeLocale = {
      lastWeek: function (date) {
        var weekday = date.getUTCDay();
        var last = weekday === 0 || weekday === 6 ? 'Ãºltimo' : 'Ãºltima';
        return "'" + last + "' eeee 'Ã s' p";
      },
      yesterday: "'ontem Ã s' p",
      today: "'hoje Ã s' p",
      tomorrow: "'amanhÃ£ Ã s' p",
      nextWeek: "eeee 'Ã s' p",
      other: 'P'
    };

    var formatRelative = function (token, date, _baseDate, _options) {
      var format = formatRelativeLocale[token];

      if (typeof format === 'function') {
        return format(date);
      }

      return format;
    };

    var formatRelative$1 = formatRelative;

    var eraValues = {
      narrow: ['aC', 'dC'],
      abbreviated: ['a.C.', 'd.C.'],
      wide: ['antes de Cristo', 'depois de Cristo']
    };
    var quarterValues = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['T1', 'T2', 'T3', 'T4'],
      wide: ['1Âº trimestre', '2Âº trimestre', '3Âº trimestre', '4Âº trimestre']
    };
    var monthValues = {
      narrow: ['j', 'f', 'm', 'a', 'm', 'j', 'j', 'a', 's', 'o', 'n', 'd'],
      abbreviated: ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez'],
      wide: ['janeiro', 'fevereiro', 'marÃ§o', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro']
    };
    var dayValues = {
      narrow: ['d', 's', 't', 'q', 'q', 's', 's'],
      short: ['dom', 'seg', 'ter', 'qua', 'qui', 'sex', 'sÃ¡b'],
      abbreviated: ['dom', 'seg', 'ter', 'qua', 'qui', 'sex', 'sÃ¡b'],
      wide: ['domingo', 'segunda-feira', 'terÃ§a-feira', 'quarta-feira', 'quinta-feira', 'sexta-feira', 'sÃ¡bado']
    };
    var dayPeriodValues = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'manhÃ£',
        afternoon: 'tarde',
        evening: 'noite',
        night: 'madrugada'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'manhÃ£',
        afternoon: 'tarde',
        evening: 'noite',
        night: 'madrugada'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'manhÃ£',
        afternoon: 'tarde',
        evening: 'noite',
        night: 'madrugada'
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'da manhÃ£',
        afternoon: 'da tarde',
        evening: 'da noite',
        night: 'da madrugada'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'da manhÃ£',
        afternoon: 'da tarde',
        evening: 'da noite',
        night: 'da madrugada'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'da manhÃ£',
        afternoon: 'da tarde',
        evening: 'da noite',
        night: 'da madrugada'
      }
    };

    var ordinalNumber = function (dirtyNumber, _options) {
      var number = Number(dirtyNumber);
      return number + 'Âº';
    };

    var localize = {
      ordinalNumber: ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: 'wide'
      })
    };
    var localize$1 = localize;

    var matchOrdinalNumberPattern = /^(\d+)(Âº|Âª)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(ac|dc|a|d)/i,
      abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
      wide: /^(antes de cristo|antes da era comum|depois de cristo|era comum)/i
    };
    var parseEraPatterns = {
      any: [/^ac/i, /^dc/i],
      wide: [/^(antes de cristo|antes da era comum)/i, /^(depois de cristo|era comum)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^T[1234]/i,
      wide: /^[1234](Âº|Âª)? trimestre/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
      wide: /^(janeiro|fevereiro|marÃ§o|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
    };
    var parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ab/i, /^mai/i, /^jun/i, /^jul/i, /^ag/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns = {
      narrow: /^[dstq]/i,
      short: /^(dom|seg|ter|qua|qui|sex|s[Ã¡a]b)/i,
      abbreviated: /^(dom|seg|ter|qua|qui|sex|s[Ã¡a]b)/i,
      wide: /^(domingo|segunda-?\s?feira|terÃ§a-?\s?feira|quarta-?\s?feira|quinta-?\s?feira|sexta-?\s?feira|s[Ã¡a]bado)/i
    };
    var parseDayPatterns = {
      narrow: [/^d/i, /^s/i, /^t/i, /^q/i, /^q/i, /^s/i, /^s/i],
      any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[Ã¡a]/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|meia-?\s?noite|meio-?\s?dia|(da) (manh[Ã£a]|tarde|noite|madrugada))/i,
      any: /^([ap]\.?\s?m\.?|meia-?\s?noite|meio-?\s?dia|(da) (manh[Ã£a]|tarde|noite|madrugada))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^meia/i,
        noon: /^meio/i,
        morning: /manh[Ã£a]/i,
        afternoon: /tarde/i,
        evening: /noite/i,
        night: /madrugada/i
      }
    };
    var match$1 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: 'any'
      })
    };
    var match$2 = match$1;

    /**
     * @type {Locale}
     * @category Locales
     * @summary Portuguese locale.
     * @language Portuguese
     * @iso-639-2 por
     * @author DÃ¡rio Freire [@dfreire]{@link https://github.com/dfreire}
     * @author AdriÃ¡n de la Rosa [@adrm]{@link https://github.com/adrm}
     */

    var locale = {
      code: 'pt',
      formatDistance: formatDistance$1,
      formatLong: formatLong$1,
      formatRelative: formatRelative$1,
      localize: localize$1,
      match: match$2,
      options: {
        weekStartsOn: 1
        /* Monday */
        ,
        firstWeekContainsDate: 4
      }
    };
    var pt = locale;

    var Helpers = /*#__PURE__*/function () {
      function Helpers() {
        _classCallCheck$1(this, Helpers);
      }

      _createClass$1(Helpers, null, [{
        key: "replaceNode",
        value: // Helps replacing a SSR node with a Svelte component
        function replaceNode(node) {
          if (node) {
            node.innerHTML = "";
          }

          return node;
        }
      }, {
        key: "hideFallbacks",
        value: function hideFallbacks(fileName) {
          var nodes = document.querySelectorAll("[data-svelte-hide=\"".concat(fileName, "\"]"));

          if (nodes && nodes.length) {
            nodes.forEach(function (node) {
              return node.remove();
            });
          }
        } // Returns a new url with updated fields

      }, {
        key: "getUpdatedFilterUrl",
        value: function getUpdatedFilterUrl(field, value, baseUrl) {
          var urlParts = baseUrl.split("?");

          if (urlParts.length > 1) {
            var queryString = urlParts[1];
            var queryStringParts = queryString.split("&");
            var queryStringVariables = {};
            queryStringParts.forEach(function (part) {
              var partParts = part.split("=");

              if (partParts && partParts.length > 1 && typeof partParts[1] !== "undefined") {
                queryStringVariables = _objectSpread2(_objectSpread2({}, queryStringVariables), {}, _defineProperty$x({}, partParts[0], partParts[1]));
              }
            });
            queryStringVariables[field] = value;
            return "".concat(urlParts[0], "?").concat(Object.keys(queryStringVariables).map(function (key) {
              return "".concat(key, "=").concat(queryStringVariables[key]);
            }).join("&"));
          } else {
            return "".concat(baseUrl, "?").concat(field, "=").concat(value);
          }
        }
      }, {
        key: "getLinkEl",
        value: function getLinkEl() {
          return document.querySelector(".hidden-filter-link");
        }
      }, {
        key: "getDateLocaleOptions",
        value: function getDateLocaleOptions() {
          var shortLocale = dist_7().split("_")[0];
          var locales = {
            de: de,
            fr: fr,
            pt: pt
          };
          return {
            weekStartsOn: dist_5$1(),
            locale: locales[shortLocale]
          };
        }
      }]);

      return Helpers;
    }();

    function get_each_context$8(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[25] = list[i];
      child_ctx[27] = i;
      return child_ctx;
    } // (229:0) {#if controls}


    function create_if_block_7$1(ctx) {
      var h2;
      return {
        c: function c() {
          h2 = element("h2");
          h2.textContent = "".concat(dist_10('timemanager', 'Statistics'));
        },
        m: function m(target, anchor) {
          insert(target, h2, anchor);
        },
        p: noop$1,
        d: function d(detaching) {
          if (detaching) detach(h2);
        }
      };
    } // (233:1) {#if controls}


    function create_if_block_6$2(ctx) {
      var div;
      var figure0;
      var figcaption0;
      var t1;
      var t2_value =
      /*simpleRounding*/
      ctx[8](
      /*todayTotal*/
      ctx[4]) + "";
      var t2;
      var t3;
      var t4_value = dist_10('timemanager', 'hrs.') + "";
      var t4;
      var t5;
      var figure1;
      var figcaption1;
      var t7;
      var t8_value =
      /*simpleRounding*/
      ctx[8](
      /*weekTotal*/
      ctx[5]) + "";
      var t8;
      var t9;
      var t10_value = dist_10('timemanager', 'hrs.') + "";
      var t10;
      return {
        c: function c() {
          div = element("div");
          figure0 = element("figure");
          figcaption0 = element("figcaption");
          figcaption0.textContent = "".concat(dist_10('timemanager', 'Today'));
          t1 = space$1();
          t2 = text(t2_value);
          t3 = space$1();
          t4 = text(t4_value);
          t5 = space$1();
          figure1 = element("figure");
          figcaption1 = element("figcaption");
          figcaption1.textContent = "".concat(dist_10('timemanager', 'Week'));
          t7 = space$1();
          t8 = text(t8_value);
          t9 = space$1();
          t10 = text(t10_value);
          attr(figcaption0, "class", "tm_label");
          attr(figcaption1, "class", "tm_label");
          attr(div, "class", "top-stats");
        },
        m: function m(target, anchor) {
          insert(target, div, anchor);
          append(div, figure0);
          append(figure0, figcaption0);
          append(figure0, t1);
          append(figure0, t2);
          append(figure0, t3);
          append(figure0, t4);
          append(div, t5);
          append(div, figure1);
          append(figure1, figcaption1);
          append(figure1, t7);
          append(figure1, t8);
          append(figure1, t9);
          append(figure1, t10);
        },
        p: function p(ctx, dirty) {
          if (dirty &
          /*todayTotal*/
          16 && t2_value !== (t2_value =
          /*simpleRounding*/
          ctx[8](
          /*todayTotal*/
          ctx[4]) + "")) set_data(t2, t2_value);
          if (dirty &
          /*weekTotal*/
          32 && t8_value !== (t8_value =
          /*simpleRounding*/
          ctx[8](
          /*weekTotal*/
          ctx[5]) + "")) set_data(t8, t8_value);
        },
        d: function d(detaching) {
          if (detaching) detach(div);
        }
      };
    } // (247:3) {#if !loading && weekTotal > 0}


    function create_if_block_3$2(ctx) {
      var each_1_anchor;
      var each_value =
      /*points*/
      ctx[3];
      var each_blocks = [];

      for (var i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
      }

      return {
        c: function c() {
          for (var _i = 0; _i < each_blocks.length; _i += 1) {
            each_blocks[_i].c();
          }

          each_1_anchor = empty();
        },
        m: function m(target, anchor) {
          for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
            each_blocks[_i2].m(target, anchor);
          }

          insert(target, each_1_anchor, anchor);
        },
        p: function p(ctx, dirty) {
          if (dirty &
          /*formatDateForScale, points, highest, translate*/
          2120) {
            each_value =
            /*points*/
            ctx[3];

            var _i3;

            for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
              var child_ctx = get_each_context$8(ctx, each_value, _i3);

              if (each_blocks[_i3]) {
                each_blocks[_i3].p(child_ctx, dirty);
              } else {
                each_blocks[_i3] = create_each_block$8(child_ctx);

                each_blocks[_i3].c();

                each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; _i3 < each_blocks.length; _i3 += 1) {
              each_blocks[_i3].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function d(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach(each_1_anchor);
        }
      };
    } // (250:6) {#if point && point.stats}


    function create_if_block_4$2(ctx) {
      var t0;
      var div;
      var span0;
      var t1_value =
      /*formatDateForScale*/
      ctx[11](
      /*point*/
      ctx[25].date, 'primary') + "";
      var t1;
      var t2;
      var span1;
      var t3_value =
      /*formatDateForScale*/
      ctx[11](
      /*point*/
      ctx[25].date, 'secondary') + "";
      var t3;
      var if_block =
      /*point*/
      ctx[25].stats.total > 0 && create_if_block_5$2(ctx);
      return {
        c: function c() {
          if (if_block) if_block.c();
          t0 = space$1();
          div = element("div");
          span0 = element("span");
          t1 = text(t1_value);
          t2 = space$1();
          span1 = element("span");
          t3 = text(t3_value);
          attr(span0, "class", "day");
          attr(span1, "class", "date");
          attr(div, "class", "date-label");
        },
        m: function m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, t0, anchor);
          insert(target, div, anchor);
          append(div, span0);
          append(span0, t1);
          append(div, t2);
          append(div, span1);
          append(span1, t3);
        },
        p: function p(ctx, dirty) {
          if (
          /*point*/
          ctx[25].stats.total > 0) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_5$2(ctx);
              if_block.c();
              if_block.m(t0.parentNode, t0);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty &
          /*points*/
          8 && t1_value !== (t1_value =
          /*formatDateForScale*/
          ctx[11](
          /*point*/
          ctx[25].date, 'primary') + "")) set_data(t1, t1_value);
          if (dirty &
          /*points*/
          8 && t3_value !== (t3_value =
          /*formatDateForScale*/
          ctx[11](
          /*point*/
          ctx[25].date, 'secondary') + "")) set_data(t3, t3_value);
        },
        d: function d(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach(t0);
          if (detaching) detach(div);
        }
      };
    } // (251:7) {#if point.stats.total > 0}


    function create_if_block_5$2(ctx) {
      var span;
      var t0_value =
      /*point*/
      ctx[25].stats.total + "";
      var t0;
      var t1;
      var t2_value = dist_10('timemanager', 'hrs.') + "";
      var t2;
      var t3;
      var div;
      var div_style_value;
      return {
        c: function c() {
          span = element("span");
          t0 = text(t0_value);
          t1 = space$1();
          t2 = text(t2_value);
          t3 = space$1();
          div = element("div");
          attr(span, "class", "hours-label");
          attr(div, "class", "column-inner");
          attr(div, "style", div_style_value = "height: ".concat(
          /*point*/
          ctx[25].stats.total /
          /*highest*/
          ctx[6] * 100, "%"));
        },
        m: function m(target, anchor) {
          insert(target, span, anchor);
          append(span, t0);
          append(span, t1);
          append(span, t2);
          insert(target, t3, anchor);
          insert(target, div, anchor);
        },
        p: function p(ctx, dirty) {
          if (dirty &
          /*points*/
          8 && t0_value !== (t0_value =
          /*point*/
          ctx[25].stats.total + "")) set_data(t0, t0_value);

          if (dirty &
          /*points, highest*/
          72 && div_style_value !== (div_style_value = "height: ".concat(
          /*point*/
          ctx[25].stats.total /
          /*highest*/
          ctx[6] * 100, "%"))) {
            attr(div, "style", div_style_value);
          }
        },
        d: function d(detaching) {
          if (detaching) detach(span);
          if (detaching) detach(t3);
          if (detaching) detach(div);
        }
      };
    } // (248:4) {#each points as point, index}


    function create_each_block$8(ctx) {
      var div;
      var t;
      var if_block =
      /*point*/
      ctx[25] &&
      /*point*/
      ctx[25].stats && create_if_block_4$2(ctx);
      return {
        c: function c() {
          div = element("div");
          if (if_block) if_block.c();
          t = space$1();
          attr(div, "class", "column");
        },
        m: function m(target, anchor) {
          insert(target, div, anchor);
          if (if_block) if_block.m(div, null);
          append(div, t);
        },
        p: function p(ctx, dirty) {
          if (
          /*point*/
          ctx[25] &&
          /*point*/
          ctx[25].stats) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_4$2(ctx);
              if_block.c();
              if_block.m(div, t);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d: function d(detaching) {
          if (detaching) detach(div);
          if (if_block) if_block.d();
        }
      };
    } // (263:3) {#if controls && !loading && weekTotal === 0}


    function create_if_block_2$3(ctx) {
      var p;
      return {
        c: function c() {
          p = element("p");
          p.textContent = "".concat(dist_10('timemanager', 'When you add entries for this week graphs will appear here.'));
          attr(p, "class", "empty");
        },
        m: function m(target, anchor) {
          insert(target, p, anchor);
        },
        p: noop$1,
        d: function d(detaching) {
          if (detaching) detach(p);
        }
      };
    } // (267:2) {#if controls}


    function create_if_block$j(ctx) {
      var nav;
      var button0;
      var t1;
      var span1;
      var t2_value = dist_10('timemanager', 'Week') + "";
      var t2;
      var t3;
      var t4;
      var t5;
      var span0;
      var t6;
      var t7_value = format$2(startOfWeek(
      /*startCursor*/
      ctx[1],
      /*localeOptions*/
      ctx[9]), 'iiiiii d.MM.Y',
      /*localeOptions*/
      ctx[9]) + "";
      var t7;
      var t8;
      var t9_value = format$2(endOfWeek(
      /*startCursor*/
      ctx[1],
      /*localeOptions*/
      ctx[9]), 'iiiiii d.MM.Y',
      /*localeOptions*/
      ctx[9]) + "";
      var t9;
      var t10;
      var t11;
      var span2;
      var show_if = !isSameDay(startOfWeek(startOfToday(),
      /*localeOptions*/
      ctx[9]),
      /*startCursor*/
      ctx[1]);
      var t12;
      var button1;
      var mounted;
      var dispose;
      var if_block = show_if && create_if_block_1$7(ctx);
      return {
        c: function c() {
          nav = element("nav");
          button0 = element("button");
          button0.textContent = "".concat(dist_10('timemanager', 'Previous week'));
          t1 = space$1();
          span1 = element("span");
          t2 = text(t2_value);
          t3 = space$1();
          t4 = text(
          /*currentWeek*/
          ctx[7]);
          t5 = space$1();
          span0 = element("span");
          t6 = text("(");
          t7 = text(t7_value);
          t8 = text(" â ");
          t9 = text(t9_value);
          t10 = text(")");
          t11 = space$1();
          span2 = element("span");
          if (if_block) if_block.c();
          t12 = space$1();
          button1 = element("button");
          button1.textContent = "".concat(dist_10('timemanager', 'Next week'));
          attr(button0, "class", "previous");
          attr(span0, "class", "dates");
          attr(button1, "class", "next");
          attr(nav, "class", "week-navigation");
        },
        m: function m(target, anchor) {
          insert(target, nav, anchor);
          append(nav, button0);
          append(nav, t1);
          append(nav, span1);
          append(span1, t2);
          append(span1, t3);
          append(span1, t4);
          append(span1, t5);
          append(span1, span0);
          append(span0, t6);
          append(span0, t7);
          append(span0, t8);
          append(span0, t9);
          append(span0, t10);
          append(nav, t11);
          append(nav, span2);
          if (if_block) if_block.m(span2, null);
          append(span2, t12);
          append(span2, button1);

          if (!mounted) {
            dispose = [listen(button0, "click", prevent_default(
            /*click_handler*/
            ctx[17])), listen(button1, "click", prevent_default(
            /*click_handler_2*/
            ctx[19]))];
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if (dirty &
          /*currentWeek*/
          128) set_data(t4,
          /*currentWeek*/
          ctx[7]);
          if (dirty &
          /*startCursor*/
          2 && t7_value !== (t7_value = format$2(startOfWeek(
          /*startCursor*/
          ctx[1],
          /*localeOptions*/
          ctx[9]), 'iiiiii d.MM.Y',
          /*localeOptions*/
          ctx[9]) + "")) set_data(t7, t7_value);
          if (dirty &
          /*startCursor*/
          2 && t9_value !== (t9_value = format$2(endOfWeek(
          /*startCursor*/
          ctx[1],
          /*localeOptions*/
          ctx[9]), 'iiiiii d.MM.Y',
          /*localeOptions*/
          ctx[9]) + "")) set_data(t9, t9_value);
          if (dirty &
          /*startCursor*/
          2) show_if = !isSameDay(startOfWeek(startOfToday(),
          /*localeOptions*/
          ctx[9]),
          /*startCursor*/
          ctx[1]);

          if (show_if) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_1$7(ctx);
              if_block.c();
              if_block.m(span2, t12);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d: function d(detaching) {
          if (detaching) detach(nav);
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    } // (279:5) {#if !isSameDay(startOfWeek(startOfToday(), localeOptions), startCursor)}


    function create_if_block_1$7(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c: function c() {
          button = element("button");
          button.textContent = "".concat(dist_10('timemanager', 'Current week'));
          attr(button, "class", "current");
        },
        m: function m(target, anchor) {
          insert(target, button, anchor);

          if (!mounted) {
            dispose = listen(button, "click", prevent_default(
            /*click_handler_1*/
            ctx[18]));
            mounted = true;
          }
        },
        p: noop$1,
        d: function d(detaching) {
          if (detaching) detach(button);
          mounted = false;
          dispose();
        }
      };
    }

    function create_fragment$s(ctx) {
      var t0;
      var div2;
      var t1;
      var div1;
      var div0;
      var t2;
      var div0_class_value;
      var t3;
      var div2_class_value;
      var if_block0 =
      /*controls*/
      ctx[0] && create_if_block_7$1();
      var if_block1 =
      /*controls*/
      ctx[0] && create_if_block_6$2(ctx);
      var if_block2 = !
      /*loading*/
      ctx[2] &&
      /*weekTotal*/
      ctx[5] > 0 && create_if_block_3$2(ctx);
      var if_block3 =
      /*controls*/
      ctx[0] && !
      /*loading*/
      ctx[2] &&
      /*weekTotal*/
      ctx[5] === 0 && create_if_block_2$3();
      var if_block4 =
      /*controls*/
      ctx[0] && create_if_block$j(ctx);
      return {
        c: function c() {
          if (if_block0) if_block0.c();
          t0 = space$1();
          div2 = element("div");
          if (if_block1) if_block1.c();
          t1 = space$1();
          div1 = element("div");
          div0 = element("div");
          if (if_block2) if_block2.c();
          t2 = space$1();
          if (if_block3) if_block3.c();
          t3 = space$1();
          if (if_block4) if_block4.c();
          attr(div0, "class", div0_class_value = "hours-per-week ".concat(
          /*points*/
          ctx[3].length > 12 || window.clientWidth < 768 ? 'many' : 'few'));
          attr(div1, "class", "graphs");
          attr(div2, "class", div2_class_value = "".concat(
          /*loading*/
          ctx[2] ? 'icon-loading' : ''));
        },
        m: function m(target, anchor) {
          if (if_block0) if_block0.m(target, anchor);
          insert(target, t0, anchor);
          insert(target, div2, anchor);
          if (if_block1) if_block1.m(div2, null);
          append(div2, t1);
          append(div2, div1);
          append(div1, div0);
          if (if_block2) if_block2.m(div0, null);
          append(div0, t2);
          if (if_block3) if_block3.m(div0, null);
          append(div1, t3);
          if (if_block4) if_block4.m(div1, null);
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (
          /*controls*/
          ctx[0]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_7$1();
              if_block0.c();
              if_block0.m(t0.parentNode, t0);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*controls*/
          ctx[0]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block_6$2(ctx);
              if_block1.c();
              if_block1.m(div2, t1);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }

          if (!
          /*loading*/
          ctx[2] &&
          /*weekTotal*/
          ctx[5] > 0) {
            if (if_block2) {
              if_block2.p(ctx, dirty);
            } else {
              if_block2 = create_if_block_3$2(ctx);
              if_block2.c();
              if_block2.m(div0, t2);
            }
          } else if (if_block2) {
            if_block2.d(1);
            if_block2 = null;
          }

          if (
          /*controls*/
          ctx[0] && !
          /*loading*/
          ctx[2] &&
          /*weekTotal*/
          ctx[5] === 0) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
            } else {
              if_block3 = create_if_block_2$3();
              if_block3.c();
              if_block3.m(div0, null);
            }
          } else if (if_block3) {
            if_block3.d(1);
            if_block3 = null;
          }

          if (dirty &
          /*points*/
          8 && div0_class_value !== (div0_class_value = "hours-per-week ".concat(
          /*points*/
          ctx[3].length > 12 || window.clientWidth < 768 ? 'many' : 'few'))) {
            attr(div0, "class", div0_class_value);
          }

          if (
          /*controls*/
          ctx[0]) {
            if (if_block4) {
              if_block4.p(ctx, dirty);
            } else {
              if_block4 = create_if_block$j(ctx);
              if_block4.c();
              if_block4.m(div1, null);
            }
          } else if (if_block4) {
            if_block4.d(1);
            if_block4 = null;
          }

          if (dirty &
          /*loading*/
          4 && div2_class_value !== (div2_class_value = "".concat(
          /*loading*/
          ctx[2] ? 'icon-loading' : ''))) {
            attr(div2, "class", div2_class_value);
          }
        },
        i: noop$1,
        o: noop$1,
        d: function d(detaching) {
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach(t0);
          if (detaching) detach(div2);
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          if (if_block3) if_block3.d();
          if (if_block4) if_block4.d();
        }
      };
    }

    var dateFormat$1 = "yyyy-MM-dd";

    function instance$r($$self, $$props, $$invalidate) {
      var loading;
      var scale;
      var points;
      var weekTotal;
      var todayTotal;
      var highest;
      var startCursor;
      var endCursor;
      var currentWeek;
      var statsApiUrl = $$props.statsApiUrl;
      var requestToken = $$props.requestToken;
      var _$$props$controls = $$props.controls,
          controls = _$$props$controls === void 0 ? true : _$$props$controls;
      var _$$props$includeShare = $$props.includeShared,
          includeShared = _$$props$includeShare === void 0 ? false : _$$props$includeShare;

      var simpleRounding = function simpleRounding(number) {
        return Math.round(number * 100) / 100;
      };

      var localeOptions = Helpers.getDateLocaleOptions();
      var _$$props$start = $$props.start,
          start = _$$props$start === void 0 ? format$2(startOfWeek(new Date(), localeOptions), dateFormat$1, new Date()) : _$$props$start;
      var _$$props$end = $$props.end,
          end = _$$props$end === void 0 ? format$2(endOfWeek(new Date(), localeOptions), dateFormat$1, new Date()) : _$$props$end;

      var updateWeek = function updateWeek() {
        $$invalidate(5, weekTotal = 0);
        $$invalidate(4, todayTotal = 0);
        $$invalidate(6, highest = 0);
        $$invalidate(7, currentWeek = getWeek(startCursor, localeOptions));
      };

      onMount( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                updateWeek();
                loadData();

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })));

      var loadData = /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var durationDays, durationMonths, durationWeeks, durationYears, _yield$loadStats, grouped, js_date_format;

          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  $$invalidate(2, loading = true); // Reset points

                  $$invalidate(3, points = []); // Determine duration between cursors

                  durationDays = differenceInDays(endCursor, startCursor);
                  durationMonths = differenceInMonths(endCursor, startCursor);
                  durationWeeks = differenceInWeeks(endCursor, startCursor);
                  durationYears = differenceInYears(endCursor, startCursor); // Determine scale

                  if (durationDays > 31 && durationDays <= 180) {
                    scale = "week";
                    Array.from(Array(durationWeeks + 1).keys()).forEach(function (week) {
                      points.push({
                        date: addWeeks(startCursor, week)
                      });
                    });
                  } else if (durationDays > 180 && durationMonths <= 24) {
                    scale = "month";
                    Array.from(Array(durationMonths + 1).keys()).forEach(function (month) {
                      points.push({
                        date: addMonths(startCursor, month)
                      });
                    });
                  } else if (durationMonths > 24) {
                    scale = "year";
                    Array.from(Array(durationYears + 1).keys()).forEach(function (year) {
                      points.push({
                        date: addYears(startCursor, year)
                      });
                    });
                  } else {
                    scale = "day";
                    Array.from(Array(durationDays + 1).keys()).forEach(function (day) {
                      points.push({
                        date: addDays(startCursor, day)
                      });
                    });
                  } // Load data from API


                  _context2.next = 9;
                  return loadStats();

                case 9:
                  _yield$loadStats = _context2.sent;
                  grouped = _yield$loadStats.grouped;
                  js_date_format = _yield$loadStats.js_date_format;
                  // Extract points from grouped array
                  $$invalidate(3, points = points.map(function (point) {
                    // Get total from API response
                    var total = grouped[format$2(point.date, js_date_format)];
                    point.stats = {
                      total: total ? simpleRounding(total) : 0
                    }; // Find highest value

                    if (total > highest) {
                      $$invalidate(6, highest = total);
                    } // Sum up total


                    $$invalidate(5, weekTotal += point.stats.total); // Day total

                    if (isSameDay(point.date, startOfToday())) {
                      $$invalidate(4, todayTotal += point.stats.total);
                    }

                    return point;
                  })); // Set columns

                  document.documentElement.style.setProperty("--tm-stats-columns", points.length);
                  $$invalidate(2, loading = false);

                case 15:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function loadData() {
          return _ref4.apply(this, arguments);
        };
      }();

      var loadStats = /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          var start, end, statUrl, urlParts, queryString, queryStringParts, stats;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  start = format$2(startOfDay(startCursor), "yyyy-MM-dd HH:mm:ss");
                  end = format$2(endOfDay(endCursor), "yyyy-MM-dd HH:mm:ss");
                  statUrl = "".concat(statsApiUrl, "?start=").concat(start, "&end=").concat(end, "&group_by=").concat(scale, "&shared=").concat(includeShared ? 1 : 0); // Parse current URL for filters

                  urlParts = document.location.href.split("?");

                  if (urlParts.length > 1) {
                    queryString = urlParts[1];
                    queryStringParts = queryString.split("&");

                    queryStringParts.forEach(function (part) {
                      // Split query params
                      var partParts = part.split("=");

                      var _partParts = _slicedToArray(partParts, 2),
                          name = _partParts[0],
                          value = _partParts[1]; // Apply filters from query params


                      if (name === "status" && value) {
                        statUrl += "&status=".concat(value);
                      }

                      if (name === "tasks" && value && value.length) {
                        statUrl += "&tasks=".concat(value);
                      }

                      if (name === "projects" && value && value.length) {
                        statUrl += "&projects=".concat(value);
                      }

                      if (name === "clients" && value && value.length) {
                        statUrl += "&clients=".concat(value);
                      }

                      if (name === "userFilter" && value && value.length) {
                        statUrl += "&userFilter=".concat(value);
                      }
                    });
                  }

                  _context3.next = 7;
                  return fetch(statUrl, {
                    method: "GET",
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });

                case 7:
                  stats = _context3.sent;
                  _context3.next = 10;
                  return stats.json();

                case 10:
                  return _context3.abrupt("return", _context3.sent);

                case 11:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function loadStats() {
          return _ref5.apply(this, arguments);
        };
      }();

      var weekNavigation = function weekNavigation(mode) {
        if (mode === "reset") {
          $$invalidate(1, startCursor = startOfWeek(startOfToday(), localeOptions));
          endCursor = endOfWeek(startCursor, localeOptions);
        } else if (mode === "next") {
          $$invalidate(1, startCursor = addWeeks(startCursor, 1));
          endCursor = addWeeks(endCursor, 1);
        } else {
          $$invalidate(1, startCursor = subWeeks(startCursor, 1));
          endCursor = subWeeks(endCursor, 1);
        }

        updateWeek();
        loadData();
      };

      var formatDateForScale = function formatDateForScale(date, type) {
        if (type === "primary") {
          if (scale === "year") {
            return format$2(date, "yyyy", localeOptions);
          }

          if (scale === "month") {
            return format$2(date, "LLL", localeOptions);
          }

          if (scale === "week") {
            return "".concat(dist_10("timemanager", "Week"), " ").concat(format$2(date, "w", localeOptions));
          }

          return format$2(date, "iii", localeOptions);
        }

        if (type === "secondary") {
          if (scale === "year") {
            return "";
          }

          if (scale === "month") {
            return format$2(date, "yyyy", localeOptions);
          }

          if (scale === "week") {
            return "".concat(format$2(startOfWeek(date, localeOptions), "d.M.", localeOptions), " - ").concat(format$2(endOfWeek(date, localeOptions), "d.M.", localeOptions));
          }

          return format$2(date, "d.M.", localeOptions);
        }
      };

      var click_handler = function click_handler() {
        return weekNavigation('previous');
      };

      var click_handler_1 = function click_handler_1() {
        return weekNavigation('reset');
      };

      var click_handler_2 = function click_handler_2() {
        return weekNavigation('next');
      };

      $$self.$$set = function ($$props) {
        if ('statsApiUrl' in $$props) $$invalidate(12, statsApiUrl = $$props.statsApiUrl);
        if ('requestToken' in $$props) $$invalidate(13, requestToken = $$props.requestToken);
        if ('controls' in $$props) $$invalidate(0, controls = $$props.controls);
        if ('includeShared' in $$props) $$invalidate(14, includeShared = $$props.includeShared);
        if ('start' in $$props) $$invalidate(15, start = $$props.start);
        if ('end' in $$props) $$invalidate(16, end = $$props.end);
      };

      $$self.$$.update = function () {
        if ($$self.$$.dirty &
        /*start*/
        32768) {
          $$invalidate(1, startCursor = isDate$1(parse$2(start, dateFormat$1, new Date())) ? parse$2(start, dateFormat$1, new Date()) : startOfWeek(new Date(), localeOptions));
        }

        if ($$self.$$.dirty &
        /*end*/
        65536) {
          endCursor = isDate$1(parse$2(end, dateFormat$1, new Date())) ? parse$2(end, dateFormat$1, new Date()) : endOfWeek(new Date(), localeOptions);
        }
      };

      $$invalidate(2, loading = false);

      scale = "day";

      $$invalidate(3, points = []);

      $$invalidate(5, weekTotal = 0);

      $$invalidate(4, todayTotal = 0);

      $$invalidate(6, highest = 0);

      $$invalidate(7, currentWeek = null);

      return [controls, startCursor, loading, points, todayTotal, weekTotal, highest, currentWeek, simpleRounding, localeOptions, weekNavigation, formatDateForScale, statsApiUrl, requestToken, includeShared, start, end, click_handler, click_handler_1, click_handler_2];
    }

    var Statistics = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(Statistics, _SvelteComponent);

      var _super = _createSuper(Statistics);

      function Statistics(options) {
        var _this;

        _classCallCheck$1(this, Statistics);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$r, create_fragment$s, safe_not_equal, {
          statsApiUrl: 12,
          requestToken: 13,
          controls: 0,
          includeShared: 14,
          start: 15,
          end: 16
        });
        return _this;
      }

      return _createClass$1(Statistics);
    }(SvelteComponent);

    function create_fragment$r(ctx) {
      var div0;
      var t;
      var div1;
      var div1_class_value;
      var current;
      var default_slot_template =
      /*#slots*/
      ctx[2].default;
      var default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[1], null);
      return {
        c: function c() {
          div0 = element("div");
          t = space$1();
          div1 = element("div");
          if (default_slot) default_slot.c();
          attr(div0, "class", "oc-dialog-dim");
          attr(div1, "class", div1_class_value = "oc-dialog ".concat(
          /*loading*/
          ctx[0] ? 'icon-loading' : ''));
          set_style(div1, "position", "fixed");
        },
        m: function m(target, anchor) {
          insert(target, div0, anchor);
          insert(target, t, anchor);
          insert(target, div1, anchor);

          if (default_slot) {
            default_slot.m(div1, null);
          }

          current = true;
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (default_slot) {
            if (default_slot.p && (!current || dirty &
            /*$$scope*/
            2)) {
              update_slot_base(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[1], !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[1]) : get_slot_changes(default_slot_template,
              /*$$scope*/
              ctx[1], dirty, null), null);
            }
          }

          if (!current || dirty &
          /*loading*/
          1 && div1_class_value !== (div1_class_value = "oc-dialog ".concat(
          /*loading*/
          ctx[0] ? 'icon-loading' : ''))) {
            attr(div1, "class", div1_class_value);
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function o(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function d(detaching) {
          if (detaching) detach(div0);
          if (detaching) detach(t);
          if (detaching) detach(div1);
          if (default_slot) default_slot.d(detaching);
        }
      };
    }

    function instance$q($$self, $$props, $$invalidate) {
      var _$$props$$$slots = $$props.$$slots,
          slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
          $$scope = $$props.$$scope;
      var _$$props$loading = $$props.loading,
          loading = _$$props$loading === void 0 ? false : _$$props$loading;

      $$self.$$set = function ($$props) {
        if ('loading' in $$props) $$invalidate(0, loading = $$props.loading);
        if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
      };

      return [loading, $$scope, slots];
    }

    var Overlay = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(Overlay, _SvelteComponent);

      var _super = _createSuper(Overlay);

      function Overlay(options) {
        var _this;

        _classCallCheck$1(this, Overlay);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$q, create_fragment$r, safe_not_equal, {
          loading: 0
        });
        return _this;
      }

      return _createClass$1(Overlay);
    }(SvelteComponent);

    function create_if_block$i(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c: function c() {
          button = element("button");
          button.textContent = "".concat(dist_10('timemanager', 'Cancel'));
          attr(button, "type", "reset");
          attr(button, "class", "button");
        },
        m: function m(target, anchor) {
          insert(target, button, anchor);

          if (!mounted) {
            dispose = listen(button, "click", prevent_default(function () {
              if (is_function(
              /*onCancel*/
              ctx[3]))
                /*onCancel*/
                ctx[3].apply(this, arguments);
            }));
            mounted = true;
          }
        },
        p: function p(new_ctx, dirty) {
          ctx = new_ctx;
        },
        d: function d(detaching) {
          if (detaching) detach(button);
          mounted = false;
          dispose();
        }
      };
    }

    function create_fragment$q(ctx) {
      var div1;
      var h3;
      var t0;
      var t1;
      var form;
      var label0;
      var t2_value = dist_10('timemanager', 'Client name') + "";
      var t2;
      var t3;
      var br0;
      var t4;
      var input0;
      var t5;
      var label1;
      var t6_value = dist_10('timemanager', 'Note') + "";
      var t6;
      var t7;
      var br1;
      var t8;
      var textarea;
      var t9;
      var input1;
      var t10;
      var div0;
      var button;
      var t11;
      var t12;
      var mounted;
      var dispose;
      var if_block = !
      /*isServer*/
      ctx[2] && create_if_block$i(ctx);
      return {
        c: function c() {
          div1 = element("div");
          h3 = element("h3");
          t0 = text(
          /*clientEditorCaption*/
          ctx[5]);
          t1 = space$1();
          form = element("form");
          label0 = element("label");
          t2 = text(t2_value);
          t3 = space$1();
          br0 = element("br");
          t4 = space$1();
          input0 = element("input");
          t5 = space$1();
          label1 = element("label");
          t6 = text(t6_value);
          t7 = space$1();
          br1 = element("br");
          t8 = space$1();
          textarea = element("textarea");
          t9 = space$1();
          input1 = element("input");
          t10 = space$1();
          div0 = element("div");
          button = element("button");
          t11 = text(
          /*clientEditorButtonCaption*/
          ctx[4]);
          t12 = space$1();
          if (if_block) if_block.c();
          input0.autofocus = true;
          attr(input0, "type", "text");
          set_style(input0, "width", "100%");
          attr(input0, "class", "input-wide");
          attr(input0, "name", "name");
          attr(input0, "placeholder", dist_10('timemanager', 'Example Corp.'));
          input0.required = true;
          attr(label0, "class", "space-top");
          set_style(textarea, "width", "100%");
          attr(textarea, "class", "input-wide");
          attr(textarea, "name", "note");
          attr(textarea, "placeholder", "");
          textarea.value =
          /*note*/
          ctx[7];
          attr(label1, "class", "space-top");
          attr(input1, "type", "hidden");
          attr(input1, "name", "requesttoken");
          input1.value =
          /*requestToken*/
          ctx[1];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(form, "action",
          /*action*/
          ctx[0]);
          attr(form, "method", "post");
          attr(div1, "class", "inner tm_new-item");
        },
        m: function m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, h3);
          append(h3, t0);
          append(div1, t1);
          append(div1, form);
          append(form, label0);
          append(label0, t2);
          append(label0, t3);
          append(label0, br0);
          append(label0, t4);
          append(label0, input0);
          set_input_value(input0,
          /*name*/
          ctx[6]);
          append(form, t5);
          append(form, label1);
          append(label1, t6);
          append(label1, t7);
          append(label1, br1);
          append(label1, t8);
          append(label1, textarea);
          append(form, t9);
          append(form, input1);
          append(form, t10);
          append(form, div0);
          append(div0, button);
          append(button, t11);
          append(div0, t12);
          if (if_block) if_block.m(div0, null);
          input0.focus();

          if (!mounted) {
            dispose = [listen(input0, "input",
            /*input0_input_handler*/
            ctx[11]), listen(textarea, "input",
            /*input_handler*/
            ctx[12]), listen(form, "submit", prevent_default(
            /*submit*/
            ctx[8]))];
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (dirty &
          /*clientEditorCaption*/
          32) set_data(t0,
          /*clientEditorCaption*/
          ctx[5]);

          if (dirty &
          /*name*/
          64 && input0.value !==
          /*name*/
          ctx[6]) {
            set_input_value(input0,
            /*name*/
            ctx[6]);
          }

          if (dirty &
          /*note*/
          128) {
            textarea.value =
            /*note*/
            ctx[7];
          }

          if (dirty &
          /*requestToken*/
          2) {
            input1.value =
            /*requestToken*/
            ctx[1];
          }

          if (dirty &
          /*clientEditorButtonCaption*/
          16) set_data(t11,
          /*clientEditorButtonCaption*/
          ctx[4]);

          if (!
          /*isServer*/
          ctx[2]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$i(ctx);
              if_block.c();
              if_block.m(div0, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty &
          /*action*/
          1) {
            attr(form, "action",
            /*action*/
            ctx[0]);
          }
        },
        i: noop$1,
        o: noop$1,
        d: function d(detaching) {
          if (detaching) detach(div1);
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }

    function instance$p($$self, $$props, $$invalidate) {
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var isServer = $$props.isServer;
      var onCancel = $$props.onCancel;
      var onSubmit = $$props.onSubmit;
      var clientEditorButtonCaption = $$props.clientEditorButtonCaption;
      var clientEditorCaption = $$props.clientEditorCaption;
      var editClientData = $$props.editClientData;
      var name = editClientData ? editClientData.name : "";
      var note = editClientData ? editClientData.note : "";

      var submit = function submit() {
        onSubmit({
          name: name,
          note: note
        });
      };

      function input0_input_handler() {
        name = this.value;
        $$invalidate(6, name);
      }

      var input_handler = function input_handler(e) {
        return $$invalidate(7, note = e.target.value);
      };

      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('isServer' in $$props) $$invalidate(2, isServer = $$props.isServer);
        if ('onCancel' in $$props) $$invalidate(3, onCancel = $$props.onCancel);
        if ('onSubmit' in $$props) $$invalidate(9, onSubmit = $$props.onSubmit);
        if ('clientEditorButtonCaption' in $$props) $$invalidate(4, clientEditorButtonCaption = $$props.clientEditorButtonCaption);
        if ('clientEditorCaption' in $$props) $$invalidate(5, clientEditorCaption = $$props.clientEditorCaption);
        if ('editClientData' in $$props) $$invalidate(10, editClientData = $$props.editClientData);
      };

      return [action, requestToken, isServer, onCancel, clientEditorButtonCaption, clientEditorCaption, name, note, submit, onSubmit, editClientData, input0_input_handler, input_handler];
    }

    var ClientEditor = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(ClientEditor, _SvelteComponent);

      var _super = _createSuper(ClientEditor);

      function ClientEditor(options) {
        var _this;

        _classCallCheck$1(this, ClientEditor);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$p, create_fragment$q, safe_not_equal, {
          action: 0,
          requestToken: 1,
          isServer: 2,
          onCancel: 3,
          onSubmit: 9,
          clientEditorButtonCaption: 4,
          clientEditorCaption: 5,
          editClientData: 10
        });
        return _this;
      }

      return _createClass$1(ClientEditor);
    }(SvelteComponent);

    function create_if_block$h(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          loading:
          /*loading*/
          ctx[5],
          $$slots: {
            default: [create_default_slot$8]
          },
          $$scope: {
            ctx: ctx
          }
        }
      });
      return {
        c: function c() {
          create_component(overlay.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty &
          /*loading*/
          32) overlay_changes.loading =
          /*loading*/
          ctx[5];

          if (dirty &
          /*$$scope, action, requestToken, show, clientEditorButtonCaption, clientEditorCaption, editClientData*/
          4191) {
            overlay_changes.$$scope = {
              dirty: dirty,
              ctx: ctx
            };
          }

          overlay.$set(overlay_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    } // (56:1) <Overlay {loading}>


    function create_default_slot$8(ctx) {
      var clienteditor;
      var current;
      clienteditor = new ClientEditor({
        props: {
          action:
          /*action*/
          ctx[0],
          requestToken:
          /*requestToken*/
          ctx[1],
          onCancel:
          /*func*/
          ctx[11],
          onSubmit:
          /*save*/
          ctx[7],
          clientEditorButtonCaption:
          /*clientEditorButtonCaption*/
          ctx[2],
          clientEditorCaption:
          /*clientEditorCaption*/
          ctx[3],
          editClientData:
          /*editClientData*/
          ctx[4]
        }
      });
      return {
        c: function c() {
          create_component(clienteditor.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(clienteditor, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var clienteditor_changes = {};
          if (dirty &
          /*action*/
          1) clienteditor_changes.action =
          /*action*/
          ctx[0];
          if (dirty &
          /*requestToken*/
          2) clienteditor_changes.requestToken =
          /*requestToken*/
          ctx[1];
          if (dirty &
          /*show*/
          64) clienteditor_changes.onCancel =
          /*func*/
          ctx[11];
          if (dirty &
          /*clientEditorButtonCaption*/
          4) clienteditor_changes.clientEditorButtonCaption =
          /*clientEditorButtonCaption*/
          ctx[2];
          if (dirty &
          /*clientEditorCaption*/
          8) clienteditor_changes.clientEditorCaption =
          /*clientEditorCaption*/
          ctx[3];
          if (dirty &
          /*editClientData*/
          16) clienteditor_changes.editClientData =
          /*editClientData*/
          ctx[4];
          clienteditor.$set(clienteditor_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(clienteditor.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(clienteditor.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(clienteditor, detaching);
        }
      };
    }

    function create_fragment$p(ctx) {
      var a;
      var span;
      var t0;
      var t1;
      var if_block_anchor;
      var current;
      var mounted;
      var dispose;
      var if_block =
      /*show*/
      ctx[6] && create_if_block$h(ctx);
      return {
        c: function c() {
          a = element("a");
          span = element("span");
          t0 = text(
          /*clientEditorButtonCaption*/
          ctx[2]);
          t1 = space$1();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr(a, "href", "#/");
          attr(a, "class", "button primary new");
        },
        m: function m(target, anchor) {
          insert(target, a, anchor);
          append(a, span);
          append(span, t0);
          insert(target, t1, anchor);
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;

          if (!mounted) {
            dispose = listen(a, "click", prevent_default(
            /*click_handler*/
            ctx[10]));
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (!current || dirty &
          /*clientEditorButtonCaption*/
          4) set_data(t0,
          /*clientEditorButtonCaption*/
          ctx[2]);

          if (
          /*show*/
          ctx[6]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*show*/
              64) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$h(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function o(local) {
          transition_out(if_block);
          current = false;
        },
        d: function d(detaching) {
          if (detaching) detach(a);
          if (detaching) detach(t1);
          if (if_block) if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
          mounted = false;
          dispose();
        }
      };
    }

    function instance$o($$self, $$props, $$invalidate) {
      var show;
      var loading;
      var action = $$props.action;
      var editAction = $$props.editAction;
      var requestToken = $$props.requestToken;
      var clientEditorButtonCaption = $$props.clientEditorButtonCaption;
      var clientEditorCaption = $$props.clientEditorCaption;
      var clientUuid = $$props.clientUuid;
      var editClientData = $$props.editClientData;
      onMount(function () {
        Helpers.hideFallbacks("ClientEditor.svelte");
      });

      var save = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref4) {
          var name, note, client, response;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  name = _ref4.name, note = _ref4.note;
                  $$invalidate(5, loading = true);
                  _context.prev = 2;
                  client = {
                    name: name,
                    note: note
                  };

                  if (clientUuid) {
                    client = _objectSpread2(_objectSpread2({}, client), {}, {
                      uuid: clientUuid
                    });
                  }

                  _context.next = 7;
                  return fetch(clientUuid ? editAction : action, {
                    method: clientUuid ? "PATCH" : "POST",
                    body: JSON.stringify(client),
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });

                case 7:
                  response = _context.sent;

                  if (response && response.ok) {
                    $$invalidate(6, show = false);

                    if (clientUuid) {
                      document.querySelector(".app-timemanager [data-current-link]").click();
                    } else {
                      document.querySelector("#app-navigation a.active").click();
                    }
                  }

                  _context.next = 14;
                  break;

                case 11:
                  _context.prev = 11;
                  _context.t0 = _context["catch"](2);
                  console.error(_context.t0);

                case 14:
                  $$invalidate(5, loading = false);

                case 15:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[2, 11]]);
        }));

        return function save(_x) {
          return _ref3.apply(this, arguments);
        };
      }();

      var click_handler = function click_handler() {
        return $$invalidate(6, show = !show);
      };

      var func = function func() {
        return $$invalidate(6, show = false);
      };

      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('editAction' in $$props) $$invalidate(8, editAction = $$props.editAction);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientEditorButtonCaption' in $$props) $$invalidate(2, clientEditorButtonCaption = $$props.clientEditorButtonCaption);
        if ('clientEditorCaption' in $$props) $$invalidate(3, clientEditorCaption = $$props.clientEditorCaption);
        if ('clientUuid' in $$props) $$invalidate(9, clientUuid = $$props.clientUuid);
        if ('editClientData' in $$props) $$invalidate(4, editClientData = $$props.editClientData);
      };

      $$invalidate(6, show = false);

      $$invalidate(5, loading = false);

      return [action, requestToken, clientEditorButtonCaption, clientEditorCaption, editClientData, loading, show, save, editAction, clientUuid, click_handler, func];
    }

    var ClientEditorDialog = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(ClientEditorDialog, _SvelteComponent);

      var _super = _createSuper(ClientEditorDialog);

      function ClientEditorDialog(options) {
        var _this;

        _classCallCheck$1(this, ClientEditorDialog);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$o, create_fragment$p, safe_not_equal, {
          action: 0,
          editAction: 8,
          requestToken: 1,
          clientEditorButtonCaption: 2,
          clientEditorCaption: 3,
          clientUuid: 9,
          editClientData: 4
        });
        return _this;
      }

      return _createClass$1(ClientEditorDialog);
    }(SvelteComponent);

    function create_if_block$g(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c: function c() {
          button = element("button");
          button.textContent = "".concat(dist_10('timemanager', 'Cancel'));
          attr(button, "type", "reset");
          attr(button, "class", "button");
        },
        m: function m(target, anchor) {
          insert(target, button, anchor);

          if (!mounted) {
            dispose = listen(button, "click", prevent_default(function () {
              if (is_function(
              /*onCancel*/
              ctx[4]))
                /*onCancel*/
                ctx[4].apply(this, arguments);
            }));
            mounted = true;
          }
        },
        p: function p(new_ctx, dirty) {
          ctx = new_ctx;
        },
        d: function d(detaching) {
          if (detaching) detach(button);
          mounted = false;
          dispose();
        }
      };
    }

    function create_fragment$o(ctx) {
      var div1;
      var h3;
      var t0;
      var t1;
      var form;
      var label0;
      var t2_value = dist_10('timemanager', 'Project name') + "";
      var t2;
      var t3;
      var br0;
      var t4;
      var input0;
      var t5;
      var label1;
      var t6_value = dist_10('timemanager', 'For client') + "";
      var t6;
      var t7;
      var br1;
      var t8;
      var strong;
      var t9;
      var t10;
      var br2;
      var t11;
      var input1;
      var t12;
      var div0;
      var button;
      var t13;
      var t14;
      var mounted;
      var dispose;
      var if_block = !
      /*isServer*/
      ctx[3] && create_if_block$g(ctx);
      return {
        c: function c() {
          div1 = element("div");
          h3 = element("h3");
          t0 = text(
          /*projectEditorCaption*/
          ctx[6]);
          t1 = space$1();
          form = element("form");
          label0 = element("label");
          t2 = text(t2_value);
          t3 = space$1();
          br0 = element("br");
          t4 = space$1();
          input0 = element("input");
          t5 = space$1();
          label1 = element("label");
          t6 = text(t6_value);
          t7 = space$1();
          br1 = element("br");
          t8 = space$1();
          strong = element("strong");
          t9 = text(
          /*clientName*/
          ctx[2]);
          t10 = space$1();
          br2 = element("br");
          t11 = space$1();
          input1 = element("input");
          t12 = space$1();
          div0 = element("div");
          button = element("button");
          t13 = text(
          /*projectEditorButtonCaption*/
          ctx[5]);
          t14 = space$1();
          if (if_block) if_block.c();
          input0.autofocus = true;
          attr(input0, "type", "text");
          set_style(input0, "width", "100%");
          attr(input0, "class", "input-wide");
          attr(input0, "name", "name");
          attr(input0, "placeholder", dist_10('timemanager', 'A project name'));
          input0.required = true;
          attr(label0, "class", "space-top");
          attr(label1, "class", "space-top");
          attr(input1, "type", "hidden");
          attr(input1, "name", "requesttoken");
          input1.value =
          /*requestToken*/
          ctx[1];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(form, "action",
          /*action*/
          ctx[0]);
          attr(form, "method", "post");
          attr(div1, "class", "inner tm_new-item");
        },
        m: function m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, h3);
          append(h3, t0);
          append(div1, t1);
          append(div1, form);
          append(form, label0);
          append(label0, t2);
          append(label0, t3);
          append(label0, br0);
          append(label0, t4);
          append(label0, input0);
          set_input_value(input0,
          /*name*/
          ctx[7]);
          append(form, t5);
          append(form, label1);
          append(label1, t6);
          append(label1, t7);
          append(label1, br1);
          append(label1, t8);
          append(label1, strong);
          append(strong, t9);
          append(form, t10);
          append(form, br2);
          append(form, t11);
          append(form, input1);
          append(form, t12);
          append(form, div0);
          append(div0, button);
          append(button, t13);
          append(div0, t14);
          if (if_block) if_block.m(div0, null);
          input0.focus();

          if (!mounted) {
            dispose = [listen(input0, "input",
            /*input0_input_handler*/
            ctx[11]), listen(form, "submit", prevent_default(
            /*submit*/
            ctx[8]))];
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (dirty &
          /*projectEditorCaption*/
          64) set_data(t0,
          /*projectEditorCaption*/
          ctx[6]);

          if (dirty &
          /*name*/
          128 && input0.value !==
          /*name*/
          ctx[7]) {
            set_input_value(input0,
            /*name*/
            ctx[7]);
          }

          if (dirty &
          /*clientName*/
          4) set_data(t9,
          /*clientName*/
          ctx[2]);

          if (dirty &
          /*requestToken*/
          2) {
            input1.value =
            /*requestToken*/
            ctx[1];
          }

          if (dirty &
          /*projectEditorButtonCaption*/
          32) set_data(t13,
          /*projectEditorButtonCaption*/
          ctx[5]);

          if (!
          /*isServer*/
          ctx[3]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$g(ctx);
              if_block.c();
              if_block.m(div0, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty &
          /*action*/
          1) {
            attr(form, "action",
            /*action*/
            ctx[0]);
          }
        },
        i: noop$1,
        o: noop$1,
        d: function d(detaching) {
          if (detaching) detach(div1);
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }

    function instance$n($$self, $$props, $$invalidate) {
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var isServer = $$props.isServer;
      var onCancel = $$props.onCancel;
      var onSubmit = $$props.onSubmit;
      var projectEditorButtonCaption = $$props.projectEditorButtonCaption;
      var projectEditorCaption = $$props.projectEditorCaption;
      var editProjectData = $$props.editProjectData;
      var name = editProjectData ? editProjectData.name : "";

      var submit = function submit() {
        onSubmit({
          name: name
        });
      };

      function input0_input_handler() {
        name = this.value;
        $$invalidate(7, name);
      }

      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(2, clientName = $$props.clientName);
        if ('isServer' in $$props) $$invalidate(3, isServer = $$props.isServer);
        if ('onCancel' in $$props) $$invalidate(4, onCancel = $$props.onCancel);
        if ('onSubmit' in $$props) $$invalidate(9, onSubmit = $$props.onSubmit);
        if ('projectEditorButtonCaption' in $$props) $$invalidate(5, projectEditorButtonCaption = $$props.projectEditorButtonCaption);
        if ('projectEditorCaption' in $$props) $$invalidate(6, projectEditorCaption = $$props.projectEditorCaption);
        if ('editProjectData' in $$props) $$invalidate(10, editProjectData = $$props.editProjectData);
      };

      return [action, requestToken, clientName, isServer, onCancel, projectEditorButtonCaption, projectEditorCaption, name, submit, onSubmit, editProjectData, input0_input_handler];
    }

    var ProjectEditor = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(ProjectEditor, _SvelteComponent);

      var _super = _createSuper(ProjectEditor);

      function ProjectEditor(options) {
        var _this;

        _classCallCheck$1(this, ProjectEditor);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$n, create_fragment$o, safe_not_equal, {
          action: 0,
          requestToken: 1,
          clientName: 2,
          isServer: 3,
          onCancel: 4,
          onSubmit: 9,
          projectEditorButtonCaption: 5,
          projectEditorCaption: 6,
          editProjectData: 10
        });
        return _this;
      }

      return _createClass$1(ProjectEditor);
    }(SvelteComponent);

    function create_if_block$f(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          loading:
          /*loading*/
          ctx[7],
          $$slots: {
            default: [create_default_slot$7]
          },
          $$scope: {
            ctx: ctx
          }
        }
      });
      return {
        c: function c() {
          create_component(overlay.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty &
          /*loading*/
          128) overlay_changes.loading =
          /*loading*/
          ctx[7];

          if (dirty &
          /*$$scope, action, requestToken, show, clientName, isServer, projectEditorButtonCaption, projectEditorCaption, editProjectData*/
          16767) {
            overlay_changes.$$scope = {
              dirty: dirty,
              ctx: ctx
            };
          }

          overlay.$set(overlay_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    } // (54:1) <Overlay {loading}>


    function create_default_slot$7(ctx) {
      var projecteditor;
      var current;
      projecteditor = new ProjectEditor({
        props: {
          action:
          /*action*/
          ctx[0],
          requestToken:
          /*requestToken*/
          ctx[1],
          onCancel:
          /*func*/
          ctx[13],
          onSubmit:
          /*save*/
          ctx[9],
          clientName:
          /*clientName*/
          ctx[2],
          isServer:
          /*isServer*/
          ctx[3],
          projectEditorButtonCaption:
          /*projectEditorButtonCaption*/
          ctx[4],
          projectEditorCaption:
          /*projectEditorCaption*/
          ctx[5],
          editProjectData:
          /*editProjectData*/
          ctx[6]
        }
      });
      return {
        c: function c() {
          create_component(projecteditor.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(projecteditor, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var projecteditor_changes = {};
          if (dirty &
          /*action*/
          1) projecteditor_changes.action =
          /*action*/
          ctx[0];
          if (dirty &
          /*requestToken*/
          2) projecteditor_changes.requestToken =
          /*requestToken*/
          ctx[1];
          if (dirty &
          /*show*/
          256) projecteditor_changes.onCancel =
          /*func*/
          ctx[13];
          if (dirty &
          /*clientName*/
          4) projecteditor_changes.clientName =
          /*clientName*/
          ctx[2];
          if (dirty &
          /*isServer*/
          8) projecteditor_changes.isServer =
          /*isServer*/
          ctx[3];
          if (dirty &
          /*projectEditorButtonCaption*/
          16) projecteditor_changes.projectEditorButtonCaption =
          /*projectEditorButtonCaption*/
          ctx[4];
          if (dirty &
          /*projectEditorCaption*/
          32) projecteditor_changes.projectEditorCaption =
          /*projectEditorCaption*/
          ctx[5];
          if (dirty &
          /*editProjectData*/
          64) projecteditor_changes.editProjectData =
          /*editProjectData*/
          ctx[6];
          projecteditor.$set(projecteditor_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(projecteditor.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(projecteditor.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(projecteditor, detaching);
        }
      };
    }

    function create_fragment$n(ctx) {
      var a;
      var span;
      var t0;
      var t1;
      var if_block_anchor;
      var current;
      var mounted;
      var dispose;
      var if_block =
      /*show*/
      ctx[8] && create_if_block$f(ctx);
      return {
        c: function c() {
          a = element("a");
          span = element("span");
          t0 = text(
          /*projectEditorButtonCaption*/
          ctx[4]);
          t1 = space$1();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr(a, "href", "#/");
          attr(a, "class", "button primary new");
        },
        m: function m(target, anchor) {
          insert(target, a, anchor);
          append(a, span);
          append(span, t0);
          insert(target, t1, anchor);
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;

          if (!mounted) {
            dispose = listen(a, "click", prevent_default(
            /*click_handler*/
            ctx[12]));
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (!current || dirty &
          /*projectEditorButtonCaption*/
          16) set_data(t0,
          /*projectEditorButtonCaption*/
          ctx[4]);

          if (
          /*show*/
          ctx[8]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*show*/
              256) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$f(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function o(local) {
          transition_out(if_block);
          current = false;
        },
        d: function d(detaching) {
          if (detaching) detach(a);
          if (detaching) detach(t1);
          if (if_block) if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
          mounted = false;
          dispose();
        }
      };
    }

    function instance$m($$self, $$props, $$invalidate) {
      var show;
      var loading;
      var action = $$props.action;
      var editAction = $$props.editAction;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var isServer = $$props.isServer;
      var projectEditorButtonCaption = $$props.projectEditorButtonCaption;
      var projectEditorCaption = $$props.projectEditorCaption;
      var projectUuid = $$props.projectUuid;
      var editProjectData = $$props.editProjectData;
      onMount(function () {
        Helpers.hideFallbacks("ProjectEditor.svelte");
      });

      var save = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref4) {
          var name, project, response;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  name = _ref4.name;
                  $$invalidate(7, loading = true);
                  _context.prev = 2;
                  project = {
                    name: name
                  };

                  if (projectUuid) {
                    project = _objectSpread2(_objectSpread2({}, project), {}, {
                      uuid: projectUuid
                    });
                  }

                  _context.next = 7;
                  return fetch(projectUuid ? editAction : action, {
                    method: projectUuid ? "PATCH" : "POST",
                    body: JSON.stringify(project),
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });

                case 7:
                  response = _context.sent;

                  if (response && response.ok) {
                    $$invalidate(8, show = false);
                    document.querySelector(".app-timemanager [data-current-link]").click();
                  }

                  _context.next = 14;
                  break;

                case 11:
                  _context.prev = 11;
                  _context.t0 = _context["catch"](2);
                  console.error(_context.t0);

                case 14:
                  $$invalidate(7, loading = false);

                case 15:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[2, 11]]);
        }));

        return function save(_x) {
          return _ref3.apply(this, arguments);
        };
      }();

      var click_handler = function click_handler() {
        return $$invalidate(8, show = !show);
      };

      var func = function func() {
        return $$invalidate(8, show = false);
      };

      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('editAction' in $$props) $$invalidate(10, editAction = $$props.editAction);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(2, clientName = $$props.clientName);
        if ('isServer' in $$props) $$invalidate(3, isServer = $$props.isServer);
        if ('projectEditorButtonCaption' in $$props) $$invalidate(4, projectEditorButtonCaption = $$props.projectEditorButtonCaption);
        if ('projectEditorCaption' in $$props) $$invalidate(5, projectEditorCaption = $$props.projectEditorCaption);
        if ('projectUuid' in $$props) $$invalidate(11, projectUuid = $$props.projectUuid);
        if ('editProjectData' in $$props) $$invalidate(6, editProjectData = $$props.editProjectData);
      };

      $$invalidate(8, show = false);

      $$invalidate(7, loading = false);

      return [action, requestToken, clientName, isServer, projectEditorButtonCaption, projectEditorCaption, editProjectData, loading, show, save, editAction, projectUuid, click_handler, func];
    }

    var ProjectEditorDialog = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(ProjectEditorDialog, _SvelteComponent);

      var _super = _createSuper(ProjectEditorDialog);

      function ProjectEditorDialog(options) {
        var _this;

        _classCallCheck$1(this, ProjectEditorDialog);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$m, create_fragment$n, safe_not_equal, {
          action: 0,
          editAction: 10,
          requestToken: 1,
          clientName: 2,
          isServer: 3,
          projectEditorButtonCaption: 4,
          projectEditorCaption: 5,
          projectUuid: 11,
          editProjectData: 6
        });
        return _this;
      }

      return _createClass$1(ProjectEditorDialog);
    }(SvelteComponent);

    function create_if_block$e(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c: function c() {
          button = element("button");
          button.textContent = "".concat(dist_10('timemanager', 'Cancel'));
          attr(button, "type", "reset");
          attr(button, "class", "button");
        },
        m: function m(target, anchor) {
          insert(target, button, anchor);

          if (!mounted) {
            dispose = listen(button, "click", prevent_default(function () {
              if (is_function(
              /*onCancel*/
              ctx[5]))
                /*onCancel*/
                ctx[5].apply(this, arguments);
            }));
            mounted = true;
          }
        },
        p: function p(new_ctx, dirty) {
          ctx = new_ctx;
        },
        d: function d(detaching) {
          if (detaching) detach(button);
          mounted = false;
          dispose();
        }
      };
    }

    function create_fragment$m(ctx) {
      var div1;
      var h3;
      var t0;
      var t1;
      var form;
      var label0;
      var t2_value = dist_10('timemanager', 'Task name') + "";
      var t2;
      var t3;
      var br0;
      var t4;
      var input0;
      var t5;
      var label1;
      var t6_value = dist_10('timemanager', 'For project') + "";
      var t6;
      var t7;
      var br1;
      var t8;
      var strong0;
      var t9;
      var t10;
      var label2;
      var t11_value = dist_10('timemanager', 'For client') + "";
      var t11;
      var t12;
      var br2;
      var t13;
      var strong1;
      var t14;
      var t15;
      var br3;
      var t16;
      var input1;
      var t17;
      var div0;
      var button;
      var t18;
      var t19;
      var mounted;
      var dispose;
      var if_block = !
      /*isServer*/
      ctx[4] && create_if_block$e(ctx);
      return {
        c: function c() {
          div1 = element("div");
          h3 = element("h3");
          t0 = text(
          /*taskEditorCaption*/
          ctx[7]);
          t1 = space$1();
          form = element("form");
          label0 = element("label");
          t2 = text(t2_value);
          t3 = space$1();
          br0 = element("br");
          t4 = space$1();
          input0 = element("input");
          t5 = space$1();
          label1 = element("label");
          t6 = text(t6_value);
          t7 = space$1();
          br1 = element("br");
          t8 = space$1();
          strong0 = element("strong");
          t9 = text(
          /*projectName*/
          ctx[3]);
          t10 = space$1();
          label2 = element("label");
          t11 = text(t11_value);
          t12 = space$1();
          br2 = element("br");
          t13 = space$1();
          strong1 = element("strong");
          t14 = text(
          /*clientName*/
          ctx[2]);
          t15 = space$1();
          br3 = element("br");
          t16 = space$1();
          input1 = element("input");
          t17 = space$1();
          div0 = element("div");
          button = element("button");
          t18 = text(
          /*taskEditorButtonCaption*/
          ctx[6]);
          t19 = space$1();
          if (if_block) if_block.c();
          input0.autofocus = true;
          attr(input0, "type", "text");
          set_style(input0, "width", "100%");
          attr(input0, "class", "input-wide");
          attr(input0, "name", "name");
          attr(input0, "placeholder", dist_10('timemanager', 'A task name'));
          input0.required = true;
          attr(label0, "class", "space-top");
          attr(label1, "class", "space-top");
          attr(label2, "class", "space-top");
          attr(input1, "type", "hidden");
          attr(input1, "name", "requesttoken");
          input1.value =
          /*requestToken*/
          ctx[1];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(form, "action",
          /*action*/
          ctx[0]);
          attr(form, "method", "post");
          attr(div1, "class", "inner tm_new-item");
        },
        m: function m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, h3);
          append(h3, t0);
          append(div1, t1);
          append(div1, form);
          append(form, label0);
          append(label0, t2);
          append(label0, t3);
          append(label0, br0);
          append(label0, t4);
          append(label0, input0);
          set_input_value(input0,
          /*name*/
          ctx[8]);
          append(form, t5);
          append(form, label1);
          append(label1, t6);
          append(label1, t7);
          append(label1, br1);
          append(label1, t8);
          append(label1, strong0);
          append(strong0, t9);
          append(form, t10);
          append(form, label2);
          append(label2, t11);
          append(label2, t12);
          append(label2, br2);
          append(label2, t13);
          append(label2, strong1);
          append(strong1, t14);
          append(form, t15);
          append(form, br3);
          append(form, t16);
          append(form, input1);
          append(form, t17);
          append(form, div0);
          append(div0, button);
          append(button, t18);
          append(div0, t19);
          if (if_block) if_block.m(div0, null);
          input0.focus();

          if (!mounted) {
            dispose = [listen(input0, "input",
            /*input0_input_handler*/
            ctx[12]), listen(form, "submit", prevent_default(
            /*submit*/
            ctx[9]))];
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (dirty &
          /*taskEditorCaption*/
          128) set_data(t0,
          /*taskEditorCaption*/
          ctx[7]);

          if (dirty &
          /*name*/
          256 && input0.value !==
          /*name*/
          ctx[8]) {
            set_input_value(input0,
            /*name*/
            ctx[8]);
          }

          if (dirty &
          /*projectName*/
          8) set_data(t9,
          /*projectName*/
          ctx[3]);
          if (dirty &
          /*clientName*/
          4) set_data(t14,
          /*clientName*/
          ctx[2]);

          if (dirty &
          /*requestToken*/
          2) {
            input1.value =
            /*requestToken*/
            ctx[1];
          }

          if (dirty &
          /*taskEditorButtonCaption*/
          64) set_data(t18,
          /*taskEditorButtonCaption*/
          ctx[6]);

          if (!
          /*isServer*/
          ctx[4]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$e(ctx);
              if_block.c();
              if_block.m(div0, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty &
          /*action*/
          1) {
            attr(form, "action",
            /*action*/
            ctx[0]);
          }
        },
        i: noop$1,
        o: noop$1,
        d: function d(detaching) {
          if (detaching) detach(div1);
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }

    function instance$l($$self, $$props, $$invalidate) {
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var projectName = $$props.projectName;
      var isServer = $$props.isServer;
      var onCancel = $$props.onCancel;
      var onSubmit = $$props.onSubmit;
      var taskEditorButtonCaption = $$props.taskEditorButtonCaption;
      var taskEditorCaption = $$props.taskEditorCaption;
      var editTaskData = $$props.editTaskData;
      var name = editTaskData ? editTaskData.name : "";

      var submit = function submit() {
        onSubmit({
          name: name
        });
      };

      function input0_input_handler() {
        name = this.value;
        $$invalidate(8, name);
      }

      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(2, clientName = $$props.clientName);
        if ('projectName' in $$props) $$invalidate(3, projectName = $$props.projectName);
        if ('isServer' in $$props) $$invalidate(4, isServer = $$props.isServer);
        if ('onCancel' in $$props) $$invalidate(5, onCancel = $$props.onCancel);
        if ('onSubmit' in $$props) $$invalidate(10, onSubmit = $$props.onSubmit);
        if ('taskEditorButtonCaption' in $$props) $$invalidate(6, taskEditorButtonCaption = $$props.taskEditorButtonCaption);
        if ('taskEditorCaption' in $$props) $$invalidate(7, taskEditorCaption = $$props.taskEditorCaption);
        if ('editTaskData' in $$props) $$invalidate(11, editTaskData = $$props.editTaskData);
      };

      return [action, requestToken, clientName, projectName, isServer, onCancel, taskEditorButtonCaption, taskEditorCaption, name, submit, onSubmit, editTaskData, input0_input_handler];
    }

    var TaskEditor = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(TaskEditor, _SvelteComponent);

      var _super = _createSuper(TaskEditor);

      function TaskEditor(options) {
        var _this;

        _classCallCheck$1(this, TaskEditor);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$l, create_fragment$m, safe_not_equal, {
          action: 0,
          requestToken: 1,
          clientName: 2,
          projectName: 3,
          isServer: 4,
          onCancel: 5,
          onSubmit: 10,
          taskEditorButtonCaption: 6,
          taskEditorCaption: 7,
          editTaskData: 11
        });
        return _this;
      }

      return _createClass$1(TaskEditor);
    }(SvelteComponent);

    function create_if_block$d(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          loading:
          /*loading*/
          ctx[8],
          $$slots: {
            default: [create_default_slot$6]
          },
          $$scope: {
            ctx: ctx
          }
        }
      });
      return {
        c: function c() {
          create_component(overlay.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty &
          /*loading*/
          256) overlay_changes.loading =
          /*loading*/
          ctx[8];

          if (dirty &
          /*$$scope, action, requestToken, show, clientName, projectName, isServer, taskEditorButtonCaption, taskEditorCaption, editTaskData*/
          33535) {
            overlay_changes.$$scope = {
              dirty: dirty,
              ctx: ctx
            };
          }

          overlay.$set(overlay_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    } // (55:1) <Overlay {loading}>


    function create_default_slot$6(ctx) {
      var taskeditor;
      var current;
      taskeditor = new TaskEditor({
        props: {
          action:
          /*action*/
          ctx[0],
          requestToken:
          /*requestToken*/
          ctx[1],
          onCancel:
          /*func*/
          ctx[14],
          onSubmit:
          /*save*/
          ctx[10],
          clientName:
          /*clientName*/
          ctx[2],
          projectName:
          /*projectName*/
          ctx[3],
          isServer:
          /*isServer*/
          ctx[4],
          taskEditorButtonCaption:
          /*taskEditorButtonCaption*/
          ctx[5],
          taskEditorCaption:
          /*taskEditorCaption*/
          ctx[6],
          editTaskData:
          /*editTaskData*/
          ctx[7]
        }
      });
      return {
        c: function c() {
          create_component(taskeditor.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(taskeditor, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var taskeditor_changes = {};
          if (dirty &
          /*action*/
          1) taskeditor_changes.action =
          /*action*/
          ctx[0];
          if (dirty &
          /*requestToken*/
          2) taskeditor_changes.requestToken =
          /*requestToken*/
          ctx[1];
          if (dirty &
          /*show*/
          512) taskeditor_changes.onCancel =
          /*func*/
          ctx[14];
          if (dirty &
          /*clientName*/
          4) taskeditor_changes.clientName =
          /*clientName*/
          ctx[2];
          if (dirty &
          /*projectName*/
          8) taskeditor_changes.projectName =
          /*projectName*/
          ctx[3];
          if (dirty &
          /*isServer*/
          16) taskeditor_changes.isServer =
          /*isServer*/
          ctx[4];
          if (dirty &
          /*taskEditorButtonCaption*/
          32) taskeditor_changes.taskEditorButtonCaption =
          /*taskEditorButtonCaption*/
          ctx[5];
          if (dirty &
          /*taskEditorCaption*/
          64) taskeditor_changes.taskEditorCaption =
          /*taskEditorCaption*/
          ctx[6];
          if (dirty &
          /*editTaskData*/
          128) taskeditor_changes.editTaskData =
          /*editTaskData*/
          ctx[7];
          taskeditor.$set(taskeditor_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(taskeditor.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(taskeditor.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(taskeditor, detaching);
        }
      };
    }

    function create_fragment$l(ctx) {
      var a;
      var span;
      var t0;
      var t1;
      var if_block_anchor;
      var current;
      var mounted;
      var dispose;
      var if_block =
      /*show*/
      ctx[9] && create_if_block$d(ctx);
      return {
        c: function c() {
          a = element("a");
          span = element("span");
          t0 = text(
          /*taskEditorButtonCaption*/
          ctx[5]);
          t1 = space$1();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr(a, "href", "#/");
          attr(a, "class", "button primary new");
        },
        m: function m(target, anchor) {
          insert(target, a, anchor);
          append(a, span);
          append(span, t0);
          insert(target, t1, anchor);
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;

          if (!mounted) {
            dispose = listen(a, "click", prevent_default(
            /*click_handler*/
            ctx[13]));
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (!current || dirty &
          /*taskEditorButtonCaption*/
          32) set_data(t0,
          /*taskEditorButtonCaption*/
          ctx[5]);

          if (
          /*show*/
          ctx[9]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*show*/
              512) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$d(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function o(local) {
          transition_out(if_block);
          current = false;
        },
        d: function d(detaching) {
          if (detaching) detach(a);
          if (detaching) detach(t1);
          if (if_block) if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
          mounted = false;
          dispose();
        }
      };
    }

    function instance$k($$self, $$props, $$invalidate) {
      var show;
      var loading;
      var action = $$props.action;
      var editAction = $$props.editAction;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var projectName = $$props.projectName;
      var isServer = $$props.isServer;
      var taskEditorButtonCaption = $$props.taskEditorButtonCaption;
      var taskEditorCaption = $$props.taskEditorCaption;
      var taskUuid = $$props.taskUuid;
      var editTaskData = $$props.editTaskData;
      onMount(function () {
        Helpers.hideFallbacks("TaskEditor.svelte");
      });

      var save = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref4) {
          var name, task, response;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  name = _ref4.name;
                  $$invalidate(8, loading = true);
                  _context.prev = 2;
                  task = {
                    name: name
                  };

                  if (taskUuid) {
                    task = _objectSpread2(_objectSpread2({}, task), {}, {
                      uuid: taskUuid
                    });
                  }

                  _context.next = 7;
                  return fetch(taskUuid ? editAction : action, {
                    method: taskUuid ? "PATCH" : "POST",
                    body: JSON.stringify(task),
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });

                case 7:
                  response = _context.sent;

                  if (response && response.ok) {
                    $$invalidate(9, show = false);
                    document.querySelector(".app-timemanager [data-current-link]").click();
                  }

                  _context.next = 14;
                  break;

                case 11:
                  _context.prev = 11;
                  _context.t0 = _context["catch"](2);
                  console.error(_context.t0);

                case 14:
                  $$invalidate(8, loading = false);

                case 15:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[2, 11]]);
        }));

        return function save(_x) {
          return _ref3.apply(this, arguments);
        };
      }();

      var click_handler = function click_handler() {
        return $$invalidate(9, show = !show);
      };

      var func = function func() {
        return $$invalidate(9, show = false);
      };

      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('editAction' in $$props) $$invalidate(11, editAction = $$props.editAction);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(2, clientName = $$props.clientName);
        if ('projectName' in $$props) $$invalidate(3, projectName = $$props.projectName);
        if ('isServer' in $$props) $$invalidate(4, isServer = $$props.isServer);
        if ('taskEditorButtonCaption' in $$props) $$invalidate(5, taskEditorButtonCaption = $$props.taskEditorButtonCaption);
        if ('taskEditorCaption' in $$props) $$invalidate(6, taskEditorCaption = $$props.taskEditorCaption);
        if ('taskUuid' in $$props) $$invalidate(12, taskUuid = $$props.taskUuid);
        if ('editTaskData' in $$props) $$invalidate(7, editTaskData = $$props.editTaskData);
      };

      $$invalidate(9, show = false);

      $$invalidate(8, loading = false);

      return [action, requestToken, clientName, projectName, isServer, taskEditorButtonCaption, taskEditorCaption, editTaskData, loading, show, save, editAction, taskUuid, click_handler, func];
    }

    var TaskEditorDialog = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(TaskEditorDialog, _SvelteComponent);

      var _super = _createSuper(TaskEditorDialog);

      function TaskEditorDialog(options) {
        var _this;

        _classCallCheck$1(this, TaskEditorDialog);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$k, create_fragment$l, safe_not_equal, {
          action: 0,
          editAction: 11,
          requestToken: 1,
          clientName: 2,
          projectName: 3,
          isServer: 4,
          taskEditorButtonCaption: 5,
          taskEditorCaption: 6,
          taskUuid: 12,
          editTaskData: 7
        });
        return _this;
      }

      return _createClass$1(TaskEditorDialog);
    }(SvelteComponent);

    function create_if_block$c(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c: function c() {
          button = element("button");
          button.textContent = "".concat(dist_10('timemanager', 'Cancel'));
          attr(button, "type", "reset");
          attr(button, "class", "button");
        },
        m: function m(target, anchor) {
          insert(target, button, anchor);

          if (!mounted) {
            dispose = listen(button, "click", prevent_default(function () {
              if (is_function(
              /*onCancel*/
              ctx[6]))
                /*onCancel*/
                ctx[6].apply(this, arguments);
            }));
            mounted = true;
          }
        },
        p: function p(new_ctx, dirty) {
          ctx = new_ctx;
        },
        d: function d(detaching) {
          if (detaching) detach(button);
          mounted = false;
          dispose();
        }
      };
    }

    function create_fragment$k(ctx) {
      var div1;
      var h3;
      var t0;
      var t1;
      var form;
      var label0;
      var t2_value = dist_10('timemanager', 'Duration (in hrs.)') + "";
      var t2;
      var t3;
      var br0;
      var t4;
      var input0;
      var t5;
      var br1;
      var t6;
      var label1;
      var t7_value = dist_10('timemanager', 'Date') + "";
      var t7;
      var t8;
      var br2;
      var t9;
      var input1;
      var t10;
      var br3;
      var t11;
      var label2;
      var t12_value = dist_10('timemanager', 'Note') + "";
      var t12;
      var t13;
      var br4;
      var t14;
      var textarea;
      var t15;
      var br5;
      var t16;
      var label3;
      var t17_value = dist_10('timemanager', 'For task') + "";
      var t17;
      var t18;
      var br6;
      var t19;
      var strong0;
      var t20;
      var t21;
      var label4;
      var t22_value = dist_10('timemanager', 'For project') + "";
      var t22;
      var t23;
      var br7;
      var t24;
      var strong1;
      var t25;
      var t26;
      var label5;
      var t27_value = dist_10('timemanager', 'For client') + "";
      var t27;
      var t28;
      var br8;
      var t29;
      var strong2;
      var t30;
      var t31;
      var br9;
      var t32;
      var input2;
      var t33;
      var div0;
      var button;
      var t34;
      var t35;
      var mounted;
      var dispose;
      var if_block = !
      /*isServer*/
      ctx[5] && create_if_block$c(ctx);
      return {
        c: function c() {
          div1 = element("div");
          h3 = element("h3");
          t0 = text(
          /*timeEditorCaption*/
          ctx[7]);
          t1 = space$1();
          form = element("form");
          label0 = element("label");
          t2 = text(t2_value);
          t3 = space$1();
          br0 = element("br");
          t4 = space$1();
          input0 = element("input");
          t5 = space$1();
          br1 = element("br");
          t6 = space$1();
          label1 = element("label");
          t7 = text(t7_value);
          t8 = space$1();
          br2 = element("br");
          t9 = space$1();
          input1 = element("input");
          t10 = space$1();
          br3 = element("br");
          t11 = space$1();
          label2 = element("label");
          t12 = text(t12_value);
          t13 = space$1();
          br4 = element("br");
          t14 = space$1();
          textarea = element("textarea");
          t15 = space$1();
          br5 = element("br");
          t16 = space$1();
          label3 = element("label");
          t17 = text(t17_value);
          t18 = space$1();
          br6 = element("br");
          t19 = space$1();
          strong0 = element("strong");
          t20 = text(
          /*taskName*/
          ctx[4]);
          t21 = space$1();
          label4 = element("label");
          t22 = text(t22_value);
          t23 = space$1();
          br7 = element("br");
          t24 = space$1();
          strong1 = element("strong");
          t25 = text(
          /*projectName*/
          ctx[3]);
          t26 = space$1();
          label5 = element("label");
          t27 = text(t27_value);
          t28 = space$1();
          br8 = element("br");
          t29 = space$1();
          strong2 = element("strong");
          t30 = text(
          /*clientName*/
          ctx[2]);
          t31 = space$1();
          br9 = element("br");
          t32 = space$1();
          input2 = element("input");
          t33 = space$1();
          div0 = element("div");
          button = element("button");
          t34 = text(
          /*timeEditorButtonCaption*/
          ctx[8]);
          t35 = space$1();
          if (if_block) if_block.c();
          input0.autofocus = true;
          attr(input0, "type", "number");
          attr(input0, "name", "duration");
          attr(input0, "step", "0.01");
          attr(input0, "placeholder", "");
          set_style(input0, "width", "100%");
          attr(input0, "class", "input-wide");
          input0.required = true;
          attr(input1, "type", "date");
          attr(input1, "name", "date");
          set_style(input1, "width", "100%");
          attr(input1, "class", "input-wide");
          set_style(textarea, "width", "100%");
          attr(textarea, "class", "input-wide");
          attr(textarea, "name", "note");
          attr(textarea, "placeholder", dist_10('timemanager', 'Describe what you did...'));
          textarea.value =
          /*note*/
          ctx[11];
          attr(label3, "class", "space-top");
          attr(label4, "class", "space-top");
          attr(label5, "class", "space-top");
          attr(input2, "type", "hidden");
          attr(input2, "name", "requesttoken");
          input2.value =
          /*requestToken*/
          ctx[1];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(form, "action",
          /*action*/
          ctx[0]);
          attr(form, "method", "post");
          attr(div1, "class", "inner tm_new-item");
        },
        m: function m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, h3);
          append(h3, t0);
          append(div1, t1);
          append(div1, form);
          append(form, label0);
          append(label0, t2);
          append(label0, t3);
          append(label0, br0);
          append(label0, t4);
          append(label0, input0);
          set_input_value(input0,
          /*duration*/
          ctx[9]);
          append(form, t5);
          append(form, br1);
          append(form, t6);
          append(form, label1);
          append(label1, t7);
          append(label1, t8);
          append(label1, br2);
          append(label1, t9);
          append(label1, input1);
          set_input_value(input1,
          /*date*/
          ctx[10]);
          append(form, t10);
          append(form, br3);
          append(form, t11);
          append(form, label2);
          append(label2, t12);
          append(label2, t13);
          append(label2, br4);
          append(label2, t14);
          append(label2, textarea);
          append(form, t15);
          append(form, br5);
          append(form, t16);
          append(form, label3);
          append(label3, t17);
          append(label3, t18);
          append(label3, br6);
          append(label3, t19);
          append(label3, strong0);
          append(strong0, t20);
          append(form, t21);
          append(form, label4);
          append(label4, t22);
          append(label4, t23);
          append(label4, br7);
          append(label4, t24);
          append(label4, strong1);
          append(strong1, t25);
          append(form, t26);
          append(form, label5);
          append(label5, t27);
          append(label5, t28);
          append(label5, br8);
          append(label5, t29);
          append(label5, strong2);
          append(strong2, t30);
          append(form, t31);
          append(form, br9);
          append(form, t32);
          append(form, input2);
          append(form, t33);
          append(form, div0);
          append(div0, button);
          append(button, t34);
          append(div0, t35);
          if (if_block) if_block.m(div0, null);
          input0.focus();

          if (!mounted) {
            dispose = [listen(input0, "input",
            /*input0_input_handler*/
            ctx[16]), listen(input1, "input",
            /*input1_input_handler*/
            ctx[17]), listen(textarea, "input",
            /*input_handler*/
            ctx[18]), listen(form, "submit", prevent_default(
            /*submit*/
            ctx[12]))];
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (dirty &
          /*timeEditorCaption*/
          128) set_data(t0,
          /*timeEditorCaption*/
          ctx[7]);

          if (dirty &
          /*duration*/
          512 && to_number(input0.value) !==
          /*duration*/
          ctx[9]) {
            set_input_value(input0,
            /*duration*/
            ctx[9]);
          }

          if (dirty &
          /*date*/
          1024) {
            set_input_value(input1,
            /*date*/
            ctx[10]);
          }

          if (dirty &
          /*note*/
          2048) {
            textarea.value =
            /*note*/
            ctx[11];
          }

          if (dirty &
          /*taskName*/
          16) set_data(t20,
          /*taskName*/
          ctx[4]);
          if (dirty &
          /*projectName*/
          8) set_data(t25,
          /*projectName*/
          ctx[3]);
          if (dirty &
          /*clientName*/
          4) set_data(t30,
          /*clientName*/
          ctx[2]);

          if (dirty &
          /*requestToken*/
          2) {
            input2.value =
            /*requestToken*/
            ctx[1];
          }

          if (dirty &
          /*timeEditorButtonCaption*/
          256) set_data(t34,
          /*timeEditorButtonCaption*/
          ctx[8]);

          if (!
          /*isServer*/
          ctx[5]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$c(ctx);
              if_block.c();
              if_block.m(div0, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty &
          /*action*/
          1) {
            attr(form, "action",
            /*action*/
            ctx[0]);
          }
        },
        i: noop$1,
        o: noop$1,
        d: function d(detaching) {
          if (detaching) detach(div1);
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }

    function instance$j($$self, $$props, $$invalidate) {
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var projectName = $$props.projectName;
      var taskName = $$props.taskName;
      var initialDate = $$props.initialDate;
      var isServer = $$props.isServer;
      var onCancel = $$props.onCancel;
      var onSubmit = $$props.onSubmit;
      var _$$props$editTimeEntr = $$props.editTimeEntryData,
          editTimeEntryData = _$$props$editTimeEntr === void 0 ? {} : _$$props$editTimeEntr;
      var timeEditorCaption = $$props.timeEditorCaption;
      var timeEditorButtonCaption = $$props.timeEditorButtonCaption;
      var duration = editTimeEntryData.duration;
      var date = editTimeEntryData.date || initialDate;
      var note = editTimeEntryData.note || "";

      var submit = function submit() {
        onSubmit({
          duration: duration,
          date: date,
          note: note
        });
      };

      function input0_input_handler() {
        duration = to_number(this.value);
        $$invalidate(9, duration);
      }

      function input1_input_handler() {
        date = this.value;
        $$invalidate(10, date);
      }

      var input_handler = function input_handler(e) {
        return $$invalidate(11, note = e.target.value);
      };

      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(2, clientName = $$props.clientName);
        if ('projectName' in $$props) $$invalidate(3, projectName = $$props.projectName);
        if ('taskName' in $$props) $$invalidate(4, taskName = $$props.taskName);
        if ('initialDate' in $$props) $$invalidate(13, initialDate = $$props.initialDate);
        if ('isServer' in $$props) $$invalidate(5, isServer = $$props.isServer);
        if ('onCancel' in $$props) $$invalidate(6, onCancel = $$props.onCancel);
        if ('onSubmit' in $$props) $$invalidate(14, onSubmit = $$props.onSubmit);
        if ('editTimeEntryData' in $$props) $$invalidate(15, editTimeEntryData = $$props.editTimeEntryData);
        if ('timeEditorCaption' in $$props) $$invalidate(7, timeEditorCaption = $$props.timeEditorCaption);
        if ('timeEditorButtonCaption' in $$props) $$invalidate(8, timeEditorButtonCaption = $$props.timeEditorButtonCaption);
      };

      return [action, requestToken, clientName, projectName, taskName, isServer, onCancel, timeEditorCaption, timeEditorButtonCaption, duration, date, note, submit, initialDate, onSubmit, editTimeEntryData, input0_input_handler, input1_input_handler, input_handler];
    }

    var TimeEditor = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(TimeEditor, _SvelteComponent);

      var _super = _createSuper(TimeEditor);

      function TimeEditor(options) {
        var _this;

        _classCallCheck$1(this, TimeEditor);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$j, create_fragment$k, safe_not_equal, {
          action: 0,
          requestToken: 1,
          clientName: 2,
          projectName: 3,
          taskName: 4,
          initialDate: 13,
          isServer: 5,
          onCancel: 6,
          onSubmit: 14,
          editTimeEntryData: 15,
          timeEditorCaption: 7,
          timeEditorButtonCaption: 8
        });
        return _this;
      }

      return _createClass$1(TimeEditor);
    }(SvelteComponent);

    function create_else_block$3(ctx) {
      var div;
      var button;
      var t;
      var mounted;
      var dispose;
      return {
        c: function c() {
          div = element("div");
          button = element("button");
          t = text(
          /*timeEditorButtonCaption*/
          ctx[7]);
          attr(button, "type", "button");
          attr(button, "class", "btn");
          attr(div, "class", "tm_inline-hover-form");
        },
        m: function m(target, anchor) {
          insert(target, div, anchor);
          append(div, button);
          append(button, t);

          if (!mounted) {
            dispose = listen(button, "click", prevent_default(
            /*click_handler_1*/
            ctx[16]));
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if (dirty &
          /*timeEditorButtonCaption*/
          128) set_data(t,
          /*timeEditorButtonCaption*/
          ctx[7]);
        },
        d: function d(detaching) {
          if (detaching) detach(div);
          mounted = false;
          dispose();
        }
      };
    } // (53:0) {#if !timeUuid}


    function create_if_block_1$6(ctx) {
      var a;
      var span;
      var t;
      var mounted;
      var dispose;
      return {
        c: function c() {
          a = element("a");
          span = element("span");
          t = text(
          /*timeEditorButtonCaption*/
          ctx[7]);
          attr(a, "href", "#/");
          attr(a, "class", "button primary new");
        },
        m: function m(target, anchor) {
          insert(target, a, anchor);
          append(a, span);
          append(span, t);

          if (!mounted) {
            dispose = listen(a, "click", prevent_default(
            /*click_handler*/
            ctx[15]));
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if (dirty &
          /*timeEditorButtonCaption*/
          128) set_data(t,
          /*timeEditorButtonCaption*/
          ctx[7]);
        },
        d: function d(detaching) {
          if (detaching) detach(a);
          mounted = false;
          dispose();
        }
      };
    } // (62:0) {#if show}


    function create_if_block$b(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          loading:
          /*loading*/
          ctx[11],
          $$slots: {
            default: [create_default_slot$5]
          },
          $$scope: {
            ctx: ctx
          }
        }
      });
      return {
        c: function c() {
          create_component(overlay.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty &
          /*loading*/
          2048) overlay_changes.loading =
          /*loading*/
          ctx[11];

          if (dirty &
          /*$$scope, action, requestToken, show, clientName, projectName, taskName, initialDate, timeEditorButtonCaption, timeEditorCaption, editTimeEntryData, isServer*/
          268285) {
            overlay_changes.$$scope = {
              dirty: dirty,
              ctx: ctx
            };
          }

          overlay.$set(overlay_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    } // (63:1) <Overlay {loading}>


    function create_default_slot$5(ctx) {
      var timeeditor;
      var current;
      timeeditor = new TimeEditor({
        props: {
          action:
          /*action*/
          ctx[0],
          requestToken:
          /*requestToken*/
          ctx[2],
          onCancel:
          /*func*/
          ctx[17],
          onSubmit:
          /*save*/
          ctx[13],
          clientName:
          /*clientName*/
          ctx[3],
          projectName:
          /*projectName*/
          ctx[4],
          taskName:
          /*taskName*/
          ctx[5],
          initialDate:
          /*initialDate*/
          ctx[6],
          timeEditorButtonCaption:
          /*timeEditorButtonCaption*/
          ctx[7],
          timeEditorCaption:
          /*timeEditorCaption*/
          ctx[8],
          editTimeEntryData:
          /*editTimeEntryData*/
          ctx[9],
          isServer:
          /*isServer*/
          ctx[10]
        }
      });
      return {
        c: function c() {
          create_component(timeeditor.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(timeeditor, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var timeeditor_changes = {};
          if (dirty &
          /*action*/
          1) timeeditor_changes.action =
          /*action*/
          ctx[0];
          if (dirty &
          /*requestToken*/
          4) timeeditor_changes.requestToken =
          /*requestToken*/
          ctx[2];
          if (dirty &
          /*show*/
          4096) timeeditor_changes.onCancel =
          /*func*/
          ctx[17];
          if (dirty &
          /*clientName*/
          8) timeeditor_changes.clientName =
          /*clientName*/
          ctx[3];
          if (dirty &
          /*projectName*/
          16) timeeditor_changes.projectName =
          /*projectName*/
          ctx[4];
          if (dirty &
          /*taskName*/
          32) timeeditor_changes.taskName =
          /*taskName*/
          ctx[5];
          if (dirty &
          /*initialDate*/
          64) timeeditor_changes.initialDate =
          /*initialDate*/
          ctx[6];
          if (dirty &
          /*timeEditorButtonCaption*/
          128) timeeditor_changes.timeEditorButtonCaption =
          /*timeEditorButtonCaption*/
          ctx[7];
          if (dirty &
          /*timeEditorCaption*/
          256) timeeditor_changes.timeEditorCaption =
          /*timeEditorCaption*/
          ctx[8];
          if (dirty &
          /*editTimeEntryData*/
          512) timeeditor_changes.editTimeEntryData =
          /*editTimeEntryData*/
          ctx[9];
          if (dirty &
          /*isServer*/
          1024) timeeditor_changes.isServer =
          /*isServer*/
          ctx[10];
          timeeditor.$set(timeeditor_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(timeeditor.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(timeeditor.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(timeeditor, detaching);
        }
      };
    }

    function create_fragment$j(ctx) {
      var t;
      var if_block1_anchor;
      var current;

      function select_block_type(ctx, dirty) {
        if (!
        /*timeUuid*/
        ctx[1]) return create_if_block_1$6;
        return create_else_block$3;
      }

      var current_block_type = select_block_type(ctx);
      var if_block0 = current_block_type(ctx);
      var if_block1 =
      /*show*/
      ctx[12] && create_if_block$b(ctx);
      return {
        c: function c() {
          if_block0.c();
          t = space$1();
          if (if_block1) if_block1.c();
          if_block1_anchor = empty();
        },
        m: function m(target, anchor) {
          if_block0.m(target, anchor);
          insert(target, t, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert(target, if_block1_anchor, anchor);
          current = true;
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0.d(1);
            if_block0 = current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(t.parentNode, t);
            }
          }

          if (
          /*show*/
          ctx[12]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*show*/
              4096) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block$b(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, function () {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(if_block1);
          current = true;
        },
        o: function o(local) {
          transition_out(if_block1);
          current = false;
        },
        d: function d(detaching) {
          if_block0.d(detaching);
          if (detaching) detach(t);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach(if_block1_anchor);
        }
      };
    }

    function instance$i($$self, $$props, $$invalidate) {
      var show;
      var loading;
      var action = $$props.action;
      var editTimeEntryAction = $$props.editTimeEntryAction;
      var timeUuid = $$props.timeUuid;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var projectName = $$props.projectName;
      var taskName = $$props.taskName;
      var initialDate = $$props.initialDate;
      var timeEditorButtonCaption = $$props.timeEditorButtonCaption;
      var timeEditorCaption = $$props.timeEditorCaption;
      var editTimeEntryData = $$props.editTimeEntryData;
      var isServer = $$props.isServer;
      onMount(function () {
        Helpers.hideFallbacks("TimeEditor.svelte");
      });

      var save = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref4) {
          var duration, date, note, entry, response;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  duration = _ref4.duration, date = _ref4.date, note = _ref4.note;
                  $$invalidate(11, loading = true);
                  _context.prev = 2;
                  entry = {
                    duration: duration,
                    date: date,
                    note: note
                  };

                  if (timeUuid) {
                    entry.uuid = timeUuid;
                  }

                  _context.next = 7;
                  return fetch(timeUuid ? editTimeEntryAction : action, {
                    method: timeUuid ? "PATCH" : "POST",
                    body: JSON.stringify(entry),
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });

                case 7:
                  response = _context.sent;

                  if (response && response.ok) {
                    $$invalidate(12, show = false);
                    document.querySelector(".app-timemanager [data-current-link]").click();
                  }

                  _context.next = 14;
                  break;

                case 11:
                  _context.prev = 11;
                  _context.t0 = _context["catch"](2);
                  console.error(_context.t0);

                case 14:
                  $$invalidate(11, loading = false);

                case 15:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[2, 11]]);
        }));

        return function save(_x) {
          return _ref3.apply(this, arguments);
        };
      }();

      var click_handler = function click_handler() {
        return $$invalidate(12, show = !show);
      };

      var click_handler_1 = function click_handler_1() {
        return $$invalidate(12, show = !show);
      };

      var func = function func() {
        return $$invalidate(12, show = false);
      };

      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('editTimeEntryAction' in $$props) $$invalidate(14, editTimeEntryAction = $$props.editTimeEntryAction);
        if ('timeUuid' in $$props) $$invalidate(1, timeUuid = $$props.timeUuid);
        if ('requestToken' in $$props) $$invalidate(2, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(3, clientName = $$props.clientName);
        if ('projectName' in $$props) $$invalidate(4, projectName = $$props.projectName);
        if ('taskName' in $$props) $$invalidate(5, taskName = $$props.taskName);
        if ('initialDate' in $$props) $$invalidate(6, initialDate = $$props.initialDate);
        if ('timeEditorButtonCaption' in $$props) $$invalidate(7, timeEditorButtonCaption = $$props.timeEditorButtonCaption);
        if ('timeEditorCaption' in $$props) $$invalidate(8, timeEditorCaption = $$props.timeEditorCaption);
        if ('editTimeEntryData' in $$props) $$invalidate(9, editTimeEntryData = $$props.editTimeEntryData);
        if ('isServer' in $$props) $$invalidate(10, isServer = $$props.isServer);
      };

      $$invalidate(12, show = false);

      $$invalidate(11, loading = false);

      return [action, timeUuid, requestToken, clientName, projectName, taskName, initialDate, timeEditorButtonCaption, timeEditorCaption, editTimeEntryData, isServer, loading, show, save, editTimeEntryAction, click_handler, click_handler_1, func];
    }

    var TimeEditorDialog = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(TimeEditorDialog, _SvelteComponent);

      var _super = _createSuper(TimeEditorDialog);

      function TimeEditorDialog(options) {
        var _this;

        _classCallCheck$1(this, TimeEditorDialog);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$i, create_fragment$j, safe_not_equal, {
          action: 0,
          editTimeEntryAction: 14,
          timeUuid: 1,
          requestToken: 2,
          clientName: 3,
          projectName: 4,
          taskName: 5,
          initialDate: 6,
          timeEditorButtonCaption: 7,
          timeEditorCaption: 8,
          editTimeEntryData: 9,
          isServer: 10
        });
        return _this;
      }

      return _createClass$1(TimeEditorDialog);
    }(SvelteComponent);

    function create_if_block$a(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot$4]
          },
          $$scope: {
            ctx: ctx
          }
        }
      });
      return {
        c: function c() {
          create_component(overlay.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var overlay_changes = {};

          if (dirty &
          /*$$scope, deleteQuestion*/
          2056) {
            overlay_changes.$$scope = {
              dirty: dirty,
              ctx: ctx
            };
          }

          overlay.$set(overlay_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    } // (38:1) <Overlay>


    function create_default_slot$4(ctx) {
      var div1;
      var t0;
      var t1;
      var div0;
      var button0;
      var t3;
      var button1;
      var mounted;
      var dispose;
      return {
        c: function c() {
          div1 = element("div");
          t0 = text(
          /*deleteQuestion*/
          ctx[3]);
          t1 = space$1();
          div0 = element("div");
          button0 = element("button");
          button0.textContent = "".concat(dist_10('timemanager', 'Delete'));
          t3 = space$1();
          button1 = element("button");
          button1.textContent = "".concat(dist_10('timemanager', 'Cancel'));
          attr(button0, "class", "button primary");
          attr(button1, "class", "button");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(div1, "class", "inner tm_new-item");
        },
        m: function m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, t0);
          append(div1, t1);
          append(div1, div0);
          append(div0, button0);
          append(div0, t3);
          append(div0, button1);

          if (!mounted) {
            dispose = [listen(button0, "click", prevent_default(
            /*doDelete*/
            ctx[7])), listen(button1, "click", prevent_default(
            /*cancelDelete*/
            ctx[8]))];
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if (dirty &
          /*deleteQuestion*/
          8) set_data(t0,
          /*deleteQuestion*/
          ctx[3]);
        },
        d: function d(detaching) {
          if (detaching) detach(div1);
          mounted = false;
          run_all(dispose);
        }
      };
    }

    function create_fragment$i(ctx) {
      var t0;
      var form_1;
      var input0;
      var t1;
      var input1;
      var t2;
      var button;
      var t3;
      var current;
      var if_block =
      /*confirmation*/
      ctx[6] && create_if_block$a(ctx);
      return {
        c: function c() {
          if (if_block) if_block.c();
          t0 = space$1();
          form_1 = element("form");
          input0 = element("input");
          t1 = space$1();
          input1 = element("input");
          t2 = space$1();
          button = element("button");
          t3 = text(
          /*deleteButtonCaption*/
          ctx[2]);
          attr(input0, "type", "hidden");
          attr(input0, "name", "uuid");
          input0.value =
          /*deleteUuid*/
          ctx[1];
          attr(input1, "type", "hidden");
          attr(input1, "name", "requesttoken");
          input1.value =
          /*requestToken*/
          ctx[4];
          attr(button, "type", "submit");
          attr(button, "name", "action");
          button.value = "delete";
          attr(button, "class", "btn");
          attr(form_1, "action",
          /*deleteAction*/
          ctx[0]);
          attr(form_1, "method", "post");
        },
        m: function m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, t0, anchor);
          insert(target, form_1, anchor);
          append(form_1, input0);
          append(form_1, t1);
          append(form_1, input1);
          append(form_1, t2);
          append(form_1, button);
          append(button, t3);
          /*form_1_binding*/

          ctx[9](form_1);
          current = true;
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (
          /*confirmation*/
          ctx[6]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*confirmation*/
              64) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$a(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(t0.parentNode, t0);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }

          if (!current || dirty &
          /*deleteUuid*/
          2) {
            input0.value =
            /*deleteUuid*/
            ctx[1];
          }

          if (!current || dirty &
          /*requestToken*/
          16) {
            input1.value =
            /*requestToken*/
            ctx[4];
          }

          if (!current || dirty &
          /*deleteButtonCaption*/
          4) set_data(t3,
          /*deleteButtonCaption*/
          ctx[2]);

          if (!current || dirty &
          /*deleteAction*/
          1) {
            attr(form_1, "action",
            /*deleteAction*/
            ctx[0]);
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function o(local) {
          transition_out(if_block);
          current = false;
        },
        d: function d(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach(t0);
          if (detaching) detach(form_1);
          /*form_1_binding*/

          ctx[9](null);
        }
      };
    }

    function instance$h($$self, $$props, $$invalidate) {
      var confirmation;
      var deleteAction = $$props.deleteAction;
      var deleteUuid = $$props.deleteUuid;
      var deleteButtonCaption = $$props.deleteButtonCaption;
      var deleteQuestion = $$props.deleteQuestion;
      var requestToken = $$props.requestToken;
      var form;
      onMount(function () {
        Helpers.hideFallbacks("DeleteButton.svelte");
        form.addEventListener("submit", submit);
      });

      var submit = function submit(e) {
        e.preventDefault();
        $$invalidate(6, confirmation = true);
      };

      var doDelete = function doDelete() {
        $$invalidate(6, confirmation = false);
        form.removeEventListener("submit", submit);
        form.submit();
      };

      var cancelDelete = function cancelDelete() {
        $$invalidate(6, confirmation = false);
      };

      function form_1_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          form = $$value;
          $$invalidate(5, form);
        });
      }

      $$self.$$set = function ($$props) {
        if ('deleteAction' in $$props) $$invalidate(0, deleteAction = $$props.deleteAction);
        if ('deleteUuid' in $$props) $$invalidate(1, deleteUuid = $$props.deleteUuid);
        if ('deleteButtonCaption' in $$props) $$invalidate(2, deleteButtonCaption = $$props.deleteButtonCaption);
        if ('deleteQuestion' in $$props) $$invalidate(3, deleteQuestion = $$props.deleteQuestion);
        if ('requestToken' in $$props) $$invalidate(4, requestToken = $$props.requestToken);
      };

      $$invalidate(6, confirmation = false);

      return [deleteAction, deleteUuid, deleteButtonCaption, deleteQuestion, requestToken, form, confirmation, doDelete, cancelDelete, form_1_binding];
    }

    var DeleteButton = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(DeleteButton, _SvelteComponent);

      var _super = _createSuper(DeleteButton);

      function DeleteButton(options) {
        var _this;

        _classCallCheck$1(this, DeleteButton);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$h, create_fragment$i, safe_not_equal, {
          deleteAction: 0,
          deleteUuid: 1,
          deleteButtonCaption: 2,
          deleteQuestion: 3,
          requestToken: 4
        });
        return _this;
      }

      return _createClass$1(DeleteButton);
    }(SvelteComponent);

    var $filter$1 = arrayIteration$1.filter;



    var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$1('filter'); // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    // with adding support of @@species

    _export$1({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT$2
    }, {
      filter: function filter(callbackfn
      /* , thisArg */
      ) {
        return $filter$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });

    var $includes = arrayIncludes$1.includes;



     // FF99+ bug


    var BROKEN_ON_SPARSE = fails$1(function () {
      return !Array(1).includes();
    }); // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes

    _export$1({
      target: 'Array',
      proto: true,
      forced: BROKEN_ON_SPARSE
    }, {
      includes: function includes(el
      /* , fromIndex = 0 */
      ) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
      }
    }); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

    addToUnscopables$1('includes');

    var TypeError$1 = global_1.TypeError;

    var notARegexp = function (it) {
      if (isRegexp$1(it)) {
        throw TypeError$1("The method doesn't accept regular expressions");
      }

      return it;
    };

    var MATCH$2 = wellKnownSymbol$1('match');

    var correctIsRegexpLogic = function (METHOD_NAME) {
      var regexp = /./;

      try {
        '/./'[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH$2] = false;
          return '/./'[METHOD_NAME](regexp);
        } catch (error2) {
          /* empty */
        }
      }

      return false;
    };

    var stringIndexOf = functionUncurryThis(''.indexOf); // `String.prototype.includes` method
    // https://tc39.es/ecma262/#sec-string.prototype.includes

    _export$1({
      target: 'String',
      proto: true,
      forced: !correctIsRegexpLogic('includes')
    }, {
      includes: function includes(searchString
      /* , position = 0 */
      ) {
        return !!~stringIndexOf(toString_1(requireObjectCoercible$1(this)), toString_1(notARegexp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
      }
    });

    function isOutOfViewport (parent, container) {
      const parentBounding = parent.getBoundingClientRect();
      const boundingContainer = container.getBoundingClientRect();
      const out = {};
      out.top = parentBounding.top < 0;
      out.left = parentBounding.left < 0;
      out.bottom = parentBounding.bottom + boundingContainer.height > (window.innerHeight || document.documentElement.clientHeight);
      out.right = parentBounding.right > (window.innerWidth || document.documentElement.clientWidth);
      out.any = out.top || out.left || out.bottom || out.right;
      return out;
    }

    function add_css$5(target) {
      append_styles(target, "svelte-3e0qet", ".item.svelte-3e0qet{cursor:default;height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--itemPadding, 0 20px);color:var(--itemColor, inherit);text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.groupHeader.svelte-3e0qet{text-transform:var(--groupTitleTextTransform, uppercase)}.groupItem.svelte-3e0qet{padding-left:var(--groupItemPaddingLeft, 40px)}.item.svelte-3e0qet:active{background:var(--itemActiveBackground, #b9daff)}.item.active.svelte-3e0qet{background:var(--itemIsActiveBG, #007aff);color:var(--itemIsActiveColor, #fff)}.item.notSelectable.svelte-3e0qet{color:var(--itemIsNotSelectableColor, #999)}.item.first.svelte-3e0qet{border-radius:var(--itemFirstBorderRadius, 4px 4px 0 0)}.item.hover.svelte-3e0qet:not(.active){background:var(--itemHoverBG, #e7f2ff);color:var(--itemHoverColor, inherit)}");
    }

    function create_fragment$h(ctx) {
      let div;
      let raw_value =
      /*getOptionLabel*/
      ctx[0](
      /*item*/
      ctx[1],
      /*filterText*/
      ctx[2]) + "";
      let div_class_value;
      return {
        c() {
          div = element("div");
          attr(div, "class", div_class_value = "item " +
          /*itemClasses*/
          ctx[3] + " svelte-3e0qet");
        },

        m(target, anchor) {
          insert(target, div, anchor);
          div.innerHTML = raw_value;
        },

        p(ctx, [dirty]) {
          if (dirty &
          /*getOptionLabel, item, filterText*/
          7 && raw_value !== (raw_value =
          /*getOptionLabel*/
          ctx[0](
          /*item*/
          ctx[1],
          /*filterText*/
          ctx[2]) + "")) div.innerHTML = raw_value;

          if (dirty &
          /*itemClasses*/
          8 && div_class_value !== (div_class_value = "item " +
          /*itemClasses*/
          ctx[3] + " svelte-3e0qet")) {
            attr(div, "class", div_class_value);
          }
        },

        i: noop$1,
        o: noop$1,

        d(detaching) {
          if (detaching) detach(div);
        }

      };
    }

    function instance$g($$self, $$props, $$invalidate) {
      let {
        isActive = false
      } = $$props;
      let {
        isFirst = false
      } = $$props;
      let {
        isHover = false
      } = $$props;
      let {
        isSelectable = false
      } = $$props;
      let {
        getOptionLabel = undefined
      } = $$props;
      let {
        item = undefined
      } = $$props;
      let {
        filterText = ''
      } = $$props;
      let itemClasses = '';

      $$self.$$set = $$props => {
        if ('isActive' in $$props) $$invalidate(4, isActive = $$props.isActive);
        if ('isFirst' in $$props) $$invalidate(5, isFirst = $$props.isFirst);
        if ('isHover' in $$props) $$invalidate(6, isHover = $$props.isHover);
        if ('isSelectable' in $$props) $$invalidate(7, isSelectable = $$props.isSelectable);
        if ('getOptionLabel' in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
        if ('item' in $$props) $$invalidate(1, item = $$props.item);
        if ('filterText' in $$props) $$invalidate(2, filterText = $$props.filterText);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*isActive, isFirst, isHover, item, isSelectable*/
        242) {
          {
            const classes = [];

            if (isActive) {
              classes.push('active');
            }

            if (isFirst) {
              classes.push('first');
            }

            if (isHover) {
              classes.push('hover');
            }

            if (item.isGroupHeader) {
              classes.push('groupHeader');
            }

            if (item.isGroupItem) {
              classes.push('groupItem');
            }

            if (!isSelectable) {
              classes.push('notSelectable');
            }

            $$invalidate(3, itemClasses = classes.join(' '));
          }
        }
      };

      return [getOptionLabel, item, filterText, itemClasses, isActive, isFirst, isHover, isSelectable];
    }

    class Item$1 extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$g, create_fragment$h, safe_not_equal, {
          isActive: 4,
          isFirst: 5,
          isHover: 6,
          isSelectable: 7,
          getOptionLabel: 0,
          item: 1,
          filterText: 2
        }, add_css$5);
      }

    }

    function add_css$4(target) {
      append_styles(target, "svelte-1uyqfml", ".listContainer.svelte-1uyqfml{box-shadow:var(--listShadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));border-radius:var(--listBorderRadius, 4px);max-height:var(--listMaxHeight, 250px);overflow-y:auto;background:var(--listBackground, #fff);border:var(--listBorder, none);position:var(--listPosition, absolute);z-index:var(--listZIndex, 2);width:100%;left:var(--listLeft, 0);right:var(--listRight, 0)}.virtualList.svelte-1uyqfml{height:var(--virtualListHeight, 200px)}.listGroupTitle.svelte-1uyqfml{color:var(--groupTitleColor, #8f8f8f);cursor:default;font-size:var(--groupTitleFontSize, 12px);font-weight:var(--groupTitleFontWeight, 600);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--groupTitlePadding, 0 20px);text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap;text-transform:var(--groupTitleTextTransform, uppercase)}.empty.svelte-1uyqfml{text-align:var(--listEmptyTextAlign, center);padding:var(--listEmptyPadding, 20px 0);color:var(--listEmptyColor, #78848f)}");
    }

    function get_each_context$7(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[41] = list[i];
      child_ctx[42] = i;
      return child_ctx;
    } // (309:4) {:else}


    function create_else_block$2(ctx) {
      let each_1_anchor;
      let current;
      let each_value =
      /*items*/
      ctx[1];
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
      }

      const out = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      let each_1_else = null;

      if (!each_value.length) {
        each_1_else = create_else_block_2(ctx);
      }

      return {
        c() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();

          if (each_1_else) {
            each_1_else.c();
          }
        },

        m(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert(target, each_1_anchor, anchor);

          if (each_1_else) {
            each_1_else.m(target, anchor);
          }

          current = true;
        },

        p(ctx, dirty) {
          if (dirty[0] &
          /*getGroupHeaderLabel, items, handleHover, handleClick, Item, filterText, getOptionLabel, value, optionIdentifier, hoverItemIndex, noOptionsMessage, hideEmptyState*/
          114390) {
            each_value =
            /*items*/
            ctx[1];
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$7(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$7(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            group_outros();

            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }

            check_outros();

            if (!each_value.length && each_1_else) {
              each_1_else.p(ctx, dirty);
            } else if (!each_value.length) {
              each_1_else = create_else_block_2(ctx);
              each_1_else.c();
              each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
            } else if (each_1_else) {
              each_1_else.d(1);
              each_1_else = null;
            }
          }
        },

        i(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },

        o(local) {
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },

        d(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach(each_1_anchor);
          if (each_1_else) each_1_else.d(detaching);
        }

      };
    } // (286:4) {#if isVirtualList}


    function create_if_block$9(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      var switch_value =
      /*VirtualList*/
      ctx[3];

      function switch_props(ctx) {
        return {
          props: {
            items:
            /*items*/
            ctx[1],
            itemHeight:
            /*itemHeight*/
            ctx[8],
            $$slots: {
              default: [create_default_slot$3, ({
                item,
                i
              }) => ({
                41: item,
                42: i
              }), ({
                item,
                i
              }) => [0, (item ? 1024 : 0) | (i ? 2048 : 0)]]
            },
            $$scope: {
              ctx
            }
          }
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
      }

      return {
        c() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },

        m(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }

          insert(target, switch_instance_anchor, anchor);
          current = true;
        },

        p(ctx, dirty) {
          const switch_instance_changes = {};
          if (dirty[0] &
          /*items*/
          2) switch_instance_changes.items =
          /*items*/
          ctx[1];
          if (dirty[0] &
          /*itemHeight*/
          256) switch_instance_changes.itemHeight =
          /*itemHeight*/
          ctx[8];

          if (dirty[0] &
          /*Item, filterText, getOptionLabel, value, optionIdentifier, hoverItemIndex, items*/
          9814 | dirty[1] &
          /*$$scope, i, item*/
          11264) {
            switch_instance_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (switch_value !== (switch_value =
          /*VirtualList*/
          ctx[3])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },

        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },

        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(switch_instance_anchor);
          if (switch_instance) destroy_component(switch_instance, detaching);
        }

      };
    } // (331:8) {:else}


    function create_else_block_2(ctx) {
      let if_block_anchor;
      let if_block = !
      /*hideEmptyState*/
      ctx[11] && create_if_block_2$2(ctx);
      return {
        c() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },

        m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
        },

        p(ctx, dirty) {
          if (!
          /*hideEmptyState*/
          ctx[11]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_2$2(ctx);
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },

        d(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
        }

      };
    } // (332:12) {#if !hideEmptyState}


    function create_if_block_2$2(ctx) {
      let div;
      let t;
      return {
        c() {
          div = element("div");
          t = text(
          /*noOptionsMessage*/
          ctx[12]);
          attr(div, "class", "empty svelte-1uyqfml");
        },

        m(target, anchor) {
          insert(target, div, anchor);
          append(div, t);
        },

        p(ctx, dirty) {
          if (dirty[0] &
          /*noOptionsMessage*/
          4096) set_data(t,
          /*noOptionsMessage*/
          ctx[12]);
        },

        d(detaching) {
          if (detaching) detach(div);
        }

      };
    } // (313:12) {:else}


    function create_else_block_1(ctx) {
      let div;
      let switch_instance;
      let t;
      let current;
      let mounted;
      let dispose;
      var switch_value =
      /*Item*/
      ctx[4];

      function switch_props(ctx) {
        return {
          props: {
            item:
            /*item*/
            ctx[41],
            filterText:
            /*filterText*/
            ctx[13],
            getOptionLabel:
            /*getOptionLabel*/
            ctx[6],
            isFirst: isItemFirst(
            /*i*/
            ctx[42]),
            isActive: isItemActive(
            /*item*/
            ctx[41],
            /*value*/
            ctx[9],
            /*optionIdentifier*/
            ctx[10]),
            isHover: isItemHover(
            /*hoverItemIndex*/
            ctx[2],
            /*item*/
            ctx[41],
            /*i*/
            ctx[42],
            /*items*/
            ctx[1]),
            isSelectable: isItemSelectable(
            /*item*/
            ctx[41])
          }
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
      }

      function mouseover_handler_1() {
        return (
          /*mouseover_handler_1*/
          ctx[29](
          /*i*/
          ctx[42])
        );
      }

      function focus_handler_1() {
        return (
          /*focus_handler_1*/
          ctx[30](
          /*i*/
          ctx[42])
        );
      }

      function click_handler_1(...args) {
        return (
          /*click_handler_1*/
          ctx[31](
          /*item*/
          ctx[41],
          /*i*/
          ctx[42], ...args)
        );
      }

      return {
        c() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          t = space$1();
          attr(div, "class", "listItem");
          attr(div, "tabindex", "-1");
        },

        m(target, anchor) {
          insert(target, div, anchor);

          if (switch_instance) {
            mount_component(switch_instance, div, null);
          }

          append(div, t);
          current = true;

          if (!mounted) {
            dispose = [listen(div, "mouseover", mouseover_handler_1), listen(div, "focus", focus_handler_1), listen(div, "click", click_handler_1)];
            mounted = true;
          }
        },

        p(new_ctx, dirty) {
          ctx = new_ctx;
          const switch_instance_changes = {};
          if (dirty[0] &
          /*items*/
          2) switch_instance_changes.item =
          /*item*/
          ctx[41];
          if (dirty[0] &
          /*filterText*/
          8192) switch_instance_changes.filterText =
          /*filterText*/
          ctx[13];
          if (dirty[0] &
          /*getOptionLabel*/
          64) switch_instance_changes.getOptionLabel =
          /*getOptionLabel*/
          ctx[6];
          if (dirty[0] &
          /*items, value, optionIdentifier*/
          1538) switch_instance_changes.isActive = isItemActive(
          /*item*/
          ctx[41],
          /*value*/
          ctx[9],
          /*optionIdentifier*/
          ctx[10]);
          if (dirty[0] &
          /*hoverItemIndex, items*/
          6) switch_instance_changes.isHover = isItemHover(
          /*hoverItemIndex*/
          ctx[2],
          /*item*/
          ctx[41],
          /*i*/
          ctx[42],
          /*items*/
          ctx[1]);
          if (dirty[0] &
          /*items*/
          2) switch_instance_changes.isSelectable = isItemSelectable(
          /*item*/
          ctx[41]);

          if (switch_value !== (switch_value =
          /*Item*/
          ctx[4])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, t);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },

        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },

        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(div);
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          run_all(dispose);
        }

      };
    } // (311:12) {#if item.isGroupHeader && !item.isSelectable}


    function create_if_block_1$5(ctx) {
      let div;
      let t_value =
      /*getGroupHeaderLabel*/
      ctx[7](
      /*item*/
      ctx[41]) + "";
      let t;
      return {
        c() {
          div = element("div");
          t = text(t_value);
          attr(div, "class", "listGroupTitle svelte-1uyqfml");
        },

        m(target, anchor) {
          insert(target, div, anchor);
          append(div, t);
        },

        p(ctx, dirty) {
          if (dirty[0] &
          /*getGroupHeaderLabel, items*/
          130 && t_value !== (t_value =
          /*getGroupHeaderLabel*/
          ctx[7](
          /*item*/
          ctx[41]) + "")) set_data(t, t_value);
        },

        i: noop$1,
        o: noop$1,

        d(detaching) {
          if (detaching) detach(div);
        }

      };
    } // (310:8) {#each items as item, i}


    function create_each_block$7(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block_1$5, create_else_block_1];
      const if_blocks = [];

      function select_block_type_1(ctx, dirty) {
        if (
        /*item*/
        ctx[41].isGroupHeader && !
        /*item*/
        ctx[41].isSelectable) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_1(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },

        m(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
        },

        p(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_1(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }

            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },

        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },

        o(local) {
          transition_out(if_block);
          current = false;
        },

        d(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach(if_block_anchor);
        }

      };
    } // (287:8) <svelte:component             this={VirtualList}             {items}             {itemHeight}             let:item             let:i>


    function create_default_slot$3(ctx) {
      let div;
      let switch_instance;
      let current;
      let mounted;
      let dispose;
      var switch_value =
      /*Item*/
      ctx[4];

      function switch_props(ctx) {
        return {
          props: {
            item:
            /*item*/
            ctx[41],
            filterText:
            /*filterText*/
            ctx[13],
            getOptionLabel:
            /*getOptionLabel*/
            ctx[6],
            isFirst: isItemFirst(
            /*i*/
            ctx[42]),
            isActive: isItemActive(
            /*item*/
            ctx[41],
            /*value*/
            ctx[9],
            /*optionIdentifier*/
            ctx[10]),
            isHover: isItemHover(
            /*hoverItemIndex*/
            ctx[2],
            /*item*/
            ctx[41],
            /*i*/
            ctx[42],
            /*items*/
            ctx[1]),
            isSelectable: isItemSelectable(
            /*item*/
            ctx[41])
          }
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
      }

      function mouseover_handler() {
        return (
          /*mouseover_handler*/
          ctx[26](
          /*i*/
          ctx[42])
        );
      }

      function focus_handler() {
        return (
          /*focus_handler*/
          ctx[27](
          /*i*/
          ctx[42])
        );
      }

      function click_handler(...args) {
        return (
          /*click_handler*/
          ctx[28](
          /*item*/
          ctx[41],
          /*i*/
          ctx[42], ...args)
        );
      }

      return {
        c() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr(div, "class", "listItem");
        },

        m(target, anchor) {
          insert(target, div, anchor);

          if (switch_instance) {
            mount_component(switch_instance, div, null);
          }

          current = true;

          if (!mounted) {
            dispose = [listen(div, "mouseover", mouseover_handler), listen(div, "focus", focus_handler), listen(div, "click", click_handler)];
            mounted = true;
          }
        },

        p(new_ctx, dirty) {
          ctx = new_ctx;
          const switch_instance_changes = {};
          if (dirty[1] &
          /*item*/
          1024) switch_instance_changes.item =
          /*item*/
          ctx[41];
          if (dirty[0] &
          /*filterText*/
          8192) switch_instance_changes.filterText =
          /*filterText*/
          ctx[13];
          if (dirty[0] &
          /*getOptionLabel*/
          64) switch_instance_changes.getOptionLabel =
          /*getOptionLabel*/
          ctx[6];
          if (dirty[1] &
          /*i*/
          2048) switch_instance_changes.isFirst = isItemFirst(
          /*i*/
          ctx[42]);
          if (dirty[0] &
          /*value, optionIdentifier*/
          1536 | dirty[1] &
          /*item*/
          1024) switch_instance_changes.isActive = isItemActive(
          /*item*/
          ctx[41],
          /*value*/
          ctx[9],
          /*optionIdentifier*/
          ctx[10]);
          if (dirty[0] &
          /*hoverItemIndex, items*/
          6 | dirty[1] &
          /*item, i*/
          3072) switch_instance_changes.isHover = isItemHover(
          /*hoverItemIndex*/
          ctx[2],
          /*item*/
          ctx[41],
          /*i*/
          ctx[42],
          /*items*/
          ctx[1]);
          if (dirty[1] &
          /*item*/
          1024) switch_instance_changes.isSelectable = isItemSelectable(
          /*item*/
          ctx[41]);

          if (switch_value !== (switch_value =
          /*Item*/
          ctx[4])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, null);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },

        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },

        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(div);
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          run_all(dispose);
        }

      };
    }

    function create_fragment$g(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let current;
      let mounted;
      let dispose;
      const if_block_creators = [create_if_block$9, create_else_block$2];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (
        /*isVirtualList*/
        ctx[5]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      return {
        c() {
          div = element("div");
          if_block.c();
          attr(div, "class", "listContainer svelte-1uyqfml");
          attr(div, "style",
          /*listStyle*/
          ctx[14]);
          toggle_class(div, "virtualList",
          /*isVirtualList*/
          ctx[5]);
        },

        m(target, anchor) {
          insert(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          /*div_binding*/

          ctx[32](div);
          current = true;

          if (!mounted) {
            dispose = [listen(window, "keydown",
            /*handleKeyDown*/
            ctx[17]), listen(window, "resize",
            /*computePlacement*/
            ctx[18])];
            mounted = true;
          }
        },

        p(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }

            transition_in(if_block, 1);
            if_block.m(div, null);
          }

          if (!current || dirty[0] &
          /*listStyle*/
          16384) {
            attr(div, "style",
            /*listStyle*/
            ctx[14]);
          }

          if (dirty[0] &
          /*isVirtualList*/
          32) {
            toggle_class(div, "virtualList",
            /*isVirtualList*/
            ctx[5]);
          }
        },

        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },

        o(local) {
          transition_out(if_block);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(div);
          if_blocks[current_block_type_index].d();
          /*div_binding*/

          ctx[32](null);
          mounted = false;
          run_all(dispose);
        }

      };
    }

    function isItemActive(item, value, optionIdentifier) {
      return value && value[optionIdentifier] === item[optionIdentifier];
    }

    function isItemFirst(itemIndex) {
      return itemIndex === 0;
    }

    function isItemHover(hoverItemIndex, item, itemIndex, items) {
      return isItemSelectable(item) && (hoverItemIndex === itemIndex || items.length === 1);
    }

    function isItemSelectable(item) {
      return item.isGroupHeader && item.isSelectable || item.selectable || !item.hasOwnProperty('selectable'); // Default; if `selectable` was not specified, the object is selectable
    }

    function instance$f($$self, $$props, $$invalidate) {
      const dispatch = createEventDispatcher();
      let {
        container = undefined
      } = $$props;
      let {
        VirtualList = null
      } = $$props;
      let {
        Item = Item$1
      } = $$props;
      let {
        isVirtualList = false
      } = $$props;
      let {
        items = []
      } = $$props;
      let {
        labelIdentifier = 'label'
      } = $$props;
      let {
        getOptionLabel = (option, filterText) => {
          if (option) return option.isCreator ? `Create \"${filterText}\"` : option[labelIdentifier];
        }
      } = $$props;
      let {
        getGroupHeaderLabel = null
      } = $$props;
      let {
        itemHeight = 40
      } = $$props;
      let {
        hoverItemIndex = 0
      } = $$props;
      let {
        value = undefined
      } = $$props;
      let {
        optionIdentifier = 'value'
      } = $$props;
      let {
        hideEmptyState = false
      } = $$props;
      let {
        noOptionsMessage = 'No options'
      } = $$props;
      let {
        isMulti = false
      } = $$props;
      let {
        activeItemIndex = 0
      } = $$props;
      let {
        filterText = ''
      } = $$props;
      let {
        parent = null
      } = $$props;
      let {
        listPlacement = null
      } = $$props;
      let {
        listAutoWidth = null
      } = $$props;
      let {
        listOffset = 5
      } = $$props;
      let isScrollingTimer = 0;
      let isScrolling = false;
      let prev_items;
      onMount(() => {
        if (items.length > 0 && !isMulti && value) {
          const _hoverItemIndex = items.findIndex(item => item[optionIdentifier] === value[optionIdentifier]);

          if (_hoverItemIndex) {
            $$invalidate(2, hoverItemIndex = _hoverItemIndex);
          }
        }

        scrollToActiveItem('active');
        container.addEventListener('scroll', () => {
          clearTimeout(isScrollingTimer);
          isScrollingTimer = setTimeout(() => {
            isScrolling = false;
          }, 100);
        }, false);
      });
      beforeUpdate(() => {
        if (!items) $$invalidate(1, items = []);

        if (items !== prev_items && items.length > 0) {
          $$invalidate(2, hoverItemIndex = 0);
        }

        prev_items = items;
      });

      function handleSelect(item) {
        if (item.isCreator) return;
        dispatch('itemSelected', item);
      }

      function handleHover(i) {
        if (isScrolling) return;
        $$invalidate(2, hoverItemIndex = i);
      }

      function handleClick(args) {
        const {
          item,
          i,
          event
        } = args;
        event.stopPropagation();
        if (value && !isMulti && value[optionIdentifier] === item[optionIdentifier]) return closeList();

        if (item.isCreator) {
          dispatch('itemCreated', filterText);
        } else if (isItemSelectable(item)) {
          $$invalidate(19, activeItemIndex = i);
          $$invalidate(2, hoverItemIndex = i);
          handleSelect(item);
        }
      }

      function closeList() {
        dispatch('closeList');
      }

      async function updateHoverItem(increment) {
        if (isVirtualList) return;
        let isNonSelectableItem = true;

        while (isNonSelectableItem) {
          if (increment > 0 && hoverItemIndex === items.length - 1) {
            $$invalidate(2, hoverItemIndex = 0);
          } else if (increment < 0 && hoverItemIndex === 0) {
            $$invalidate(2, hoverItemIndex = items.length - 1);
          } else {
            $$invalidate(2, hoverItemIndex = hoverItemIndex + increment);
          }

          isNonSelectableItem = !isItemSelectable(items[hoverItemIndex]);
        }

        await tick();
        scrollToActiveItem('hover');
      }

      function handleKeyDown(e) {
        switch (e.key) {
          case 'Escape':
            e.preventDefault();
            closeList();
            break;

          case 'ArrowDown':
            e.preventDefault();
            items.length && updateHoverItem(1);
            break;

          case 'ArrowUp':
            e.preventDefault();
            items.length && updateHoverItem(-1);
            break;

          case 'Enter':
            e.preventDefault();
            if (items.length === 0) break;
            const hoverItem = items[hoverItemIndex];

            if (value && !isMulti && value[optionIdentifier] === hoverItem[optionIdentifier]) {
              closeList();
              break;
            }

            if (hoverItem.isCreator) {
              dispatch('itemCreated', filterText);
            } else {
              $$invalidate(19, activeItemIndex = hoverItemIndex);
              handleSelect(items[hoverItemIndex]);
            }

            break;

          case 'Tab':
            e.preventDefault();

            if (items.length === 0) {
              return closeList();
            }

            if (value && value[optionIdentifier] === items[hoverItemIndex][optionIdentifier]) return closeList();
            $$invalidate(19, activeItemIndex = hoverItemIndex);
            handleSelect(items[hoverItemIndex]);
            break;
        }
      }

      function scrollToActiveItem(className) {
        if (isVirtualList || !container) return;
        let offsetBounding;
        const focusedElemBounding = container.querySelector(`.listItem .${className}`);

        if (focusedElemBounding) {
          offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
        }

        $$invalidate(0, container.scrollTop -= offsetBounding, container);
      }

      let listStyle;

      function computePlacement() {
        const {
          height,
          width
        } = parent.getBoundingClientRect();
        $$invalidate(14, listStyle = '');
        $$invalidate(14, listStyle += `min-width:${width}px;width:${listAutoWidth ? 'auto' : '100%'};`);

        if (listPlacement === 'top' || listPlacement === 'auto' && isOutOfViewport(parent, container).bottom) {
          $$invalidate(14, listStyle += `bottom:${height + listOffset}px;`);
        } else {
          $$invalidate(14, listStyle += `top:${height + listOffset}px;`);
        }
      }

      const mouseover_handler = i => handleHover(i);

      const focus_handler = i => handleHover(i);

      const click_handler = (item, i, event) => handleClick({
        item,
        i,
        event
      });

      const mouseover_handler_1 = i => handleHover(i);

      const focus_handler_1 = i => handleHover(i);

      const click_handler_1 = (item, i, event) => handleClick({
        item,
        i,
        event
      });

      function div_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          container = $$value;
          $$invalidate(0, container);
        });
      }

      $$self.$$set = $$props => {
        if ('container' in $$props) $$invalidate(0, container = $$props.container);
        if ('VirtualList' in $$props) $$invalidate(3, VirtualList = $$props.VirtualList);
        if ('Item' in $$props) $$invalidate(4, Item = $$props.Item);
        if ('isVirtualList' in $$props) $$invalidate(5, isVirtualList = $$props.isVirtualList);
        if ('items' in $$props) $$invalidate(1, items = $$props.items);
        if ('labelIdentifier' in $$props) $$invalidate(20, labelIdentifier = $$props.labelIdentifier);
        if ('getOptionLabel' in $$props) $$invalidate(6, getOptionLabel = $$props.getOptionLabel);
        if ('getGroupHeaderLabel' in $$props) $$invalidate(7, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
        if ('itemHeight' in $$props) $$invalidate(8, itemHeight = $$props.itemHeight);
        if ('hoverItemIndex' in $$props) $$invalidate(2, hoverItemIndex = $$props.hoverItemIndex);
        if ('value' in $$props) $$invalidate(9, value = $$props.value);
        if ('optionIdentifier' in $$props) $$invalidate(10, optionIdentifier = $$props.optionIdentifier);
        if ('hideEmptyState' in $$props) $$invalidate(11, hideEmptyState = $$props.hideEmptyState);
        if ('noOptionsMessage' in $$props) $$invalidate(12, noOptionsMessage = $$props.noOptionsMessage);
        if ('isMulti' in $$props) $$invalidate(21, isMulti = $$props.isMulti);
        if ('activeItemIndex' in $$props) $$invalidate(19, activeItemIndex = $$props.activeItemIndex);
        if ('filterText' in $$props) $$invalidate(13, filterText = $$props.filterText);
        if ('parent' in $$props) $$invalidate(22, parent = $$props.parent);
        if ('listPlacement' in $$props) $$invalidate(23, listPlacement = $$props.listPlacement);
        if ('listAutoWidth' in $$props) $$invalidate(24, listAutoWidth = $$props.listAutoWidth);
        if ('listOffset' in $$props) $$invalidate(25, listOffset = $$props.listOffset);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] &
        /*parent, container*/
        4194305) {
          {
            if (parent && container) computePlacement();
          }
        }
      };

      return [container, items, hoverItemIndex, VirtualList, Item, isVirtualList, getOptionLabel, getGroupHeaderLabel, itemHeight, value, optionIdentifier, hideEmptyState, noOptionsMessage, filterText, listStyle, handleHover, handleClick, handleKeyDown, computePlacement, activeItemIndex, labelIdentifier, isMulti, parent, listPlacement, listAutoWidth, listOffset, mouseover_handler, focus_handler, click_handler, mouseover_handler_1, focus_handler_1, click_handler_1, div_binding];
    }

    class List extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$f, create_fragment$g, safe_not_equal, {
          container: 0,
          VirtualList: 3,
          Item: 4,
          isVirtualList: 5,
          items: 1,
          labelIdentifier: 20,
          getOptionLabel: 6,
          getGroupHeaderLabel: 7,
          itemHeight: 8,
          hoverItemIndex: 2,
          value: 9,
          optionIdentifier: 10,
          hideEmptyState: 11,
          noOptionsMessage: 12,
          isMulti: 21,
          activeItemIndex: 19,
          filterText: 13,
          parent: 22,
          listPlacement: 23,
          listAutoWidth: 24,
          listOffset: 25
        }, add_css$4, [-1, -1]);
      }

    }

    function add_css$3(target) {
      append_styles(target, "svelte-pu1q1n", ".selection.svelte-pu1q1n{text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap}");
    }

    function create_fragment$f(ctx) {
      let div;
      let raw_value =
      /*getSelectionLabel*/
      ctx[0](
      /*item*/
      ctx[1]) + "";
      return {
        c() {
          div = element("div");
          attr(div, "class", "selection svelte-pu1q1n");
        },

        m(target, anchor) {
          insert(target, div, anchor);
          div.innerHTML = raw_value;
        },

        p(ctx, [dirty]) {
          if (dirty &
          /*getSelectionLabel, item*/
          3 && raw_value !== (raw_value =
          /*getSelectionLabel*/
          ctx[0](
          /*item*/
          ctx[1]) + "")) div.innerHTML = raw_value;
        },

        i: noop$1,
        o: noop$1,

        d(detaching) {
          if (detaching) detach(div);
        }

      };
    }

    function instance$e($$self, $$props, $$invalidate) {
      let {
        getSelectionLabel = undefined
      } = $$props;
      let {
        item = undefined
      } = $$props;

      $$self.$$set = $$props => {
        if ('getSelectionLabel' in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
        if ('item' in $$props) $$invalidate(1, item = $$props.item);
      };

      return [getSelectionLabel, item];
    }

    class Selection extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$e, create_fragment$f, safe_not_equal, {
          getSelectionLabel: 0,
          item: 1
        }, add_css$3);
      }

    }

    function add_css$2(target) {
      append_styles(target, "svelte-liu9pa", ".multiSelectItem.svelte-liu9pa.svelte-liu9pa{background:var(--multiItemBG, #ebedef);margin:var(--multiItemMargin, 5px 5px 0 0);border-radius:var(--multiItemBorderRadius, 16px);height:var(--multiItemHeight, 32px);line-height:var(--multiItemHeight, 32px);display:flex;cursor:default;padding:var(--multiItemPadding, 0 10px 0 15px);max-width:100%}.multiSelectItem_label.svelte-liu9pa.svelte-liu9pa{margin:var(--multiLabelMargin, 0 5px 0 0);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.multiSelectItem.svelte-liu9pa.svelte-liu9pa:hover,.multiSelectItem.active.svelte-liu9pa.svelte-liu9pa{background-color:var(--multiItemActiveBG, #006fff);color:var(--multiItemActiveColor, #fff)}.multiSelectItem.disabled.svelte-liu9pa.svelte-liu9pa:hover{background:var(--multiItemDisabledHoverBg, #ebedef);color:var(--multiItemDisabledHoverColor, #c1c6cc)}.multiSelectItem_clear.svelte-liu9pa.svelte-liu9pa{border-radius:var(--multiClearRadius, 50%);background:var(--multiClearBG, #52616f);min-width:var(--multiClearWidth, 16px);max-width:var(--multiClearWidth, 16px);height:var(--multiClearHeight, 16px);position:relative;top:var(--multiClearTop, 8px);text-align:var(--multiClearTextAlign, center);padding:var(--multiClearPadding, 1px)}.multiSelectItem_clear.svelte-liu9pa.svelte-liu9pa:hover,.active.svelte-liu9pa .multiSelectItem_clear.svelte-liu9pa{background:var(--multiClearHoverBG, #fff)}.multiSelectItem_clear.svelte-liu9pa:hover svg.svelte-liu9pa,.active.svelte-liu9pa .multiSelectItem_clear svg.svelte-liu9pa{fill:var(--multiClearHoverFill, #006fff)}.multiSelectItem_clear.svelte-liu9pa svg.svelte-liu9pa{fill:var(--multiClearFill, #ebedef);vertical-align:top}");
    }

    function get_each_context$6(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i];
      child_ctx[11] = i;
      return child_ctx;
    } // (87:8) {#if !isDisabled && !multiFullItemClearable}


    function create_if_block$8(ctx) {
      let div;
      let mounted;
      let dispose;

      function click_handler(...args) {
        return (
          /*click_handler*/
          ctx[6](
          /*i*/
          ctx[11], ...args)
        );
      }

      return {
        c() {
          div = element("div");
          div.innerHTML = `<svg width="100%" height="100%" viewBox="-2 -2 50 50" focusable="false" aria-hidden="true" role="presentation" class="svelte-liu9pa"><path d="M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"></path></svg>`;
          attr(div, "class", "multiSelectItem_clear svelte-liu9pa");
        },

        m(target, anchor) {
          insert(target, div, anchor);

          if (!mounted) {
            dispose = listen(div, "click", click_handler);
            mounted = true;
          }
        },

        p(new_ctx, dirty) {
          ctx = new_ctx;
        },

        d(detaching) {
          if (detaching) detach(div);
          mounted = false;
          dispose();
        }

      };
    } // (77:0) {#each value as item, i}


    function create_each_block$6(ctx) {
      let div1;
      let div0;
      let raw_value =
      /*getSelectionLabel*/
      ctx[4](
      /*item*/
      ctx[9]) + "";
      let t0;
      let t1;
      let div1_class_value;
      let mounted;
      let dispose;
      let if_block = !
      /*isDisabled*/
      ctx[2] && !
      /*multiFullItemClearable*/
      ctx[3] && create_if_block$8(ctx);

      function click_handler_1(...args) {
        return (
          /*click_handler_1*/
          ctx[7](
          /*i*/
          ctx[11], ...args)
        );
      }

      return {
        c() {
          div1 = element("div");
          div0 = element("div");
          t0 = space$1();
          if (if_block) if_block.c();
          t1 = space$1();
          attr(div0, "class", "multiSelectItem_label svelte-liu9pa");
          attr(div1, "class", div1_class_value = "multiSelectItem " + (
          /*activeValue*/
          ctx[1] ===
          /*i*/
          ctx[11] ? 'active' : '') + " " + (
          /*isDisabled*/
          ctx[2] ? 'disabled' : '') + " svelte-liu9pa");
        },

        m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, div0);
          div0.innerHTML = raw_value;
          append(div1, t0);
          if (if_block) if_block.m(div1, null);
          append(div1, t1);

          if (!mounted) {
            dispose = listen(div1, "click", click_handler_1);
            mounted = true;
          }
        },

        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty &
          /*getSelectionLabel, value*/
          17 && raw_value !== (raw_value =
          /*getSelectionLabel*/
          ctx[4](
          /*item*/
          ctx[9]) + "")) div0.innerHTML = raw_value;

          if (!
          /*isDisabled*/
          ctx[2] && !
          /*multiFullItemClearable*/
          ctx[3]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$8(ctx);
              if_block.c();
              if_block.m(div1, t1);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty &
          /*activeValue, isDisabled*/
          6 && div1_class_value !== (div1_class_value = "multiSelectItem " + (
          /*activeValue*/
          ctx[1] ===
          /*i*/
          ctx[11] ? 'active' : '') + " " + (
          /*isDisabled*/
          ctx[2] ? 'disabled' : '') + " svelte-liu9pa")) {
            attr(div1, "class", div1_class_value);
          }
        },

        d(detaching) {
          if (detaching) detach(div1);
          if (if_block) if_block.d();
          mounted = false;
          dispose();
        }

      };
    }

    function create_fragment$e(ctx) {
      let each_1_anchor;
      let each_value =
      /*value*/
      ctx[0];
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
      }

      return {
        c() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },

        m(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert(target, each_1_anchor, anchor);
        },

        p(ctx, [dirty]) {
          if (dirty &
          /*activeValue, isDisabled, multiFullItemClearable, handleClear, getSelectionLabel, value*/
          63) {
            each_value =
            /*value*/
            ctx[0];
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$6(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$6(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },

        i: noop$1,
        o: noop$1,

        d(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach(each_1_anchor);
        }

      };
    }

    function instance$d($$self, $$props, $$invalidate) {
      const dispatch = createEventDispatcher();
      let {
        value = []
      } = $$props;
      let {
        activeValue = undefined
      } = $$props;
      let {
        isDisabled = false
      } = $$props;
      let {
        multiFullItemClearable = false
      } = $$props;
      let {
        getSelectionLabel = undefined
      } = $$props;

      function handleClear(i, event) {
        event.stopPropagation();
        dispatch('multiItemClear', {
          i
        });
      }

      const click_handler = (i, event) => handleClear(i, event);

      const click_handler_1 = (i, event) => multiFullItemClearable ? handleClear(i, event) : {};

      $$self.$$set = $$props => {
        if ('value' in $$props) $$invalidate(0, value = $$props.value);
        if ('activeValue' in $$props) $$invalidate(1, activeValue = $$props.activeValue);
        if ('isDisabled' in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
        if ('multiFullItemClearable' in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
        if ('getSelectionLabel' in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
      };

      return [value, activeValue, isDisabled, multiFullItemClearable, getSelectionLabel, handleClear, click_handler, click_handler_1];
    }

    class MultiSelection extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$d, create_fragment$e, safe_not_equal, {
          value: 0,
          activeValue: 1,
          isDisabled: 2,
          multiFullItemClearable: 3,
          getSelectionLabel: 4
        }, add_css$2);
      }

    }

    function add_css$1(target) {
      append_styles(target, "svelte-g2cagw", "svelte-virtual-list-viewport.svelte-g2cagw{position:relative;overflow-y:auto;-webkit-overflow-scrolling:touch;display:block}svelte-virtual-list-contents.svelte-g2cagw,svelte-virtual-list-row.svelte-g2cagw{display:block}svelte-virtual-list-row.svelte-g2cagw{overflow:hidden}");
    }

    function get_each_context$5(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[23] = list[i];
      return child_ctx;
    }

    const get_default_slot_changes = dirty => ({
      item: dirty &
      /*visible*/
      32,
      i: dirty &
      /*visible*/
      32,
      hoverItemIndex: dirty &
      /*hoverItemIndex*/
      2
    });

    const get_default_slot_context = ctx => ({
      item:
      /*row*/
      ctx[23].data,
      i:
      /*row*/
      ctx[23].index,
      hoverItemIndex:
      /*hoverItemIndex*/
      ctx[1]
    }); // (154:69) Missing template


    function fallback_block(ctx) {
      let t;
      return {
        c() {
          t = text("Missing template");
        },

        m(target, anchor) {
          insert(target, t, anchor);
        },

        d(detaching) {
          if (detaching) detach(t);
        }

      };
    } // (152:8) {#each visible as row (row.index)}


    function create_each_block$5(key_1, ctx) {
      let svelte_virtual_list_row;
      let t;
      let current;
      const default_slot_template =
      /*#slots*/
      ctx[15].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[14], get_default_slot_context);
      const default_slot_or_fallback = default_slot || fallback_block();
      return {
        key: key_1,
        first: null,

        c() {
          svelte_virtual_list_row = element("svelte-virtual-list-row");
          if (default_slot_or_fallback) default_slot_or_fallback.c();
          t = space$1();
          set_custom_element_data(svelte_virtual_list_row, "class", "svelte-g2cagw");
          this.first = svelte_virtual_list_row;
        },

        m(target, anchor) {
          insert(target, svelte_virtual_list_row, anchor);

          if (default_slot_or_fallback) {
            default_slot_or_fallback.m(svelte_virtual_list_row, null);
          }

          append(svelte_virtual_list_row, t);
          current = true;
        },

        p(new_ctx, dirty) {
          ctx = new_ctx;

          if (default_slot) {
            if (default_slot.p && (!current || dirty &
            /*$$scope, visible, hoverItemIndex*/
            16418)) {
              update_slot_base(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[14], !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[14]) : get_slot_changes(default_slot_template,
              /*$$scope*/
              ctx[14], dirty, get_default_slot_changes), get_default_slot_context);
            }
          }
        },

        i(local) {
          if (current) return;
          transition_in(default_slot_or_fallback, local);
          current = true;
        },

        o(local) {
          transition_out(default_slot_or_fallback, local);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(svelte_virtual_list_row);
          if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
        }

      };
    }

    function create_fragment$d(ctx) {
      let svelte_virtual_list_viewport;
      let svelte_virtual_list_contents;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let svelte_virtual_list_viewport_resize_listener;
      let current;
      let mounted;
      let dispose;
      let each_value =
      /*visible*/
      ctx[5];

      const get_key = ctx =>
      /*row*/
      ctx[23].index;

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$5(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
      }

      return {
        c() {
          svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
          svelte_virtual_list_contents = element("svelte-virtual-list-contents");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          set_style(svelte_virtual_list_contents, "padding-top",
          /*top*/
          ctx[6] + "px");
          set_style(svelte_virtual_list_contents, "padding-bottom",
          /*bottom*/
          ctx[7] + "px");
          set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-g2cagw");
          set_style(svelte_virtual_list_viewport, "height",
          /*height*/
          ctx[0]);
          set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-g2cagw");
          add_render_callback(() =>
          /*svelte_virtual_list_viewport_elementresize_handler*/
          ctx[18].call(svelte_virtual_list_viewport));
        },

        m(target, anchor) {
          insert(target, svelte_virtual_list_viewport, anchor);
          append(svelte_virtual_list_viewport, svelte_virtual_list_contents);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(svelte_virtual_list_contents, null);
          }
          /*svelte_virtual_list_contents_binding*/


          ctx[16](svelte_virtual_list_contents);
          /*svelte_virtual_list_viewport_binding*/

          ctx[17](svelte_virtual_list_viewport);
          svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport,
          /*svelte_virtual_list_viewport_elementresize_handler*/
          ctx[18].bind(svelte_virtual_list_viewport));
          current = true;

          if (!mounted) {
            dispose = listen(svelte_virtual_list_viewport, "scroll",
            /*handle_scroll*/
            ctx[8]);
            mounted = true;
          }
        },

        p(ctx, [dirty]) {
          if (dirty &
          /*$$scope, visible, hoverItemIndex*/
          16418) {
            each_value =
            /*visible*/
            ctx[5];
            group_outros();
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$5, null, get_each_context$5);
            check_outros();
          }

          if (!current || dirty &
          /*top*/
          64) {
            set_style(svelte_virtual_list_contents, "padding-top",
            /*top*/
            ctx[6] + "px");
          }

          if (!current || dirty &
          /*bottom*/
          128) {
            set_style(svelte_virtual_list_contents, "padding-bottom",
            /*bottom*/
            ctx[7] + "px");
          }

          if (!current || dirty &
          /*height*/
          1) {
            set_style(svelte_virtual_list_viewport, "height",
            /*height*/
            ctx[0]);
          }
        },

        i(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },

        o(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },

        d(detaching) {
          if (detaching) detach(svelte_virtual_list_viewport);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
          /*svelte_virtual_list_contents_binding*/


          ctx[16](null);
          /*svelte_virtual_list_viewport_binding*/

          ctx[17](null);
          svelte_virtual_list_viewport_resize_listener();
          mounted = false;
          dispose();
        }

      };
    }

    function instance$c($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      let {
        items = undefined
      } = $$props;
      let {
        height = '100%'
      } = $$props;
      let {
        itemHeight = 40
      } = $$props;
      let {
        hoverItemIndex = 0
      } = $$props;
      let {
        start = 0
      } = $$props;
      let {
        end = 0
      } = $$props;
      let height_map = [];
      let rows;
      let viewport;
      let contents;
      let viewport_height = 0;
      let visible;
      let mounted;
      let top = 0;
      let bottom = 0;
      let average_height;

      async function refresh(items, viewport_height, itemHeight) {
        const {
          scrollTop
        } = viewport;
        await tick();
        let content_height = top - scrollTop;
        let i = start;

        while (content_height < viewport_height && i < items.length) {
          let row = rows[i - start];

          if (!row) {
            $$invalidate(10, end = i + 1);
            await tick();
            row = rows[i - start];
          }

          const row_height = height_map[i] = itemHeight || row.offsetHeight;
          content_height += row_height;
          i += 1;
        }

        $$invalidate(10, end = i);
        const remaining = items.length - end;
        average_height = (top + content_height) / end;
        $$invalidate(7, bottom = remaining * average_height);
        height_map.length = items.length;
        if (viewport) $$invalidate(3, viewport.scrollTop = 0, viewport);
      }

      async function handle_scroll() {
        const {
          scrollTop
        } = viewport;
        const old_start = start;

        for (let v = 0; v < rows.length; v += 1) {
          height_map[start + v] = itemHeight || rows[v].offsetHeight;
        }

        let i = 0;
        let y = 0;

        while (i < items.length) {
          const row_height = height_map[i] || average_height;

          if (y + row_height > scrollTop) {
            $$invalidate(9, start = i);
            $$invalidate(6, top = y);
            break;
          }

          y += row_height;
          i += 1;
        }

        while (i < items.length) {
          y += height_map[i] || average_height;
          i += 1;
          if (y > scrollTop + viewport_height) break;
        }

        $$invalidate(10, end = i);
        const remaining = items.length - end;
        average_height = y / end;

        while (i < items.length) height_map[i++] = average_height;

        $$invalidate(7, bottom = remaining * average_height);

        if (start < old_start) {
          await tick();
          let expected_height = 0;
          let actual_height = 0;

          for (let i = start; i < old_start; i += 1) {
            if (rows[i - start]) {
              expected_height += height_map[i];
              actual_height += itemHeight || rows[i - start].offsetHeight;
            }
          }

          const d = actual_height - expected_height;
          viewport.scrollTo(0, scrollTop + d);
        }
      }

      onMount(() => {
        rows = contents.getElementsByTagName('svelte-virtual-list-row');
        $$invalidate(13, mounted = true);
      });

      function svelte_virtual_list_contents_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          contents = $$value;
          $$invalidate(4, contents);
        });
      }

      function svelte_virtual_list_viewport_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          viewport = $$value;
          $$invalidate(3, viewport);
        });
      }

      function svelte_virtual_list_viewport_elementresize_handler() {
        viewport_height = this.offsetHeight;
        $$invalidate(2, viewport_height);
      }

      $$self.$$set = $$props => {
        if ('items' in $$props) $$invalidate(11, items = $$props.items);
        if ('height' in $$props) $$invalidate(0, height = $$props.height);
        if ('itemHeight' in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
        if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
        if ('start' in $$props) $$invalidate(9, start = $$props.start);
        if ('end' in $$props) $$invalidate(10, end = $$props.end);
        if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*items, start, end*/
        3584) {
          $$invalidate(5, visible = items.slice(start, end).map((data, i) => {
            return {
              index: i + start,
              data
            };
          }));
        }

        if ($$self.$$.dirty &
        /*mounted, items, viewport_height, itemHeight*/
        14340) {
          if (mounted) refresh(items, viewport_height, itemHeight);
        }
      };

      return [height, hoverItemIndex, viewport_height, viewport, contents, visible, top, bottom, handle_scroll, start, end, items, itemHeight, mounted, $$scope, slots, svelte_virtual_list_contents_binding, svelte_virtual_list_viewport_binding, svelte_virtual_list_viewport_elementresize_handler];
    }

    class VirtualList extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$c, create_fragment$d, safe_not_equal, {
          items: 11,
          height: 0,
          itemHeight: 12,
          hoverItemIndex: 1,
          start: 9,
          end: 10
        }, add_css$1);
      }

    }

    function create_fragment$c(ctx) {
      let svg;
      let path;
      return {
        c() {
          svg = svg_element("svg");
          path = svg_element("path");
          attr(path, "fill", "currentColor");
          attr(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
          attr(svg, "width", "100%");
          attr(svg, "height", "100%");
          attr(svg, "viewBox", "-2 -2 50 50");
          attr(svg, "focusable", "false");
          attr(svg, "aria-hidden", "true");
          attr(svg, "role", "presentation");
        },

        m(target, anchor) {
          insert(target, svg, anchor);
          append(svg, path);
        },

        p: noop$1,
        i: noop$1,
        o: noop$1,

        d(detaching) {
          if (detaching) detach(svg);
        }

      };
    }

    class ClearIcon extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, null, create_fragment$c, safe_not_equal, {});
      }

    }

    function debounce$1(func, wait, immediate) {
      let timeout;
      return function executedFunction() {
        let context = this;
        let args = arguments;

        let later = function () {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };

        let callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    }

    function add_css(target) {
      append_styles(target, "svelte-17l1npl", ".selectContainer.svelte-17l1npl.svelte-17l1npl{--internalPadding:0 16px;border:var(--border, 1px solid #d8dbdf);border-radius:var(--borderRadius, 3px);box-sizing:border-box;height:var(--height, 42px);position:relative;display:flex;align-items:center;padding:var(--padding, var(--internalPadding));background:var(--background, #fff);margin:var(--margin, 0)}.selectContainer.svelte-17l1npl input.svelte-17l1npl{cursor:default;border:none;color:var(--inputColor, #3f4f5f);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--inputPadding, var(--padding, var(--internalPadding)));width:100%;background:transparent;font-size:var(--inputFontSize, 14px);letter-spacing:var(--inputLetterSpacing, -0.08px);position:absolute;left:var(--inputLeft, 0);margin:var(--inputMargin, 0)}.selectContainer.svelte-17l1npl input.svelte-17l1npl::placeholder{color:var(--placeholderColor, #78848f);opacity:var(--placeholderOpacity, 1)}.selectContainer.svelte-17l1npl input.svelte-17l1npl:focus{outline:none}.selectContainer.svelte-17l1npl.svelte-17l1npl:hover{border-color:var(--borderHoverColor, #b2b8bf)}.selectContainer.focused.svelte-17l1npl.svelte-17l1npl{border-color:var(--borderFocusColor, #006fe8)}.selectContainer.disabled.svelte-17l1npl.svelte-17l1npl{background:var(--disabledBackground, #ebedef);border-color:var(--disabledBorderColor, #ebedef);color:var(--disabledColor, #c1c6cc)}.selectContainer.disabled.svelte-17l1npl input.svelte-17l1npl::placeholder{color:var(--disabledPlaceholderColor, #c1c6cc);opacity:var(--disabledPlaceholderOpacity, 1)}.selectedItem.svelte-17l1npl.svelte-17l1npl{line-height:var(--height, 42px);height:var(--height, 42px);overflow-x:hidden;padding:var(--selectedItemPadding, 0 20px 0 0)}.selectedItem.svelte-17l1npl.svelte-17l1npl:focus{outline:none}.clearSelect.svelte-17l1npl.svelte-17l1npl{position:absolute;right:var(--clearSelectRight, 10px);top:var(--clearSelectTop, 11px);bottom:var(--clearSelectBottom, 11px);width:var(--clearSelectWidth, 20px);color:var(--clearSelectColor, #c5cacf);flex:none !important}.clearSelect.svelte-17l1npl.svelte-17l1npl:hover{color:var(--clearSelectHoverColor, #2c3e50)}.selectContainer.focused.svelte-17l1npl .clearSelect.svelte-17l1npl{color:var(--clearSelectFocusColor, #3f4f5f)}.indicator.svelte-17l1npl.svelte-17l1npl{position:absolute;right:var(--indicatorRight, 10px);top:var(--indicatorTop, 11px);width:var(--indicatorWidth, 20px);height:var(--indicatorHeight, 20px);color:var(--indicatorColor, #c5cacf)}.indicator.svelte-17l1npl svg.svelte-17l1npl{display:inline-block;fill:var(--indicatorFill, currentcolor);line-height:1;stroke:var(--indicatorStroke, currentcolor);stroke-width:0}.spinner.svelte-17l1npl.svelte-17l1npl{position:absolute;right:var(--spinnerRight, 10px);top:var(--spinnerLeft, 11px);width:var(--spinnerWidth, 20px);height:var(--spinnerHeight, 20px);color:var(--spinnerColor, #51ce6c);animation:svelte-17l1npl-rotate 0.75s linear infinite}.spinner_icon.svelte-17l1npl.svelte-17l1npl{display:block;height:100%;transform-origin:center center;width:100%;position:absolute;top:0;bottom:0;left:0;right:0;margin:auto;-webkit-transform:none}.spinner_path.svelte-17l1npl.svelte-17l1npl{stroke-dasharray:90;stroke-linecap:round}.multiSelect.svelte-17l1npl.svelte-17l1npl{display:flex;padding:var(--multiSelectPadding, 0 35px 0 16px);height:auto;flex-wrap:wrap;align-items:stretch}.multiSelect.svelte-17l1npl>.svelte-17l1npl{flex:1 1 50px}.selectContainer.multiSelect.svelte-17l1npl input.svelte-17l1npl{padding:var(--multiSelectInputPadding, 0);position:relative;margin:var(--multiSelectInputMargin, 0)}.hasError.svelte-17l1npl.svelte-17l1npl{border:var(--errorBorder, 1px solid #ff2d55);background:var(--errorBackground, #fff)}.a11yText.svelte-17l1npl.svelte-17l1npl{z-index:9999;border:0px;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0px;white-space:nowrap}@keyframes svelte-17l1npl-rotate{100%{transform:rotate(360deg)}}");
    }

    function get_each_context$4(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[103] = list[i];
      return child_ctx;
    } // (876:8) {#if isFocused}


    function create_if_block_10(ctx) {
      let span0;
      let t0;
      let t1;
      let span1;
      let t2;
      return {
        c() {
          span0 = element("span");
          t0 = text(
          /*ariaSelection*/
          ctx[33]);
          t1 = space$1();
          span1 = element("span");
          t2 = text(
          /*ariaContext*/
          ctx[32]);
          attr(span0, "id", "aria-selection");
          attr(span1, "id", "aria-context");
        },

        m(target, anchor) {
          insert(target, span0, anchor);
          append(span0, t0);
          insert(target, t1, anchor);
          insert(target, span1, anchor);
          append(span1, t2);
        },

        p(ctx, dirty) {
          if (dirty[1] &
          /*ariaSelection*/
          4) set_data(t0,
          /*ariaSelection*/
          ctx[33]);
          if (dirty[1] &
          /*ariaContext*/
          2) set_data(t2,
          /*ariaContext*/
          ctx[32]);
        },

        d(detaching) {
          if (detaching) detach(span0);
          if (detaching) detach(t1);
          if (detaching) detach(span1);
        }

      };
    } // (884:4) {#if Icon}


    function create_if_block_9(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      const switch_instance_spread_levels = [
      /*iconProps*/
      ctx[18]];
      var switch_value =
      /*Icon*/
      ctx[17];

      function switch_props(ctx) {
        let switch_instance_props = {};

        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i]);
        }

        return {
          props: switch_instance_props
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props());
      }

      return {
        c() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },

        m(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }

          insert(target, switch_instance_anchor, anchor);
          current = true;
        },

        p(ctx, dirty) {
          const switch_instance_changes = dirty[0] &
          /*iconProps*/
          262144 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*iconProps*/
          ctx[18])]) : {};

          if (switch_value !== (switch_value =
          /*Icon*/
          ctx[17])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },

        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },

        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(switch_instance_anchor);
          if (switch_instance) destroy_component(switch_instance, detaching);
        }

      };
    } // (888:4) {#if showMultiSelect}


    function create_if_block_8(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      var switch_value =
      /*MultiSelection*/
      ctx[26];

      function switch_props(ctx) {
        return {
          props: {
            value:
            /*value*/
            ctx[2],
            getSelectionLabel:
            /*getSelectionLabel*/
            ctx[12],
            activeValue:
            /*activeValue*/
            ctx[30],
            isDisabled:
            /*isDisabled*/
            ctx[9],
            multiFullItemClearable:
            /*multiFullItemClearable*/
            ctx[8]
          }
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
        switch_instance.$on("multiItemClear",
        /*handleMultiItemClear*/
        ctx[38]);
        switch_instance.$on("focus",
        /*handleFocus*/
        ctx[40]);
      }

      return {
        c() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },

        m(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }

          insert(target, switch_instance_anchor, anchor);
          current = true;
        },

        p(ctx, dirty) {
          const switch_instance_changes = {};
          if (dirty[0] &
          /*value*/
          4) switch_instance_changes.value =
          /*value*/
          ctx[2];
          if (dirty[0] &
          /*getSelectionLabel*/
          4096) switch_instance_changes.getSelectionLabel =
          /*getSelectionLabel*/
          ctx[12];
          if (dirty[0] &
          /*activeValue*/
          1073741824) switch_instance_changes.activeValue =
          /*activeValue*/
          ctx[30];
          if (dirty[0] &
          /*isDisabled*/
          512) switch_instance_changes.isDisabled =
          /*isDisabled*/
          ctx[9];
          if (dirty[0] &
          /*multiFullItemClearable*/
          256) switch_instance_changes.multiFullItemClearable =
          /*multiFullItemClearable*/
          ctx[8];

          if (switch_value !== (switch_value =
          /*MultiSelection*/
          ctx[26])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              switch_instance.$on("multiItemClear",
              /*handleMultiItemClear*/
              ctx[38]);
              switch_instance.$on("focus",
              /*handleFocus*/
              ctx[40]);
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },

        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },

        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(switch_instance_anchor);
          if (switch_instance) destroy_component(switch_instance, detaching);
        }

      };
    } // (910:4) {#if !isMulti && showSelectedItem}


    function create_if_block_7(ctx) {
      let div;
      let switch_instance;
      let current;
      let mounted;
      let dispose;
      var switch_value =
      /*Selection*/
      ctx[25];

      function switch_props(ctx) {
        return {
          props: {
            item:
            /*value*/
            ctx[2],
            getSelectionLabel:
            /*getSelectionLabel*/
            ctx[12]
          }
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
      }

      return {
        c() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr(div, "class", "selectedItem svelte-17l1npl");
        },

        m(target, anchor) {
          insert(target, div, anchor);

          if (switch_instance) {
            mount_component(switch_instance, div, null);
          }

          current = true;

          if (!mounted) {
            dispose = listen(div, "focus",
            /*handleFocus*/
            ctx[40]);
            mounted = true;
          }
        },

        p(ctx, dirty) {
          const switch_instance_changes = {};
          if (dirty[0] &
          /*value*/
          4) switch_instance_changes.item =
          /*value*/
          ctx[2];
          if (dirty[0] &
          /*getSelectionLabel*/
          4096) switch_instance_changes.getSelectionLabel =
          /*getSelectionLabel*/
          ctx[12];

          if (switch_value !== (switch_value =
          /*Selection*/
          ctx[25])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, null);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },

        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },

        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(div);
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          dispose();
        }

      };
    } // (919:4) {#if showClearIcon}


    function create_if_block_6$1(ctx) {
      let div;
      let switch_instance;
      let current;
      let mounted;
      let dispose;
      var switch_value =
      /*ClearIcon*/
      ctx[23];

      function switch_props(ctx) {
        return {};
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props());
      }

      return {
        c() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr(div, "class", "clearSelect svelte-17l1npl");
          attr(div, "aria-hidden", "true");
        },

        m(target, anchor) {
          insert(target, div, anchor);

          if (switch_instance) {
            mount_component(switch_instance, div, null);
          }

          current = true;

          if (!mounted) {
            dispose = listen(div, "click", prevent_default(
            /*handleClear*/
            ctx[27]));
            mounted = true;
          }
        },

        p(ctx, dirty) {
          if (switch_value !== (switch_value =
          /*ClearIcon*/
          ctx[23])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, null);
            } else {
              switch_instance = null;
            }
          }
        },

        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },

        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(div);
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          dispose();
        }

      };
    } // (928:4) {#if !showClearIcon && (showIndicator || (showChevron && !value) || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}


    function create_if_block_4$1(ctx) {
      let div;

      function select_block_type(ctx, dirty) {
        if (
        /*indicatorSvg*/
        ctx[22]) return create_if_block_5$1;
        return create_else_block$1;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      return {
        c() {
          div = element("div");
          if_block.c();
          attr(div, "class", "indicator svelte-17l1npl");
          attr(div, "aria-hidden", "true");
        },

        m(target, anchor) {
          insert(target, div, anchor);
          if_block.m(div, null);
        },

        p(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(div, null);
            }
          }
        },

        d(detaching) {
          if (detaching) detach(div);
          if_block.d();
        }

      };
    } // (932:12) {:else}


    function create_else_block$1(ctx) {
      let svg;
      let path;
      return {
        c() {
          svg = svg_element("svg");
          path = svg_element("path");
          attr(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
          attr(svg, "width", "100%");
          attr(svg, "height", "100%");
          attr(svg, "viewBox", "0 0 20 20");
          attr(svg, "focusable", "false");
          attr(svg, "aria-hidden", "true");
          attr(svg, "class", "svelte-17l1npl");
        },

        m(target, anchor) {
          insert(target, svg, anchor);
          append(svg, path);
        },

        p: noop$1,

        d(detaching) {
          if (detaching) detach(svg);
        }

      };
    } // (930:12) {#if indicatorSvg}


    function create_if_block_5$1(ctx) {
      let html_tag;
      let html_anchor;
      return {
        c() {
          html_tag = new HtmlTag(false);
          html_anchor = empty();
          html_tag.a = html_anchor;
        },

        m(target, anchor) {
          html_tag.m(
          /*indicatorSvg*/
          ctx[22], target, anchor);
          insert(target, html_anchor, anchor);
        },

        p(ctx, dirty) {
          if (dirty[0] &
          /*indicatorSvg*/
          4194304) html_tag.p(
          /*indicatorSvg*/
          ctx[22]);
        },

        d(detaching) {
          if (detaching) detach(html_anchor);
          if (detaching) html_tag.d();
        }

      };
    } // (950:4) {#if isWaiting}


    function create_if_block_3$1(ctx) {
      let div;
      return {
        c() {
          div = element("div");
          div.innerHTML = `<svg class="spinner_icon svelte-17l1npl" viewBox="25 25 50 50"><circle class="spinner_path svelte-17l1npl" cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="5" stroke-miterlimit="10"></circle></svg>`;
          attr(div, "class", "spinner svelte-17l1npl");
        },

        m(target, anchor) {
          insert(target, div, anchor);
        },

        d(detaching) {
          if (detaching) detach(div);
        }

      };
    } // (966:4) {#if listOpen}


    function create_if_block_2$1(ctx) {
      let switch_instance;
      let updating_hoverItemIndex;
      let switch_instance_anchor;
      let current;
      const switch_instance_spread_levels = [
      /*listProps*/
      ctx[34]];

      function switch_instance_hoverItemIndex_binding(value) {
        /*switch_instance_hoverItemIndex_binding*/
        ctx[84](value);
      }

      var switch_value =
      /*List*/
      ctx[24];

      function switch_props(ctx) {
        let switch_instance_props = {};

        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i]);
        }

        if (
        /*hoverItemIndex*/
        ctx[28] !== void 0) {
          switch_instance_props.hoverItemIndex =
          /*hoverItemIndex*/
          ctx[28];
        }

        return {
          props: switch_instance_props
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props(ctx));
        binding_callbacks.push(() => bind(switch_instance, 'hoverItemIndex', switch_instance_hoverItemIndex_binding));
        switch_instance.$on("itemSelected",
        /*itemSelected*/
        ctx[43]);
        switch_instance.$on("itemCreated",
        /*itemCreated*/
        ctx[44]);
        switch_instance.$on("closeList",
        /*closeList*/
        ctx[45]);
      }

      return {
        c() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },

        m(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }

          insert(target, switch_instance_anchor, anchor);
          current = true;
        },

        p(ctx, dirty) {
          const switch_instance_changes = dirty[1] &
          /*listProps*/
          8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*listProps*/
          ctx[34])]) : {};

          if (!updating_hoverItemIndex && dirty[0] &
          /*hoverItemIndex*/
          268435456) {
            updating_hoverItemIndex = true;
            switch_instance_changes.hoverItemIndex =
            /*hoverItemIndex*/
            ctx[28];
            add_flush_callback(() => updating_hoverItemIndex = false);
          }

          if (switch_value !== (switch_value =
          /*List*/
          ctx[24])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props(ctx));
              binding_callbacks.push(() => bind(switch_instance, 'hoverItemIndex', switch_instance_hoverItemIndex_binding));
              switch_instance.$on("itemSelected",
              /*itemSelected*/
              ctx[43]);
              switch_instance.$on("itemCreated",
              /*itemCreated*/
              ctx[44]);
              switch_instance.$on("closeList",
              /*closeList*/
              ctx[45]);
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            switch_instance.$set(switch_instance_changes);
          }
        },

        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },

        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(switch_instance_anchor);
          if (switch_instance) destroy_component(switch_instance, detaching);
        }

      };
    } // (976:4) {#if !isMulti || (isMulti && !showMultiSelect)}


    function create_if_block_1$4(ctx) {
      let input_1;
      let input_1_name_value;
      let input_1_value_value;
      return {
        c() {
          input_1 = element("input");
          attr(input_1, "name", input_1_name_value =
          /*inputAttributes*/
          ctx[16].name);
          attr(input_1, "type", "hidden");
          input_1.value = input_1_value_value =
          /*value*/
          ctx[2] ?
          /*getSelectionLabel*/
          ctx[12](
          /*value*/
          ctx[2]) : null;
          attr(input_1, "class", "svelte-17l1npl");
        },

        m(target, anchor) {
          insert(target, input_1, anchor);
        },

        p(ctx, dirty) {
          if (dirty[0] &
          /*inputAttributes*/
          65536 && input_1_name_value !== (input_1_name_value =
          /*inputAttributes*/
          ctx[16].name)) {
            attr(input_1, "name", input_1_name_value);
          }

          if (dirty[0] &
          /*value, getSelectionLabel*/
          4100 && input_1_value_value !== (input_1_value_value =
          /*value*/
          ctx[2] ?
          /*getSelectionLabel*/
          ctx[12](
          /*value*/
          ctx[2]) : null)) {
            input_1.value = input_1_value_value;
          }
        },

        d(detaching) {
          if (detaching) detach(input_1);
        }

      };
    } // (983:4) {#if isMulti && showMultiSelect}


    function create_if_block$7(ctx) {
      let each_1_anchor;
      let each_value =
      /*value*/
      ctx[2];
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
      }

      return {
        c() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },

        m(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert(target, each_1_anchor, anchor);
        },

        p(ctx, dirty) {
          if (dirty[0] &
          /*inputAttributes, value, getSelectionLabel*/
          69636) {
            each_value =
            /*value*/
            ctx[2];
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$4(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$4(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },

        d(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach(each_1_anchor);
        }

      };
    } // (984:8) {#each value as item}


    function create_each_block$4(ctx) {
      let input_1;
      let input_1_name_value;
      let input_1_value_value;
      return {
        c() {
          input_1 = element("input");
          attr(input_1, "name", input_1_name_value =
          /*inputAttributes*/
          ctx[16].name);
          attr(input_1, "type", "hidden");
          input_1.value = input_1_value_value =
          /*item*/
          ctx[103] ?
          /*getSelectionLabel*/
          ctx[12](
          /*item*/
          ctx[103]) : null;
          attr(input_1, "class", "svelte-17l1npl");
        },

        m(target, anchor) {
          insert(target, input_1, anchor);
        },

        p(ctx, dirty) {
          if (dirty[0] &
          /*inputAttributes*/
          65536 && input_1_name_value !== (input_1_name_value =
          /*inputAttributes*/
          ctx[16].name)) {
            attr(input_1, "name", input_1_name_value);
          }

          if (dirty[0] &
          /*value, getSelectionLabel*/
          4100 && input_1_value_value !== (input_1_value_value =
          /*item*/
          ctx[103] ?
          /*getSelectionLabel*/
          ctx[12](
          /*item*/
          ctx[103]) : null)) {
            input_1.value = input_1_value_value;
          }
        },

        d(detaching) {
          if (detaching) detach(input_1);
        }

      };
    }

    function create_fragment$b(ctx) {
      let div;
      let span;
      let t0;
      let t1;
      let t2;
      let input_1;
      let input_1_readonly_value;
      let t3;
      let t4;
      let t5;
      let t6;
      let t7;
      let t8;
      let t9;
      let div_class_value;
      let current;
      let mounted;
      let dispose;
      let if_block0 =
      /*isFocused*/
      ctx[1] && create_if_block_10(ctx);
      let if_block1 =
      /*Icon*/
      ctx[17] && create_if_block_9(ctx);
      let if_block2 =
      /*showMultiSelect*/
      ctx[35] && create_if_block_8(ctx);
      let input_1_levels = [{
        readOnly: input_1_readonly_value = !
        /*isSearchable*/
        ctx[13]
      },
      /*_inputAttributes*/
      ctx[31], {
        placeholder:
        /*placeholderText*/
        ctx[36]
      }, {
        style:
        /*inputStyles*/
        ctx[14]
      }, {
        disabled:
        /*isDisabled*/
        ctx[9]
      }];
      let input_1_data = {};

      for (let i = 0; i < input_1_levels.length; i += 1) {
        input_1_data = assign$1(input_1_data, input_1_levels[i]);
      }

      let if_block3 = !
      /*isMulti*/
      ctx[7] &&
      /*showSelectedItem*/
      ctx[29] && create_if_block_7(ctx);
      let if_block4 =
      /*showClearIcon*/
      ctx[37] && create_if_block_6$1(ctx);
      let if_block5 = !
      /*showClearIcon*/
      ctx[37] && (
      /*showIndicator*/
      ctx[20] ||
      /*showChevron*/
      ctx[19] && !
      /*value*/
      ctx[2] || !
      /*isSearchable*/
      ctx[13] && !
      /*isDisabled*/
      ctx[9] && !
      /*isWaiting*/
      ctx[4] && (
      /*showSelectedItem*/
      ctx[29] && !
      /*isClearable*/
      ctx[15] || !
      /*showSelectedItem*/
      ctx[29])) && create_if_block_4$1(ctx);
      let if_block6 =
      /*isWaiting*/
      ctx[4] && create_if_block_3$1();
      let if_block7 =
      /*listOpen*/
      ctx[5] && create_if_block_2$1(ctx);
      let if_block8 = (!
      /*isMulti*/
      ctx[7] ||
      /*isMulti*/
      ctx[7] && !
      /*showMultiSelect*/
      ctx[35]) && create_if_block_1$4(ctx);
      let if_block9 =
      /*isMulti*/
      ctx[7] &&
      /*showMultiSelect*/
      ctx[35] && create_if_block$7(ctx);
      return {
        c() {
          div = element("div");
          span = element("span");
          if (if_block0) if_block0.c();
          t0 = space$1();
          if (if_block1) if_block1.c();
          t1 = space$1();
          if (if_block2) if_block2.c();
          t2 = space$1();
          input_1 = element("input");
          t3 = space$1();
          if (if_block3) if_block3.c();
          t4 = space$1();
          if (if_block4) if_block4.c();
          t5 = space$1();
          if (if_block5) if_block5.c();
          t6 = space$1();
          if (if_block6) if_block6.c();
          t7 = space$1();
          if (if_block7) if_block7.c();
          t8 = space$1();
          if (if_block8) if_block8.c();
          t9 = space$1();
          if (if_block9) if_block9.c();
          attr(span, "aria-live", "polite");
          attr(span, "aria-atomic", "false");
          attr(span, "aria-relevant", "additions text");
          attr(span, "class", "a11yText svelte-17l1npl");
          set_attributes(input_1, input_1_data);
          toggle_class(input_1, "svelte-17l1npl", true);
          attr(div, "class", div_class_value = "selectContainer " +
          /*containerClasses*/
          ctx[21] + " svelte-17l1npl");
          attr(div, "style",
          /*containerStyles*/
          ctx[11]);
          toggle_class(div, "hasError",
          /*hasError*/
          ctx[10]);
          toggle_class(div, "multiSelect",
          /*isMulti*/
          ctx[7]);
          toggle_class(div, "disabled",
          /*isDisabled*/
          ctx[9]);
          toggle_class(div, "focused",
          /*isFocused*/
          ctx[1]);
        },

        m(target, anchor) {
          insert(target, div, anchor);
          append(div, span);
          if (if_block0) if_block0.m(span, null);
          append(div, t0);
          if (if_block1) if_block1.m(div, null);
          append(div, t1);
          if (if_block2) if_block2.m(div, null);
          append(div, t2);
          append(div, input_1);
          if (input_1.autofocus) input_1.focus();
          /*input_1_binding*/

          ctx[82](input_1);
          set_input_value(input_1,
          /*filterText*/
          ctx[3]);
          append(div, t3);
          if (if_block3) if_block3.m(div, null);
          append(div, t4);
          if (if_block4) if_block4.m(div, null);
          append(div, t5);
          if (if_block5) if_block5.m(div, null);
          append(div, t6);
          if (if_block6) if_block6.m(div, null);
          append(div, t7);
          if (if_block7) if_block7.m(div, null);
          append(div, t8);
          if (if_block8) if_block8.m(div, null);
          append(div, t9);
          if (if_block9) if_block9.m(div, null);
          /*div_binding*/

          ctx[85](div);
          current = true;

          if (!mounted) {
            dispose = [listen(window, "click",
            /*handleWindowEvent*/
            ctx[41]), listen(window, "focusin",
            /*handleWindowEvent*/
            ctx[41]), listen(window, "keydown",
            /*handleKeyDown*/
            ctx[39]), listen(input_1, "focus",
            /*handleFocus*/
            ctx[40]), listen(input_1, "input",
            /*input_1_input_handler*/
            ctx[83]), listen(div, "click",
            /*handleClick*/
            ctx[42])];
            mounted = true;
          }
        },

        p(ctx, dirty) {
          if (
          /*isFocused*/
          ctx[1]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_10(ctx);
              if_block0.c();
              if_block0.m(span, null);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*Icon*/
          ctx[17]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty[0] &
              /*Icon*/
              131072) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_9(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, t1);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*showMultiSelect*/
          ctx[35]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty[1] &
              /*showMultiSelect*/
              16) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_8(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div, t2);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [(!current || dirty[0] &
          /*isSearchable*/
          8192 && input_1_readonly_value !== (input_1_readonly_value = !
          /*isSearchable*/
          ctx[13])) && {
            readOnly: input_1_readonly_value
          }, dirty[1] &
          /*_inputAttributes*/
          1 &&
          /*_inputAttributes*/
          ctx[31], (!current || dirty[1] &
          /*placeholderText*/
          32) && {
            placeholder:
            /*placeholderText*/
            ctx[36]
          }, (!current || dirty[0] &
          /*inputStyles*/
          16384) && {
            style:
            /*inputStyles*/
            ctx[14]
          }, (!current || dirty[0] &
          /*isDisabled*/
          512) && {
            disabled:
            /*isDisabled*/
            ctx[9]
          }]));

          if (dirty[0] &
          /*filterText*/
          8 && input_1.value !==
          /*filterText*/
          ctx[3]) {
            set_input_value(input_1,
            /*filterText*/
            ctx[3]);
          }

          toggle_class(input_1, "svelte-17l1npl", true);

          if (!
          /*isMulti*/
          ctx[7] &&
          /*showSelectedItem*/
          ctx[29]) {
            if (if_block3) {
              if_block3.p(ctx, dirty);

              if (dirty[0] &
              /*isMulti, showSelectedItem*/
              536871040) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_7(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div, t4);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }

          if (
          /*showClearIcon*/
          ctx[37]) {
            if (if_block4) {
              if_block4.p(ctx, dirty);

              if (dirty[1] &
              /*showClearIcon*/
              64) {
                transition_in(if_block4, 1);
              }
            } else {
              if_block4 = create_if_block_6$1(ctx);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(div, t5);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }

          if (!
          /*showClearIcon*/
          ctx[37] && (
          /*showIndicator*/
          ctx[20] ||
          /*showChevron*/
          ctx[19] && !
          /*value*/
          ctx[2] || !
          /*isSearchable*/
          ctx[13] && !
          /*isDisabled*/
          ctx[9] && !
          /*isWaiting*/
          ctx[4] && (
          /*showSelectedItem*/
          ctx[29] && !
          /*isClearable*/
          ctx[15] || !
          /*showSelectedItem*/
          ctx[29]))) {
            if (if_block5) {
              if_block5.p(ctx, dirty);
            } else {
              if_block5 = create_if_block_4$1(ctx);
              if_block5.c();
              if_block5.m(div, t6);
            }
          } else if (if_block5) {
            if_block5.d(1);
            if_block5 = null;
          }

          if (
          /*isWaiting*/
          ctx[4]) {
            if (if_block6) ; else {
              if_block6 = create_if_block_3$1();
              if_block6.c();
              if_block6.m(div, t7);
            }
          } else if (if_block6) {
            if_block6.d(1);
            if_block6 = null;
          }

          if (
          /*listOpen*/
          ctx[5]) {
            if (if_block7) {
              if_block7.p(ctx, dirty);

              if (dirty[0] &
              /*listOpen*/
              32) {
                transition_in(if_block7, 1);
              }
            } else {
              if_block7 = create_if_block_2$1(ctx);
              if_block7.c();
              transition_in(if_block7, 1);
              if_block7.m(div, t8);
            }
          } else if (if_block7) {
            group_outros();
            transition_out(if_block7, 1, 1, () => {
              if_block7 = null;
            });
            check_outros();
          }

          if (!
          /*isMulti*/
          ctx[7] ||
          /*isMulti*/
          ctx[7] && !
          /*showMultiSelect*/
          ctx[35]) {
            if (if_block8) {
              if_block8.p(ctx, dirty);
            } else {
              if_block8 = create_if_block_1$4(ctx);
              if_block8.c();
              if_block8.m(div, t9);
            }
          } else if (if_block8) {
            if_block8.d(1);
            if_block8 = null;
          }

          if (
          /*isMulti*/
          ctx[7] &&
          /*showMultiSelect*/
          ctx[35]) {
            if (if_block9) {
              if_block9.p(ctx, dirty);
            } else {
              if_block9 = create_if_block$7(ctx);
              if_block9.c();
              if_block9.m(div, null);
            }
          } else if (if_block9) {
            if_block9.d(1);
            if_block9 = null;
          }

          if (!current || dirty[0] &
          /*containerClasses*/
          2097152 && div_class_value !== (div_class_value = "selectContainer " +
          /*containerClasses*/
          ctx[21] + " svelte-17l1npl")) {
            attr(div, "class", div_class_value);
          }

          if (!current || dirty[0] &
          /*containerStyles*/
          2048) {
            attr(div, "style",
            /*containerStyles*/
            ctx[11]);
          }

          if (dirty[0] &
          /*containerClasses, hasError*/
          2098176) {
            toggle_class(div, "hasError",
            /*hasError*/
            ctx[10]);
          }

          if (dirty[0] &
          /*containerClasses, isMulti*/
          2097280) {
            toggle_class(div, "multiSelect",
            /*isMulti*/
            ctx[7]);
          }

          if (dirty[0] &
          /*containerClasses, isDisabled*/
          2097664) {
            toggle_class(div, "disabled",
            /*isDisabled*/
            ctx[9]);
          }

          if (dirty[0] &
          /*containerClasses, isFocused*/
          2097154) {
            toggle_class(div, "focused",
            /*isFocused*/
            ctx[1]);
          }
        },

        i(local) {
          if (current) return;
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(if_block4);
          transition_in(if_block7);
          current = true;
        },

        o(local) {
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(if_block4);
          transition_out(if_block7);
          current = false;
        },

        d(detaching) {
          if (detaching) detach(div);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          /*input_1_binding*/

          ctx[82](null);
          if (if_block3) if_block3.d();
          if (if_block4) if_block4.d();
          if (if_block5) if_block5.d();
          if (if_block6) if_block6.d();
          if (if_block7) if_block7.d();
          if (if_block8) if_block8.d();
          if (if_block9) if_block9.d();
          /*div_binding*/

          ctx[85](null);
          mounted = false;
          run_all(dispose);
        }

      };
    }

    function convertStringItemsToObjects(_items) {
      return _items.map((item, index) => {
        return {
          index,
          value: item,
          label: `${item}`
        };
      });
    }

    function instance$b($$self, $$props, $$invalidate) {
      let filteredItems;
      let showSelectedItem;
      let showClearIcon;
      let placeholderText;
      let showMultiSelect;
      let listProps;
      let ariaSelection;
      let ariaContext;
      const dispatch = createEventDispatcher();
      let {
        id = null
      } = $$props;
      let {
        container = undefined
      } = $$props;
      let {
        input = undefined
      } = $$props;
      let {
        isMulti = false
      } = $$props;
      let {
        multiFullItemClearable = false
      } = $$props;
      let {
        isDisabled = false
      } = $$props;
      let {
        isCreatable = false
      } = $$props;
      let {
        isFocused = false
      } = $$props;
      let {
        value = null
      } = $$props;
      let {
        filterText = ''
      } = $$props;
      let {
        placeholder = 'Select...'
      } = $$props;
      let {
        placeholderAlwaysShow = false
      } = $$props;
      let {
        items = null
      } = $$props;
      let {
        itemFilter = (label, filterText, option) => `${label}`.toLowerCase().includes(filterText.toLowerCase())
      } = $$props;
      let {
        groupBy = undefined
      } = $$props;
      let {
        groupFilter = groups => groups
      } = $$props;
      let {
        isGroupHeaderSelectable = false
      } = $$props;
      let {
        getGroupHeaderLabel = option => {
          return option[labelIdentifier] || option.id;
        }
      } = $$props;
      let {
        labelIdentifier = 'label'
      } = $$props;
      let {
        getOptionLabel = (option, filterText) => {
          return option.isCreator ? `Create \"${filterText}\"` : option[labelIdentifier];
        }
      } = $$props;
      let {
        optionIdentifier = 'value'
      } = $$props;
      let {
        loadOptions = undefined
      } = $$props;
      let {
        hasError = false
      } = $$props;
      let {
        containerStyles = ''
      } = $$props;
      let {
        getSelectionLabel = option => {
          if (option) return option[labelIdentifier];else return null;
        }
      } = $$props;
      let {
        createGroupHeaderItem = groupValue => {
          return {
            value: groupValue,
            label: groupValue
          };
        }
      } = $$props;
      let {
        createItem = filterText => {
          return {
            value: filterText,
            label: filterText
          };
        }
      } = $$props;

      const getFilteredItems = () => {
        return filteredItems;
      };

      let {
        isSearchable = true
      } = $$props;
      let {
        inputStyles = ''
      } = $$props;
      let {
        isClearable = true
      } = $$props;
      let {
        isWaiting = false
      } = $$props;
      let {
        listPlacement = 'auto'
      } = $$props;
      let {
        listOpen = false
      } = $$props;
      let {
        isVirtualList = false
      } = $$props;
      let {
        loadOptionsInterval = 300
      } = $$props;
      let {
        noOptionsMessage = 'No options'
      } = $$props;
      let {
        hideEmptyState = false
      } = $$props;
      let {
        inputAttributes = {}
      } = $$props;
      let {
        listAutoWidth = true
      } = $$props;
      let {
        itemHeight = 40
      } = $$props;
      let {
        Icon = undefined
      } = $$props;
      let {
        iconProps = {}
      } = $$props;
      let {
        showChevron = false
      } = $$props;
      let {
        showIndicator = false
      } = $$props;
      let {
        containerClasses = ''
      } = $$props;
      let {
        indicatorSvg = undefined
      } = $$props;
      let {
        listOffset = 5
      } = $$props;
      let {
        ClearIcon: ClearIcon$1 = ClearIcon
      } = $$props;
      let {
        Item = Item$1
      } = $$props;
      let {
        List: List$1 = List
      } = $$props;
      let {
        Selection: Selection$1 = Selection
      } = $$props;
      let {
        MultiSelection: MultiSelection$1 = MultiSelection
      } = $$props;
      let {
        VirtualList: VirtualList$1 = VirtualList
      } = $$props;

      function filterMethod(args) {
        if (args.loadOptions && args.filterText.length > 0) return;
        if (!args.items) return [];

        if (args.items && args.items.length > 0 && typeof args.items[0] !== 'object') {
          args.items = convertStringItemsToObjects(args.items);
        }

        let filterResults = args.items.filter(item => {
          let matchesFilter = itemFilter(getOptionLabel(item, args.filterText), args.filterText, item);

          if (matchesFilter && args.isMulti && args.value && Array.isArray(args.value)) {
            matchesFilter = !args.value.some(x => {
              return x[args.optionIdentifier] === item[args.optionIdentifier];
            });
          }

          return matchesFilter;
        });

        if (args.groupBy) {
          filterResults = filterGroupedItems(filterResults);
        }

        if (args.isCreatable) {
          filterResults = addCreatableItem(filterResults, args.filterText);
        }

        return filterResults;
      }

      function addCreatableItem(_items, _filterText) {
        if (_filterText.length === 0) return _items;
        const itemToCreate = createItem(_filterText);
        if (_items[0] && _filterText === _items[0][labelIdentifier]) return _items;
        itemToCreate.isCreator = true;
        return [..._items, itemToCreate];
      }

      let {
        selectedValue = null
      } = $$props;
      let activeValue;
      let prev_value;
      let prev_filterText;
      let prev_isFocused;
      let prev_isMulti;
      let hoverItemIndex;
      const getItems = debounce$1(async () => {
        $$invalidate(4, isWaiting = true);
        let res = await loadOptions(filterText).catch(err => {
          console.warn('svelte-select loadOptions error :>> ', err);
          dispatch('error', {
            type: 'loadOptions',
            details: err
          });
        });

        if (res && !res.cancelled) {
          if (res) {
            if (res && res.length > 0 && typeof res[0] !== 'object') {
              res = convertStringItemsToObjects(res);
            }

            $$invalidate(81, filteredItems = [...res]);
            dispatch('loaded', {
              items: filteredItems
            });
          } else {
            $$invalidate(81, filteredItems = []);
          }

          if (isCreatable) {
            $$invalidate(81, filteredItems = addCreatableItem(filteredItems, filterText));
          }

          $$invalidate(4, isWaiting = false);
          $$invalidate(1, isFocused = true);
          $$invalidate(5, listOpen = true);
        }
      }, loadOptionsInterval);

      function setValue() {
        if (typeof value === 'string') {
          $$invalidate(2, value = {
            [optionIdentifier]: value,
            label: value
          });
        } else if (isMulti && Array.isArray(value) && value.length > 0) {
          $$invalidate(2, value = value.map(item => typeof item === 'string' ? {
            value: item,
            label: item
          } : item));
        }
      }

      let _inputAttributes;

      function assignInputAttributes() {
        $$invalidate(31, _inputAttributes = Object.assign({
          autocapitalize: 'none',
          autocomplete: 'off',
          autocorrect: 'off',
          spellcheck: false,
          tabindex: 0,
          type: 'text',
          'aria-autocomplete': 'list'
        }, inputAttributes));

        if (id) {
          $$invalidate(31, _inputAttributes.id = id, _inputAttributes);
        }

        if (!isSearchable) {
          $$invalidate(31, _inputAttributes.readonly = true, _inputAttributes);
        }
      }

      function filterGroupedItems(_items) {
        const groupValues = [];
        const groups = {};

        _items.forEach(item => {
          const groupValue = groupBy(item);

          if (!groupValues.includes(groupValue)) {
            groupValues.push(groupValue);
            groups[groupValue] = [];

            if (groupValue) {
              groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
                id: groupValue,
                isGroupHeader: true,
                isSelectable: isGroupHeaderSelectable
              }));
            }
          }

          groups[groupValue].push(Object.assign({
            isGroupItem: !!groupValue
          }, item));
        });

        const sortedGroupedItems = [];
        groupFilter(groupValues).forEach(groupValue => {
          sortedGroupedItems.push(...groups[groupValue]);
        });
        return sortedGroupedItems;
      }

      function dispatchSelectedItem() {
        if (isMulti) {
          if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
            if (checkValueForDuplicates()) {
              dispatch('select', value);
            }
          }

          return;
        }

        if (!prev_value || JSON.stringify(value[optionIdentifier]) !== JSON.stringify(prev_value[optionIdentifier])) {
          dispatch('select', value);
        }
      }

      function setupFocus() {
        if (isFocused || listOpen) {
          handleFocus();
        } else {
          if (input) input.blur();
        }
      }

      function setupMulti() {
        if (value) {
          if (Array.isArray(value)) {
            $$invalidate(2, value = [...value]);
          } else {
            $$invalidate(2, value = [value]);
          }
        }
      }

      function setupSingle() {
        if (value) $$invalidate(2, value = null);
      }

      function setupFilterText() {
        if (filterText.length === 0) return;
        $$invalidate(1, isFocused = true);
        $$invalidate(5, listOpen = true);

        if (loadOptions) {
          getItems();
        } else {
          $$invalidate(5, listOpen = true);

          if (isMulti) {
            $$invalidate(30, activeValue = undefined);
          }
        }
      }

      beforeUpdate(async () => {
        $$invalidate(77, prev_value = value);
        $$invalidate(78, prev_filterText = filterText);
        $$invalidate(79, prev_isFocused = isFocused);
        $$invalidate(80, prev_isMulti = isMulti);
      });

      function checkValueForDuplicates() {
        let noDuplicates = true;

        if (value) {
          const ids = [];
          const uniqueValues = [];
          value.forEach(val => {
            if (!ids.includes(val[optionIdentifier])) {
              ids.push(val[optionIdentifier]);
              uniqueValues.push(val);
            } else {
              noDuplicates = false;
            }
          });
          if (!noDuplicates) $$invalidate(2, value = uniqueValues);
        }

        return noDuplicates;
      }

      function findItem(selection) {
        let matchTo = selection ? selection[optionIdentifier] : value[optionIdentifier];
        return items.find(item => item[optionIdentifier] === matchTo);
      }

      function updateValueDisplay(items) {
        if (!items || items.length === 0 || items.some(item => typeof item !== 'object')) return;
        if (!value || (isMulti ? value.some(selection => !selection || !selection[optionIdentifier]) : !value[optionIdentifier])) return;

        if (Array.isArray(value)) {
          $$invalidate(2, value = value.map(selection => findItem(selection) || selection));
        } else {
          $$invalidate(2, value = findItem() || value);
        }
      }

      function handleMultiItemClear(event) {
        const {
          detail
        } = event;
        const itemToRemove = value[detail ? detail.i : value.length - 1];

        if (value.length === 1) {
          $$invalidate(2, value = undefined);
        } else {
          $$invalidate(2, value = value.filter(item => {
            return item !== itemToRemove;
          }));
        }

        dispatch('clear', itemToRemove);
      }

      function handleKeyDown(e) {
        if (!isFocused) return;

        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            $$invalidate(5, listOpen = true);
            $$invalidate(30, activeValue = undefined);
            break;

          case 'ArrowUp':
            e.preventDefault();
            $$invalidate(5, listOpen = true);
            $$invalidate(30, activeValue = undefined);
            break;

          case 'Tab':
            if (!listOpen) $$invalidate(1, isFocused = false);
            break;

          case 'Backspace':
            if (!isMulti || filterText.length > 0) return;

            if (isMulti && value && value.length > 0) {
              handleMultiItemClear(activeValue !== undefined ? activeValue : value.length - 1);
              if (activeValue === 0 || activeValue === undefined) break;
              $$invalidate(30, activeValue = value.length > activeValue ? activeValue - 1 : undefined);
            }

            break;

          case 'ArrowLeft':
            if (!isMulti || filterText.length > 0) return;

            if (activeValue === undefined) {
              $$invalidate(30, activeValue = value.length - 1);
            } else if (value.length > activeValue && activeValue !== 0) {
              $$invalidate(30, activeValue -= 1);
            }

            break;

          case 'ArrowRight':
            if (!isMulti || filterText.length > 0 || activeValue === undefined) return;

            if (activeValue === value.length - 1) {
              $$invalidate(30, activeValue = undefined);
            } else if (activeValue < value.length - 1) {
              $$invalidate(30, activeValue += 1);
            }

            break;
        }
      }

      function handleFocus() {
        $$invalidate(1, isFocused = true);
        if (input) input.focus();
      }

      function handleWindowEvent(event) {
        if (!container) return;
        const eventTarget = event.path && event.path.length > 0 ? event.path[0] : event.target;

        if (container.contains(eventTarget) || container.contains(event.relatedTarget)) {
          return;
        }

        $$invalidate(1, isFocused = false);
        $$invalidate(5, listOpen = false);
        $$invalidate(30, activeValue = undefined);
        if (input) input.blur();
      }

      function handleClick() {
        if (isDisabled) return;
        $$invalidate(1, isFocused = true);
        $$invalidate(5, listOpen = !listOpen);
      }

      function handleClear() {
        $$invalidate(2, value = undefined);
        $$invalidate(5, listOpen = false);
        dispatch('clear', value);
        handleFocus();
      }

      onMount(() => {
        if (isFocused && input) input.focus();
      });

      function itemSelected(event) {
        const {
          detail
        } = event;

        if (detail) {
          $$invalidate(3, filterText = '');
          const item = Object.assign({}, detail);

          if (!item.isGroupHeader || item.isSelectable) {
            if (isMulti) {
              $$invalidate(2, value = value ? value.concat([item]) : [item]);
            } else {
              $$invalidate(2, value = item);
            }

            $$invalidate(2, value);
            setTimeout(() => {
              $$invalidate(5, listOpen = false);
              $$invalidate(30, activeValue = undefined);
            });
          }
        }
      }

      function itemCreated(event) {
        const {
          detail
        } = event;

        if (isMulti) {
          $$invalidate(2, value = value || []);
          $$invalidate(2, value = [...value, createItem(detail)]);
        } else {
          $$invalidate(2, value = createItem(detail));
        }

        dispatch('itemCreated', detail);
        $$invalidate(3, filterText = '');
        $$invalidate(5, listOpen = false);
        $$invalidate(30, activeValue = undefined);
      }

      function closeList() {
        $$invalidate(3, filterText = '');
        $$invalidate(5, listOpen = false);
      }

      let {
        ariaValues = values => {
          return `Option ${values}, selected.`;
        }
      } = $$props;
      let {
        ariaListOpen = (label, count) => {
          return `You are currently focused on option ${label}. There are ${count} results available.`;
        }
      } = $$props;
      let {
        ariaFocused = () => {
          return `Select is focused, type to refine list, press down to open the menu.`;
        }
      } = $$props;

      function handleAriaSelection() {
        let selected = undefined;

        if (isMulti && value.length > 0) {
          selected = value.map(v => getSelectionLabel(v)).join(', ');
        } else {
          selected = getSelectionLabel(value);
        }

        return ariaValues(selected);
      }

      function handleAriaContent() {
        if (!isFocused || !filteredItems || filteredItems.length === 0) return '';
        let _item = filteredItems[hoverItemIndex];

        if (listOpen && _item) {
          let label = getSelectionLabel(_item);
          let count = filteredItems ? filteredItems.length : 0;
          return ariaListOpen(label, count);
        } else {
          return ariaFocused();
        }
      }

      function input_1_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          input = $$value;
          $$invalidate(6, input);
        });
      }

      function input_1_input_handler() {
        filterText = this.value;
        $$invalidate(3, filterText);
      }

      function switch_instance_hoverItemIndex_binding(value) {
        hoverItemIndex = value;
        $$invalidate(28, hoverItemIndex);
      }

      function div_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          container = $$value;
          $$invalidate(0, container);
        });
      }

      $$self.$$set = $$props => {
        if ('id' in $$props) $$invalidate(46, id = $$props.id);
        if ('container' in $$props) $$invalidate(0, container = $$props.container);
        if ('input' in $$props) $$invalidate(6, input = $$props.input);
        if ('isMulti' in $$props) $$invalidate(7, isMulti = $$props.isMulti);
        if ('multiFullItemClearable' in $$props) $$invalidate(8, multiFullItemClearable = $$props.multiFullItemClearable);
        if ('isDisabled' in $$props) $$invalidate(9, isDisabled = $$props.isDisabled);
        if ('isCreatable' in $$props) $$invalidate(47, isCreatable = $$props.isCreatable);
        if ('isFocused' in $$props) $$invalidate(1, isFocused = $$props.isFocused);
        if ('value' in $$props) $$invalidate(2, value = $$props.value);
        if ('filterText' in $$props) $$invalidate(3, filterText = $$props.filterText);
        if ('placeholder' in $$props) $$invalidate(48, placeholder = $$props.placeholder);
        if ('placeholderAlwaysShow' in $$props) $$invalidate(49, placeholderAlwaysShow = $$props.placeholderAlwaysShow);
        if ('items' in $$props) $$invalidate(50, items = $$props.items);
        if ('itemFilter' in $$props) $$invalidate(51, itemFilter = $$props.itemFilter);
        if ('groupBy' in $$props) $$invalidate(52, groupBy = $$props.groupBy);
        if ('groupFilter' in $$props) $$invalidate(53, groupFilter = $$props.groupFilter);
        if ('isGroupHeaderSelectable' in $$props) $$invalidate(54, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
        if ('getGroupHeaderLabel' in $$props) $$invalidate(55, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
        if ('labelIdentifier' in $$props) $$invalidate(56, labelIdentifier = $$props.labelIdentifier);
        if ('getOptionLabel' in $$props) $$invalidate(57, getOptionLabel = $$props.getOptionLabel);
        if ('optionIdentifier' in $$props) $$invalidate(58, optionIdentifier = $$props.optionIdentifier);
        if ('loadOptions' in $$props) $$invalidate(59, loadOptions = $$props.loadOptions);
        if ('hasError' in $$props) $$invalidate(10, hasError = $$props.hasError);
        if ('containerStyles' in $$props) $$invalidate(11, containerStyles = $$props.containerStyles);
        if ('getSelectionLabel' in $$props) $$invalidate(12, getSelectionLabel = $$props.getSelectionLabel);
        if ('createGroupHeaderItem' in $$props) $$invalidate(60, createGroupHeaderItem = $$props.createGroupHeaderItem);
        if ('createItem' in $$props) $$invalidate(61, createItem = $$props.createItem);
        if ('isSearchable' in $$props) $$invalidate(13, isSearchable = $$props.isSearchable);
        if ('inputStyles' in $$props) $$invalidate(14, inputStyles = $$props.inputStyles);
        if ('isClearable' in $$props) $$invalidate(15, isClearable = $$props.isClearable);
        if ('isWaiting' in $$props) $$invalidate(4, isWaiting = $$props.isWaiting);
        if ('listPlacement' in $$props) $$invalidate(63, listPlacement = $$props.listPlacement);
        if ('listOpen' in $$props) $$invalidate(5, listOpen = $$props.listOpen);
        if ('isVirtualList' in $$props) $$invalidate(64, isVirtualList = $$props.isVirtualList);
        if ('loadOptionsInterval' in $$props) $$invalidate(65, loadOptionsInterval = $$props.loadOptionsInterval);
        if ('noOptionsMessage' in $$props) $$invalidate(66, noOptionsMessage = $$props.noOptionsMessage);
        if ('hideEmptyState' in $$props) $$invalidate(67, hideEmptyState = $$props.hideEmptyState);
        if ('inputAttributes' in $$props) $$invalidate(16, inputAttributes = $$props.inputAttributes);
        if ('listAutoWidth' in $$props) $$invalidate(68, listAutoWidth = $$props.listAutoWidth);
        if ('itemHeight' in $$props) $$invalidate(69, itemHeight = $$props.itemHeight);
        if ('Icon' in $$props) $$invalidate(17, Icon = $$props.Icon);
        if ('iconProps' in $$props) $$invalidate(18, iconProps = $$props.iconProps);
        if ('showChevron' in $$props) $$invalidate(19, showChevron = $$props.showChevron);
        if ('showIndicator' in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
        if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
        if ('indicatorSvg' in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
        if ('listOffset' in $$props) $$invalidate(70, listOffset = $$props.listOffset);
        if ('ClearIcon' in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
        if ('Item' in $$props) $$invalidate(71, Item = $$props.Item);
        if ('List' in $$props) $$invalidate(24, List$1 = $$props.List);
        if ('Selection' in $$props) $$invalidate(25, Selection$1 = $$props.Selection);
        if ('MultiSelection' in $$props) $$invalidate(26, MultiSelection$1 = $$props.MultiSelection);
        if ('VirtualList' in $$props) $$invalidate(72, VirtualList$1 = $$props.VirtualList);
        if ('selectedValue' in $$props) $$invalidate(73, selectedValue = $$props.selectedValue);
        if ('ariaValues' in $$props) $$invalidate(74, ariaValues = $$props.ariaValues);
        if ('ariaListOpen' in $$props) $$invalidate(75, ariaListOpen = $$props.ariaListOpen);
        if ('ariaFocused' in $$props) $$invalidate(76, ariaFocused = $$props.ariaFocused);
      };

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] &
        /*filterText, value, isMulti*/
        140 | $$self.$$.dirty[1] &
        /*loadOptions, items, optionIdentifier, groupBy, isCreatable*/
        405340160) {
          $$invalidate(81, filteredItems = filterMethod({
            loadOptions,
            filterText,
            items,
            value,
            isMulti,
            optionIdentifier,
            groupBy,
            isCreatable
          }));
        }

        if ($$self.$$.dirty[2] &
        /*selectedValue*/
        2048) {
          {
            if (selectedValue) console.warn('selectedValue is no longer used. Please use value instead.');
          }
        }

        if ($$self.$$.dirty[1] &
        /*items*/
        524288) {
          updateValueDisplay(items);
        }

        if ($$self.$$.dirty[0] &
        /*value*/
        4) {
          {
            if (value) setValue();
          }
        }

        if ($$self.$$.dirty[0] &
        /*inputAttributes, isSearchable*/
        73728) {
          {
            if (inputAttributes || !isSearchable) assignInputAttributes();
          }
        }

        if ($$self.$$.dirty[0] &
        /*isMulti*/
        128 | $$self.$$.dirty[2] &
        /*prev_isMulti*/
        262144) {
          {
            if (isMulti) {
              setupMulti();
            }

            if (prev_isMulti && !isMulti) {
              setupSingle();
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*isMulti, value*/
        132) {
          {
            if (isMulti && value && value.length > 1) {
              checkValueForDuplicates();
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*value*/
        4) {
          {
            if (value) dispatchSelectedItem();
          }
        }

        if ($$self.$$.dirty[0] &
        /*value, isMulti*/
        132 | $$self.$$.dirty[2] &
        /*prev_value*/
        32768) {
          {
            if (!value && isMulti && prev_value) {
              dispatch('select', value);
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*isFocused*/
        2 | $$self.$$.dirty[2] &
        /*prev_isFocused*/
        131072) {
          {
            if (isFocused !== prev_isFocused) {
              setupFocus();
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*filterText*/
        8 | $$self.$$.dirty[2] &
        /*prev_filterText*/
        65536) {
          {
            if (filterText !== prev_filterText) {
              setupFilterText();
            }
          }
        }

        if ($$self.$$.dirty[0] &
        /*value, filterText*/
        12) {
          $$invalidate(29, showSelectedItem = value && filterText.length === 0);
        }

        if ($$self.$$.dirty[0] &
        /*showSelectedItem, isClearable, isDisabled, isWaiting*/
        536904208) {
          $$invalidate(37, showClearIcon = showSelectedItem && isClearable && !isDisabled && !isWaiting);
        }

        if ($$self.$$.dirty[0] &
        /*isMulti, value*/
        132 | $$self.$$.dirty[1] &
        /*placeholderAlwaysShow, placeholder*/
        393216) {
          $$invalidate(36, placeholderText = placeholderAlwaysShow && isMulti ? placeholder : value ? '' : placeholder);
        }

        if ($$self.$$.dirty[0] &
        /*isMulti, value*/
        132) {
          $$invalidate(35, showMultiSelect = isMulti && value && value.length > 0);
        }

        if ($$self.$$.dirty[0] &
        /*filterText, value, isMulti, container*/
        141 | $$self.$$.dirty[1] &
        /*optionIdentifier, getGroupHeaderLabel, getOptionLabel*/
        218103808 | $$self.$$.dirty[2] &
        /*Item, noOptionsMessage, hideEmptyState, isVirtualList, VirtualList, filteredItems, itemHeight, listPlacement, listAutoWidth, listOffset*/
        526326) {
          $$invalidate(34, listProps = {
            Item,
            filterText,
            optionIdentifier,
            noOptionsMessage,
            hideEmptyState,
            isVirtualList,
            VirtualList: VirtualList$1,
            value,
            isMulti,
            getGroupHeaderLabel,
            items: filteredItems,
            itemHeight,
            getOptionLabel,
            listPlacement,
            parent: container,
            listAutoWidth,
            listOffset
          });
        }

        if ($$self.$$.dirty[0] &
        /*value, isMulti*/
        132) {
          $$invalidate(33, ariaSelection = value ? handleAriaSelection() : '');
        }

        if ($$self.$$.dirty[0] &
        /*hoverItemIndex, isFocused, listOpen*/
        268435490 | $$self.$$.dirty[2] &
        /*filteredItems*/
        524288) {
          $$invalidate(32, ariaContext = handleAriaContent());
        }
      };

      return [container, isFocused, value, filterText, isWaiting, listOpen, input, isMulti, multiFullItemClearable, isDisabled, hasError, containerStyles, getSelectionLabel, isSearchable, inputStyles, isClearable, inputAttributes, Icon, iconProps, showChevron, showIndicator, containerClasses, indicatorSvg, ClearIcon$1, List$1, Selection$1, MultiSelection$1, handleClear, hoverItemIndex, showSelectedItem, activeValue, _inputAttributes, ariaContext, ariaSelection, listProps, showMultiSelect, placeholderText, showClearIcon, handleMultiItemClear, handleKeyDown, handleFocus, handleWindowEvent, handleClick, itemSelected, itemCreated, closeList, id, isCreatable, placeholder, placeholderAlwaysShow, items, itemFilter, groupBy, groupFilter, isGroupHeaderSelectable, getGroupHeaderLabel, labelIdentifier, getOptionLabel, optionIdentifier, loadOptions, createGroupHeaderItem, createItem, getFilteredItems, listPlacement, isVirtualList, loadOptionsInterval, noOptionsMessage, hideEmptyState, listAutoWidth, itemHeight, listOffset, Item, VirtualList$1, selectedValue, ariaValues, ariaListOpen, ariaFocused, prev_value, prev_filterText, prev_isFocused, prev_isMulti, filteredItems, input_1_binding, input_1_input_handler, switch_instance_hoverItemIndex_binding, div_binding];
    }

    class Select extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$b, create_fragment$b, safe_not_equal, {
          id: 46,
          container: 0,
          input: 6,
          isMulti: 7,
          multiFullItemClearable: 8,
          isDisabled: 9,
          isCreatable: 47,
          isFocused: 1,
          value: 2,
          filterText: 3,
          placeholder: 48,
          placeholderAlwaysShow: 49,
          items: 50,
          itemFilter: 51,
          groupBy: 52,
          groupFilter: 53,
          isGroupHeaderSelectable: 54,
          getGroupHeaderLabel: 55,
          labelIdentifier: 56,
          getOptionLabel: 57,
          optionIdentifier: 58,
          loadOptions: 59,
          hasError: 10,
          containerStyles: 11,
          getSelectionLabel: 12,
          createGroupHeaderItem: 60,
          createItem: 61,
          getFilteredItems: 62,
          isSearchable: 13,
          inputStyles: 14,
          isClearable: 15,
          isWaiting: 4,
          listPlacement: 63,
          listOpen: 5,
          isVirtualList: 64,
          loadOptionsInterval: 65,
          noOptionsMessage: 66,
          hideEmptyState: 67,
          inputAttributes: 16,
          listAutoWidth: 68,
          itemHeight: 69,
          Icon: 17,
          iconProps: 18,
          showChevron: 19,
          showIndicator: 20,
          containerClasses: 21,
          indicatorSvg: 22,
          listOffset: 70,
          ClearIcon: 23,
          Item: 71,
          List: 24,
          Selection: 25,
          MultiSelection: 26,
          VirtualList: 72,
          selectedValue: 73,
          handleClear: 27,
          ariaValues: 74,
          ariaListOpen: 75,
          ariaFocused: 76
        }, add_css, [-1, -1, -1, -1]);
      }

      get getFilteredItems() {
        return this.$$.ctx[62];
      }

      get handleClear() {
        return this.$$.ctx[27];
      }

    }

    var dist$1 = createCommonjsModule$1(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getRootUrl = exports.generateFilePath = exports.imagePath = exports.generateUrl = exports.generateOcsUrl = exports.generateRemoteUrl = exports.linkTo = void 0;

     /// <reference types="@nextcloud/typings" />

    /**
     * Get an url with webroot to a file in an app
     *
     * @param {string} app the id of the app the file belongs to
     * @param {string} file the file path relative to the app folder
     * @return {string} URL with webroot to a file
     */


    const linkTo = (app, file) => generateFilePath(app, '', file);
    /**
     * Creates a relative url for remote use
     *
     * @param {string} service id
     * @return {string} the url
     */


    exports.linkTo = linkTo;

    const linkToRemoteBase = service => getRootUrl() + '/remote.php/' + service;
    /**
     * @brief Creates an absolute url for remote use
     * @param {string} service id
     * @return {string} the url
     */


    const generateRemoteUrl = service => window.location.protocol + '//' + window.location.host + linkToRemoteBase(service);
    /**
     * Get the base path for the given OCS API service
     *
     * @param {string} url OCS API service url
     * @param {object} params parameters to be replaced into the service url
     * @param {UrlOptions} options options for the parameter replacement
     * @param {boolean} options.escape Set to false if parameters should not be URL encoded (default true)
     * @param {Number} options.ocsVersion OCS version to use (defaults to 2)
     * @return {string} Absolute path for the OCS URL
     */


    exports.generateRemoteUrl = generateRemoteUrl;

    const generateOcsUrl = (url, params, options) => {
      const allOptions = Object.assign({
        ocsVersion: 2
      }, options || {});
      const version = allOptions.ocsVersion === 1 ? 1 : 2;
      return window.location.protocol + '//' + window.location.host + getRootUrl() + '/ocs/v' + version + '.php' + _generateUrlPath(url, params, options);
    };

    exports.generateOcsUrl = generateOcsUrl;
    /**
     * Generate a url path, which can contain parameters
     *
     * Parameters will be URL encoded automatically
     *
     * @param {string} url address (can contain placeholders e.g. /call/{token} would replace {token} with the value of params.token
     * @param {object} params parameters to be replaced into the address
     * @param {UrlOptions} options options for the parameter replacement
     * @return {string} Path part for the given URL
     */

    const _generateUrlPath = (url, params, options) => {
      const allOptions = Object.assign({
        escape: true
      }, options || {});

      const _build = function (text, vars) {
        vars = vars || {};
        return text.replace(/{([^{}]*)}/g, function (a, b) {
          var r = vars[b];

          if (allOptions.escape) {
            return typeof r === 'string' || typeof r === 'number' ? encodeURIComponent(r.toString()) : encodeURIComponent(a);
          } else {
            return typeof r === 'string' || typeof r === 'number' ? r.toString() : a;
          }
        });
      };

      if (url.charAt(0) !== '/') {
        url = '/' + url;
      }

      return _build(url, params || {});
    };
    /**
     * Generate the url with webroot for the given relative url, which can contain parameters
     *
     * Parameters will be URL encoded automatically
     *
     * @param {string} url address (can contain placeholders e.g. /call/{token} would replace {token} with the value of params.token
     * @param {object} params parameters to be replaced into the url
     * @param {UrlOptions} options options for the parameter replacement
     * @param {boolean} options.noRewrite True if you want to force index.php being added
     * @param {boolean} options.escape Set to false if parameters should not be URL encoded (default true)
     * @return {string} URL with webroot for the given relative URL
     */


    const generateUrl = (url, params, options) => {
      const allOptions = Object.assign({
        noRewrite: false
      }, options || {});

      if (OC.config.modRewriteWorking === true && !allOptions.noRewrite) {
        return getRootUrl() + _generateUrlPath(url, params, options);
      }

      return getRootUrl() + '/index.php' + _generateUrlPath(url, params, options);
    };
    /**
     * Get the path with webroot to an image file
     * if no extension is given for the image, it will automatically decide
     * between .png and .svg based on what the browser supports
     *
     * @param {string} app the app id to which the image belongs
     * @param {string} file the name of the image file
     * @return {string}
     */


    exports.generateUrl = generateUrl;

    const imagePath = (app, file) => {
      if (file.indexOf('.') === -1) {
        //if no extension is given, use svg
        return generateFilePath(app, 'img', file + '.svg');
      }

      return generateFilePath(app, 'img', file);
    };
    /**
     * Get the url with webroot for a file in an app
     *
     * @param {string} app the id of the app
     * @param {string} type the type of the file to link to (e.g. css,img,ajax.template)
     * @param {string} file the filename
     * @return {string} URL with webroot for a file in an app
     */


    exports.imagePath = imagePath;

    const generateFilePath = (app, type, file) => {
      const isCore = OC.coreApps.indexOf(app) !== -1;
      let link = getRootUrl();

      if (file.substring(file.length - 3) === 'php' && !isCore) {
        link += '/index.php/apps/' + app;

        if (file !== 'index.php') {
          link += '/';

          if (type) {
            link += encodeURI(type + '/');
          }

          link += file;
        }
      } else if (file.substring(file.length - 3) !== 'php' && !isCore) {
        link = OC.appswebroots[app];

        if (type) {
          link += '/' + type + '/';
        }

        if (link.substring(link.length - 1) !== '/') {
          link += '/';
        }

        link += file;
      } else {
        if ((app === 'settings' || app === 'core' || app === 'search') && type === 'ajax') {
          link += '/index.php/';
        } else {
          link += '/';
        }

        if (!isCore) {
          link += 'apps/';
        }

        if (app !== '') {
          app += '/';
          link += app;
        }

        if (type) {
          link += type + '/';
        }

        link += file;
      }

      return link;
    };
    /**
     * Return the web root path where this Nextcloud instance
     * is accessible, with a leading slash.
     * For example "/nextcloud".
     *
     * @return {string} web root path
     */


    exports.generateFilePath = generateFilePath;

    const getRootUrl = () => OC.webroot;

    exports.getRootUrl = getRootUrl;
    });

    unwrapExports(dist$1);
    dist$1.getRootUrl;
    dist$1.generateFilePath;
    dist$1.imagePath;
    var dist_4 = dist$1.generateUrl;
    var dist_5 = dist$1.generateOcsUrl;
    dist$1.generateRemoteUrl;
    dist$1.linkTo;

    function get_each_context$3(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[16] = list[i];
      return child_ctx;
    } // (78:0) {#if dialogVisible}


    function create_if_block$6(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot$2]
          },
          $$scope: {
            ctx: ctx
          }
        }
      });
      return {
        c: function c() {
          create_component(overlay.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var overlay_changes = {};

          if (dirty &
          /*$$scope, sharees, deleteShareAction, requestToken, clientUuid, loading, selectedSharee*/
          524638) {
            overlay_changes.$$scope = {
              dirty: dirty,
              ctx: ctx
            };
          }

          overlay.$set(overlay_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    } // (94:4) {#if !sharees || !sharees.length}


    function create_if_block_1$3(ctx) {
      var p;
      var em;
      return {
        c: function c() {
          p = element("p");
          em = element("em");
          em.textContent = "".concat(dist_10("timemanager", "You haven't shared this client with anyone"));
        },
        m: function m(target, anchor) {
          insert(target, p, anchor);
          append(p, em);
        },
        p: noop$1,
        d: function d(detaching) {
          if (detaching) detach(p);
        }
      };
    } // (100:5) {#each sharees as sharee}


    function create_each_block$3(ctx) {
      var li;
      var figure;
      var img;
      var img_src_value;
      var img_srcset_value;
      var t0;
      var figcaption;
      var t1_value = (
      /*sharee*/
      ctx[16].recipient_display_name ||
      /*sharee*/
      ctx[16].recipient_user_id) + "";
      var t1;
      var t2;
      var form_1;
      var input0;
      var t3;
      var input1;
      var input1_value_value;
      var t4;
      var input2;
      var t5;
      var button;
      var t7;
      return {
        c: function c() {
          li = element("li");
          figure = element("figure");
          img = element("img");
          t0 = space$1();
          figcaption = element("figcaption");
          t1 = text(t1_value);
          t2 = space$1();
          form_1 = element("form");
          input0 = element("input");
          t3 = space$1();
          input1 = element("input");
          t4 = space$1();
          input2 = element("input");
          t5 = space$1();
          button = element("button");
          button.textContent = "".concat(dist_10("timemanager", "Delete"));
          t7 = space$1();
          if (!src_url_equal(img.src, img_src_value = dist_4("avatar/".concat(
          /*sharee*/
          ctx[16].recipient_user_id, "/32")))) attr(img, "src", img_src_value);
          attr(img, "srcset", img_srcset_value = "".concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[16].recipient_user_id, "/32")), " 1x, ").concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[16].recipient_user_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[16].recipient_user_id, "/128")), " 4x"));
          attr(img, "alt", "");
          attr(input0, "type", "hidden");
          attr(input0, "name", "client_uuid");
          input0.value =
          /*clientUuid*/
          ctx[3];
          attr(input1, "type", "hidden");
          attr(input1, "name", "uuid");
          input1.value = input1_value_value =
          /*sharee*/
          ctx[16].uuid;
          attr(input2, "type", "hidden");
          attr(input2, "name", "requesttoken");
          input2.value =
          /*requestToken*/
          ctx[4];
          attr(button, "type", "submit");
          attr(button, "name", "action");
          button.value = "delete";
          attr(button, "class", "btn small");
          attr(form_1, "action",
          /*deleteShareAction*/
          ctx[1]);
          attr(form_1, "method", "post");
        },
        m: function m(target, anchor) {
          insert(target, li, anchor);
          append(li, figure);
          append(figure, img);
          append(figure, t0);
          append(figure, figcaption);
          append(figcaption, t1);
          append(li, t2);
          append(li, form_1);
          append(form_1, input0);
          append(form_1, t3);
          append(form_1, input1);
          append(form_1, t4);
          append(form_1, input2);
          append(form_1, t5);
          append(form_1, button);
          append(li, t7);
        },
        p: function p(ctx, dirty) {
          if (dirty &
          /*sharees*/
          4 && !src_url_equal(img.src, img_src_value = dist_4("avatar/".concat(
          /*sharee*/
          ctx[16].recipient_user_id, "/32")))) {
            attr(img, "src", img_src_value);
          }

          if (dirty &
          /*sharees*/
          4 && img_srcset_value !== (img_srcset_value = "".concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[16].recipient_user_id, "/32")), " 1x, ").concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[16].recipient_user_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[16].recipient_user_id, "/128")), " 4x"))) {
            attr(img, "srcset", img_srcset_value);
          }

          if (dirty &
          /*sharees*/
          4 && t1_value !== (t1_value = (
          /*sharee*/
          ctx[16].recipient_display_name ||
          /*sharee*/
          ctx[16].recipient_user_id) + "")) set_data(t1, t1_value);

          if (dirty &
          /*clientUuid*/
          8) {
            input0.value =
            /*clientUuid*/
            ctx[3];
          }

          if (dirty &
          /*sharees*/
          4 && input1_value_value !== (input1_value_value =
          /*sharee*/
          ctx[16].uuid)) {
            input1.value = input1_value_value;
          }

          if (dirty &
          /*requestToken*/
          16) {
            input2.value =
            /*requestToken*/
            ctx[4];
          }

          if (dirty &
          /*deleteShareAction*/
          2) {
            attr(form_1, "action",
            /*deleteShareAction*/
            ctx[1]);
          }
        },
        d: function d(detaching) {
          if (detaching) detach(li);
        }
      };
    } // (79:1) <Overlay>


    function create_default_slot$2(ctx) {
      var div2;
      var label;
      var t0_value = dist_10("timemanager", "Share with") + "";
      var t0;
      var t1;
      var select;
      var t2;
      var div0;
      var h4;
      var t4;
      var t5;
      var ul;
      var t6;
      var aside;
      var p0;
      var t8;
      var p1;
      var t10;
      var p2;
      var t12;
      var div1;
      var button0;
      var t14;
      var button1;
      var current;
      var mounted;
      var dispose;
      select = new Select({
        props: {
          noOptionsMessage:
          /*loading*/
          ctx[8] ? dist_10("timemanager", "Loading...") : dist_10("timemanager", "No options"),
          placeholder: dist_10("timemanager", "Search..."),
          inputAttributes: {
            id: "sharee-select"
          },
          loadOptions:
          /*search*/
          ctx[10],
          value:
          /*selectedSharee*/
          ctx[6]
        }
      });
      select.$on("select",
      /*handleSelectSharee*/
      ctx[12]);
      var if_block = (!
      /*sharees*/
      ctx[2] || !
      /*sharees*/
      ctx[2].length) && create_if_block_1$3();
      var each_value =
      /*sharees*/
      ctx[2];
      var each_blocks = [];

      for (var i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
      }

      return {
        c: function c() {
          div2 = element("div");
          label = element("label");
          t0 = text(t0_value);
          t1 = space$1();
          create_component(select.$$.fragment);
          t2 = space$1();
          div0 = element("div");
          h4 = element("h4");
          h4.textContent = "".concat(dist_10("timemanager", "Existing shares"));
          t4 = space$1();
          if (if_block) if_block.c();
          t5 = space$1();
          ul = element("ul");

          for (var _i = 0; _i < each_blocks.length; _i += 1) {
            each_blocks[_i].c();
          }

          t6 = space$1();
          aside = element("aside");
          p0 = element("p");
          p0.textContent = "".concat(dist_10("timemanager", "You automatically grant read-only access to projects and tasks by sharing."));
          t8 = space$1();
          p1 = element("p");
          p1.textContent = "".concat(dist_10("timemanager", "Users you share with can create time entries."));
          t10 = space$1();
          p2 = element("p");
          p2.textContent = "".concat(dist_10("timemanager", "You can see all time entries, while others can only see and edit their own time entries."));
          t12 = space$1();
          div1 = element("div");
          button0 = element("button");
          button0.textContent = "".concat(dist_10("timemanager", "Add"));
          t14 = space$1();
          button1 = element("button");
          button1.textContent = "".concat(dist_10("timemanager", "Cancel"));
          attr(label, "for", "sharee-select");
          attr(label, "class", "sharees");
          attr(h4, "class", "tm_label");
          attr(div0, "class", "sharee-list");
          attr(button0, "class", "button primary");
          attr(button1, "class", "button");
          attr(div1, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(div2, "class", "inner tm_new-item sharing-dialog");
        },
        m: function m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, label);
          append(label, t0);
          append(label, t1);
          mount_component(select, label, null);
          append(div2, t2);
          append(div2, div0);
          append(div0, h4);
          append(div0, t4);
          if (if_block) if_block.m(div0, null);
          append(div0, t5);
          append(div0, ul);

          for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
            each_blocks[_i2].m(ul, null);
          }

          append(div0, t6);
          append(div0, aside);
          append(aside, p0);
          append(aside, t8);
          append(aside, p1);
          append(aside, t10);
          append(aside, p2);
          append(div2, t12);
          append(div2, div1);
          append(div1, button0);
          append(div1, t14);
          append(div1, button1);
          current = true;

          if (!mounted) {
            dispose = [listen(button0, "click", prevent_default(
            /*addShare*/
            ctx[9])), listen(button1, "click", prevent_default(
            /*closeDialog*/
            ctx[11]))];
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          var select_changes = {};
          if (dirty &
          /*loading*/
          256) select_changes.noOptionsMessage =
          /*loading*/
          ctx[8] ? dist_10("timemanager", "Loading...") : dist_10("timemanager", "No options");
          if (dirty &
          /*selectedSharee*/
          64) select_changes.value =
          /*selectedSharee*/
          ctx[6];
          select.$set(select_changes);

          if (!
          /*sharees*/
          ctx[2] || !
          /*sharees*/
          ctx[2].length) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_1$3();
              if_block.c();
              if_block.m(div0, t5);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty &
          /*deleteShareAction, translate, requestToken, sharees, clientUuid, generateUrl*/
          30) {
            each_value =
            /*sharees*/
            ctx[2];

            var _i3;

            for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
              var child_ctx = get_each_context$3(ctx, each_value, _i3);

              if (each_blocks[_i3]) {
                each_blocks[_i3].p(child_ctx, dirty);
              } else {
                each_blocks[_i3] = create_each_block$3(child_ctx);

                each_blocks[_i3].c();

                each_blocks[_i3].m(ul, null);
              }
            }

            for (; _i3 < each_blocks.length; _i3 += 1) {
              each_blocks[_i3].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(select.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(select.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          if (detaching) detach(div2);
          destroy_component(select);
          if (if_block) if_block.d();
          destroy_each(each_blocks, detaching);
          mounted = false;
          run_all(dispose);
        }
      };
    }

    function create_fragment$a(ctx) {
      var t0;
      var form_1;
      var input0;
      var t1;
      var input1;
      var input1_value_value;
      var t2;
      var input2;
      var t3;
      var button;
      var current;
      var if_block =
      /*dialogVisible*/
      ctx[7] && create_if_block$6(ctx);
      return {
        c: function c() {
          if (if_block) if_block.c();
          t0 = space$1();
          form_1 = element("form");
          input0 = element("input");
          t1 = space$1();
          input1 = element("input");
          t2 = space$1();
          input2 = element("input");
          t3 = space$1();
          button = element("button");
          button.textContent = "".concat(dist_10("timemanager", "Share client"));
          attr(input0, "type", "hidden");
          attr(input0, "name", "client_uuid");
          input0.value =
          /*clientUuid*/
          ctx[3];
          attr(input1, "type", "hidden");
          attr(input1, "name", "user_id");
          input1.value = input1_value_value =
          /*selectedSharee*/
          ctx[6] ?
          /*selectedSharee*/
          ctx[6].value.shareWith : "";
          attr(input2, "type", "hidden");
          attr(input2, "name", "requesttoken");
          input2.value =
          /*requestToken*/
          ctx[4];
          attr(button, "type", "submit");
          attr(button, "name", "action");
          button.value = "share";
          attr(button, "class", "btn");
          attr(form_1, "action",
          /*shareAction*/
          ctx[0]);
          attr(form_1, "method", "post");
        },
        m: function m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, t0, anchor);
          insert(target, form_1, anchor);
          append(form_1, input0);
          append(form_1, t1);
          append(form_1, input1);
          append(form_1, t2);
          append(form_1, input2);
          append(form_1, t3);
          append(form_1, button);
          /*form_1_binding*/

          ctx[14](form_1);
          current = true;
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (
          /*dialogVisible*/
          ctx[7]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*dialogVisible*/
              128) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$6(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(t0.parentNode, t0);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }

          if (!current || dirty &
          /*clientUuid*/
          8) {
            input0.value =
            /*clientUuid*/
            ctx[3];
          }

          if (!current || dirty &
          /*selectedSharee*/
          64 && input1_value_value !== (input1_value_value =
          /*selectedSharee*/
          ctx[6] ?
          /*selectedSharee*/
          ctx[6].value.shareWith : "")) {
            input1.value = input1_value_value;
          }

          if (!current || dirty &
          /*requestToken*/
          16) {
            input2.value =
            /*requestToken*/
            ctx[4];
          }

          if (!current || dirty &
          /*shareAction*/
          1) {
            attr(form_1, "action",
            /*shareAction*/
            ctx[0]);
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function o(local) {
          transition_out(if_block);
          current = false;
        },
        d: function d(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach(t0);
          if (detaching) detach(form_1);
          /*form_1_binding*/

          ctx[14](null);
        }
      };
    }

    function instance$a($$self, $$props, $$invalidate) {
      var dialogVisible;
      var loading;
      var shareAction = $$props.shareAction;
      var deleteShareAction = $$props.deleteShareAction;
      var sharees = $$props.sharees;
      var clientUuid = $$props.clientUuid;
      var requestToken = $$props.requestToken;
      var userId = $$props.userId;
      var form;
      var selectedSharee;
      onMount(function () {
        Helpers.hideFallbacks("ShareDialog.svelte");

        if (form) {
          form.addEventListener("submit", submit);
          return function () {
            form.removeEventListener("submit", submit);
          };
        }
      });

      var submit = function submit(e) {
        e.preventDefault();
        $$invalidate(7, dialogVisible = true);
      };

      var addShare = function addShare() {
        form.submit();
      };

      var search = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(query) {
          var response, _yield$response$json$, users, exact, existing;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(typeof query === "undefined")) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return");

                case 2:
                  $$invalidate(8, loading = true);
                  _context.next = 5;
                  return fetch(dist_5("apps/files_sharing/api/v1/sharees?search=".concat(query, "&format=json&perPage=20&itemType=[0]")), {
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });

                case 5:
                  response = _context.sent;
                  $$invalidate(8, loading = false);

                  if (!response.ok) {
                    _context.next = 15;
                    break;
                  }

                  _context.next = 10;
                  return response.json();

                case 10:
                  _yield$response$json$ = _context.sent.ocs.data;
                  users = _yield$response$json$.users;
                  exact = _yield$response$json$.exact;
                  existing = sharees.map(function (share) {
                    return share.recipient_user_id;
                  });
                  return _context.abrupt("return", [].concat(_toConsumableArray(users), _toConsumableArray(exact.users)).filter(function (user) {
                    return !existing.includes(user.value.shareWith) && user.value.shareWith !== userId;
                  }));

                case 15:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function search(_x) {
          return _ref3.apply(this, arguments);
        };
      }();

      var closeDialog = function closeDialog() {
        $$invalidate(7, dialogVisible = false);
      };

      var handleSelectSharee = function handleSelectSharee(event) {
        $$invalidate(6, selectedSharee = event.detail);
      };

      function form_1_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          form = $$value;
          $$invalidate(5, form);
        });
      }

      $$self.$$set = function ($$props) {
        if ('shareAction' in $$props) $$invalidate(0, shareAction = $$props.shareAction);
        if ('deleteShareAction' in $$props) $$invalidate(1, deleteShareAction = $$props.deleteShareAction);
        if ('sharees' in $$props) $$invalidate(2, sharees = $$props.sharees);
        if ('clientUuid' in $$props) $$invalidate(3, clientUuid = $$props.clientUuid);
        if ('requestToken' in $$props) $$invalidate(4, requestToken = $$props.requestToken);
        if ('userId' in $$props) $$invalidate(13, userId = $$props.userId);
      };

      $$invalidate(7, dialogVisible = false);

      $$invalidate(8, loading = false);

      return [shareAction, deleteShareAction, sharees, clientUuid, requestToken, form, selectedSharee, dialogVisible, loading, addShare, search, closeDialog, handleSelectSharee, userId, form_1_binding];
    }

    var ShareDialog = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(ShareDialog, _SvelteComponent);

      var _super = _createSuper(ShareDialog);

      function ShareDialog(options) {
        var _this;

        _classCallCheck$1(this, ShareDialog);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$a, create_fragment$a, safe_not_equal, {
          shareAction: 0,
          deleteShareAction: 1,
          sharees: 2,
          clientUuid: 3,
          requestToken: 4,
          userId: 13
        });
        return _this;
      }

      return _createClass$1(ShareDialog);
    }(SvelteComponent);

    function get_each_context$2(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[2] = list[i];
      child_ctx[4] = i;
      return child_ctx;
    } // (15:0) {#if sharees && sharees.length}


    function create_if_block_1$2(ctx) {
      var span;
      var t1;
      var ul;
      var each_value =
      /*sharees*/
      ctx[0];
      var each_blocks = [];

      for (var i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
      }

      return {
        c: function c() {
          span = element("span");
          span.textContent = "".concat(dist_10("timemanager", "Shared with"));
          t1 = space$1();
          ul = element("ul");

          for (var _i = 0; _i < each_blocks.length; _i += 1) {
            each_blocks[_i].c();
          }

          attr(span, "class", "tm_label");
          attr(ul, "class", "existing-sharees");
        },
        m: function m(target, anchor) {
          insert(target, span, anchor);
          insert(target, t1, anchor);
          insert(target, ul, anchor);

          for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
            each_blocks[_i2].m(ul, null);
          }
        },
        p: function p(ctx, dirty) {
          if (dirty &
          /*sharees, generateUrl*/
          1) {
            each_value =
            /*sharees*/
            ctx[0];

            var _i3;

            for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
              var child_ctx = get_each_context$2(ctx, each_value, _i3);

              if (each_blocks[_i3]) {
                each_blocks[_i3].p(child_ctx, dirty);
              } else {
                each_blocks[_i3] = create_each_block$2(child_ctx);

                each_blocks[_i3].c();

                each_blocks[_i3].m(ul, null);
              }
            }

            for (; _i3 < each_blocks.length; _i3 += 1) {
              each_blocks[_i3].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function d(detaching) {
          if (detaching) detach(span);
          if (detaching) detach(t1);
          if (detaching) detach(ul);
          destroy_each(each_blocks, detaching);
        }
      };
    } // (18:2) {#each sharees as sharee, index}


    function create_each_block$2(ctx) {
      var li;
      var img;
      var img_src_value;
      var img_srcset_value;
      var t0;
      var t1_value = (
      /*sharee*/
      ctx[2].recipient_display_name ||
      /*sharee*/
      ctx[2].recipient_user_id) + "";
      var t1;
      var t2;
      return {
        c: function c() {
          li = element("li");
          img = element("img");
          t0 = space$1();
          t1 = text(t1_value);
          t2 = space$1();
          if (!src_url_equal(img.src, img_src_value = dist_4("avatar/".concat(
          /*sharee*/
          ctx[2].recipient_user_id, "/32")))) attr(img, "src", img_src_value);
          attr(img, "srcset", img_srcset_value = "".concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[2].recipient_user_id, "/32")), " 1x, ").concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[2].recipient_user_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[2].recipient_user_id, "/128")), " 4x"));
          attr(img, "alt", "");
        },
        m: function m(target, anchor) {
          insert(target, li, anchor);
          append(li, img);
          append(li, t0);
          append(li, t1);
          append(li, t2);
        },
        p: function p(ctx, dirty) {
          if (dirty &
          /*sharees*/
          1 && !src_url_equal(img.src, img_src_value = dist_4("avatar/".concat(
          /*sharee*/
          ctx[2].recipient_user_id, "/32")))) {
            attr(img, "src", img_src_value);
          }

          if (dirty &
          /*sharees*/
          1 && img_srcset_value !== (img_srcset_value = "".concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[2].recipient_user_id, "/32")), " 1x, ").concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[2].recipient_user_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_4("avatar/".concat(
          /*sharee*/
          ctx[2].recipient_user_id, "/128")), " 4x"))) {
            attr(img, "srcset", img_srcset_value);
          }

          if (dirty &
          /*sharees*/
          1 && t1_value !== (t1_value = (
          /*sharee*/
          ctx[2].recipient_display_name ||
          /*sharee*/
          ctx[2].recipient_user_id) + "")) set_data(t1, t1_value);
        },
        d: function d(detaching) {
          if (detaching) detach(li);
        }
      };
    } // (34:0) {#if sharedBy}


    function create_if_block$5(ctx) {
      var span;
      var t1;
      var ul;
      var li;
      var img;
      var img_src_value;
      var img_srcset_value;
      var t2;
      var t3_value = (
      /*sharedBy*/
      ctx[1].author_display_name ||
      /*sharedBy*/
      ctx[1].author_user_id) + "";
      var t3;
      return {
        c: function c() {
          span = element("span");
          span.textContent = "".concat(dist_10("timemanager", "Shared with you by"));
          t1 = space$1();
          ul = element("ul");
          li = element("li");
          img = element("img");
          t2 = space$1();
          t3 = text(t3_value);
          attr(span, "class", "tm_label");
          if (!src_url_equal(img.src, img_src_value = dist_4("avatar/".concat(
          /*sharedBy*/
          ctx[1].author_user_id, "/32")))) attr(img, "src", img_src_value);
          attr(img, "srcset", img_srcset_value = "".concat(dist_4("avatar/".concat(
          /*sharedBy*/
          ctx[1].author_user_id, "/32")), " 1x, ").concat(dist_4("avatar/".concat(
          /*sharedBy*/
          ctx[1].author_user_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_4("avatar/".concat(
          /*sharedBy*/
          ctx[1].author_user_id, "/128")), " 4x"));
          attr(img, "alt", "");
          attr(ul, "class", "existing-sharees");
        },
        m: function m(target, anchor) {
          insert(target, span, anchor);
          insert(target, t1, anchor);
          insert(target, ul, anchor);
          append(ul, li);
          append(li, img);
          append(li, t2);
          append(li, t3);
        },
        p: function p(ctx, dirty) {
          if (dirty &
          /*sharedBy*/
          2 && !src_url_equal(img.src, img_src_value = dist_4("avatar/".concat(
          /*sharedBy*/
          ctx[1].author_user_id, "/32")))) {
            attr(img, "src", img_src_value);
          }

          if (dirty &
          /*sharedBy*/
          2 && img_srcset_value !== (img_srcset_value = "".concat(dist_4("avatar/".concat(
          /*sharedBy*/
          ctx[1].author_user_id, "/32")), " 1x, ").concat(dist_4("avatar/".concat(
          /*sharedBy*/
          ctx[1].author_user_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_4("avatar/".concat(
          /*sharedBy*/
          ctx[1].author_user_id, "/128")), " 4x"))) {
            attr(img, "srcset", img_srcset_value);
          }

          if (dirty &
          /*sharedBy*/
          2 && t3_value !== (t3_value = (
          /*sharedBy*/
          ctx[1].author_display_name ||
          /*sharedBy*/
          ctx[1].author_user_id) + "")) set_data(t3, t3_value);
        },
        d: function d(detaching) {
          if (detaching) detach(span);
          if (detaching) detach(t1);
          if (detaching) detach(ul);
        }
      };
    }

    function create_fragment$9(ctx) {
      var t;
      var if_block1_anchor;
      var if_block0 =
      /*sharees*/
      ctx[0] &&
      /*sharees*/
      ctx[0].length && create_if_block_1$2(ctx);
      var if_block1 =
      /*sharedBy*/
      ctx[1] && create_if_block$5(ctx);
      return {
        c: function c() {
          if (if_block0) if_block0.c();
          t = space$1();
          if (if_block1) if_block1.c();
          if_block1_anchor = empty();
        },
        m: function m(target, anchor) {
          if (if_block0) if_block0.m(target, anchor);
          insert(target, t, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert(target, if_block1_anchor, anchor);
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (
          /*sharees*/
          ctx[0] &&
          /*sharees*/
          ctx[0].length) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_1$2(ctx);
              if_block0.c();
              if_block0.m(t.parentNode, t);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*sharedBy*/
          ctx[1]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block$5(ctx);
              if_block1.c();
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
        },
        i: noop$1,
        o: noop$1,
        d: function d(detaching) {
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach(t);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach(if_block1_anchor);
        }
      };
    }

    function instance$9($$self, $$props, $$invalidate) {
      var sharees = $$props.sharees;
      var sharedBy = $$props.sharedBy;
      onMount(function () {
        Helpers.hideFallbacks("ShareDialog.svelte");
      });

      $$self.$$set = function ($$props) {
        if ('sharees' in $$props) $$invalidate(0, sharees = $$props.sharees);
        if ('sharedBy' in $$props) $$invalidate(1, sharedBy = $$props.sharedBy);
      };

      return [sharees, sharedBy];
    }

    var ShareStatus = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(ShareStatus, _SvelteComponent);

      var _super = _createSuper(ShareStatus);

      function ShareStatus(options) {
        var _this;

        _classCallCheck$1(this, ShareStatus);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$9, create_fragment$9, safe_not_equal, {
          sharees: 0,
          sharedBy: 1
        });
        return _this;
      }

      return _createClass$1(ShareStatus);
    }(SvelteComponent);

    function create_if_block$4(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot$1]
          },
          $$scope: {
            ctx: ctx
          }
        }
      });
      return {
        c: function c() {
          create_component(overlay.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var overlay_changes = {};

          if (dirty &
          /*$$scope*/
          128) {
            overlay_changes.$$scope = {
              dirty: dirty,
              ctx: ctx
            };
          }

          overlay.$set(overlay_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    } // (56:1) <Overlay>


    function create_default_slot$1(ctx) {
      var div1;
      var t0_value = dist_10('timemanager', 'Do you want to delete this time entry?') + "";
      var t0;
      var t1;
      var div0;
      var button0;
      var t3;
      var button1;
      var mounted;
      var dispose;
      return {
        c: function c() {
          div1 = element("div");
          t0 = text(t0_value);
          t1 = space$1();
          div0 = element("div");
          button0 = element("button");
          button0.textContent = "".concat(dist_10('timemanager', 'Delete'));
          t3 = space$1();
          button1 = element("button");
          button1.textContent = "".concat(dist_10('timemanager', 'Cancel'));
          attr(button0, "class", "button primary");
          attr(button1, "class", "button");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(div1, "class", "inner tm_new-item");
        },
        m: function m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, t0);
          append(div1, t1);
          append(div1, div0);
          append(div0, button0);
          append(div0, t3);
          append(div0, button1);

          if (!mounted) {
            dispose = [listen(button0, "click", prevent_default(
            /*doDelete*/
            ctx[5])), listen(button1, "click", prevent_default(
            /*cancelDelete*/
            ctx[6]))];
            mounted = true;
          }
        },
        p: noop$1,
        d: function d(detaching) {
          if (detaching) detach(div1);
          mounted = false;
          run_all(dispose);
        }
      };
    }

    function create_fragment$8(ctx) {
      var t0;
      var form;
      var input0;
      var t1;
      var input1;
      var t2;
      var button;
      var current;
      var mounted;
      var dispose;
      var if_block =
      /*confirmation*/
      ctx[3] && create_if_block$4(ctx);
      return {
        c: function c() {
          if (if_block) if_block.c();
          t0 = space$1();
          form = element("form");
          input0 = element("input");
          t1 = space$1();
          input1 = element("input");
          t2 = space$1();
          button = element("button");
          button.textContent = "".concat(dist_10('timemanager', 'Delete'));
          attr(input0, "type", "hidden");
          attr(input0, "name", "uuid");
          input0.value =
          /*deleteTimeEntryUuid*/
          ctx[1];
          attr(input1, "type", "hidden");
          attr(input1, "name", "requesttoken");
          input1.value =
          /*requestToken*/
          ctx[2];
          attr(button, "type", "submit");
          attr(button, "name", "action");
          button.value = "delete";
          attr(button, "class", "btn");
          attr(form, "action",
          /*deleteTimeEntryAction*/
          ctx[0]);
          attr(form, "method", "post");
          attr(form, "class", "tm_inline-hover-form");
        },
        m: function m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, t0, anchor);
          insert(target, form, anchor);
          append(form, input0);
          append(form, t1);
          append(form, input1);
          append(form, t2);
          append(form, button);
          current = true;

          if (!mounted) {
            dispose = listen(form, "submit",
            /*submit*/
            ctx[4]);
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (
          /*confirmation*/
          ctx[3]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*confirmation*/
              8) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$4(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(t0.parentNode, t0);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }

          if (!current || dirty &
          /*deleteTimeEntryUuid*/
          2) {
            input0.value =
            /*deleteTimeEntryUuid*/
            ctx[1];
          }

          if (!current || dirty &
          /*requestToken*/
          4) {
            input1.value =
            /*requestToken*/
            ctx[2];
          }

          if (!current || dirty &
          /*deleteTimeEntryAction*/
          1) {
            attr(form, "action",
            /*deleteTimeEntryAction*/
            ctx[0]);
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function o(local) {
          transition_out(if_block);
          current = false;
        },
        d: function d(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach(t0);
          if (detaching) detach(form);
          mounted = false;
          dispose();
        }
      };
    }

    function instance$8($$self, $$props, $$invalidate) {
      var confirmation;
      var deleteTimeEntryAction = $$props.deleteTimeEntryAction;
      var deleteTimeEntryUuid = $$props.deleteTimeEntryUuid;
      var requestToken = $$props.requestToken;
      onMount(function () {
        Helpers.hideFallbacks("DeleteTimeEntryButton.svelte@".concat(deleteTimeEntryUuid));
      });

      var submit = function submit(e) {
        e.preventDefault();
        $$invalidate(3, confirmation = true);
      };

      var doDelete = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var _element, response;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  $$invalidate(3, confirmation = false);
                  _context.prev = 1;
                  _element = document.querySelector("#content.app-timemanager [data-remove-on-delete='".concat(deleteTimeEntryUuid, "']"));

                  if (_element) {
                    _element.classList.add("warning");
                  }

                  _context.next = 6;
                  return window.fetch(deleteTimeEntryAction, {
                    method: "POST",
                    body: JSON.stringify({
                      uuid: deleteTimeEntryUuid
                    }),
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });

                case 6:
                  response = _context.sent;

                  if (response && response.ok) {
                    _element.remove();

                    document.querySelector(".app-timemanager [data-current-link]").click();
                  }

                  _context.next = 13;
                  break;

                case 10:
                  _context.prev = 10;
                  _context.t0 = _context["catch"](1);
                  console.error(_context.t0);

                case 13:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[1, 10]]);
        }));

        return function doDelete() {
          return _ref3.apply(this, arguments);
        };
      }();

      var cancelDelete = function cancelDelete() {
        $$invalidate(3, confirmation = false);
      };

      $$self.$$set = function ($$props) {
        if ('deleteTimeEntryAction' in $$props) $$invalidate(0, deleteTimeEntryAction = $$props.deleteTimeEntryAction);
        if ('deleteTimeEntryUuid' in $$props) $$invalidate(1, deleteTimeEntryUuid = $$props.deleteTimeEntryUuid);
        if ('requestToken' in $$props) $$invalidate(2, requestToken = $$props.requestToken);
      };

      $$invalidate(3, confirmation = false);

      return [deleteTimeEntryAction, deleteTimeEntryUuid, requestToken, confirmation, submit, doDelete, cancelDelete];
    }

    var DeleteTimeEntryButton = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(DeleteTimeEntryButton, _SvelteComponent);

      var _super = _createSuper(DeleteTimeEntryButton);

      function DeleteTimeEntryButton(options) {
        var _this;

        _classCallCheck$1(this, DeleteTimeEntryButton);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$8, create_fragment$8, safe_not_equal, {
          deleteTimeEntryAction: 0,
          deleteTimeEntryUuid: 1,
          requestToken: 2
        });
        return _this;
      }

      return _createClass$1(DeleteTimeEntryButton);
    }(SvelteComponent);

    var $find = arrayIteration$1.find;



    var FIND = 'find';
    var SKIPS_HOLES = true; // Shouldn't skip holes

    if (FIND in []) Array(1)[FIND](function () {
      SKIPS_HOLES = false;
    }); // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find

    _export$1({
      target: 'Array',
      proto: true,
      forced: SKIPS_HOLES
    }, {
      find: function find(callbackfn
      /* , that = undefined */
      ) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    }); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

    addToUnscopables$1(FIND);

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read$1 = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write$1 = 'write';
    var afterWrite$1 = 'afterWrite';
    var modifierPhases = [beforeRead, read$1, afterRead, beforeMain, main, afterMain, beforeWrite, write$1, afterWrite$1];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }

    var max$1 = Math.max;
    var min$3 = Math.min;
    var round = Math.round;

    function getUAString() {
      var uaData = navigator.userAgentData;

      if (uaData != null && uaData.brands) {
        return uaData.brands.map(function (item) {
          return item.brand + "/" + item.version;
        }).join(' ');
      }

      return navigator.userAgent;
    }

    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }

    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }

      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }

      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;

      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
      }

      var _ref = isElement(element) ? getWindow(element) : window,
          visualViewport = _ref.visualViewport;

      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width: width,
        height: height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x: x,
        y: y
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains$1(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;

        do {
          if (next && parent.isSameNode(next)) {
            return true;
          } // $FlowFixMe[prop-missing]: need a better way to handle this...


          next = next.parentNode || next.host;
        } while (next);
      } // Give up, the result is false


      return false;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());

      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle$1(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    function within(min, value, max) {
      return max$1(min, min$3(value, max));
    }
    function withinMaxClamp(min, value, max) {
      var v = within(min, value, max);
      return v > max ? max : v;
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      if (process.env.NODE_ENV !== "production") {
        if (!isHTMLElement(arrowElement)) {
          console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
        }
      }

      if (!contains$1(state.elements.popper, arrowElement)) {
        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
        }

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x * dpr) / dpr || 0,
        y: round(y * dpr) / dpr || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          variation = _ref2.variation,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets,
          isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x,
          x = _offsets$x === void 0 ? 0 : _offsets$x,
          _offsets$y = offsets.y,
          y = _offsets$y === void 0 ? 0 : _offsets$y;

      var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
          offsetParent[heightProp];
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
          offsetParent[widthProp];
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref4.x;
      y = _ref4.y;

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref5) {
      var state = _ref5.state,
          options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      if (process.env.NODE_ENV !== "production") {
        var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';

        if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
          return transitionProperty.indexOf(property) >= 0;
        })) {
          console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
        }
      }

      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0;

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();

        if (layoutViewport || !layoutViewport && strategy === 'fixed') {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === 'fixed');
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max$1(rect.top, accRect.top);
        accRect.right = min$3(rect.right, accRect.right);
        accRect.bottom = min$3(rect.bottom, accRect.bottom);
        accRect.left = max$1(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$strategy = _options.strategy,
          strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;

        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
        }
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement(placement);

        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases â research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name; // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step

      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis) {
        var _offsetModifierState$;

        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min = offset + overflow[mainSide];
        var max = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min$3(min, tetherMin) : min, offset, tether ? max$1(max, tetherMax) : max);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
      }

      if (checkAltAxis) {
        var _offsetModifierState$2;

        var _mainSide = mainAxis === 'x' ? top : left;

        var _altSide = mainAxis === 'x' ? bottom : right;

        var _offset = popperOffsets[altAxis];

        var _len = altAxis === 'y' ? 'height' : 'width';

        var _min = _offset + overflow[_mainSide];

        var _max = _offset - overflow[_altSide];

        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.


    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function format$1(str) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return [].concat(args).reduce(function (p, c) {
        return p.replace(/%s/, c);
      }, str);
    }

    var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
    var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
    var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
    function validateModifiers(modifiers) {
      modifiers.forEach(function (modifier) {
        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
        .filter(function (value, index, self) {
          return self.indexOf(value) === index;
        }).forEach(function (key) {
          switch (key) {
            case 'name':
              if (typeof modifier.name !== 'string') {
                console.error(format$1(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
              }

              break;

            case 'enabled':
              if (typeof modifier.enabled !== 'boolean') {
                console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
              }

              break;

            case 'phase':
              if (modifierPhases.indexOf(modifier.phase) < 0) {
                console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
              }

              break;

            case 'fn':
              if (typeof modifier.fn !== 'function') {
                console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'effect':
              if (modifier.effect != null && typeof modifier.effect !== 'function') {
                console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'requires':
              if (modifier.requires != null && !Array.isArray(modifier.requires)) {
                console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
              }

              break;

            case 'requiresIfExists':
              if (!Array.isArray(modifier.requiresIfExists)) {
                console.error(format$1(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
              }

              break;

            case 'options':
            case 'data':
              break;

            default:
              console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
                return "\"" + s + "\"";
              }).join(', ') + "; but \"" + key + "\" was provided.");
          }

          modifier.requires && modifier.requires.forEach(function (requirement) {
            if (modifiers.find(function (mod) {
              return mod.name === requirement;
            }) == null) {
              console.error(format$1(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            }
          });
        });
      });
    }

    function uniqueBy(arr, fn) {
      var identifiers = new Set();
      return arr.filter(function (item) {
        var identifier = fn(item);

        if (!identifiers.has(identifier)) {
          identifiers.add(identifier);
          return true;
        }
      });
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
    var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(setOptionsAction) {
            var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned
            // if one of the modifiers is invalid for any reason

            if (process.env.NODE_ENV !== "production") {
              var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
                var name = _ref.name;
                return name;
              });
              validateModifiers(modifiers);

              if (getBasePlacement(state.options.placement) === auto) {
                var flipModifier = state.orderedModifiers.find(function (_ref2) {
                  var name = _ref2.name;
                  return name === 'flip';
                });

                if (!flipModifier) {
                  console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
                }
              }

              var _getComputedStyle = getComputedStyle$1(popper),
                  marginTop = _getComputedStyle.marginTop,
                  marginRight = _getComputedStyle.marginRight,
                  marginBottom = _getComputedStyle.marginBottom,
                  marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
              // cause bugs with positioning, so we'll warn the consumer


              if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
                return parseFloat(margin);
              })) {
                console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
              }
            }

            runModifierEffects();
            return instance.update();
          },
          // Sync update â it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {
              if (process.env.NODE_ENV !== "production") {
                console.error(INVALID_ELEMENT_ERROR);
              }

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            var __debug_loops__ = 0;

            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (process.env.NODE_ENV !== "production") {
                __debug_loops__ += 1;

                if (__debug_loops__ > 100) {
                  console.error(INFINITE_LOOP_ERROR);
                  break;
                }
              }

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update â it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }

        return t;
      };

      return __assign.apply(this, arguments);
    };

    function createPopperActions(initOptions) {
      var popperInstance = null;
      var referenceNode;
      var contentNode;
      var options = initOptions;

      var initPopper = function () {
        if (referenceNode && contentNode) {
          popperInstance = createPopper(referenceNode, contentNode, options);
        }
      };

      var deinitPopper = function () {
        if (popperInstance) {
          popperInstance.destroy();
          popperInstance = null;
        }
      };

      var referenceAction = function (node) {
        referenceNode = node;
        initPopper();
        return {
          destroy: function () {
            deinitPopper();
          }
        };
      };

      var contentAction = function (node, contentOptions) {
        contentNode = node;
        options = __assign(__assign({}, initOptions), contentOptions);
        initPopper();
        return {
          update: function (newContentOptions) {
            options = __assign(__assign({}, initOptions), newContentOptions);

            if (popperInstance && options) {
              popperInstance.setOptions(options);
            }
          },
          destroy: function () {
            deinitPopper();
          }
        };
      };

      return [referenceAction, contentAction, function () {
        return popperInstance;
      }];
    }

    function get_each_context$1(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[33] = list[i];
      return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[36] = list[i];
      return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[13] = list[i];
      return child_ctx;
    } // (165:1) {#if showTooltip}


    function create_if_block$3(ctx) {
      var div2;
      var label;
      var span;
      var t1;
      var input;
      var t2;
      var div0;
      var t3;
      var button;
      var t4_value = dist_10("timemanager", "Add task") + "";
      var t4;
      var t5;
      var div1;
      var mounted;
      var dispose;

      function select_block_type(ctx, dirty) {
        var _ctx$;

        if (
        /*searchResults*/
        (_ctx$ = ctx[11]) !== null && _ctx$ !== void 0 && _ctx$.length) return create_if_block_1$1;
        return create_else_block;
      }

      var current_block_type = select_block_type(ctx);
      var if_block = current_block_type(ctx);
      return {
        c: function c() {
          div2 = element("div");
          label = element("label");
          span = element("span");
          span.textContent = "".concat(dist_10("timemanager", "Search for client, project or task"));
          t1 = space$1();
          input = element("input");
          t2 = space$1();
          div0 = element("div");
          if_block.c();
          t3 = space$1();
          button = element("button");
          t4 = text(t4_value);
          t5 = space$1();
          div1 = element("div");
          attr(span, "class", "hidden-visually");
          attr(input, "class", "search-input icon-search button-w-icon");
          attr(input, "type", "text");
          attr(input, "placeholder", dist_10("timemanager", "Type to search for client, project or task"));
          input.autofocus = true;
          attr(label, "class", "search");
          attr(div0, "class", "search-results");
          button.disabled =
          /*loading*/
          ctx[7];
          attr(button, "type", "button");
          attr(button, "class", "icon-add button-w-icon button secondary task-add-button");
          attr(div1, "class", "popover-arrow");
          attr(div1, "data-popper-arrow", "");
          attr(div2, "class", "task-selector-popover popover");
        },
        m: function m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, label);
          append(label, span);
          append(label, t1);
          append(label, input);
          /*input_binding*/

          ctx[25](input);
          append(div2, t2);
          append(div2, div0);
          if_block.m(div0, null);
          append(div2, t3);
          append(div2, button);
          append(button, t4);
          append(div2, t5);
          append(div2, div1);
          input.focus();

          if (!mounted) {
            dispose = [action_destroyer(/*popperContent*/
            ctx[9].call(null, div2,
            /*extraOpts*/
            ctx[10])), listen(div2, "click", click_handler)];
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if_block.p(ctx, dirty);

          if (dirty[0] &
          /*loading*/
          128) {
            button.disabled =
            /*loading*/
            ctx[7];
          }
        },
        d: function d(detaching) {
          if (detaching) detach(div2);
          /*input_binding*/

          ctx[25](null);
          if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    } // (205:4) {:else}


    function create_else_block(ctx) {
      var p;
      return {
        c: function c() {
          p = element("p");
          p.textContent = "".concat(dist_10("timemanager", "Nothing found"));
          attr(p, "class", "no-result");
        },
        m: function m(target, anchor) {
          insert(target, p, anchor);
        },
        p: noop$1,
        d: function d(detaching) {
          if (detaching) detach(p);
        }
      };
    } // (185:4) {#if searchResults?.length}


    function create_if_block_1$1(ctx) {
      var each_1_anchor;
      var each_value =
      /*searchResults*/
      ctx[11];
      var each_blocks = [];

      for (var i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
      }

      return {
        c: function c() {
          for (var _i = 0; _i < each_blocks.length; _i += 1) {
            each_blocks[_i].c();
          }

          each_1_anchor = empty();
        },
        m: function m(target, anchor) {
          for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
            each_blocks[_i2].m(target, anchor);
          }

          insert(target, each_1_anchor, anchor);
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*searchResults*/
          2048) {
            each_value =
            /*searchResults*/
            ctx[11];

            var _i3;

            for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
              var child_ctx = get_each_context$1(ctx, each_value, _i3);

              if (each_blocks[_i3]) {
                each_blocks[_i3].p(child_ctx, dirty);
              } else {
                each_blocks[_i3] = create_each_block$1(child_ctx);

                each_blocks[_i3].c();

                each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            for (; _i3 < each_blocks.length; _i3 += 1) {
              each_blocks[_i3].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function d(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach(each_1_anchor);
        }
      };
    } // (195:12) {#each project.tasks as task}


    function create_each_block_2$1(ctx) {
      var li;
      var a;
      var t_value =
      /*task*/
      ctx[13].name + "";
      var t;
      return {
        c: function c() {
          li = element("li");
          a = element("a");
          t = text(t_value);
          attr(a, "href", "#");
          attr(a, "class", "task");
        },
        m: function m(target, anchor) {
          insert(target, li, anchor);
          append(li, a);
          append(a, t);
        },
        p: noop$1,
        d: function d(detaching) {
          if (detaching) detach(li);
        }
      };
    } // (191:9) {#each result.client.projects as project}


    function create_each_block_1$1(ctx) {
      var li;
      var span;
      var t0_value =
      /*project*/
      ctx[36].name + "";
      var t0;
      var t1;
      var ul;
      var t2;
      var each_value_2 =
      /*project*/
      ctx[36].tasks;
      var each_blocks = [];

      for (var i = 0; i < each_value_2.length; i += 1) {
        each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
      }

      return {
        c: function c() {
          li = element("li");
          span = element("span");
          t0 = text(t0_value);
          t1 = space$1();
          ul = element("ul");

          for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {
            each_blocks[_i4].c();
          }

          t2 = space$1();
          attr(span, "class", "project");
        },
        m: function m(target, anchor) {
          insert(target, li, anchor);
          append(li, span);
          append(span, t0);
          append(li, t1);
          append(li, ul);

          for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
            each_blocks[_i5].m(ul, null);
          }

          append(li, t2);
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*searchResults*/
          2048) {
            each_value_2 =
            /*project*/
            ctx[36].tasks;

            var _i6;

            for (_i6 = 0; _i6 < each_value_2.length; _i6 += 1) {
              var child_ctx = get_each_context_2$1(ctx, each_value_2, _i6);

              if (each_blocks[_i6]) {
                each_blocks[_i6].p(child_ctx, dirty);
              } else {
                each_blocks[_i6] = create_each_block_2$1(child_ctx);

                each_blocks[_i6].c();

                each_blocks[_i6].m(ul, null);
              }
            }

            for (; _i6 < each_blocks.length; _i6 += 1) {
              each_blocks[_i6].d(1);
            }

            each_blocks.length = each_value_2.length;
          }
        },
        d: function d(detaching) {
          if (detaching) detach(li);
          destroy_each(each_blocks, detaching);
        }
      };
    } // (186:5) {#each searchResults as result}


    function create_each_block$1(ctx) {
      var ul1;
      var li;
      var span;
      var t0_value =
      /*result*/
      ctx[33].client.name + "";
      var t0;
      var t1;
      var ul0;
      var t2;
      var each_value_1 =
      /*result*/
      ctx[33].client.projects;
      var each_blocks = [];

      for (var i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
      }

      return {
        c: function c() {
          ul1 = element("ul");
          li = element("li");
          span = element("span");
          t0 = text(t0_value);
          t1 = space$1();
          ul0 = element("ul");

          for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {
            each_blocks[_i7].c();
          }

          t2 = space$1();
          attr(span, "class", "client");
          attr(ul1, "class", "result");
        },
        m: function m(target, anchor) {
          insert(target, ul1, anchor);
          append(ul1, li);
          append(li, span);
          append(span, t0);
          append(li, t1);
          append(li, ul0);

          for (var _i8 = 0; _i8 < each_blocks.length; _i8 += 1) {
            each_blocks[_i8].m(ul0, null);
          }

          append(ul1, t2);
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*searchResults*/
          2048) {
            each_value_1 =
            /*result*/
            ctx[33].client.projects;

            var _i9;

            for (_i9 = 0; _i9 < each_value_1.length; _i9 += 1) {
              var child_ctx = get_each_context_1$1(ctx, each_value_1, _i9);

              if (each_blocks[_i9]) {
                each_blocks[_i9].p(child_ctx, dirty);
              } else {
                each_blocks[_i9] = create_each_block_1$1(child_ctx);

                each_blocks[_i9].c();

                each_blocks[_i9].m(ul0, null);
              }
            }

            for (; _i9 < each_blocks.length; _i9 += 1) {
              each_blocks[_i9].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        d: function d(detaching) {
          if (detaching) detach(ul1);
          destroy_each(each_blocks, detaching);
        }
      };
    }

    function create_fragment$7(ctx) {
      var form;
      var label0;
      var t0_value = dist_10("timemanager", "Note") + "";
      var t0;
      var t1;
      var input0;
      var t2;
      var label1;
      var html_tag;
      var raw_value = dist_10("timemanager", "Duration (in hrs.) & Date") + "";
      var t3;
      var span0;
      var input1;
      var t4;
      var input2;
      var t5;
      var label2;
      var t6_value = dist_10("timemanager", "Client, project or task") + "";
      var t6;
      var t7;
      var input3;
      var t8;
      var t9;
      var span1;
      var button;
      var t10_value = dist_10("timemanager", "Add") + "";
      var t10;
      var form_class_value;
      var mounted;
      var dispose;
      var if_block =
      /*showTooltip*/
      ctx[0] && create_if_block$3(ctx);
      return {
        c: function c() {
          form = element("form");
          label0 = element("label");
          t0 = text(t0_value);
          t1 = space$1();
          input0 = element("input");
          t2 = space$1();
          label1 = element("label");
          html_tag = new HtmlTag(false);
          t3 = space$1();
          span0 = element("span");
          input1 = element("input");
          t4 = space$1();
          input2 = element("input");
          t5 = space$1();
          label2 = element("label");
          t6 = text(t6_value);
          t7 = space$1();
          input3 = element("input");
          t8 = space$1();
          if (if_block) if_block.c();
          t9 = space$1();
          span1 = element("span");
          button = element("button");
          t10 = text(t10_value);
          attr(input0, "type", "text");
          attr(input0, "name", "note");
          attr(input0, "class", "note");
          attr(input0, "placeholder", dist_10("timemanager", "Describe what you did..."));
          attr(label0, "class", "note");
          html_tag.a = t3;
          attr(input1, "id", "quick-add-time");
          attr(input1, "type", "number");
          attr(input1, "name", "duration");
          attr(input1, "step", "0.01");
          attr(input1, "placeholder", "");
          attr(input1, "class", "duration-input");
          attr(input2, "type", "date");
          attr(input2, "name", "date");
          attr(input2, "class", "date-input");
          attr(span0, "class", "double");
          attr(label1, "for", "quick-add-time");
          attr(input3, "type", "text");
          attr(input3, "placeholder", dist_10("timemanager", "Select..."));
          input3.disabled =
          /*showTooltip*/
          ctx[0];
          attr(label2, "class", "task-selector-trigger");
          button.disabled =
          /*loading*/
          ctx[7];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(span1, "class", "actions");
          attr(form, "class", form_class_value = "quick-add".concat(
          /*loading*/
          ctx[7] ? " icon-loading" : ""));
        },
        m: function m(target, anchor) {
          insert(target, form, anchor);
          append(form, label0);
          append(label0, t0);
          append(label0, t1);
          append(label0, input0);
          set_input_value(input0,
          /*note*/
          ctx[3]);
          /*input0_binding*/

          ctx[20](input0);
          append(form, t2);
          append(form, label1);
          html_tag.m(raw_value, label1);
          append(label1, t3);
          append(label1, span0);
          append(span0, input1);
          set_input_value(input1,
          /*duration*/
          ctx[1]);
          append(span0, t4);
          append(span0, input2);
          set_input_value(input2,
          /*date*/
          ctx[2]);
          append(form, t5);
          append(form, label2);
          append(label2, t6);
          append(label2, t7);
          append(label2, input3);
          /*input3_binding*/

          ctx[24](input3);
          append(form, t8);
          if (if_block) if_block.m(form, null);
          append(form, t9);
          append(form, span1);
          append(span1, button);
          append(button, t10);

          if (!mounted) {
            dispose = [listen(input0, "input",
            /*input0_input_handler*/
            ctx[19]), listen(input1, "input",
            /*input1_input_handler*/
            ctx[21]), listen(input2, "input",
            /*input2_input_handler*/
            ctx[22]), action_destroyer(/*popperRef*/
            ctx[8].call(null, input3)), listen(input3, "focus",
            /*focus_handler*/
            ctx[23]), listen(form, "submit", prevent_default(
            /*save*/
            ctx[12]))];
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*note*/
          8 && input0.value !==
          /*note*/
          ctx[3]) {
            set_input_value(input0,
            /*note*/
            ctx[3]);
          }

          if (dirty[0] &
          /*duration*/
          2 && to_number(input1.value) !==
          /*duration*/
          ctx[1]) {
            set_input_value(input1,
            /*duration*/
            ctx[1]);
          }

          if (dirty[0] &
          /*date*/
          4) {
            set_input_value(input2,
            /*date*/
            ctx[2]);
          }

          if (dirty[0] &
          /*showTooltip*/
          1) {
            input3.disabled =
            /*showTooltip*/
            ctx[0];
          }

          if (
          /*showTooltip*/
          ctx[0]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$3(ctx);
              if_block.c();
              if_block.m(form, t9);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty[0] &
          /*loading*/
          128) {
            button.disabled =
            /*loading*/
            ctx[7];
          }

          if (dirty[0] &
          /*loading*/
          128 && form_class_value !== (form_class_value = "quick-add".concat(
          /*loading*/
          ctx[7] ? " icon-loading" : ""))) {
            attr(form, "class", form_class_value);
          }
        },
        i: noop$1,
        o: noop$1,
        d: function d(detaching) {
          if (detaching) detach(form);
          /*input0_binding*/

          ctx[20](null);
          /*input3_binding*/

          ctx[24](null);
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }

    var click_handler = function click_handler(event) {
      event.stopPropagation();
      event.preventDefault();
    };

    function instance$7($$self, $$props, $$invalidate) {
      var loading;
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var projects = $$props.projects;
      var tasks = $$props.tasks;
      var initialDate = $$props.initialDate;

      var _createPopperActions = createPopperActions({
        placement: "bottom",
        strategy: "fixed"
      }),
          _createPopperActions2 = _slicedToArray(_createPopperActions, 2),
          popperRef = _createPopperActions2[0],
          popperContent = _createPopperActions2[1];

      var extraOpts = {
        modifiers: [{
          name: "offset",
          options: {
            offset: [0, 8]
          }
        }]
      };
      var showTooltip = false;
      var duration = 1;
      var date = initialDate;
      var note;
      var task;
      var noteInput;
      var buttonInput;
      var searchInput;
      // 	{
      // 		client: {
      // 			name: "Zoo",
      // 			projects: [{ name: "Tigers", tasks: [{ name: "Feeding" }, { name: "Cleaning" }, { name: "Playing" }] }],
      // 		},
      // 	},
      // 	{
      // 		client: {
      // 			name: "Grime, Cronin and Cruickshank",
      // 			projects: [
      // 				{ name: "Cobbler Birthday Cake", tasks: [{ name: "Mexico City" }] },
      // 				{ name: "Cheesecake with caramel", tasks: [{ name: "Sidney" }] },
      // 			],
      // 		},
      // 	},
      // ];

      var searchResults = [];
      tasks && tasks.length ? tasks.map(function (aTask) {
        aTask.project = projects.find(function (aProject) {
          return aProject.value === aTask.projectUuid;
        });
        return aTask;
      }) : [];

      var hideTooltip = function hideTooltip() {
        $$invalidate(0, showTooltip = false);
      };

      onMount(function () {
        document.addEventListener("DOMContentLoaded", function () {
          if (noteInput) {
            noteInput.focus();
          }
        });

        if (noteInput) {
          noteInput.focus();
        }

        document.addEventListener("click", hideTooltip);
        return function () {
          document.removeEventListener("click", hideTooltip);
        };
      });

      var save = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var entry, response;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  $$invalidate(7, loading = true);

                  $$invalidate(7, loading = false);
                  return _context.abrupt("return");

                case 6:
                  _context.prev = 6;
                  entry = {
                    duration: duration,
                    date: date,
                    note: note,
                    task: task.value
                  };
                  _context.next = 10;
                  return fetch(action, {
                    method: "POST",
                    body: JSON.stringify(entry),
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });

                case 10:
                  response = _context.sent;

                  if (response && response.ok) {
                    document.querySelector(".app-timemanager [data-current-link]").click();
                  }

                  _context.next = 17;
                  break;

                case 14:
                  _context.prev = 14;
                  _context.t0 = _context["catch"](6);
                  console.error(_context.t0);

                case 17:
                  $$invalidate(7, loading = false);

                case 18:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[6, 14]]);
        }));

        return function save() {
          return _ref.apply(this, arguments);
        };
      }();

      function input0_input_handler() {
        note = this.value;
        $$invalidate(3, note);
      }

      function input0_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          noteInput = $$value;
          $$invalidate(4, noteInput);
        });
      }

      function input1_input_handler() {
        duration = to_number(this.value);
        $$invalidate(1, duration);
      }

      function input2_input_handler() {
        date = this.value;
        $$invalidate(2, date);
      }

      var focus_handler = function focus_handler() {
        var _buttonInput, _searchInput;

        // We want to use this input as a button
        // and then focus the actual search input
        (_buttonInput = buttonInput) === null || _buttonInput === void 0 ? void 0 : _buttonInput.blur();
        (_searchInput = searchInput) === null || _searchInput === void 0 ? void 0 : _searchInput.focus();
        $$invalidate(0, showTooltip = true);
      };

      function input3_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          buttonInput = $$value;
          $$invalidate(5, buttonInput);
        });
      }

      function input_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          searchInput = $$value;
          $$invalidate(6, searchInput);
        });
      }

      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(14, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(15, requestToken = $$props.requestToken);
        if ('projects' in $$props) $$invalidate(16, projects = $$props.projects);
        if ('tasks' in $$props) $$invalidate(17, tasks = $$props.tasks);
        if ('initialDate' in $$props) $$invalidate(18, initialDate = $$props.initialDate);
      };

      $$invalidate(7, loading = false);

      return [showTooltip, duration, date, note, noteInput, buttonInput, searchInput, loading, popperRef, popperContent, extraOpts, searchResults, save, task, action, requestToken, projects, tasks, initialDate, input0_input_handler, input0_binding, input1_input_handler, input2_input_handler, focus_handler, input3_binding, input_binding];
    }

    var QuickAdd = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(QuickAdd, _SvelteComponent);

      var _super = _createSuper(QuickAdd);

      function QuickAdd(options) {
        var _this;

        _classCallCheck$1(this, QuickAdd);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$7, create_fragment$7, safe_not_equal, {
          action: 14,
          requestToken: 15,
          projects: 16,
          tasks: 17,
          initialDate: 18
        }, null, [-1, -1]);
        return _this;
      }

      return _createClass$1(QuickAdd);
    }(SvelteComponent);

    function create_fragment$6(ctx) {
      var span0;
      var input;
      var input_id_value;
      var input_checked_value;
      var t0;
      var label;
      var label_for_value;
      var t1;
      var span1;
      var span1_class_value;
      var mounted;
      var dispose;
      return {
        c: function c() {
          span0 = element("span");
          input = element("input");
          t0 = space$1();
          label = element("label");
          t1 = space$1();
          span1 = element("span");
          attr(input, "type", "checkbox");
          attr(input, "id", input_id_value = "check_".concat(
          /*uuid*/
          ctx[0]));
          attr(input, "class", "checkbox");
          input.checked = input_checked_value =
          /*initialState*/
          ctx[1] === 'paid';
          input.disabled =
          /*loading*/
          ctx[3];
          attr(label, "for", label_for_value = "check_".concat(
          /*uuid*/
          ctx[0]));
          attr(span0, "class", "checkbox-action");
          attr(span1, "class", span1_class_value = "checkbox-action-loading".concat(
          /*loading*/
          ctx[3] ? ' icon-loading' : ''));
        },
        m: function m(target, anchor) {
          insert(target, span0, anchor);
          append(span0, input);
          append(span0, t0);
          append(span0, label);
          insert(target, t1, anchor);
          insert(target, span1, anchor);

          if (!mounted) {
            dispose = listen(input, "change", prevent_default(
            /*change_handler*/
            ctx[7]));
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (dirty &
          /*uuid*/
          1 && input_id_value !== (input_id_value = "check_".concat(
          /*uuid*/
          ctx[0]))) {
            attr(input, "id", input_id_value);
          }

          if (dirty &
          /*initialState*/
          2 && input_checked_value !== (input_checked_value =
          /*initialState*/
          ctx[1] === 'paid')) {
            input.checked = input_checked_value;
          }

          if (dirty &
          /*loading*/
          8) {
            input.disabled =
            /*loading*/
            ctx[3];
          }

          if (dirty &
          /*uuid*/
          1 && label_for_value !== (label_for_value = "check_".concat(
          /*uuid*/
          ctx[0]))) {
            attr(label, "for", label_for_value);
          }

          if (dirty &
          /*loading*/
          8 && span1_class_value !== (span1_class_value = "checkbox-action-loading".concat(
          /*loading*/
          ctx[3] ? ' icon-loading' : ''))) {
            attr(span1, "class", span1_class_value);
          }
        },
        i: noop$1,
        o: noop$1,
        d: function d(detaching) {
          if (detaching) detach(span0);
          if (detaching) detach(t1);
          if (detaching) detach(span1);
          mounted = false;
          dispose();
        }
      };
    }

    function instance$6($$self, $$props, $$invalidate) {
      var loading;
      var uuid = $$props.uuid;
      var initialState = $$props.initialState;
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var state = initialState;
      onMount(function () {
        Helpers.hideFallbacks("Checkmark.svelte");
      });

      var save = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var response;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  $$invalidate(3, loading = true);
                  _context.prev = 1;
                  _context.next = 4;
                  return fetch("".concat(action, "/").concat(state), {
                    method: "POST",
                    body: JSON.stringify({
                      uuid: uuid
                    }),
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });

                case 4:
                  response = _context.sent;

                  if (!response || !response.ok) {
                    // Roll back selection
                    $$invalidate(2, state = state === "paid" ? "unpaid" : "paid");
                  }

                  _context.next = 11;
                  break;

                case 8:
                  _context.prev = 8;
                  _context.t0 = _context["catch"](1);
                  console.error(_context.t0);

                case 11:
                  $$invalidate(3, loading = false);

                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[1, 8]]);
        }));

        return function save() {
          return _ref3.apply(this, arguments);
        };
      }();

      var change_handler = function change_handler() {
        $$invalidate(2, state = state === 'paid' ? 'unpaid' : 'paid');
        save();
      };

      $$self.$$set = function ($$props) {
        if ('uuid' in $$props) $$invalidate(0, uuid = $$props.uuid);
        if ('initialState' in $$props) $$invalidate(1, initialState = $$props.initialState);
        if ('action' in $$props) $$invalidate(5, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(6, requestToken = $$props.requestToken);
      };

      $$invalidate(3, loading = false);

      return [uuid, initialState, state, loading, save, action, requestToken, change_handler];
    }

    var Checkmark = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(Checkmark, _SvelteComponent);

      var _super = _createSuper(Checkmark);

      function Checkmark(options) {
        var _this;

        _classCallCheck$1(this, Checkmark);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$6, create_fragment$6, safe_not_equal, {
          uuid: 0,
          initialState: 1,
          action: 5,
          requestToken: 6
        });
        return _this;
      }

      return _createClass$1(Checkmark);
    }(SvelteComponent);

    function create_fragment$5(ctx) {
      var form;
      var label0;
      var t0_value = dist_10('timemanager', 'Clients') + "";
      var t0;
      var t1;
      var select0;
      var t2;
      var label1;
      var t3_value = dist_10('timemanager', 'Projects') + "";
      var t3;
      var t4;
      var select1;
      var t5;
      var label2;
      var t6_value = dist_10('timemanager', 'Tasks') + "";
      var t6;
      var t7;
      var select2;
      var t8;
      var label3;
      var t9_value = dist_10('timemanager', 'Status') + "";
      var t9;
      var t10;
      var select3;
      var t11;
      var span;
      var button;
      var t12_value = dist_10('timemanager', 'Apply filters') + "";
      var t12;
      var form_class_value;
      var current;
      var mounted;
      var dispose;
      select0 = new Select({
        props: {
          noOptionsMessage: dist_10('timemanager', 'No options'),
          placeholder: dist_10('timemanager', 'Select...'),
          inputAttributes: {
            id: 'client-select'
          },
          items:
          /*clients*/
          ctx[0],
          value:
          /*selectedClients*/
          ctx[1],
          isMulti: true
        }
      });
      select0.$on("select",
      /*handleSelectClients*/
      ctx[10]);
      select1 = new Select({
        props: {
          noOptionsMessage: dist_10('timemanager', 'No options'),
          placeholder: dist_10('timemanager', 'Select...'),
          inputAttributes: {
            id: 'projects-select'
          },
          items:
          /*availableProjects*/
          ctx[6],
          value:
          /*selectedProjects*/
          ctx[2],
          isMulti: true
        }
      });
      select1.$on("select",
      /*handleSelectProjects*/
      ctx[11]);
      select2 = new Select({
        props: {
          noOptionsMessage: dist_10('timemanager', 'No options'),
          placeholder: dist_10('timemanager', 'Select...'),
          inputAttributes: {
            id: 'tasks-select'
          },
          items:
          /*availableTasks*/
          ctx[5],
          value:
          /*selectedTasks*/
          ctx[3],
          isMulti: true
        }
      });
      select2.$on("select",
      /*handleSelectTasks*/
      ctx[12]);
      select3 = new Select({
        props: {
          noOptionsMessage: dist_10('timemanager', 'No options'),
          placeholder: dist_10('timemanager', 'Select...'),
          inputAttributes: {
            id: 'status-select'
          },
          items:
          /*availableStatus*/
          ctx[8],
          value:
          /*selectedStatus*/
          ctx[4]
        }
      });
      select3.$on("select",
      /*handleSelectStatus*/
      ctx[13]);
      select3.$on("clear",
      /*handleClearStatus*/
      ctx[14]);
      return {
        c: function c() {
          form = element("form");
          label0 = element("label");
          t0 = text(t0_value);
          t1 = space$1();
          create_component(select0.$$.fragment);
          t2 = space$1();
          label1 = element("label");
          t3 = text(t3_value);
          t4 = space$1();
          create_component(select1.$$.fragment);
          t5 = space$1();
          label2 = element("label");
          t6 = text(t6_value);
          t7 = space$1();
          create_component(select2.$$.fragment);
          t8 = space$1();
          label3 = element("label");
          t9 = text(t9_value);
          t10 = space$1();
          create_component(select3.$$.fragment);
          t11 = space$1();
          span = element("span");
          button = element("button");
          t12 = text(t12_value);
          attr(label0, "for", "client-select");
          attr(label0, "class", "clients");
          attr(label1, "for", "projects-select");
          attr(label1, "class", "projects");
          attr(label2, "for", "tasks-select");
          attr(label2, "class", "tasks");
          attr(label3, "for", "status-select");
          attr(label3, "class", "status");
          button.disabled =
          /*loading*/
          ctx[7];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(span, "class", "actions");
          attr(form, "class", form_class_value = "reports-filters".concat(
          /*loading*/
          ctx[7] ? ' icon-loading' : ''));
        },
        m: function m(target, anchor) {
          insert(target, form, anchor);
          append(form, label0);
          append(label0, t0);
          append(label0, t1);
          mount_component(select0, label0, null);
          append(form, t2);
          append(form, label1);
          append(label1, t3);
          append(label1, t4);
          mount_component(select1, label1, null);
          append(form, t5);
          append(form, label2);
          append(label2, t6);
          append(label2, t7);
          mount_component(select2, label2, null);
          append(form, t8);
          append(form, label3);
          append(label3, t9);
          append(label3, t10);
          mount_component(select3, label3, null);
          append(form, t11);
          append(form, span);
          append(span, button);
          append(button, t12);
          current = true;

          if (!mounted) {
            dispose = listen(form, "submit", prevent_default(
            /*apply*/
            ctx[9]));
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          var select0_changes = {};
          if (dirty &
          /*clients*/
          1) select0_changes.items =
          /*clients*/
          ctx[0];
          if (dirty &
          /*selectedClients*/
          2) select0_changes.value =
          /*selectedClients*/
          ctx[1];
          select0.$set(select0_changes);
          var select1_changes = {};
          if (dirty &
          /*availableProjects*/
          64) select1_changes.items =
          /*availableProjects*/
          ctx[6];
          if (dirty &
          /*selectedProjects*/
          4) select1_changes.value =
          /*selectedProjects*/
          ctx[2];
          select1.$set(select1_changes);
          var select2_changes = {};
          if (dirty &
          /*availableTasks*/
          32) select2_changes.items =
          /*availableTasks*/
          ctx[5];
          if (dirty &
          /*selectedTasks*/
          8) select2_changes.value =
          /*selectedTasks*/
          ctx[3];
          select2.$set(select2_changes);
          var select3_changes = {};
          if (dirty &
          /*selectedStatus*/
          16) select3_changes.value =
          /*selectedStatus*/
          ctx[4];
          select3.$set(select3_changes);

          if (!current || dirty &
          /*loading*/
          128) {
            button.disabled =
            /*loading*/
            ctx[7];
          }

          if (!current || dirty &
          /*loading*/
          128 && form_class_value !== (form_class_value = "reports-filters".concat(
          /*loading*/
          ctx[7] ? ' icon-loading' : ''))) {
            attr(form, "class", form_class_value);
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(select0.$$.fragment, local);
          transition_in(select1.$$.fragment, local);
          transition_in(select2.$$.fragment, local);
          transition_in(select3.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(select0.$$.fragment, local);
          transition_out(select1.$$.fragment, local);
          transition_out(select2.$$.fragment, local);
          transition_out(select3.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          if (detaching) detach(form);
          destroy_component(select0);
          destroy_component(select1);
          destroy_component(select2);
          destroy_component(select3);
          mounted = false;
          dispose();
        }
      };
    }

    function instance$5($$self, $$props, $$invalidate) {
      var loading;
      var availableProjects;
      var availableTasks;
      var clients = $$props.clients;
      var projects = $$props.projects;
      var tasks = $$props.tasks;
      var selectedClients;
      var selectedProjects;
      var selectedTasks;
      var selectedStatus;
      var availableStatus = [{
        value: "unpaid",
        label: dist_10("timemanager", "Unresolved")
      }, {
        value: "paid",
        label: dist_10("timemanager", "Resolved")
      }];

      var apply = function apply(e) {
        // Prepare a link with get attributes
        var filterLinkElement = Helpers.getLinkEl(); // Base off current url

        var newUrl = document.location.href; // Add filter attributes to url

        newUrl = Helpers.getUpdatedFilterUrl("clients", selectedClients ? selectedClients.map(function (c) {
          return c.value;
        }).join(",") : "", newUrl);
        newUrl = Helpers.getUpdatedFilterUrl("projects", selectedProjects ? selectedProjects.map(function (p) {
          return p.value;
        }).join(",") : "", newUrl);
        newUrl = Helpers.getUpdatedFilterUrl("tasks", selectedTasks ? selectedTasks.map(function (t) {
          return t.value;
        }).join(",") : "", newUrl);
        newUrl = Helpers.getUpdatedFilterUrl("status", selectedStatus ? selectedStatus.value : "", newUrl); // Attach url to hidden pjax link

        filterLinkElement.href = newUrl; // Navigate

        filterLinkElement.click();
      };

      var handleSelectClients = function handleSelectClients(event) {
        $$invalidate(1, selectedClients = event.detail);

        if (selectedClients && selectedClients.length) {
          $$invalidate(6, availableProjects = projects.filter(function (project) {
            return selectedClients.find(function (client) {
              return project.clientUuid === client.value;
            });
          }));
        } else {
          $$invalidate(6, availableProjects = projects);
        }

        if (selectedProjects && selectedProjects.length) {
          $$invalidate(5, availableTasks = tasks.filter(function (task) {
            return selectedProjects.find(function (project) {
              return task.projectUuid === project.value;
            });
          }));
        } else {
          $$invalidate(5, availableTasks = tasks);
        }
      };

      var handleSelectProjects = function handleSelectProjects(event) {
        $$invalidate(2, selectedProjects = event.detail);

        if (selectedClients && selectedClients.length) {
          $$invalidate(6, availableProjects = projects.filter(function (project) {
            return selectedClients.find(function (client) {
              return project.clientUuid === client.value;
            });
          }));
        } else {
          $$invalidate(6, availableProjects = projects);
        }

        if (selectedProjects && selectedProjects.length) {
          $$invalidate(5, availableTasks = tasks.filter(function (task) {
            return selectedProjects.find(function (project) {
              return task.projectUuid === project.value;
            });
          }));
        } else {
          $$invalidate(5, availableTasks = tasks);
        }
      };

      var handleSelectTasks = function handleSelectTasks(event) {
        $$invalidate(3, selectedTasks = event.detail);
      };

      var handleSelectStatus = function handleSelectStatus(event) {
        $$invalidate(4, selectedStatus = event.detail);
      };

      var handleClearStatus = function handleClearStatus() {
        $$invalidate(4, selectedStatus = "");
      };

      onMount(function () {
        // Parse current URL
        var urlParts = document.location.href.split("?");

        if (urlParts.length > 1) {
          var queryString = urlParts[1];
          var queryStringParts = queryString.split("&");

          queryStringParts.map(function (part) {
            // Split query params
            var partParts = part.split("=");

            var _partParts = _slicedToArray(partParts, 2),
                name = _partParts[0],
                value = _partParts[1]; // Apply filters from query params


            if (name === "status" && value) {
              $$invalidate(4, selectedStatus = availableStatus.find(function (status) {
                return status.value === value;
              }));
            }

            if (name === "tasks" && value && value.length) {
              $$invalidate(3, selectedTasks = value.split(",").map(function (taskId) {
                return tasks.find(function (task) {
                  return task.value === taskId;
                });
              }));
            }

            if (name === "projects" && value && value.length) {
              handleSelectProjects({
                detail: value.split(",").map(function (projectId) {
                  return projects.find(function (project) {
                    return project.value === projectId;
                  });
                })
              });
            }

            if (name === "clients" && value && value.length) {
              handleSelectClients({
                detail: value.split(",").map(function (clientId) {
                  return clients.find(function (client) {
                    return client.value === clientId;
                  });
                })
              });
            }
          });
        }
      });

      $$self.$$set = function ($$props) {
        if ('clients' in $$props) $$invalidate(0, clients = $$props.clients);
        if ('projects' in $$props) $$invalidate(15, projects = $$props.projects);
        if ('tasks' in $$props) $$invalidate(16, tasks = $$props.tasks);
      };

      $$self.$$.update = function () {
        if ($$self.$$.dirty &
        /*projects*/
        32768) {
          $$invalidate(6, availableProjects = projects);
        }

        if ($$self.$$.dirty &
        /*tasks*/
        65536) {
          $$invalidate(5, availableTasks = tasks);
        }
      };

      $$invalidate(7, loading = false);

      return [clients, selectedClients, selectedProjects, selectedTasks, selectedStatus, availableTasks, availableProjects, loading, availableStatus, apply, handleSelectClients, handleSelectProjects, handleSelectTasks, handleSelectStatus, handleClearStatus, projects, tasks];
    }

    var Filters = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(Filters, _SvelteComponent);

      var _super = _createSuper(Filters);

      function Filters(options) {
        var _this;

        _classCallCheck$1(this, Filters);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$5, create_fragment$5, safe_not_equal, {
          clients: 0,
          projects: 15,
          tasks: 16
        });
        return _this;
      }

      return _createClass$1(Filters);
    }(SvelteComponent);

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$1) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$1) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$1;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    var isFilterSet = writable(false);

    function create_if_block$2(ctx) {
      var label;
      var t0_value = dist_10('timemanager', 'Created by') + "";
      var t0;
      var t1;
      var select;
      var current;
      select = new Select({
        props: {
          noOptionsMessage:
          /*loading*/
          ctx[2] ? dist_10('timemanager', 'Loading...') : dist_10('timemanager', 'No options'),
          placeholder: dist_10('timemanager', 'Search...'),
          inputAttributes: {
            id: 'sharee-filter-select'
          },
          loadOptions:
          /*search*/
          ctx[5],
          value:
          /*selectedSharee*/
          ctx[1]
        }
      });
      select.$on("select",
      /*handleSelectSharee*/
      ctx[3]);
      select.$on("clear",
      /*handleClearSharee*/
      ctx[4]);
      return {
        c: function c() {
          label = element("label");
          t0 = text(t0_value);
          t1 = space$1();
          create_component(select.$$.fragment);
          attr(label, "for", "sharee-filter-select");
          attr(label, "class", "sharee-filter-label");
        },
        m: function m(target, anchor) {
          insert(target, label, anchor);
          append(label, t0);
          append(label, t1);
          mount_component(select, label, null);
          current = true;
        },
        p: function p(ctx, dirty) {
          var select_changes = {};
          if (dirty &
          /*loading*/
          4) select_changes.noOptionsMessage =
          /*loading*/
          ctx[2] ? dist_10('timemanager', 'Loading...') : dist_10('timemanager', 'No options');
          if (dirty &
          /*selectedSharee*/
          2) select_changes.value =
          /*selectedSharee*/
          ctx[1];
          select.$set(select_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(select.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(select.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          if (detaching) detach(label);
          destroy_component(select);
        }
      };
    }

    function create_fragment$4(ctx) {
      var if_block_anchor;
      var current;
      var if_block =
      /*isVisible*/
      ctx[0] && create_if_block$2(ctx);
      return {
        c: function c() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        m: function m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (
          /*isVisible*/
          ctx[0]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*isVisible*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$2(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function o(local) {
          transition_out(if_block);
          current = false;
        },
        d: function d(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
        }
      };
    }

    function instance$4($$self, $$props, $$invalidate) {
      var loading;
      var requestToken = $$props.requestToken;
      var _$$props$isVisible = $$props.isVisible,
          isVisible = _$$props$isVisible === void 0 ? true : _$$props$isVisible;
      var selectedSharee;

      var handleSelectSharee = function handleSelectSharee(event) {
        if (selectedSharee && selectedSharee.value.shareWith === event.detail.value.shareWith) {
          return;
        }

        $$invalidate(1, selectedSharee = event.detail); // Prepare a link with get attributes

        var filterLinkElement = Helpers.getLinkEl(); // Base off current url

        var newUrl = document.location.href; // Add filter attributes to url

        newUrl = Helpers.getUpdatedFilterUrl("userFilter", selectedSharee ? selectedSharee.value.shareWith : "", newUrl); // Attach url to hidden pjax link

        filterLinkElement.href = newUrl; // Navigate

        filterLinkElement.click();
      };

      var handleClearSharee = function handleClearSharee() {
        handleSelectSharee({
          detail: {
            value: {
              shareWith: ""
            },
            label: ""
          }
        });
        isFilterSet.set(false);
      };

      var search = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(query) {
          var response, _yield$response$json$, users, exact;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(typeof query === "undefined")) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return");

                case 2:
                  $$invalidate(2, loading = true);
                  _context.next = 5;
                  return fetch(dist_5("apps/files_sharing/api/v1/sharees?search=".concat(query, "&format=json&perPage=20&itemType=[0]")), {
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });

                case 5:
                  response = _context.sent;
                  $$invalidate(2, loading = false);

                  if (!response.ok) {
                    _context.next = 14;
                    break;
                  }

                  _context.next = 10;
                  return response.json();

                case 10:
                  _yield$response$json$ = _context.sent.ocs.data;
                  users = _yield$response$json$.users;
                  exact = _yield$response$json$.exact;
                  return _context.abrupt("return", [].concat(_toConsumableArray(users), _toConsumableArray(exact.users)));

                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function search(_x) {
          return _ref3.apply(this, arguments);
        };
      }();

      onMount( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var urlParts, queryString, queryStringParts, _iterator, _step, part, partParts, _partParts, name, value, result;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // Parse current URL
                urlParts = document.location.href.split("?");

                if (!(urlParts.length > 1)) {
                  _context2.next = 27;
                  break;
                }

                queryString = urlParts[1];
                queryStringParts = queryString.split("&");

                _iterator = _createForOfIteratorHelper(queryStringParts);
                _context2.prev = 6;

                _iterator.s();

              case 8:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 19;
                  break;
                }

                part = _step.value;
                // Split query params
                partParts = part.split("=");
                _partParts = _slicedToArray(partParts, 2), name = _partParts[0], value = _partParts[1]; // Apply filters from query params

                if (!(name === "userFilter" && value)) {
                  _context2.next = 17;
                  break;
                }

                _context2.next = 15;
                return search(value);

              case 15:
                result = _context2.sent;

                if (result && result.length) {
                  $$invalidate(1, selectedSharee = result[0]);
                  isFilterSet.set(true);
                }

              case 17:
                _context2.next = 8;
                break;

              case 19:
                _context2.next = 24;
                break;

              case 21:
                _context2.prev = 21;
                _context2.t0 = _context2["catch"](6);

                _iterator.e(_context2.t0);

              case 24:
                _context2.prev = 24;

                _iterator.f();

                return _context2.finish(24);

              case 27:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[6, 21, 24, 27]]);
      })));

      $$self.$$set = function ($$props) {
        if ('requestToken' in $$props) $$invalidate(6, requestToken = $$props.requestToken);
        if ('isVisible' in $$props) $$invalidate(0, isVisible = $$props.isVisible);
      };

      $$invalidate(2, loading = false);

      return [isVisible, selectedSharee, loading, handleSelectSharee, handleClearSharee, search, requestToken];
    }

    var UserFilterSelect = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(UserFilterSelect, _SvelteComponent);

      var _super = _createSuper(UserFilterSelect);

      function UserFilterSelect(options) {
        var _this;

        _classCallCheck$1(this, UserFilterSelect);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$4, create_fragment$4, safe_not_equal, {
          requestToken: 6,
          isVisible: 0
        });
        return _this;
      }

      return _createClass$1(UserFilterSelect);
    }(SvelteComponent);

    function create_fragment$3(ctx) {
      var form;
      var userfilterselect;
      var t0;
      var label0;
      var t1_value = dist_10('timemanager', 'From') + "";
      var t1;
      var t2;
      var input0;
      var t3;
      var label1;
      var t4_value = dist_10('timemanager', 'To') + "";
      var t4;
      var t5;
      var input1;
      var t6;
      var label2;
      var t7_value = dist_10('timemanager', 'Presets') + "";
      var t7;
      var t8;
      var select;
      var t9;
      var span;
      var button;
      var t10_value = dist_10('timemanager', 'Apply range') + "";
      var t10;
      var form_class_value;
      var current;
      var mounted;
      var dispose;
      userfilterselect = new UserFilterSelect({
        props: {
          requestToken:
          /*requestToken*/
          ctx[0]
        }
      });
      select = new Select({
        props: {
          noOptionsMessage: dist_10('timemanager', 'No options'),
          placeholder: dist_10('timemanager', 'Select...'),
          inputAttributes: {
            id: 'preset-select'
          },
          items:
          /*presets*/
          ctx[4]
        }
      });
      select.$on("select",
      /*handleSelectPreset*/
      ctx[6]);
      return {
        c: function c() {
          form = element("form");
          create_component(userfilterselect.$$.fragment);
          t0 = space$1();
          label0 = element("label");
          t1 = text(t1_value);
          t2 = space$1();
          input0 = element("input");
          t3 = space$1();
          label1 = element("label");
          t4 = text(t4_value);
          t5 = space$1();
          input1 = element("input");
          t6 = space$1();
          label2 = element("label");
          t7 = text(t7_value);
          t8 = space$1();
          create_component(select.$$.fragment);
          t9 = space$1();
          span = element("span");
          button = element("button");
          t10 = text(t10_value);
          attr(input0, "id", "start");
          attr(input0, "type", "date");
          attr(input0, "pattern", "Y-m-d");
          attr(label0, "for", "start");
          attr(label0, "class", "start");
          attr(input1, "id", "end");
          attr(input1, "type", "date");
          attr(input1, "pattern", "Y-m-d");
          attr(label1, "for", "end");
          attr(label1, "class", "end");
          attr(label2, "for", "preset-select");
          attr(label2, "class", "status");
          button.disabled =
          /*loading*/
          ctx[3];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(span, "class", "actions");
          attr(form, "class", form_class_value = "reports-timerange".concat(
          /*loading*/
          ctx[3] ? ' icon-loading' : ''));
        },
        m: function m(target, anchor) {
          insert(target, form, anchor);
          mount_component(userfilterselect, form, null);
          append(form, t0);
          append(form, label0);
          append(label0, t1);
          append(label0, t2);
          append(label0, input0);
          set_input_value(input0,
          /*start*/
          ctx[2]);
          append(form, t3);
          append(form, label1);
          append(label1, t4);
          append(label1, t5);
          append(label1, input1);
          set_input_value(input1,
          /*end*/
          ctx[1]);
          append(form, t6);
          append(form, label2);
          append(label2, t7);
          append(label2, t8);
          mount_component(select, label2, null);
          append(form, t9);
          append(form, span);
          append(span, button);
          append(button, t10);
          current = true;

          if (!mounted) {
            dispose = [listen(input0, "input",
            /*input0_input_handler*/
            ctx[9]), listen(input1, "input",
            /*input1_input_handler*/
            ctx[10]), listen(form, "submit", prevent_default(
            /*applyRange*/
            ctx[5]))];
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          var userfilterselect_changes = {};
          if (dirty &
          /*requestToken*/
          1) userfilterselect_changes.requestToken =
          /*requestToken*/
          ctx[0];
          userfilterselect.$set(userfilterselect_changes);

          if (dirty &
          /*start*/
          4) {
            set_input_value(input0,
            /*start*/
            ctx[2]);
          }

          if (dirty &
          /*end*/
          2) {
            set_input_value(input1,
            /*end*/
            ctx[1]);
          }

          if (!current || dirty &
          /*loading*/
          8) {
            button.disabled =
            /*loading*/
            ctx[3];
          }

          if (!current || dirty &
          /*loading*/
          8 && form_class_value !== (form_class_value = "reports-timerange".concat(
          /*loading*/
          ctx[3] ? ' icon-loading' : ''))) {
            attr(form, "class", form_class_value);
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(userfilterselect.$$.fragment, local);
          transition_in(select.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(userfilterselect.$$.fragment, local);
          transition_out(select.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          if (detaching) detach(form);
          destroy_component(userfilterselect);
          destroy_component(select);
          mounted = false;
          run_all(dispose);
        }
      };
    }

    var dateFormat = "yyyy-MM-dd";

    function instance$3($$self, $$props, $$invalidate) {
      var loading;
      var start;
      var end;
      var requestToken = $$props.requestToken;
      var startOfMonth$1 = $$props.startOfMonth;
      var endOfMonth$1 = $$props.endOfMonth;
      var presets = [{
        label: dist_10("timemanager", "Today"),
        value: "today"
      }, {
        label: dist_10("timemanager", "Yesterday"),
        value: "yesterday"
      }, {
        label: dist_10("timemanager", "This Week"),
        value: "week"
      }, {
        label: dist_10("timemanager", "Last week"),
        value: "week-1"
      }, {
        label: dist_10("timemanager", "This month"),
        value: "month"
      }, {
        label: dist_10("timemanager", "Last month"),
        value: "month-1"
      }, {
        label: dist_10("timemanager", "This year"),
        value: "year"
      }, {
        label: dist_10("timemanager", "Last year"),
        value: "year-1"
      }];

      var applyRange = function applyRange() {
        // Prepare a link with get attributes
        var filterLinkElement = Helpers.getLinkEl(); // Base off current url

        var newUrl = document.location.href; // Add filter attributes to url

        newUrl = Helpers.getUpdatedFilterUrl("start", start ? start : "", newUrl);
        newUrl = Helpers.getUpdatedFilterUrl("end", end ? end : "", newUrl); // Attach url to hidden pjax link

        filterLinkElement.href = newUrl; // Navigate

        filterLinkElement.click();
      };

      var handleSelectPreset = function handleSelectPreset(selectedValue) {
        var preset = selectedValue.detail.value;

        switch (preset) {
          case "today":
            $$invalidate(2, start = format$2(startOfToday(), dateFormat));
            $$invalidate(1, end = format$2(startOfToday(), dateFormat));
            break;

          case "yesterday":
            $$invalidate(2, start = format$2(startOfYesterday(), dateFormat));
            $$invalidate(1, end = format$2(startOfYesterday(), dateFormat));
            break;

          case "week":
            $$invalidate(2, start = format$2(startOfWeek(startOfToday(), {
              weekStartsOn: dist_5$1()
            }), dateFormat));
            $$invalidate(1, end = format$2(endOfWeek(startOfToday(), {
              weekStartsOn: dist_5$1()
            }), dateFormat));
            break;

          case "week-1":
            $$invalidate(2, start = format$2(startOfWeek(sub(startOfToday(), {
              weeks: 1
            }), {
              weekStartsOn: dist_5$1()
            }), dateFormat));
            $$invalidate(1, end = format$2(endOfWeek(sub(startOfToday(), {
              weeks: 1
            }), {
              weekStartsOn: dist_5$1()
            }), dateFormat));
            break;

          case "month":
            $$invalidate(2, start = format$2(startOfMonth(startOfToday()), dateFormat));
            $$invalidate(1, end = format$2(endOfMonth(startOfToday()), dateFormat));
            break;

          case "month-1":
            $$invalidate(2, start = format$2(startOfMonth(sub(startOfToday(), {
              months: 1
            })), dateFormat));
            $$invalidate(1, end = format$2(endOfMonth(sub(startOfToday(), {
              months: 1
            })), dateFormat));
            break;

          case "year":
            $$invalidate(2, start = format$2(startOfYear(startOfToday()), dateFormat));
            $$invalidate(1, end = format$2(endOfYear(startOfToday()), dateFormat));
            break;

          case "year-1":
            $$invalidate(2, start = format$2(startOfYear(sub(startOfToday(), {
              years: 1
            })), dateFormat));
            $$invalidate(1, end = format$2(endOfYear(sub(startOfToday(), {
              years: 1
            })), dateFormat));
            break;
        }
      };

      onMount(function () {
        // Parse current URL
        var urlParts = document.location.href.split("?");

        if (urlParts.length > 1) {
          var queryString = urlParts[1];
          var queryStringParts = queryString.split("&");

          queryStringParts.map(function (part) {
            // Split query params
            var partParts = part.split("=");

            var _partParts = _slicedToArray(partParts, 2),
                name = _partParts[0],
                value = _partParts[1]; // Apply filters from query params


            if (name === "start" && value) {
              $$invalidate(2, start = value);
            }

            if (name === "end" && value) {
              $$invalidate(1, end = value);
            }
          });
        }
      });

      function input0_input_handler() {
        start = this.value;
        $$invalidate(2, start), $$invalidate(7, startOfMonth$1);
      }

      function input1_input_handler() {
        end = this.value;
        $$invalidate(1, end), $$invalidate(8, endOfMonth$1);
      }

      $$self.$$set = function ($$props) {
        if ('requestToken' in $$props) $$invalidate(0, requestToken = $$props.requestToken);
        if ('startOfMonth' in $$props) $$invalidate(7, startOfMonth$1 = $$props.startOfMonth);
        if ('endOfMonth' in $$props) $$invalidate(8, endOfMonth$1 = $$props.endOfMonth);
      };

      $$self.$$.update = function () {
        if ($$self.$$.dirty &
        /*startOfMonth*/
        128) {
          $$invalidate(2, start = startOfMonth$1);
        }

        if ($$self.$$.dirty &
        /*endOfMonth*/
        256) {
          $$invalidate(1, end = endOfMonth$1);
        }
      };

      $$invalidate(3, loading = false);

      return [requestToken, end, start, loading, presets, applyRange, handleSelectPreset, startOfMonth$1, endOfMonth$1, input0_input_handler, input1_input_handler];
    }

    var Timerange = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(Timerange, _SvelteComponent);

      var _super = _createSuper(Timerange);

      function Timerange(options) {
        var _this;

        _classCallCheck$1(this, Timerange);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$3, create_fragment$3, safe_not_equal, {
          requestToken: 0,
          startOfMonth: 7,
          endOfMonth: 8
        });
        return _this;
      }

      return _createClass$1(Timerange);
    }(SvelteComponent);

    function create_fragment$2(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c: function c() {
          button = element("button");
          button.textContent = "".concat(dist_10('timemanager', 'Print report'));
          attr(button, "type", "button");
          attr(button, "class", "button secondary");
        },
        m: function m(target, anchor) {
          insert(target, button, anchor);

          if (!mounted) {
            dispose = listen(button, "click",
            /*click_handler*/
            ctx[0]);
            mounted = true;
          }
        },
        p: noop$1,
        i: noop$1,
        o: noop$1,
        d: function d(detaching) {
          if (detaching) detach(button);
          mounted = false;
          dispose();
        }
      };
    }

    function instance$2($$self) {
      onMount(function () {
        var openDetailsBeforePrint = function openDetailsBeforePrint() {
          var details = document.querySelectorAll("details");
          details && details.length && details.forEach(function (details) {
            if (!details.open) {
              details.setAttribute("open", "open");
              details.setAttribute("data-print", "true");
            }
          });
        };

        var closeDetailsAfterPrint = function closeDetailsAfterPrint() {
          var details = document.querySelectorAll("details[data-print=true]");
          details && details.length && details.forEach(function (details) {
            details.removeAttribute("open");
            details.removeAttribute("data-print");
          });
        };

        window.addEventListener("beforeprint", openDetailsBeforePrint);
        window.addEventListener("afterprint", closeDetailsAfterPrint);
        return function () {
          window.removeEventListener("beforeprint", openDetailsBeforePrint);
          window.removeEventListener("afterprint", closeDetailsAfterPrint);
        };
      });

      var click_handler = function click_handler() {
        return window.print();
      };

      return [click_handler];
    }

    var PrintButton = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(PrintButton, _SvelteComponent);

      var _super = _createSuper(PrintButton);

      function PrintButton(options) {
        var _this;

        _classCallCheck$1(this, PrintButton);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$2, create_fragment$2, safe_not_equal, {});
        return _this;
      }

      return _createClass$1(PrintButton);
    }(SvelteComponent);

    var $propertyIsEnumerable$1 = objectPropertyIsEnumerable$1.f;

    var propertyIsEnumerable = functionUncurryThis($propertyIsEnumerable$1);
    var push$1 = functionUncurryThis([].push); // `Object.{ entries, values }` methods implementation

    var createMethod$4 = function (TO_ENTRIES) {
      return function (it) {
        var O = toIndexedObject$1(it);
        var keys = objectKeys$1(O);
        var length = keys.length;
        var i = 0;
        var result = [];
        var key;

        while (length > i) {
          key = keys[i++];

          if (!descriptors$1 || propertyIsEnumerable(O, key)) {
            push$1(result, TO_ENTRIES ? [key, O[key]] : O[key]);
          }
        }

        return result;
      };
    };

    var objectToArray = {
      // `Object.entries` method
      // https://tc39.es/ecma262/#sec-object.entries
      entries: createMethod$4(true),
      // `Object.values` method
      // https://tc39.es/ecma262/#sec-object.values
      values: createMethod$4(false)
    };

    var $entries = objectToArray.entries; // `Object.entries` method
    // https://tc39.es/ecma262/#sec-object.entries


    _export$1({
      target: 'Object',
      stat: true
    }, {
      entries: function entries(O) {
        return $entries(O);
      }
    });

    var global$1$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;

    function init$1() {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray(b64) {
      if (!inited) {
        init$1();
      }

      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      } // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice


      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

      arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

      l = placeHolders > 0 ? len - 4 : len;
      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = tmp >> 16 & 0xFF;
        arr[L++] = tmp >> 8 & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[L++] = tmp >> 8 & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr;
    }

    function tripletToBase64(num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
    }

    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];

      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
        output.push(tripletToBase64(tmp));
      }

      return output.join('');
    }

    function fromByteArray(uint8) {
      if (!inited) {
        init$1();
      }

      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3
      // go through the array every three bytes, we'll deal with trailing stuff later

      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
      } // pad the end with zeros, but make sure to not forget the extra bytes


      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[tmp << 4 & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        output += lookup[tmp >> 10];
        output += lookup[tmp >> 4 & 0x3F];
        output += lookup[tmp << 2 & 0x3F];
        output += '=';
      }

      parts.push(output);
      return parts.join('');
    }

    function read(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;

      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;

      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }

      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }

    function write(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);

        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }

        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }

        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = e << mLen | m;
      eLen += mLen;

      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString$1 = {}.toString;

    var isArray$1 = Array.isArray || function (arr) {
      return toString$1.call(arr) == '[object Array]';
    };

    var INSPECT_MAX_BYTES = 50;
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */

    Buffer.TYPED_ARRAY_SUPPORT = global$1$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1$1.TYPED_ARRAY_SUPPORT : true;

    function kMaxLength() {
      return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
    }

    function createBuffer(that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length');
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }

        that.length = length;
      }

      return that;
    }
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */


    function Buffer(arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length);
      } // Common case.


      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error('If encoding is specified then the first argument must be a string');
        }

        return allocUnsafe(this, arg);
      }

      return from(this, arg, encodingOrOffset, length);
    }

    Buffer.poolSize = 8192; // not used by this implementation
    // TODO: Legacy, not needed anymore. Remove in next major version.

    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr;
    };

    function from(that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number');
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length);
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset);
      }

      return fromObject(that, value);
    }
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/


    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
    }

    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number');
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
    }

    function alloc(that, size, fill, encoding) {
      assertSize(size);

      if (size <= 0) {
        return createBuffer(that, size);
      }

      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
      }

      return createBuffer(that, size);
    }
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/


    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding);
    };

    function allocUnsafe(that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }

      return that;
    }
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */


    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size);
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */


    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size);
    };

    function fromString(that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);
      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that;
    }

    function fromArrayLike(that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);

      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }

      return that;
    }

    function fromArrayBuffer(that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds');
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds');
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }

      return that;
    }

    function fromObject(that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that;
        }

        obj.copy(that, 0, 0, len);
        return that;
      }

      if (obj) {
        if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0);
          }

          return fromArrayLike(that, obj);
        }

        if (obj.type === 'Buffer' && isArray$1(obj.data)) {
          return fromArrayLike(that, obj.data);
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
    }

    function checked(length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
      }

      return length | 0;
    }

    Buffer.isBuffer = isBuffer;

    function internalIsBuffer(b) {
      return !!(b != null && b._isBuffer);
    }

    Buffer.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers');
      }

      if (a === b) return 0;
      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true;

        default:
          return false;
      }
    };

    Buffer.concat = function concat(list, length) {
      if (!isArray$1(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      if (list.length === 0) {
        return Buffer.alloc(0);
      }

      var i;

      if (length === undefined) {
        length = 0;

        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;

      for (i = 0; i < list.length; ++i) {
        var buf = list[i];

        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }

        buf.copy(buffer, pos);
        pos += buf.length;
      }

      return buffer;
    };

    function byteLength(string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length;
      }

      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
      }

      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0; // Use a for loop to avoid recursion

      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len;

          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length;

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2;

          case 'hex':
            return len >>> 1;

          case 'base64':
            return base64ToBytes(string).length;

          default:
            if (loweredCase) return utf8ToBytes(string).length; // assume utf8

            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }

    Buffer.byteLength = byteLength;

    function slowToString(encoding, start, end) {
      var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

      if (start === undefined || start < 0) {
        start = 0;
      } // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.


      if (start > this.length) {
        return '';
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return '';
      } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return '';
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end);

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end);

          case 'ascii':
            return asciiSlice(this, start, end);

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end);

          case 'base64':
            return base64Slice(this, start, end);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.


    Buffer.prototype._isBuffer = true;

    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;

      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }

      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }

      return this;
    };

    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;

      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }

      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }

      return this;
    };

    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;

      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }

      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }

      return this;
    };

    Buffer.prototype.toString = function toString() {
      var length = this.length | 0;
      if (length === 0) return '';
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };

    Buffer.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
      if (this === b) return true;
      return Buffer.compare(this, b) === 0;
    };

    Buffer.prototype.inspect = function inspect() {
      var str = '';
      var max = INSPECT_MAX_BYTES;

      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }

      return '<Buffer ' + str + '>';
    };

    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer');
      }

      if (start === undefined) {
        start = 0;
      }

      if (end === undefined) {
        end = target ? target.length : 0;
      }

      if (thisStart === undefined) {
        thisStart = 0;
      }

      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }

      if (thisStart >= thisEnd) {
        return -1;
      }

      if (start >= end) {
        return 1;
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf


    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1; // Normalize byteOffset

      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }

      byteOffset = +byteOffset; // Coerce to Number.

      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : buffer.length - 1;
      } // Normalize byteOffset: negative offsets start from the end of the buffer


      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

      if (byteOffset >= buffer.length) {
        if (dir) return -1;else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;else return -1;
      } // Normalize val


      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      } // Finally, search either indexOf (if dir is true) or lastIndexOf


      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1;
        }

        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]

        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }

        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }

      throw new TypeError('val must be string, number or Buffer');
    }

    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();

        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }

          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i];
        } else {
          return buf.readUInt16BE(i * indexSize);
        }
      }

      var i;

      if (dir) {
        var foundIndex = -1;

        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

        for (i = byteOffset; i >= 0; i--) {
          var found = true;

          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }

          if (found) return i;
        }
      }

      return -1;
    }

    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };

    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };

    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;

      if (!length) {
        length = remaining;
      } else {
        length = Number(length);

        if (length > remaining) {
          length = remaining;
        }
      } // must be an even number of digits


      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

      if (length > strLen / 2) {
        length = strLen / 2;
      }

      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }

      return i;
    }

    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }

    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }

    function latin1Write(buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length);
    }

    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }

    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }

    Buffer.prototype.write = function write(string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0; // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0; // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;

        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        } // legacy write(string, encoding, offset, length) - remove in v0.13

      } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
      }

      if (!encoding) encoding = 'utf8';
      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length);

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length);

          case 'ascii':
            return asciiWrite(this, string, offset, length);

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length);

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };

    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf);
      } else {
        return fromByteArray(buf.slice(start, end));
      }
    }

    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;

      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }

              break;

            case 2:
              secondByte = buf[i + 1];

              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }

          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res);
    } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety


    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;

      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
      } // Decode in chunks to avoid "call stack size exceeded".


      var res = '';
      var i = 0;

      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }

      return res;
    }

    function asciiSlice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }

      return ret;
    }

    function latin1Slice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }

      return ret;
    }

    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = '';

      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }

      return out;
    }

    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';

      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }

      return res;
    }

    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;
      var newBuf;

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);

        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf;
    };
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */


    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
    }

    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val;
    };

    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;

      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;

      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val;
    };

    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };

    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];

      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return this[offset];
      return (0xff - this[offset] + 1) * -1;
    };

    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };

    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };

    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };

    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };

    function checkInt(buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = value & 0xff;
      return offset + 1;
    };

    function objectWriteUInt16(buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;

      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }

      return offset + 2;
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }

      return offset + 2;
    };

    function objectWriteUInt32(buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;

      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }

      return offset + 4;
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }

      return offset + 4;
    };

    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }

      return offset + 2;
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }

      return offset + 2;
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }

      return offset + 4;
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }

      return offset + 4;
    };

    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
      if (offset < 0) throw new RangeError('Index out of range');
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }

      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };

    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }

      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
      }

      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
      if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

      if (end > this.length) end = this.length;

      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }

      return len;
    }; // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])


    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }

        if (val.length === 1) {
          var code = val.charCodeAt(0);

          if (code < 256) {
            val = code;
          }
        }

        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string');
        }

        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      } // Invalid ranges are not set to a default, so can range check early.


      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
      }

      if (end <= start) {
        return this;
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;

      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;

        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this;
    }; // HELPER FUNCTIONS
    // ================


    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean(str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

      if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

      while (str.length % 4 !== 0) {
        str = str + '=';
      }

      return str;
    }

    function stringtrim(str) {
      if (str.trim) return str.trim();
      return str.replace(/^\s+|\s+$/g, '');
    }

    function toHex(n) {
      if (n < 16) return '0' + n.toString(16);
      return n.toString(16);
    }

    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i); // is surrogate component

        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } // valid lead


            leadSurrogate = codePoint;
            continue;
          } // 2 leads in a row


          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          } // valid surrogate pair


          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null; // encode utf8

        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new Error('Invalid code point');
        }
      }

      return bytes;
    }

    function asciiToBytes(str) {
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }

      return byteArray;
    }

    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray;
    }

    function base64ToBytes(str) {
      return toByteArray(base64clean(str));
    }

    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }

      return i;
    }

    function isnan(val) {
      return val !== val; // eslint-disable-line no-self-compare
    } // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually


    function isBuffer(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
    }

    function isFastBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
    } // For Node v0.10 support. Remove this eventually.


    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
    }

    var domain; // This constructor is used to store event handlers. Instantiating this is
    // faster than explicitly calling `Object.create(null)` to get a "clean" empty
    // object (tested with v8 v4.9).

    function EventHandlers() {}

    EventHandlers.prototype = Object.create(null);

    function EventEmitter() {
      EventEmitter.init.call(this);
    } // nodejs oddity
    // require('events') === require('events').EventEmitter


    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = undefined;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.

    EventEmitter.defaultMaxListeners = 10;

    EventEmitter.init = function () {
      this.domain = null;

      if (EventEmitter.usingDomains) {
        // if there is an active domain, then attach to it.
        if (domain.active) ;
      }

      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }

      this._maxListeners = this._maxListeners || undefined;
    }; // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.


    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };

    function $getMaxListeners(that) {
      if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }

    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    }; // These standalone emit* functions are used to optimize calling of event
    // handlers for fast cases because emit() itself often has a variable number of
    // arguments and can be deoptimized because of that. These functions always have
    // the same number of arguments and thus do not get deoptimized, so the code
    // inside them can execute faster.


    function emitNone(handler, isFn, self) {
      if (isFn) handler.call(self);else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);

        for (var i = 0; i < len; ++i) listeners[i].call(self);
      }
    }

    function emitOne(handler, isFn, self, arg1) {
      if (isFn) handler.call(self, arg1);else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);

        for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
      }
    }

    function emitTwo(handler, isFn, self, arg1, arg2) {
      if (isFn) handler.call(self, arg1, arg2);else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);

        for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
      }
    }

    function emitThree(handler, isFn, self, arg1, arg2, arg3) {
      if (isFn) handler.call(self, arg1, arg2, arg3);else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);

        for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
      }
    }

    function emitMany(handler, isFn, self, args) {
      if (isFn) handler.apply(self, args);else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);

        for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
      }
    }

    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain;
      var doError = type === 'error';
      events = this._events;
      if (events) doError = doError && events.error == null;else if (!doError) return false;
      domain = this.domain; // If there is no 'error' event listener then throw.

      if (doError) {
        er = arguments[1];

        if (domain) {
          if (!er) er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain;
          er.domainThrown = false;
          domain.emit('error', er);
        } else if (er instanceof Error) {
          throw er; // Unhandled 'error' event
        } else {
          // At least give some kind of context to the user
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
          err.context = er;
          throw err;
        }

        return false;
      }

      handler = events[type];
      if (!handler) return false;
      var isFn = typeof handler === 'function';
      len = arguments.length;

      switch (len) {
        // fast cases
        case 1:
          emitNone(handler, isFn, this);
          break;

        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;

        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;

        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        // slower

        default:
          args = new Array(len - 1);

          for (i = 1; i < len; i++) args[i - 1] = arguments[i];

          emitMany(handler, isFn, this, args);
      }

      return true;
    };

    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
      events = target._events;

      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener) {
          target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object

          events = target._events;
        }

        existing = events[type];
      }

      if (!existing) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else {
          // If we've already got an array, just append.
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        } // Check for listener leak


        if (!existing.warned) {
          m = $getMaxListeners(target);

          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }

      return target;
    }

    function emitWarning(e) {
      typeof console.warn === 'function' ? console.warn(e) : console.log(e);
    }

    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

    function _onceWrap(target, type, listener) {
      var fired = false;

      function g() {
        target.removeListener(type, g);

        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }

      g.listener = listener;
      return g;
    }

    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };

    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    }; // emits a 'removeListener' event iff the listener was removed


    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events) return this;
      list = events[type];
      if (!list) return this;

      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0) this._events = new EventHandlers();else {
          delete events[type];
          if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0) return this;

        if (list.length === 1) {
          list[0] = undefined;

          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener) this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events;
      events = this._events;
      if (!events) return this; // not listening for removeListener, no need to emit

      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];
        }

        return this;
      } // emit removeListener for all listeners on all events


      if (arguments.length === 0) {
        var keys = Object.keys(events);

        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }

        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events) ret = [];else {
        evlistener = events[type];
        if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);
      }
      return ret;
    };

    EventEmitter.listenerCount = function (emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount$1.call(emitter, type);
      }
    };

    EventEmitter.prototype.listenerCount = listenerCount$1;

    function listenerCount$1(type) {
      var events = this._events;

      if (events) {
        var evlistener = events[type];

        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }

      return 0;
    }

    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    }; // About 1.5x faster than the two-arg version of Array#splice().


    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];

      list.pop();
    }

    function arrayClone(arr, i) {
      var copy = new Array(i);

      while (i--) copy[i] = arr[i];

      return copy;
    }

    function unwrapListeners(arr) {
      var ret = new Array(arr.length);

      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }

      return ret;
    } // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js


    function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
    }

    function defaultClearTimeout() {
      throw new Error('clearTimeout has not been defined');
    }

    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;

    if (typeof global$1$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    }

    if (typeof global$1$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
      } // if setTimeout wasn't available but was latter defined


      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }

      try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }

    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
      } // if clearTimeout wasn't available but was latter defined


      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }

      try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
          // Some versions of I.E. have different rules for clearTimeout vs setTimeout
          return cachedClearTimeout.call(this, marker);
        }
      }
    }

    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }

      draining = false;

      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }

      if (queue.length) {
        drainQueue();
      }
    }

    function drainQueue() {
      if (draining) {
        return;
      }

      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;

      while (len) {
        currentQueue = queue;
        queue = [];

        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }

        queueIndex = -1;
        len = queue.length;
      }

      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }

    function nextTick(fun) {
      var args = new Array(arguments.length - 1);

      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }

      queue.push(new Item(fun, args));

      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    } // v8 likes predictible objects


    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }

    Item.prototype.run = function () {
      this.fun.apply(null, this.array);
    }; // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js


    var performance = global$1$1.performance || {};
    performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
      return new Date().getTime();
    };

    var inherits;

    if (typeof Object.create === 'function') {
      inherits = function inherits(ctor, superCtor) {
        // implementation from standard node.js 'util' module
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function () {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }

    var inherits$1 = inherits;
    var formatRegExp = /%[sdj%]/g;

    function format(f) {
      if (!isString(f)) {
        var objects = [];

        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }

        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function (x) {
        if (x === '%%') return '%';
        if (i >= len) return x;

        switch (x) {
          case '%s':
            return String(args[i++]);

          case '%d':
            return Number(args[i++]);

          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }

          default:
            return x;
        }
      });

      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject$1(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }

      return str;
    } // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.


    function deprecate(fn, msg) {
      // Allow for deprecating things in the process of starting up.
      if (isUndefined(global$1$1.process)) {
        return function () {
          return deprecate(fn, msg).apply(this, arguments);
        };
      }

      var warned = false;

      function deprecated() {
        if (!warned) {
          {
            console.error(msg);
          }
          warned = true;
        }

        return fn.apply(this, arguments);
      }

      return deprecated;
    }

    var debugs = {};
    var debugEnviron;

    function debuglog(set) {
      if (isUndefined(debugEnviron)) debugEnviron = '';
      set = set.toUpperCase();

      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = 0;

          debugs[set] = function () {
            var msg = format.apply(null, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function () {};
        }
      }

      return debugs[set];
    }
    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */

    /* legacy: obj, showHidden, depth, colors*/


    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      }; // legacy...

      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];

      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        _extend(ctx, opts);
      } // set default options


      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    } // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics


    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    }; // Don't use 'blue' not visible on cmd.exe

    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };

    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }

    function stylizeNoColor(str, styleType) {
      return str;
    }

    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }

    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);

        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }

        return ret;
      } // Primitive types cannot have properties


      var primitive = formatPrimitive(ctx, value);

      if (primitive) {
        return primitive;
      } // Look up the keys of the object.


      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      } // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      } // Some type of object without properties can be shortcutted.


      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }

        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }

        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }

        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '',
          array = false,
          braces = ['{', '}']; // Make Array say that they are Array

      if (isArray$2(value)) {
        array = true;
        braces = ['[', ']'];
      } // Make functions say that they are functions


      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      } // Make RegExps say that they are RegExps


      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      } // Make dates with properties first say the date


      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      } // Make error with message first say the error


      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);
      var output;

      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }

    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }

      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

      if (isNull(value)) return ctx.stylize('null', 'null');
    }

    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }

    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];

      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty$1(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }

      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }

    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };

      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }

      if (!hasOwnProperty$1(visibleKeys, key)) {
        name = '[' + key + ']';
      }

      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }

          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }

      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }

        name = JSON.stringify('' + key);

        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }

    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function (prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    } // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.


    function isArray$2(ar) {
      return Array.isArray(ar);
    }

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    function isString(arg) {
      return typeof arg === 'string';
    }

    function isUndefined(arg) {
      return arg === void 0;
    }

    function isRegExp(re) {
      return isObject$1(re) && objectToString$1(re) === '[object RegExp]';
    }

    function isObject$1(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isDate(d) {
      return isObject$1(d) && objectToString$1(d) === '[object Date]';
    }

    function isError(e) {
      return isObject$1(e) && (objectToString$1(e) === '[object Error]' || e instanceof Error);
    }

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    function objectToString$1(o) {
      return Object.prototype.toString.call(o);
    }

    function _extend(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject$1(add)) return origin;
      var keys = Object.keys(add);
      var i = keys.length;

      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }

      return origin;
    }

    function hasOwnProperty$1(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    function BufferList() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }

    BufferList.prototype.push = function (v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    };

    BufferList.prototype.unshift = function (v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    };

    BufferList.prototype.shift = function () {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    };

    BufferList.prototype.clear = function () {
      this.head = this.tail = null;
      this.length = 0;
    };

    BufferList.prototype.join = function (s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    };

    BufferList.prototype.concat = function (n) {
      if (this.length === 0) return Buffer.alloc(0);
      if (this.length === 1) return this.head.data;
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    }; // Copyright Joyent, Inc. and other Node contributors.


    var isBufferEncoding = Buffer.isEncoding || function (encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
          return true;

        default:
          return false;
      }
    };

    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    } // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters. CESU-8 is handled as part of the UTF-8 encoding.
    //
    // @TODO Handling all encodings inside a single object makes it very difficult
    // to reason about this code, so it should be split up in the future.
    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
    // points as used by CESU-8.


    function StringDecoder(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);

      switch (this.encoding) {
        case 'utf8':
          // CESU-8 represents each of Surrogate Pair by 3-bytes
          this.surrogateSize = 3;
          break;

        case 'ucs2':
        case 'utf16le':
          // UTF-16 represents each of Surrogate Pair by 2-bytes
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;

        case 'base64':
          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;

        default:
          this.write = passThroughWrite;
          return;
      } // Enough space to store all bytes of a single character. UTF-8 needs 4
      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).


      this.charBuffer = new Buffer(6); // Number of bytes received for the current incomplete multi-byte character.

      this.charReceived = 0; // Number of bytes expected for the current incomplete multi-byte character.

      this.charLength = 0;
    } // write decodes the given buffer and returns it as JS string that is
    // guaranteed to not contain any partial multi-byte characters. Any partial
    // character found at the end of the buffer is buffered up, and will be
    // returned when calling write again with the remaining bytes.
    //
    // Note: Converting a Buffer containing an orphan surrogate to a String
    // currently works, but converting a String to a Buffer (via `new Buffer`, or
    // Buffer#write) will replace incomplete surrogates with the unicode
    // replacement character. See https://codereview.chromium.org/121173009/ .


    StringDecoder.prototype.write = function (buffer) {
      var charStr = ''; // if our last write ended with an incomplete multibyte character

      while (this.charLength) {
        // determine how many remaining bytes this buffer has to offer for this char
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length; // add the new bytes to the char buffer

        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;

        if (this.charReceived < this.charLength) {
          // still not enough chars in this buffer? wait for more ...
          return '';
        } // remove bytes belonging to the current character from the buffer


        buffer = buffer.slice(available, buffer.length); // get the character that was split

        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding); // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character

        var charCode = charStr.charCodeAt(charStr.length - 1);

        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }

        this.charReceived = this.charLength = 0; // if there are no more bytes in this buffer, just emit our char

        if (buffer.length === 0) {
          return charStr;
        }

        break;
      } // determine and set charLength / charReceived


      this.detectIncompleteChar(buffer);
      var end = buffer.length;

      if (this.charLength) {
        // buffer the incomplete character bytes we got
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }

      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end); // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character

      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      } // or just emit the charStr


      return charStr;
    }; // detectIncompleteChar determines if there is an incomplete UTF-8 character at
    // the end of the given buffer. If so, it sets this.charLength to the byte
    // length that character, and sets this.charReceived to the number of bytes
    // that are available for this character.


    StringDecoder.prototype.detectIncompleteChar = function (buffer) {
      // determine how many bytes we have to check at the end of this buffer
      var i = buffer.length >= 3 ? 3 : buffer.length; // Figure out if one of the last i bytes of our buffer announces an
      // incomplete char.

      for (; i > 0; i--) {
        var c = buffer[buffer.length - i]; // See http://en.wikipedia.org/wiki/UTF-8#Description
        // 110XXXXX

        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        } // 1110XXXX


        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        } // 11110XXX


        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }

      this.charReceived = i;
    };

    StringDecoder.prototype.end = function (buffer) {
      var res = '';
      if (buffer && buffer.length) res = this.write(buffer);

      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }

      return res;
    };

    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }

    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }

    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }

    Readable.ReadableState = ReadableState;
    var debug$1 = debuglog('stream');
    inherits$1(Readable, EventEmitter);

    function prependListener(emitter, event, fn) {
      // Sadly this is not cacheable as some libraries bundle their own
      // event emitter implementation with them.
      if (typeof emitter.prependListener === 'function') {
        return emitter.prependListener(event, fn);
      } else {
        // This is a hack to make sure that our error handler is attached before any
        // userland ones.  NEVER DO THIS. This is here only because this code needs
        // to continue to work with older versions of Node.js that do not include
        // the prependListener() method. The goal is to eventually remove this hack.
        if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
      }
    }

    function listenerCount(emitter, type) {
      return emitter.listeners(type).length;
    }

    function ReadableState(options, stream) {
      options = options || {}; // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away

      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"

      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // cast to ints.

      this.highWaterMark = ~~this.highWaterMark; // A linked list is used to store data chunks instead of an array because the
      // linked list can remove elements from the beginning faster than
      // array.shift()

      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false; // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.

      this.sync = true; // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.

      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false; // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.

      this.defaultEncoding = options.defaultEncoding || 'utf8'; // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.

      this.ranOut = false; // the number of writers that are awaiting a drain event in .pipe()s

      this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;

      if (options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }

    function Readable(options) {
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this); // legacy

      this.readable = true;
      if (options && typeof options.read === 'function') this._read = options.read;
      EventEmitter.call(this);
    } // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.


    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState;

      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;

        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = '';
        }
      }

      return readableAddChunk(this, state, chunk, encoding, false);
    }; // Unshift should *always* be something directly out of read()


    Readable.prototype.unshift = function (chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };

    Readable.prototype.isPaused = function () {
      return this._readableState.flowing === false;
    };

    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);

      if (er) {
        stream.emit('error', er);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var _e = new Error('stream.unshift() after end event');

          stream.emit('error', _e);
        } else {
          var skipAdd;

          if (state.decoder && !addToFront && !encoding) {
            chunk = state.decoder.write(chunk);
            skipAdd = !state.objectMode && chunk.length === 0;
          }

          if (!addToFront) state.reading = false; // Don't add to the buffer if we've decoded to an empty string chunk and
          // we're not in object mode

          if (!skipAdd) {
            // if we want the data now, just emit it.
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk);
              stream.read(0);
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
              if (state.needReadable) emitReadable(stream);
            }
          }

          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }

      return needMoreData(state);
    } // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.


    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    } // backwards compatibility.


    Readable.prototype.setEncoding = function (enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    }; // Don't raise the hwm > 8MB


    var MAX_HWM = 0x800000;

    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }

      return n;
    } // This function is designed to be inlinable, so please take care when making
    // changes to the function body.


    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;

      if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
      } // If we're asking for more than the current hwm, then raise the hwm.


      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n; // Don't have enough

      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }

      return state.length;
    } // you can override either this method, or the async _read(n) below.


    Readable.prototype.read = function (n) {
      debug$1('read', n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.

      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug$1('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
        return null;
      }

      n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      } // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.
      // if we need a readable event, then we need to do some reading.


      var doRead = state.needReadable;
      debug$1('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug$1('length less than watermark', doRead);
      } // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.


      if (state.ended || state.reading) {
        doRead = false;
        debug$1('reading or ended', doRead);
      } else if (doRead) {
        debug$1('do read');
        state.reading = true;
        state.sync = true; // if the length is currently zero, then we *need* a readable event.

        if (state.length === 0) state.needReadable = true; // call internal read method

        this._read(state.highWaterMark);

        state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.

        if (!state.reading) n = howMuchToRead(nOrig, state);
      }

      var ret;
      if (n > 0) ret = fromList(n, state);else ret = null;

      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }

      if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

        if (nOrig !== n && state.ended) endReadable(this);
      }

      if (ret !== null) this.emit('data', ret);
      return ret;
    };

    function chunkInvalid(state, chunk) {
      var er = null;

      if (!isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }

      return er;
    }

    function onEofChunk(stream, state) {
      if (state.ended) return;

      if (state.decoder) {
        var chunk = state.decoder.end();

        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }

      state.ended = true; // emit 'readable' now to make sure it gets picked up.

      emitReadable(stream);
    } // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.


    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;

      if (!state.emittedReadable) {
        debug$1('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
      }
    }

    function emitReadable_(stream) {
      debug$1('emit readable');
      stream.emit('readable');
      flow(stream);
    } // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.


    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        nextTick(maybeReadMore_, stream, state);
      }
    }

    function maybeReadMore_(stream, state) {
      var len = state.length;

      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug$1('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length) // didn't get any data, stop spinning.
          break;else len = state.length;
      }

      state.readingMore = false;
    } // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.


    Readable.prototype._read = function (n) {
      this.emit('error', new Error('not implemented'));
    };

    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this;
      var state = this._readableState;

      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;

        case 1:
          state.pipes = [state.pipes, dest];
          break;

        default:
          state.pipes.push(dest);
          break;
      }

      state.pipesCount += 1;
      debug$1('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);
      dest.on('unpipe', onunpipe);

      function onunpipe(readable) {
        debug$1('onunpipe');

        if (readable === src) {
          cleanup();
        }
      }

      function onend() {
        debug$1('onend');
        dest.end();
      } // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.


      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);
      var cleanedUp = false;

      function cleanup() {
        debug$1('cleanup'); // cleanup event handlers once the pipe is broken

        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
        cleanedUp = true; // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.

        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      } // If the user pushes more data while we're writing to dest then we'll end up
      // in ondata again. However, we only want to increase awaitDrain once because
      // dest will only emit one 'drain' event for the multiple writes.
      // => Introduce a guard on increasing awaitDrain.


      var increasedAwaitDrain = false;
      src.on('data', ondata);

      function ondata(chunk) {
        debug$1('ondata');
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);

        if (false === ret && !increasedAwaitDrain) {
          // If the user unpiped during `dest.write()`, it is possible
          // to get stuck in a permanently paused state if that write
          // also returned false.
          // => Check whether `dest` is still a piping destination.
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf$1(state.pipes, dest) !== -1) && !cleanedUp) {
            debug$1('false write response, pause', src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }

          src.pause();
        }
      } // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.


      function onerror(er) {
        debug$1('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
      } // Make sure our error handler is attached before userland ones.


      prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }

      dest.once('close', onclose);

      function onfinish() {
        debug$1('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }

      dest.once('finish', onfinish);

      function unpipe() {
        debug$1('unpipe');
        src.unpipe(dest);
      } // tell the dest that it's being piped to


      dest.emit('pipe', src); // start the flow if it hasn't been started already.

      if (!state.flowing) {
        debug$1('pipe resume');
        src.resume();
      }

      return dest;
    };

    function pipeOnDrain(src) {
      return function () {
        var state = src._readableState;
        debug$1('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;

        if (state.awaitDrain === 0 && src.listeners('data').length) {
          state.flowing = true;
          flow(src);
        }
      };
    }

    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState; // if we're not piping anywhere, then do nothing.

      if (state.pipesCount === 0) return this; // just one destination.  most common case.

      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes; // got a match.

        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this);
        return this;
      } // slow case. multiple pipe destinations.


      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;

        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit('unpipe', this);
        }

        return this;
      } // try to find the right one.


      var i = indexOf$1(state.pipes, dest);
      if (i === -1) return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit('unpipe', this);
      return this;
    }; // set up data events if they are asked for
    // Ensure readable listeners eventually get something


    Readable.prototype.on = function (ev, fn) {
      var res = EventEmitter.prototype.on.call(this, ev, fn);

      if (ev === 'data') {
        // Start flowing on next tick if stream isn't explicitly paused
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === 'readable') {
        var state = this._readableState;

        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;

          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }

      return res;
    };

    Readable.prototype.addListener = Readable.prototype.on;

    function nReadingNextTick(self) {
      debug$1('readable nexttick read 0');
      self.read(0);
    } // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.


    Readable.prototype.resume = function () {
      var state = this._readableState;

      if (!state.flowing) {
        debug$1('resume');
        state.flowing = true;
        resume(this, state);
      }

      return this;
    };

    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick(resume_, stream, state);
      }
    }

    function resume_(stream, state) {
      if (!state.reading) {
        debug$1('resume read 0');
        stream.read(0);
      }

      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }

    Readable.prototype.pause = function () {
      debug$1('call pause flowing=%j', this._readableState.flowing);

      if (false !== this._readableState.flowing) {
        debug$1('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }

      return this;
    };

    function flow(stream) {
      var state = stream._readableState;
      debug$1('flow', state.flowing);

      while (state.flowing && stream.read() !== null) {}
    } // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.


    Readable.prototype.wrap = function (stream) {
      var state = this._readableState;
      var paused = false;
      var self = this;
      stream.on('end', function () {
        debug$1('wrapped end');

        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) self.push(chunk);
        }

        self.push(null);
      });
      stream.on('data', function (chunk) {
        debug$1('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

        if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = self.push(chunk);

        if (!ret) {
          paused = true;
          stream.pause();
        }
      }); // proxy all the other methods.
      // important when wrapping filters and duplexes.

      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function (method) {
            return function () {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      } // proxy certain important events.


      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function (ev) {
        stream.on(ev, self.emit.bind(self, ev));
      }); // when we try to consume some more bytes, simply unpause the
      // underlying stream.

      self._read = function (n) {
        debug$1('wrapped _read', n);

        if (paused) {
          paused = false;
          stream.resume();
        }
      };

      return self;
    }; // exposed for testing purposes only.


    Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.

    function fromList(n, state) {
      // nothing buffered
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        // read part of list
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    } // Extracts only enough buffered data to satisfy the amount requested.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.


    function fromListPartial(n, list, hasStrings) {
      var ret;

      if (n < list.head.data.length) {
        // slice is the same for buffers and strings
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        // first chunk is a perfect match
        ret = list.shift();
      } else {
        // result spans more than one buffer
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }

      return ret;
    } // Copies a specified amount of characters from the list of buffered data
    // chunks.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.


    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      list.length -= c;
      return ret;
    } // Copies a specified amount of bytes from the list of buffered data chunks.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.


    function copyFromBuffer(n, list) {
      var ret = Buffer.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      list.length -= c;
      return ret;
    }

    function endReadable(stream) {
      var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.

      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

      if (!state.endEmitted) {
        state.ended = true;
        nextTick(endReadableNT, state, stream);
      }
    }

    function endReadableNT(state, stream) {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    }

    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }

    function indexOf$1(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }

      return -1;
    } // A bit simpler than readable streams.


    Writable.WritableState = WritableState;
    inherits$1(Writable, EventEmitter);

    function nop() {}

    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }

    function WritableState(options, stream) {
      Object.defineProperty(this, 'buffer', {
        get: deprecate(function () {
          return this.getBuffer();
        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
      });
      options = options || {}; // object stream flag to indicate whether or not this stream
      // contains buffers or objects.

      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()

      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // cast to ints.

      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false; // at the start of calling end()

      this.ending = false; // when end() has been called, and returned

      this.ended = false; // when 'finish' is emitted

      this.finished = false; // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.

      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.

      this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.

      this.length = 0; // a flag to see when we're in the middle of a write.

      this.writing = false; // when true all writes will be buffered until .uncork() call

      this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.

      this.sync = true; // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.

      this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

      this.onwrite = function (er) {
        onwrite(stream, er);
      }; // the callback that the user supplies to write(chunk,encoding,cb)


      this.writecb = null; // the amount that is being written when _write is called.

      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
      // this must be 0 before 'finish' can be emitted

      this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
      // This is relevant for synchronous Transform streams

      this.prefinished = false; // True if the error was already emitted and should not be thrown again

      this.errorEmitted = false; // count buffered requests

      this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
      // one allocated and free to use, and we maintain at most two

      this.corkedRequestsFree = new CorkedRequest(this);
    }

    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];

      while (current) {
        out.push(current);
        current = current.next;
      }

      return out;
    };

    function Writable(options) {
      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
      this._writableState = new WritableState(options, this); // legacy.

      this.writable = true;

      if (options) {
        if (typeof options.write === 'function') this._write = options.write;
        if (typeof options.writev === 'function') this._writev = options.writev;
      }

      EventEmitter.call(this);
    } // Otherwise people can pipe Writable streams, which is just wrong.


    Writable.prototype.pipe = function () {
      this.emit('error', new Error('Cannot pipe, not readable'));
    };

    function writeAfterEnd(stream, cb) {
      var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

      stream.emit('error', er);
      nextTick(cb, er);
    } // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.


    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false; // Always throw error if a null is written
      // if we are not in object mode then throw
      // if it is not a buffer, string, or undefined.

      if (chunk === null) {
        er = new TypeError('May not write null values to stream');
      } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }

      if (er) {
        stream.emit('error', er);
        nextTick(cb, er);
        valid = false;
      }

      return valid;
    }

    Writable.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;

      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== 'function') cb = nop;
      if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };

    Writable.prototype.cork = function () {
      var state = this._writableState;
      state.corked++;
    };

    Writable.prototype.uncork = function () {
      var state = this._writableState;

      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };

    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string') encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };

    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = Buffer.from(chunk, encoding);
      }

      return chunk;
    } // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.


    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer.isBuffer(chunk)) encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

      if (!ret) state.needDrain = true;

      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);

        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }

        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }

      return ret;
    }

    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }

    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) nextTick(cb, er);else cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }

    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }

    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);

        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }

        if (sync) {
          /*<replacement>*/
          nextTick(afterWrite, stream, state, finished, cb);
          /*</replacement>*/
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }

    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    } // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.


    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    } // if there's something in the buffer waiting, then process it


    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;

      if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;

        while (entry) {
          buffer[count] = entry;
          entry = entry.next;
          count += 1;
        }

        doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite

        state.pendingcb++;
        state.lastBufferedRequest = null;

        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
      } else {
        // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next; // if we didn't call the onwrite immediately, then
          // it means that we need to wait until it does.
          // also, that means that the chunk and cb are currently
          // being processed, so move the buffer counter past them.

          if (state.writing) {
            break;
          }
        }

        if (entry === null) state.lastBufferedRequest = null;
      }

      state.bufferedRequestCount = 0;
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }

    Writable.prototype._write = function (chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };

    Writable.prototype._writev = null;

    Writable.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState;

      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

      if (state.corked) {
        state.corked = 1;
        this.uncork();
      } // ignore unnecessary end() calls.


      if (!state.ending && !state.finished) endWritable(this, state, cb);
    };

    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }

    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }

    function finishMaybe(stream, state) {
      var need = needFinish(state);

      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish(stream, state);
        }
      }

      return need;
    }

    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);

      if (cb) {
        if (state.finished) nextTick(cb);else stream.once('finish', cb);
      }

      state.ended = true;
      stream.writable = false;
    } // It seems a linked list but it is not
    // there will be only 2 of these for each stream


    function CorkedRequest(state) {
      var _this = this;

      this.next = null;
      this.entry = null;

      this.finish = function (err) {
        var entry = _this.entry;
        _this.entry = null;

        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }

        if (state.corkedRequestsFree) {
          state.corkedRequestsFree.next = _this;
        } else {
          state.corkedRequestsFree = _this;
        }
      };
    }

    inherits$1(Duplex, Readable);
    var keys$3 = Object.keys(Writable.prototype);

    for (var v = 0; v < keys$3.length; v++) {
      var method = keys$3[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }

    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once('end', onend);
    } // the no-half-open enforcer


    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
      // But allow more writes to happen in this tick.

      nextTick(onEndNT, this);
    }

    function onEndNT(self) {
      self.end();
    } // a transform stream is a readable/writable stream where you do


    inherits$1(Transform, Duplex);

    function TransformState(stream) {
      this.afterTransform = function (er, data) {
        return afterTransform(stream, er, data);
      };

      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
      this.writeencoding = null;
    }

    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== undefined) stream.push(data);
      cb(er);
      var rs = stream._readableState;
      rs.reading = false;

      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }

    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(this); // when the writable side finishes, then flush out anything remaining.

      var stream = this; // start out asking for a readable event once data is transformed.

      this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.

      this._readableState.sync = false;

      if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;
        if (typeof options.flush === 'function') this._flush = options.flush;
      }

      this.once('prefinish', function () {
        if (typeof this._flush === 'function') this._flush(function (er) {
          done(stream, er);
        });else done(stream);
      });
    }

    Transform.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    }; // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.


    Transform.prototype._transform = function (chunk, encoding, cb) {
      throw new Error('Not implemented');
    };

    Transform.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;

      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    }; // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.


    Transform.prototype._read = function (n) {
      var ts = this._transformState;

      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;

        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };

    function done(stream, er) {
      if (er) return stream.emit('error', er); // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided

      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length) throw new Error('Calling transform done when ws.length != 0');
      if (ts.transforming) throw new Error('Calling transform done when still transforming');
      return stream.push(null);
    }

    inherits$1(PassThrough, Transform);

    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }

    PassThrough.prototype._transform = function (chunk, encoding, cb) {
      cb(null, chunk);
    };

    inherits$1(Stream, EventEmitter);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough; // Backwards-compat with node 0.4.x

    Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
    // part of this class) is overridden in the Readable class.

    function Stream() {
      EventEmitter.call(this);
    }

    Stream.prototype.pipe = function (dest, options) {
      var source = this;

      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }

      source.on('data', ondata);

      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }

      dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
      // source gets the 'end' or 'close' events.  Only dest.end() once.

      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
      }

      var didOnEnd = false;

      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }

      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === 'function') dest.destroy();
      } // don't leave dangling pipes when there are errors.


      function onerror(er) {
        cleanup();

        if (EventEmitter.listenerCount(this, 'error') === 0) {
          throw er; // Unhandled stream error in pipe.
        }
      }

      source.on('error', onerror);
      dest.on('error', onerror); // remove all the event listeners that were added.

      function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);
        source.removeListener('end', onend);
        source.removeListener('close', onclose);
        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);
        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);
        dest.removeListener('close', cleanup);
      }

      source.on('end', cleanup);
      source.on('close', cleanup);
      dest.on('close', cleanup);
      dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

      return dest;
    };

    class ResizeableBuffer {
      constructor(size = 100) {
        this.size = size;
        this.length = 0;
        this.buf = Buffer.allocUnsafe(size);
      }

      prepend(val) {
        if (isBuffer(val)) {
          const length = this.length + val.length;

          if (length >= this.size) {
            this.resize();

            if (length >= this.size) {
              throw Error('INVALID_BUFFER_STATE');
            }
          }

          const buf = this.buf;
          this.buf = Buffer.allocUnsafe(this.size);
          val.copy(this.buf, 0);
          buf.copy(this.buf, val.length);
          this.length += val.length;
        } else {
          const length = this.length++;

          if (length === this.size) {
            this.resize();
          }

          const buf = this.clone();
          this.buf[0] = val;
          buf.copy(this.buf, 1, 0, length);
        }
      }

      append(val) {
        const length = this.length++;

        if (length === this.size) {
          this.resize();
        }

        this.buf[length] = val;
      }

      clone() {
        return Buffer.from(this.buf.slice(0, this.length));
      }

      resize() {
        const length = this.length;
        this.size = this.size * 2;
        const buf = Buffer.allocUnsafe(this.size);
        this.buf.copy(buf, 0, 0, length);
        this.buf = buf;
      }

      toString(encoding) {
        if (encoding) {
          return this.buf.slice(0, this.length).toString(encoding);
        } else {
          return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
        }
      }

      toJSON() {
        return this.toString('utf8');
      }

      reset() {
        this.length = 0;
      }

    } // white space characters
    // https://en.wikipedia.org/wiki/Whitespace_character
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types
    // \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff


    const tab = 9;
    const nl = 10; // \n, 0x0A in hexadecimal, 10 in decimal

    const np = 12;
    const cr = 13; // \r, 0x0D in hexadÃ©cimal, 13 in decimal

    const space = 32;
    const boms = {
      // Note, the following are equals:
      // Buffer.from("\ufeff")
      // Buffer.from([239, 187, 191])
      // Buffer.from('EFBBBF', 'hex')
      'utf8': Buffer.from([239, 187, 191]),
      // Note, the following are equals:
      // Buffer.from "\ufeff", 'utf16le
      // Buffer.from([255, 254])
      'utf16le': Buffer.from([255, 254])
    };

    class CsvError extends Error {
      constructor(code, message, options, ...contexts) {
        if (Array.isArray(message)) message = message.join(' ');
        super(message);

        if (Error.captureStackTrace !== undefined) {
          Error.captureStackTrace(this, CsvError);
        }

        this.code = code;

        for (const context of contexts) {
          for (const key in context) {
            const value = context[key];
            this[key] = isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));
          }
        }
      }

    }

    const underscore = function (str) {
      return str.replace(/([A-Z])/g, function (_, match) {
        return '_' + match.toLowerCase();
      });
    };

    const isObject$2 = function (obj) {
      return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
    };

    const isRecordEmpty = function (record) {
      return record.every(field => field == null || field.toString && field.toString().trim() === '');
    };

    const normalizeColumnsArray = function (columns) {
      const normalizedColumns = [];

      for (let i = 0, l = columns.length; i < l; i++) {
        const column = columns[i];

        if (column === undefined || column === null || column === false) {
          normalizedColumns[i] = {
            disabled: true
          };
        } else if (typeof column === 'string') {
          normalizedColumns[i] = {
            name: column
          };
        } else if (isObject$2(column)) {
          if (typeof column.name !== 'string') {
            throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', ['Option columns missing name:', `property "name" is required at position ${i}`, 'when column is an object literal']);
          }

          normalizedColumns[i] = column;
        } else {
          throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', ['Invalid column definition:', 'expect a string or a literal object,', `got ${JSON.stringify(column)} at position ${i}`]);
        }
      }

      return normalizedColumns;
    };

    class Parser extends Transform {
      constructor(opts = {}) {
        super({ ...{
            readableObjectMode: true
          },
          ...opts,
          encoding: null
        });
        this.__originalOptions = opts;

        this.__normalizeOptions(opts);
      }

      __normalizeOptions(opts) {
        const options = {}; // Merge with user options

        for (const opt in opts) {
          options[underscore(opt)] = opts[opt];
        } // Normalize option `encoding`
        // Note: defined first because other options depends on it
        // to convert chars/strings into buffers.


        if (options.encoding === undefined || options.encoding === true) {
          options.encoding = 'utf8';
        } else if (options.encoding === null || options.encoding === false) {
          options.encoding = null;
        } else if (typeof options.encoding !== 'string' && options.encoding !== null) {
          throw new CsvError('CSV_INVALID_OPTION_ENCODING', ['Invalid option encoding:', 'encoding must be a string or null to return a buffer,', `got ${JSON.stringify(options.encoding)}`], options);
        } // Normalize option `bom`


        if (options.bom === undefined || options.bom === null || options.bom === false) {
          options.bom = false;
        } else if (options.bom !== true) {
          throw new CsvError('CSV_INVALID_OPTION_BOM', ['Invalid option bom:', 'bom must be true,', `got ${JSON.stringify(options.bom)}`], options);
        } // Normalize option `cast`


        let fnCastField = null;

        if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === '') {
          options.cast = undefined;
        } else if (typeof options.cast === 'function') {
          fnCastField = options.cast;
          options.cast = true;
        } else if (options.cast !== true) {
          throw new CsvError('CSV_INVALID_OPTION_CAST', ['Invalid option cast:', 'cast must be true or a function,', `got ${JSON.stringify(options.cast)}`], options);
        } // Normalize option `cast_date`


        if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === '') {
          options.cast_date = false;
        } else if (options.cast_date === true) {
          options.cast_date = function (value) {
            const date = Date.parse(value);
            return !isNaN(date) ? new Date(date) : value;
          };
        } else {
          throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', ['Invalid option cast_date:', 'cast_date must be true or a function,', `got ${JSON.stringify(options.cast_date)}`], options);
        } // Normalize option `columns`


        let fnFirstLineToHeaders = null;

        if (options.columns === true) {
          // Fields in the first line are converted as-is to columns
          fnFirstLineToHeaders = undefined;
        } else if (typeof options.columns === 'function') {
          fnFirstLineToHeaders = options.columns;
          options.columns = true;
        } else if (Array.isArray(options.columns)) {
          options.columns = normalizeColumnsArray(options.columns);
        } else if (options.columns === undefined || options.columns === null || options.columns === false) {
          options.columns = false;
        } else {
          throw new CsvError('CSV_INVALID_OPTION_COLUMNS', ['Invalid option columns:', 'expect an array, a function or true,', `got ${JSON.stringify(options.columns)}`], options);
        } // Normalize option `group_columns_by_name`


        if (options.group_columns_by_name === undefined || options.group_columns_by_name === null || options.group_columns_by_name === false) {
          options.group_columns_by_name = false;
        } else if (options.group_columns_by_name !== true) {
          throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', ['Invalid option group_columns_by_name:', 'expect an boolean,', `got ${JSON.stringify(options.group_columns_by_name)}`], options);
        } else if (options.columns === false) {
          throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', ['Invalid option group_columns_by_name:', 'the `columns` mode must be activated.'], options);
        } // Normalize option `comment`


        if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === '') {
          options.comment = null;
        } else {
          if (typeof options.comment === 'string') {
            options.comment = Buffer.from(options.comment, options.encoding);
          }

          if (!isBuffer(options.comment)) {
            throw new CsvError('CSV_INVALID_OPTION_COMMENT', ['Invalid option comment:', 'comment must be a buffer or a string,', `got ${JSON.stringify(options.comment)}`], options);
          }
        } // Normalize option `delimiter`


        const delimiter_json = JSON.stringify(options.delimiter);
        if (!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];

        if (options.delimiter.length === 0) {
          throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', `got ${delimiter_json}`], options);
        }

        options.delimiter = options.delimiter.map(function (delimiter) {
          if (delimiter === undefined || delimiter === null || delimiter === false) {
            return Buffer.from(',', options.encoding);
          }

          if (typeof delimiter === 'string') {
            delimiter = Buffer.from(delimiter, options.encoding);
          }

          if (!isBuffer(delimiter) || delimiter.length === 0) {
            throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', `got ${delimiter_json}`], options);
          }

          return delimiter;
        }); // Normalize option `escape`

        if (options.escape === undefined || options.escape === true) {
          options.escape = Buffer.from('"', options.encoding);
        } else if (typeof options.escape === 'string') {
          options.escape = Buffer.from(options.escape, options.encoding);
        } else if (options.escape === null || options.escape === false) {
          options.escape = null;
        }

        if (options.escape !== null) {
          if (!isBuffer(options.escape)) {
            throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);
          }
        } // Normalize option `from`


        if (options.from === undefined || options.from === null) {
          options.from = 1;
        } else {
          if (typeof options.from === 'string' && /\d+/.test(options.from)) {
            options.from = parseInt(options.from);
          }

          if (Number.isInteger(options.from)) {
            if (options.from < 0) {
              throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);
            }
          } else {
            throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);
          }
        } // Normalize option `from_line`


        if (options.from_line === undefined || options.from_line === null) {
          options.from_line = 1;
        } else {
          if (typeof options.from_line === 'string' && /\d+/.test(options.from_line)) {
            options.from_line = parseInt(options.from_line);
          }

          if (Number.isInteger(options.from_line)) {
            if (options.from_line <= 0) {
              throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);
            }
          } else {
            throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);
          }
        } // Normalize options `ignore_last_delimiters`


        if (options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null) {
          options.ignore_last_delimiters = false;
        } else if (typeof options.ignore_last_delimiters === 'number') {
          options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);

          if (options.ignore_last_delimiters === 0) {
            options.ignore_last_delimiters = false;
          }
        } else if (typeof options.ignore_last_delimiters !== 'boolean') {
          throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', ['Invalid option `ignore_last_delimiters`:', 'the value must be a boolean value or an integer,', `got ${JSON.stringify(options.ignore_last_delimiters)}`], options);
        }

        if (options.ignore_last_delimiters === true && options.columns === false) {
          throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', ['The option `ignore_last_delimiters`', 'requires the activation of the `columns` option'], options);
        } // Normalize option `info`


        if (options.info === undefined || options.info === null || options.info === false) {
          options.info = false;
        } else if (options.info !== true) {
          throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);
        } // Normalize option `max_record_size`


        if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {
          options.max_record_size = 0;
        } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) ;else if (typeof options.max_record_size === 'string' && /\d+/.test(options.max_record_size)) {
          options.max_record_size = parseInt(options.max_record_size);
        } else {
          throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);
        } // Normalize option `objname`


        if (options.objname === undefined || options.objname === null || options.objname === false) {
          options.objname = undefined;
        } else if (isBuffer(options.objname)) {
          if (options.objname.length === 0) {
            throw new Error(`Invalid Option: objname must be a non empty buffer`);
          }

          if (options.encoding === null) ;else {
            options.objname = options.objname.toString(options.encoding);
          }
        } else if (typeof options.objname === 'string') {
          if (options.objname.length === 0) {
            throw new Error(`Invalid Option: objname must be a non empty string`);
          } // Great, nothing to do

        } else if (typeof options.objname === 'number') ;else {
          throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);
        }

        if (options.objname !== undefined) {
          if (typeof options.objname === 'number') {
            if (options.columns !== false) {
              throw Error('Invalid Option: objname index cannot be combined with columns or be defined as a field');
            }
          } else {
            // A string or a buffer
            if (options.columns === false) {
              throw Error('Invalid Option: objname field must be combined with columns or be defined as an index');
            }
          }
        } // Normalize option `on_record`


        if (options.on_record === undefined || options.on_record === null) {
          options.on_record = undefined;
        } else if (typeof options.on_record !== 'function') {
          throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', ['Invalid option `on_record`:', 'expect a function,', `got ${JSON.stringify(options.on_record)}`], options);
        } // Normalize option `quote`


        if (options.quote === null || options.quote === false || options.quote === '') {
          options.quote = null;
        } else {
          if (options.quote === undefined || options.quote === true) {
            options.quote = Buffer.from('"', options.encoding);
          } else if (typeof options.quote === 'string') {
            options.quote = Buffer.from(options.quote, options.encoding);
          }

          if (!isBuffer(options.quote)) {
            throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);
          }
        } // Normalize option `raw`


        if (options.raw === undefined || options.raw === null || options.raw === false) {
          options.raw = false;
        } else if (options.raw !== true) {
          throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);
        } // Normalize option `record_delimiter`


        if (options.record_delimiter === undefined) {
          options.record_delimiter = [];
        } else if (typeof options.record_delimiter === 'string' || isBuffer(options.record_delimiter)) {
          if (options.record_delimiter.length === 0) {
            throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a non empty string or buffer,', `got ${JSON.stringify(options.record_delimiter)}`], options);
          }

          options.record_delimiter = [options.record_delimiter];
        } else if (!Array.isArray(options.record_delimiter)) {
          throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a string, a buffer or array of string|buffer,', `got ${JSON.stringify(options.record_delimiter)}`], options);
        }

        options.record_delimiter = options.record_delimiter.map(function (rd, i) {
          if (typeof rd !== 'string' && !isBuffer(rd)) {
            throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a string, a buffer or array of string|buffer', `at index ${i},`, `got ${JSON.stringify(rd)}`], options);
          } else if (rd.length === 0) {
            throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a non empty string or buffer', `at index ${i},`, `got ${JSON.stringify(rd)}`], options);
          }

          if (typeof rd === 'string') {
            rd = Buffer.from(rd, options.encoding);
          }

          return rd;
        }); // Normalize option `relax_column_count`

        if (typeof options.relax_column_count === 'boolean') ;else if (options.relax_column_count === undefined || options.relax_column_count === null) {
          options.relax_column_count = false;
        } else {
          throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);
        }
        if (typeof options.relax_column_count_less === 'boolean') ;else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {
          options.relax_column_count_less = false;
        } else {
          throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);
        }
        if (typeof options.relax_column_count_more === 'boolean') ;else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {
          options.relax_column_count_more = false;
        } else {
          throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);
        } // Normalize option `relax_quotes`

        if (typeof options.relax_quotes === 'boolean') ;else if (options.relax_quotes === undefined || options.relax_quotes === null) {
          options.relax_quotes = false;
        } else {
          throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);
        } // Normalize option `skip_empty_lines`

        if (typeof options.skip_empty_lines === 'boolean') ;else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {
          options.skip_empty_lines = false;
        } else {
          throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);
        } // Normalize option `skip_records_with_empty_values`

        if (typeof options.skip_records_with_empty_values === 'boolean') ;else if (options.skip_records_with_empty_values === undefined || options.skip_records_with_empty_values === null) {
          options.skip_records_with_empty_values = false;
        } else {
          throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);
        } // Normalize option `skip_records_with_error`

        if (typeof options.skip_records_with_error === 'boolean') ;else if (options.skip_records_with_error === undefined || options.skip_records_with_error === null) {
          options.skip_records_with_error = false;
        } else {
          throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);
        } // Normalize option `rtrim`

        if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {
          options.rtrim = false;
        } else if (options.rtrim !== true) {
          throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);
        } // Normalize option `ltrim`


        if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {
          options.ltrim = false;
        } else if (options.ltrim !== true) {
          throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);
        } // Normalize option `trim`


        if (options.trim === undefined || options.trim === null || options.trim === false) {
          options.trim = false;
        } else if (options.trim !== true) {
          throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);
        } // Normalize options `trim`, `ltrim` and `rtrim`


        if (options.trim === true && opts.ltrim !== false) {
          options.ltrim = true;
        } else if (options.ltrim !== true) {
          options.ltrim = false;
        }

        if (options.trim === true && opts.rtrim !== false) {
          options.rtrim = true;
        } else if (options.rtrim !== true) {
          options.rtrim = false;
        } // Normalize option `to`


        if (options.to === undefined || options.to === null) {
          options.to = -1;
        } else {
          if (typeof options.to === 'string' && /\d+/.test(options.to)) {
            options.to = parseInt(options.to);
          }

          if (Number.isInteger(options.to)) {
            if (options.to <= 0) {
              throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);
            }
          } else {
            throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);
          }
        } // Normalize option `to_line`


        if (options.to_line === undefined || options.to_line === null) {
          options.to_line = -1;
        } else {
          if (typeof options.to_line === 'string' && /\d+/.test(options.to_line)) {
            options.to_line = parseInt(options.to_line);
          }

          if (Number.isInteger(options.to_line)) {
            if (options.to_line <= 0) {
              throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);
            }
          } else {
            throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);
          }
        }

        this.info = {
          bytes: 0,
          comment_lines: 0,
          empty_lines: 0,
          invalid_field_length: 0,
          lines: 1,
          records: 0
        };
        this.options = options;
        this.state = {
          bomSkipped: false,
          bufBytesStart: 0,
          castField: fnCastField,
          commenting: false,
          // Current error encountered by a record
          error: undefined,
          enabled: options.from_line === 1,
          escaping: false,
          escapeIsQuote: isBuffer(options.escape) && isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,
          // columns can be `false`, `true`, `Array`
          expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,
          field: new ResizeableBuffer(20),
          firstLineToHeaders: fnFirstLineToHeaders,
          needMoreDataSize: Math.max( // Skip if the remaining buffer smaller than comment
          options.comment !== null ? options.comment.length : 0, // Skip if the remaining buffer can be delimiter
          ...options.delimiter.map(delimiter => delimiter.length), // Skip if the remaining buffer can be escape sequence
          options.quote !== null ? options.quote.length : 0),
          previousBuf: undefined,
          quoting: false,
          stop: false,
          rawBuffer: new ResizeableBuffer(100),
          record: [],
          recordHasError: false,
          record_length: 0,
          recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map(v => v.length)),
          trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\t', options.encoding)[0]],
          wasQuoting: false,
          wasRowDelimiter: false
        };
      } // Implementation of `Transform._transform`


      _transform(buf, encoding, callback) {
        if (this.state.stop === true) {
          return;
        }

        const err = this.__parse(buf, false);

        if (err !== undefined) {
          this.state.stop = true;
        }

        callback(err);
      } // Implementation of `Transform._flush`


      _flush(callback) {
        if (this.state.stop === true) {
          return;
        }

        const err = this.__parse(undefined, true);

        callback(err);
      } // Central parser implementation


      __parse(nextBuf, end) {
        const {
          bom,
          comment,
          escape,
          from_line,
          ltrim,
          max_record_size,
          quote,
          raw,
          relax_quotes,
          rtrim,
          skip_empty_lines,
          to,
          to_line
        } = this.options;
        let {
          record_delimiter
        } = this.options;
        const {
          bomSkipped,
          previousBuf,
          rawBuffer,
          escapeIsQuote
        } = this.state;
        let buf;

        if (previousBuf === undefined) {
          if (nextBuf === undefined) {
            // Handle empty string
            this.push(null);
            return;
          } else {
            buf = nextBuf;
          }
        } else if (previousBuf !== undefined && nextBuf === undefined) {
          buf = previousBuf;
        } else {
          buf = Buffer.concat([previousBuf, nextBuf]);
        } // Handle UTF BOM


        if (bomSkipped === false) {
          if (bom === false) {
            this.state.bomSkipped = true;
          } else if (buf.length < 3) {
            // No enough data
            if (end === false) {
              // Wait for more data
              this.state.previousBuf = buf;
              return;
            }
          } else {
            for (const encoding in boms) {
              if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {
                // Skip BOM
                const bomLength = boms[encoding].length;
                this.state.bufBytesStart += bomLength;
                buf = buf.slice(bomLength); // Renormalize original options with the new encoding

                this.__normalizeOptions({ ...this.__originalOptions,
                  encoding: encoding
                });

                break;
              }
            }

            this.state.bomSkipped = true;
          }
        }

        const bufLen = buf.length;
        let pos;

        for (pos = 0; pos < bufLen; pos++) {
          // Ensure we get enough space to look ahead
          // There should be a way to move this out of the loop
          if (this.__needMoreData(pos, bufLen, end)) {
            break;
          }

          if (this.state.wasRowDelimiter === true) {
            this.info.lines++;
            this.state.wasRowDelimiter = false;
          }

          if (to_line !== -1 && this.info.lines > to_line) {
            this.state.stop = true;
            this.push(null);
            return;
          } // Auto discovery of record_delimiter, unix, mac and windows supported


          if (this.state.quoting === false && record_delimiter.length === 0) {
            const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);

            if (record_delimiterCount) {
              record_delimiter = this.options.record_delimiter;
            }
          }

          const chr = buf[pos];

          if (raw === true) {
            rawBuffer.append(chr);
          }

          if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {
            this.state.wasRowDelimiter = true;
          } // Previous char was a valid escape char
          // treat the current char as a regular char


          if (this.state.escaping === true) {
            this.state.escaping = false;
          } else {
            // Escape is only active inside quoted fields
            // We are quoting, the char is an escape chr and there is a chr to escape
            // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){
            if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {
              if (escapeIsQuote) {
                if (this.__isQuote(buf, pos + escape.length)) {
                  this.state.escaping = true;
                  pos += escape.length - 1;
                  continue;
                }
              } else {
                this.state.escaping = true;
                pos += escape.length - 1;
                continue;
              }
            } // Not currently escaping and chr is a quote
            // TODO: need to compare bytes instead of single char


            if (this.state.commenting === false && this.__isQuote(buf, pos)) {
              if (this.state.quoting === true) {
                const nextChr = buf[pos + quote.length];

                const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr);

                const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);

                const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);

                const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length); // Escape a quote
                // Treat next char as a regular character

                if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {
                  pos += escape.length - 1;
                } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {
                  this.state.quoting = false;
                  this.state.wasQuoting = true;
                  pos += quote.length - 1;
                  continue;
                } else if (relax_quotes === false) {
                  const err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', ['Invalid Closing Quote:', `got "${String.fromCharCode(nextChr)}"`, `at line ${this.info.lines}`, 'instead of delimiter, record delimiter, trimable character', '(if activated) or comment'], this.options, this.__infoField()));

                  if (err !== undefined) return err;
                } else {
                  this.state.quoting = false;
                  this.state.wasQuoting = true;
                  this.state.field.prepend(quote);
                  pos += quote.length - 1;
                }
              } else {
                if (this.state.field.length !== 0) {
                  // In relax_quotes mode, treat opening quote preceded by chrs as regular
                  if (relax_quotes === false) {
                    const err = this.__error(new CsvError('INVALID_OPENING_QUOTE', ['Invalid Opening Quote:', `a quote is found inside a field at line ${this.info.lines}`], this.options, this.__infoField(), {
                      field: this.state.field
                    }));

                    if (err !== undefined) return err;
                  }
                } else {
                  this.state.quoting = true;
                  pos += quote.length - 1;
                  continue;
                }
              }
            }

            if (this.state.quoting === false) {
              const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);

              if (recordDelimiterLength !== 0) {
                // Do not emit comments which take a full line
                const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;

                if (skipCommentLine) {
                  this.info.comment_lines++; // Skip full comment line
                } else {
                  // Activate records emition if above from_line
                  if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {
                    this.state.enabled = true;

                    this.__resetField();

                    this.__resetRecord();

                    pos += recordDelimiterLength - 1;
                    continue;
                  } // Skip if line is empty and skip_empty_lines activated


                  if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {
                    this.info.empty_lines++;
                    pos += recordDelimiterLength - 1;
                    continue;
                  }

                  this.info.bytes = this.state.bufBytesStart + pos;

                  const errField = this.__onField();

                  if (errField !== undefined) return errField;
                  this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;

                  const errRecord = this.__onRecord();

                  if (errRecord !== undefined) return errRecord;

                  if (to !== -1 && this.info.records >= to) {
                    this.state.stop = true;
                    this.push(null);
                    return;
                  }
                }

                this.state.commenting = false;
                pos += recordDelimiterLength - 1;
                continue;
              }

              if (this.state.commenting) {
                continue;
              }

              const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);

              if (commentCount !== 0) {
                this.state.commenting = true;
                continue;
              }

              const delimiterLength = this.__isDelimiter(buf, pos, chr);

              if (delimiterLength !== 0) {
                this.info.bytes = this.state.bufBytesStart + pos;

                const errField = this.__onField();

                if (errField !== undefined) return errField;
                pos += delimiterLength - 1;
                continue;
              }
            }
          }

          if (this.state.commenting === false) {
            if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {
              const err = this.__error(new CsvError('CSV_MAX_RECORD_SIZE', ['Max Record Size:', 'record exceed the maximum number of tolerated bytes', `of ${max_record_size}`, `at line ${this.info.lines}`], this.options, this.__infoField()));

              if (err !== undefined) return err;
            }
          }

          const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr); // rtrim in non quoting is handle in __onField

          const rappend = rtrim === false || this.state.wasQuoting === false;

          if (lappend === true && rappend === true) {
            this.state.field.append(chr);
          } else if (rtrim === true && !this.__isCharTrimable(chr)) {
            const err = this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', ['Invalid Closing Quote:', 'found non trimable byte after quote', `at line ${this.info.lines}`], this.options, this.__infoField()));

            if (err !== undefined) return err;
          }
        }

        if (end === true) {
          // Ensure we are not ending in a quoting state
          if (this.state.quoting === true) {
            const err = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', ['Quote Not Closed:', `the parsing is finished with an opening quote at line ${this.info.lines}`], this.options, this.__infoField()));

            if (err !== undefined) return err;
          } else {
            // Skip last line if it has no characters
            if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {
              this.info.bytes = this.state.bufBytesStart + pos;

              const errField = this.__onField();

              if (errField !== undefined) return errField;

              const errRecord = this.__onRecord();

              if (errRecord !== undefined) return errRecord;
            } else if (this.state.wasRowDelimiter === true) {
              this.info.empty_lines++;
            } else if (this.state.commenting === true) {
              this.info.comment_lines++;
            }
          }
        } else {
          this.state.bufBytesStart += pos;
          this.state.previousBuf = buf.slice(pos);
        }

        if (this.state.wasRowDelimiter === true) {
          this.info.lines++;
          this.state.wasRowDelimiter = false;
        }
      }

      __onRecord() {
        const {
          columns,
          group_columns_by_name,
          encoding,
          info,
          from,
          relax_column_count,
          relax_column_count_less,
          relax_column_count_more,
          raw,
          skip_records_with_empty_values
        } = this.options;
        const {
          enabled,
          record
        } = this.state;

        if (enabled === false) {
          return this.__resetRecord();
        } // Convert the first line into column names


        const recordLength = record.length;

        if (columns === true) {
          if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
            this.__resetRecord();

            return;
          }

          return this.__firstLineToColumns(record);
        }

        if (columns === false && this.info.records === 0) {
          this.state.expectedRecordLength = recordLength;
        }

        if (recordLength !== this.state.expectedRecordLength) {
          const err = columns === false ? new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', ['Invalid Record Length:', `expect ${this.state.expectedRecordLength},`, `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {
            record: record
          }) : new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', ['Invalid Record Length:', `columns length is ${columns.length},`, // rename columns
          `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {
            record: record
          });

          if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {
            this.info.invalid_field_length++;
            this.state.error = err; // Error is undefined with skip_records_with_error
          } else {
            const finalErr = this.__error(err);

            if (finalErr) return finalErr;
          }
        }

        if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
          this.__resetRecord();

          return;
        }

        if (this.state.recordHasError === true) {
          this.__resetRecord();

          this.state.recordHasError = false;
          return;
        }

        this.info.records++;

        if (from === 1 || this.info.records >= from) {
          const {
            objname
          } = this.options; // With columns, records are object

          if (columns !== false) {
            const obj = {}; // Transform record array to an object

            for (let i = 0, l = record.length; i < l; i++) {
              if (columns[i] === undefined || columns[i].disabled) continue; // Turn duplicate columns into an array

              if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {
                if (Array.isArray(obj[columns[i].name])) {
                  obj[columns[i].name] = obj[columns[i].name].concat(record[i]);
                } else {
                  obj[columns[i].name] = [obj[columns[i].name], record[i]];
                }
              } else {
                obj[columns[i].name] = record[i];
              }
            } // Without objname (default)


            if (raw === true || info === true) {
              const extRecord = Object.assign({
                record: obj
              }, raw === true ? {
                raw: this.state.rawBuffer.toString(encoding)
              } : {}, info === true ? {
                info: this.__infoRecord()
              } : {});

              const err = this.__push(objname === undefined ? extRecord : [obj[objname], extRecord]);

              if (err) {
                return err;
              }
            } else {
              const err = this.__push(objname === undefined ? obj : [obj[objname], obj]);

              if (err) {
                return err;
              }
            } // Without columns, records are array

          } else {
            if (raw === true || info === true) {
              const extRecord = Object.assign({
                record: record
              }, raw === true ? {
                raw: this.state.rawBuffer.toString(encoding)
              } : {}, info === true ? {
                info: this.__infoRecord()
              } : {});

              const err = this.__push(objname === undefined ? extRecord : [record[objname], extRecord]);

              if (err) {
                return err;
              }
            } else {
              const err = this.__push(objname === undefined ? record : [record[objname], record]);

              if (err) {
                return err;
              }
            }
          }
        }

        this.__resetRecord();
      }

      __firstLineToColumns(record) {
        const {
          firstLineToHeaders
        } = this.state;

        try {
          const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);

          if (!Array.isArray(headers)) {
            return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', ['Invalid Column Mapping:', 'expect an array from column function,', `got ${JSON.stringify(headers)}`], this.options, this.__infoField(), {
              headers: headers
            }));
          }

          const normalizedHeaders = normalizeColumnsArray(headers);
          this.state.expectedRecordLength = normalizedHeaders.length;
          this.options.columns = normalizedHeaders;

          this.__resetRecord();

          return;
        } catch (err) {
          return err;
        }
      }

      __resetRecord() {
        if (this.options.raw === true) {
          this.state.rawBuffer.reset();
        }

        this.state.error = undefined;
        this.state.record = [];
        this.state.record_length = 0;
      }

      __onField() {
        const {
          cast,
          encoding,
          rtrim,
          max_record_size
        } = this.options;
        const {
          enabled,
          wasQuoting
        } = this.state; // Short circuit for the from_line options

        if (enabled === false) {
          return this.__resetField();
        }

        let field = this.state.field.toString(encoding);

        if (rtrim === true && wasQuoting === false) {
          field = field.trimRight();
        }

        if (cast === true) {
          const [err, f] = this.__cast(field);

          if (err !== undefined) return err;
          field = f;
        }

        this.state.record.push(field); // Increment record length if record size must not exceed a limit

        if (max_record_size !== 0 && typeof field === 'string') {
          this.state.record_length += field.length;
        }

        this.__resetField();
      }

      __resetField() {
        this.state.field.reset();
        this.state.wasQuoting = false;
      }

      __push(record) {
        const {
          on_record
        } = this.options;

        if (on_record !== undefined) {
          const info = this.__infoRecord();

          try {
            record = on_record.call(null, record, info);
          } catch (err) {
            return err;
          }

          if (record === undefined || record === null) {
            return;
          }
        }

        this.push(record);
      } // Return a tuple with the error and the casted value


      __cast(field) {
        const {
          columns,
          relax_column_count
        } = this.options;
        const isColumns = Array.isArray(columns); // Dont loose time calling cast
        // because the final record is an object
        // and this field can't be associated to a key present in columns

        if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {
          return [undefined, undefined];
        }

        if (this.state.castField !== null) {
          try {
            const info = this.__infoField();

            return [undefined, this.state.castField.call(null, field, info)];
          } catch (err) {
            return [err];
          }
        }

        if (this.__isFloat(field)) {
          return [undefined, parseFloat(field)];
        } else if (this.options.cast_date !== false) {
          const info = this.__infoField();

          return [undefined, this.options.cast_date.call(null, field, info)];
        }

        return [undefined, field];
      } // Helper to test if a character is a space or a line delimiter


      __isCharTrimable(chr) {
        return chr === space || chr === tab || chr === cr || chr === nl || chr === np;
      } // Keep it in case we implement the `cast_int` option
      // __isInt(value){
      //   // return Number.isInteger(parseInt(value))
      //   // return !isNaN( parseInt( obj ) );
      //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
      // }


      __isFloat(value) {
        return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery
      }

      __compareBytes(sourceBuf, targetBuf, targetPos, firstByte) {
        if (sourceBuf[0] !== firstByte) return 0;
        const sourceLength = sourceBuf.length;

        for (let i = 1; i < sourceLength; i++) {
          if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;
        }

        return sourceLength;
      }

      __needMoreData(i, bufLen, end) {
        if (end) return false;
        const {
          quote
        } = this.options;
        const {
          quoting,
          needMoreDataSize,
          recordDelimiterMaxLength
        } = this.state;
        const numOfCharLeft = bufLen - i - 1;
        const requiredLength = Math.max(needMoreDataSize, // Skip if the remaining buffer smaller than record delimiter
        recordDelimiterMaxLength, // Skip if the remaining buffer can be record delimiter following the closing quote
        // 1 is for quote.length
        quoting ? quote.length + recordDelimiterMaxLength : 0);
        return numOfCharLeft < requiredLength;
      }

      __isDelimiter(buf, pos, chr) {
        const {
          delimiter,
          ignore_last_delimiters
        } = this.options;

        if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {
          return 0;
        } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1) {
          return 0;
        }

        loop1: for (let i = 0; i < delimiter.length; i++) {
          const del = delimiter[i];

          if (del[0] === chr) {
            for (let j = 1; j < del.length; j++) {
              if (del[j] !== buf[pos + j]) continue loop1;
            }

            return del.length;
          }
        }

        return 0;
      }

      __isRecordDelimiter(chr, buf, pos) {
        const {
          record_delimiter
        } = this.options;
        const recordDelimiterLength = record_delimiter.length;

        loop1: for (let i = 0; i < recordDelimiterLength; i++) {
          const rd = record_delimiter[i];
          const rdLength = rd.length;

          if (rd[0] !== chr) {
            continue;
          }

          for (let j = 1; j < rdLength; j++) {
            if (rd[j] !== buf[pos + j]) {
              continue loop1;
            }
          }

          return rd.length;
        }

        return 0;
      }

      __isEscape(buf, pos, chr) {
        const {
          escape
        } = this.options;
        if (escape === null) return false;
        const l = escape.length;

        if (escape[0] === chr) {
          for (let i = 0; i < l; i++) {
            if (escape[i] !== buf[pos + i]) {
              return false;
            }
          }

          return true;
        }

        return false;
      }

      __isQuote(buf, pos) {
        const {
          quote
        } = this.options;
        if (quote === null) return false;
        const l = quote.length;

        for (let i = 0; i < l; i++) {
          if (quote[i] !== buf[pos + i]) {
            return false;
          }
        }

        return true;
      }

      __autoDiscoverRecordDelimiter(buf, pos) {
        const {
          encoding
        } = this.options;
        const chr = buf[pos];

        if (chr === cr) {
          if (buf[pos + 1] === nl) {
            this.options.record_delimiter.push(Buffer.from('\r\n', encoding));
            this.state.recordDelimiterMaxLength = 2;
            return 2;
          } else {
            this.options.record_delimiter.push(Buffer.from('\r', encoding));
            this.state.recordDelimiterMaxLength = 1;
            return 1;
          }
        } else if (chr === nl) {
          this.options.record_delimiter.push(Buffer.from('\n', encoding));
          this.state.recordDelimiterMaxLength = 1;
          return 1;
        }

        return 0;
      }

      __error(msg) {
        const {
          encoding,
          raw,
          skip_records_with_error
        } = this.options;
        const err = typeof msg === 'string' ? new Error(msg) : msg;

        if (skip_records_with_error) {
          this.state.recordHasError = true;
          this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);
          return undefined;
        } else {
          return err;
        }
      }

      __infoDataSet() {
        return { ...this.info,
          columns: this.options.columns
        };
      }

      __infoRecord() {
        const {
          columns,
          raw,
          encoding
        } = this.options;
        return { ...this.__infoDataSet(),
          error: this.state.error,
          header: columns === true,
          index: this.state.record.length,
          raw: raw ? this.state.rawBuffer.toString(encoding) : undefined
        };
      }

      __infoField() {
        const {
          columns
        } = this.options;
        const isColumns = Array.isArray(columns);
        return { ...this.__infoRecord(),
          column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,
          quoting: this.state.wasQuoting
        };
      }

    }

    const parse$1 = function () {
      let data, options, callback;

      for (const i in arguments) {
        const argument = arguments[i];
        const type = typeof argument;

        if (data === undefined && (typeof argument === 'string' || isBuffer(argument))) {
          data = argument;
        } else if (options === undefined && isObject$2(argument)) {
          options = argument;
        } else if (callback === undefined && type === 'function') {
          callback = argument;
        } else {
          throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', `got ${JSON.stringify(argument)} at index ${i}`], options || {});
        }
      }

      const parser = new Parser(options);

      if (callback) {
        const records = options === undefined || options.objname === undefined ? [] : {};
        parser.on('readable', function () {
          let record;

          while ((record = this.read()) !== null) {
            if (options === undefined || options.objname === undefined) {
              records.push(record);
            } else {
              records[record[0]] = record[1];
            }
          }
        });
        parser.on('error', function (err) {
          callback(err, undefined, parser.__infoDataSet());
        });
        parser.on('end', function () {
          callback(undefined, records, parser.__infoDataSet());
        });
      }

      if (data !== undefined) {
        const writer = function () {
          parser.write(data);
          parser.end();
        }; // Support Deno, Rollup doesnt provide a shim for setImmediate


        if (typeof setImmediate === 'function') {
          setImmediate(writer);
        } else {
          setTimeout(writer, 0);
        }
      }

      return parser;
    };

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

    function validate(uuid) {
      return typeof uuid === 'string' && REGEX.test(uuid);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = [];

    for (var i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1));
    }

    function stringify(arr) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

      var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }

      return uuid;
    }

    function v4(options, buf, offset) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return stringify(rnds);
    }

    function get_each_context(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[24] = list[i];
      return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[27] = list[i];
      return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[30] = list[i];
      return child_ctx;
    } // (229:0) {#if parseError}


    function create_if_block_6(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot_2]
          },
          $$scope: {
            ctx: ctx
          }
        }
      });
      return {
        c: function c() {
          create_component(overlay.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var overlay_changes = {};

          if (dirty[0] &
          /*parseError*/
          512 | dirty[1] &
          /*$$scope*/
          4) {
            overlay_changes.$$scope = {
              dirty: dirty,
              ctx: ctx
            };
          }

          overlay.$set(overlay_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    } // (230:1) <Overlay>


    function create_default_slot_2(ctx) {
      var div2;
      var h3;
      var t1;
      var div0;
      var t2_value = dist_10('timemanager', 'CSV parse error:') + "";
      var t2;
      var t3;
      var t4;
      var t5;
      var div1;
      var button;
      var mounted;
      var dispose;
      return {
        c: function c() {
          div2 = element("div");
          h3 = element("h3");
          h3.textContent = "".concat(dist_10('timemanager', 'Error reading CSV file'));
          t1 = space$1();
          div0 = element("div");
          t2 = text(t2_value);
          t3 = space$1();
          t4 = text(
          /*parseError*/
          ctx[9]);
          t5 = space$1();
          div1 = element("div");
          button = element("button");
          button.textContent = "".concat(dist_10('timemanager', 'Close'));
          attr(div0, "class", "error");
          attr(button, "class", "button");
          attr(div1, "class", "oc-dialog-buttonrow onebutton");
          attr(div2, "class", "inner");
        },
        m: function m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, h3);
          append(div2, t1);
          append(div2, div0);
          append(div0, t2);
          append(div0, t3);
          append(div0, t4);
          append(div2, t5);
          append(div2, div1);
          append(div1, button);

          if (!mounted) {
            dispose = listen(button, "click", prevent_default(
            /*click_handler*/
            ctx[17]));
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*parseError*/
          512) set_data(t4,
          /*parseError*/
          ctx[9]);
        },
        d: function d(detaching) {
          if (detaching) detach(div2);
          mounted = false;
          dispose();
        }
      };
    } // (247:0) {#if importError}


    function create_if_block_5(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot_1]
          },
          $$scope: {
            ctx: ctx
          }
        }
      });
      return {
        c: function c() {
          create_component(overlay.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var overlay_changes = {};

          if (dirty[0] &
          /*importError*/
          64 | dirty[1] &
          /*$$scope*/
          4) {
            overlay_changes.$$scope = {
              dirty: dirty,
              ctx: ctx
            };
          }

          overlay.$set(overlay_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    } // (248:1) <Overlay>


    function create_default_slot_1(ctx) {
      var div2;
      var h3;
      var t1;
      var div0;
      var t2_value = dist_10('timemanager', 'Import API error:') + "";
      var t2;
      var t3;
      var t4;
      var t5;
      var div1;
      var button;
      var mounted;
      var dispose;
      return {
        c: function c() {
          div2 = element("div");
          h3 = element("h3");
          h3.textContent = "".concat(dist_10('timemanager', 'Error importing entries'));
          t1 = space$1();
          div0 = element("div");
          t2 = text(t2_value);
          t3 = space$1();
          t4 = text(
          /*importError*/
          ctx[6]);
          t5 = space$1();
          div1 = element("div");
          button = element("button");
          button.textContent = "".concat(dist_10('timemanager', 'Close'));
          attr(div0, "class", "error");
          attr(button, "class", "button");
          attr(div1, "class", "oc-dialog-buttonrow onebutton");
          attr(div2, "class", "inner");
        },
        m: function m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, h3);
          append(div2, t1);
          append(div2, div0);
          append(div0, t2);
          append(div0, t3);
          append(div0, t4);
          append(div2, t5);
          append(div2, div1);
          append(div1, button);

          if (!mounted) {
            dispose = listen(button, "click", prevent_default(
            /*click_handler_1*/
            ctx[18]));
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*importError*/
          64) set_data(t4,
          /*importError*/
          ctx[6]);
        },
        d: function d(detaching) {
          if (detaching) detach(div2);
          mounted = false;
          dispose();
        }
      };
    } // (265:0) {#if successMessage}


    function create_if_block_4(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot]
          },
          $$scope: {
            ctx: ctx
          }
        }
      });
      return {
        c: function c() {
          create_component(overlay.$$.fragment);
        },
        m: function m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p: function p(ctx, dirty) {
          var overlay_changes = {};

          if (dirty[0] &
          /*successMessage*/
          128 | dirty[1] &
          /*$$scope*/
          4) {
            overlay_changes.$$scope = {
              dirty: dirty,
              ctx: ctx
            };
          }

          overlay.$set(overlay_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    } // (266:1) <Overlay>


    function create_default_slot(ctx) {
      var div2;
      var h3;
      var t1;
      var div0;
      var t2_value = dist_10('timemanager', 'Done:') + "";
      var t2;
      var t3;
      var t4;
      var t5;
      var div1;
      var button;
      var mounted;
      var dispose;
      return {
        c: function c() {
          div2 = element("div");
          h3 = element("h3");
          h3.textContent = "".concat(dist_10('timemanager', 'Import successful'));
          t1 = space$1();
          div0 = element("div");
          t2 = text(t2_value);
          t3 = space$1();
          t4 = text(
          /*successMessage*/
          ctx[7]);
          t5 = space$1();
          div1 = element("div");
          button = element("button");
          button.textContent = "".concat(dist_10('timemanager', 'Close'));
          attr(div0, "class", "error");
          attr(button, "class", "button");
          attr(div1, "class", "oc-dialog-buttonrow onebutton");
          attr(div2, "class", "inner");
        },
        m: function m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, h3);
          append(div2, t1);
          append(div2, div0);
          append(div0, t2);
          append(div0, t3);
          append(div0, t4);
          append(div2, t5);
          append(div2, div1);
          append(div1, button);

          if (!mounted) {
            dispose = listen(button, "click", prevent_default(
            /*click_handler_2*/
            ctx[19]));
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*successMessage*/
          128) set_data(t4,
          /*successMessage*/
          ctx[7]);
        },
        d: function d(detaching) {
          if (detaching) detach(div2);
          mounted = false;
          dispose();
        }
      };
    } // (283:0) {#if importPreviewData.length}


    function create_if_block_3(ctx) {
      var div0;
      var p;
      var strong;
      var t1;
      var button0;
      var t3;
      var button1;
      var t5;
      var div1;
      var dl;
      var dt0;
      var dd0;
      var t7_value =
      /*preparedClients*/
      ctx[2].length + "";
      var t7;
      var dt1;
      var dd1;
      var t9_value =
      /*preparedProjects*/
      ctx[3].length + "";
      var t9;
      var dt2;
      var dd2;
      var t11_value =
      /*preparedTasks*/
      ctx[4].length + "";
      var t11;
      var mounted;
      var dispose;
      return {
        c: function c() {
          div0 = element("div");
          p = element("p");
          strong = element("strong");
          strong.textContent = "".concat(dist_10('timemanager', 'Preview'));
          t1 = space$1();
          button0 = element("button");
          button0.textContent = "".concat(dist_10('timemanager', 'Collapse all'));
          t3 = space$1();
          button1 = element("button");
          button1.textContent = "".concat(dist_10('timemanager', 'Expand all'));
          t5 = space$1();
          div1 = element("div");
          dl = element("dl");
          dt0 = element("dt");
          dt0.textContent = "".concat(dist_10('timemanager', 'Clients'));
          dd0 = element("dd");
          t7 = text(t7_value);
          dt1 = element("dt");
          dt1.textContent = "".concat(dist_10('timemanager', 'Projects'));
          dd1 = element("dd");
          t9 = text(t9_value);
          dt2 = element("dt");
          dt2.textContent = "".concat(dist_10('timemanager', 'Tasks'));
          dd2 = element("dd");
          t11 = text(t11_value);
          attr(button0, "class", "button");
          attr(button1, "class", "button");
          attr(div0, "class", "tm_object-details-item");
          attr(div1, "class", "tm_object-details-item");
        },
        m: function m(target, anchor) {
          insert(target, div0, anchor);
          append(div0, p);
          append(p, strong);
          append(div0, t1);
          append(div0, button0);
          append(div0, t3);
          append(div0, button1);
          insert(target, t5, anchor);
          insert(target, div1, anchor);
          append(div1, dl);
          append(dl, dt0);
          append(dl, dd0);
          append(dd0, t7);
          append(dl, dt1);
          append(dl, dd1);
          append(dd1, t9);
          append(dl, dt2);
          append(dl, dd2);
          append(dd2, t11);

          if (!mounted) {
            dispose = [listen(button0, "click", prevent_default(
            /*click_handler_3*/
            ctx[20])), listen(button1, "click", prevent_default(
            /*click_handler_4*/
            ctx[21]))];
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*preparedClients*/
          4 && t7_value !== (t7_value =
          /*preparedClients*/
          ctx[2].length + "")) set_data(t7, t7_value);
          if (dirty[0] &
          /*preparedProjects*/
          8 && t9_value !== (t9_value =
          /*preparedProjects*/
          ctx[3].length + "")) set_data(t9, t9_value);
          if (dirty[0] &
          /*preparedTasks*/
          16 && t11_value !== (t11_value =
          /*preparedTasks*/
          ctx[4].length + "")) set_data(t11, t11_value);
        },
        d: function d(detaching) {
          if (detaching) detach(div0);
          if (detaching) detach(t5);
          if (detaching) detach(div1);
          mounted = false;
          run_all(dispose);
        }
      };
    } // (318:2) {#if client.projects}


    function create_if_block_1(ctx) {
      var details;
      var summary;
      var t1;
      var each_value_1 =
      /*client*/
      ctx[24].projects;
      var each_blocks = [];

      for (var i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
      }

      return {
        c: function c() {
          details = element("details");
          summary = element("summary");
          summary.textContent = "".concat(dist_10('timemanager', 'Projects'));
          t1 = space$1();

          for (var _i = 0; _i < each_blocks.length; _i += 1) {
            each_blocks[_i].c();
          }

          details.open =
          /*allOpen*/
          ctx[10];
        },
        m: function m(target, anchor) {
          insert(target, details, anchor);
          append(details, summary);
          append(details, t1);

          for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
            each_blocks[_i2].m(details, null);
          }
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*allOpen, importPreviewData*/
          1280) {
            each_value_1 =
            /*client*/
            ctx[24].projects;

            var _i3;

            for (_i3 = 0; _i3 < each_value_1.length; _i3 += 1) {
              var child_ctx = get_each_context_1(ctx, each_value_1, _i3);

              if (each_blocks[_i3]) {
                each_blocks[_i3].p(child_ctx, dirty);
              } else {
                each_blocks[_i3] = create_each_block_1(child_ctx);

                each_blocks[_i3].c();

                each_blocks[_i3].m(details, null);
              }
            }

            for (; _i3 < each_blocks.length; _i3 += 1) {
              each_blocks[_i3].d(1);
            }

            each_blocks.length = each_value_1.length;
          }

          if (dirty[0] &
          /*allOpen*/
          1024) {
            details.open =
            /*allOpen*/
            ctx[10];
          }
        },
        d: function d(detaching) {
          if (detaching) detach(details);
          destroy_each(each_blocks, detaching);
        }
      };
    } // (331:6) {#if project.tasks}


    function create_if_block_2(ctx) {
      var details;
      var summary;
      var t1;
      var each_value_2 =
      /*project*/
      ctx[27].tasks;
      var each_blocks = [];

      for (var i = 0; i < each_value_2.length; i += 1) {
        each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
      }

      return {
        c: function c() {
          details = element("details");
          summary = element("summary");
          summary.textContent = "".concat(dist_10('timemanager', 'Tasks'));
          t1 = space$1();

          for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {
            each_blocks[_i4].c();
          }

          details.open =
          /*allOpen*/
          ctx[10];
        },
        m: function m(target, anchor) {
          insert(target, details, anchor);
          append(details, summary);
          append(details, t1);

          for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
            each_blocks[_i5].m(details, null);
          }
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*importPreviewData*/
          256) {
            each_value_2 =
            /*project*/
            ctx[27].tasks;

            var _i6;

            for (_i6 = 0; _i6 < each_value_2.length; _i6 += 1) {
              var child_ctx = get_each_context_2(ctx, each_value_2, _i6);

              if (each_blocks[_i6]) {
                each_blocks[_i6].p(child_ctx, dirty);
              } else {
                each_blocks[_i6] = create_each_block_2(child_ctx);

                each_blocks[_i6].c();

                each_blocks[_i6].m(details, null);
              }
            }

            for (; _i6 < each_blocks.length; _i6 += 1) {
              each_blocks[_i6].d(1);
            }

            each_blocks.length = each_value_2.length;
          }

          if (dirty[0] &
          /*allOpen*/
          1024) {
            details.open =
            /*allOpen*/
            ctx[10];
          }
        },
        d: function d(detaching) {
          if (detaching) detach(details);
          destroy_each(each_blocks, detaching);
        }
      };
    } // (334:8) {#each project.tasks as task}


    function create_each_block_2(ctx) {
      var div2;
      var div0;
      var span0;
      var t1;
      var h3;
      var t2_value =
      /*task*/
      ctx[30].name + "";
      var t2;
      var t3;
      var div1;
      var span1;
      var t5;
      var t6_value =
      /*task*/
      ctx[30].note + "";
      var t6;
      return {
        c: function c() {
          div2 = element("div");
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "".concat(dist_10('timemanager', 'Task name'));
          t1 = space$1();
          h3 = element("h3");
          t2 = text(t2_value);
          t3 = space$1();
          div1 = element("div");
          span1 = element("span");
          span1.textContent = "".concat(dist_10('timemanager', 'Note'));
          t5 = space$1();
          t6 = text(t6_value);
          attr(span0, "class", "tm_label");
          attr(span1, "class", "tm_label");
          attr(div2, "class", "tm_item-row");
        },
        m: function m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, div0);
          append(div0, span0);
          append(div0, t1);
          append(div0, h3);
          append(h3, t2);
          append(div2, t3);
          append(div2, div1);
          append(div1, span1);
          append(div1, t5);
          append(div1, t6);
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*importPreviewData*/
          256 && t2_value !== (t2_value =
          /*task*/
          ctx[30].name + "")) set_data(t2, t2_value);
          if (dirty[0] &
          /*importPreviewData*/
          256 && t6_value !== (t6_value =
          /*task*/
          ctx[30].note + "")) set_data(t6, t6_value);
        },
        d: function d(detaching) {
          if (detaching) detach(div2);
        }
      };
    } // (321:4) {#each client.projects as project}


    function create_each_block_1(ctx) {
      var div2;
      var div0;
      var span0;
      var t1;
      var h3;
      var t2_value =
      /*project*/
      ctx[27].name + "";
      var t2;
      var t3;
      var div1;
      var span1;
      var t5;
      var t6_value =
      /*project*/
      ctx[27].note + "";
      var t6;
      var t7;
      var if_block =
      /*project*/
      ctx[27].tasks && create_if_block_2(ctx);
      return {
        c: function c() {
          div2 = element("div");
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "".concat(dist_10('timemanager', 'Project name'));
          t1 = space$1();
          h3 = element("h3");
          t2 = text(t2_value);
          t3 = space$1();
          div1 = element("div");
          span1 = element("span");
          span1.textContent = "".concat(dist_10('timemanager', 'Note'));
          t5 = space$1();
          t6 = text(t6_value);
          t7 = space$1();
          if (if_block) if_block.c();
          attr(span0, "class", "tm_label");
          attr(span1, "class", "tm_label");
          attr(div2, "class", "tm_item-row");
        },
        m: function m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, div0);
          append(div0, span0);
          append(div0, t1);
          append(div0, h3);
          append(h3, t2);
          append(div2, t3);
          append(div2, div1);
          append(div1, span1);
          append(div1, t5);
          append(div1, t6);
          append(div2, t7);
          if (if_block) if_block.m(div2, null);
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*importPreviewData*/
          256 && t2_value !== (t2_value =
          /*project*/
          ctx[27].name + "")) set_data(t2, t2_value);
          if (dirty[0] &
          /*importPreviewData*/
          256 && t6_value !== (t6_value =
          /*project*/
          ctx[27].note + "")) set_data(t6, t6_value);

          if (
          /*project*/
          ctx[27].tasks) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_2(ctx);
              if_block.c();
              if_block.m(div2, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d: function d(detaching) {
          if (detaching) detach(div2);
          if (if_block) if_block.d();
        }
      };
    } // (308:0) {#each importPreviewData as client}


    function create_each_block(ctx) {
      var div2;
      var div0;
      var span0;
      var t1;
      var h3;
      var t2_value =
      /*client*/
      ctx[24].name + "";
      var t2;
      var t3;
      var div1;
      var span1;
      var t5;
      var t6_value =
      /*client*/
      ctx[24].note + "";
      var t6;
      var t7;
      var if_block =
      /*client*/
      ctx[24].projects && create_if_block_1(ctx);
      return {
        c: function c() {
          div2 = element("div");
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "".concat(dist_10('timemanager', 'Client'));
          t1 = space$1();
          h3 = element("h3");
          t2 = text(t2_value);
          t3 = space$1();
          div1 = element("div");
          span1 = element("span");
          span1.textContent = "".concat(dist_10('timemanager', 'Note'));
          t5 = space$1();
          t6 = text(t6_value);
          t7 = space$1();
          if (if_block) if_block.c();
          attr(span0, "class", "tm_label");
          attr(span1, "class", "tm_label");
          attr(div2, "class", "tm_item-row");
        },
        m: function m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, div0);
          append(div0, span0);
          append(div0, t1);
          append(div0, h3);
          append(h3, t2);
          append(div2, t3);
          append(div2, div1);
          append(div1, span1);
          append(div1, t5);
          append(div1, t6);
          append(div2, t7);
          if (if_block) if_block.m(div2, null);
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*importPreviewData*/
          256 && t2_value !== (t2_value =
          /*client*/
          ctx[24].name + "")) set_data(t2, t2_value);
          if (dirty[0] &
          /*importPreviewData*/
          256 && t6_value !== (t6_value =
          /*client*/
          ctx[24].note + "")) set_data(t6, t6_value);

          if (
          /*client*/
          ctx[24].projects) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_1(ctx);
              if_block.c();
              if_block.m(div2, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d: function d(detaching) {
          if (detaching) detach(div2);
          if (if_block) if_block.d();
        }
      };
    } // (355:0) {#if importPreviewData.length}


    function create_if_block$1(ctx) {
      var form;
      var button;
      var t_value = dist_10('timemanager', 'Import now') + "";
      var t;
      var form_class_value;
      var mounted;
      var dispose;
      return {
        c: function c() {
          form = element("form");
          button = element("button");
          t = text(t_value);
          button.disabled =
          /*loading*/
          ctx[5];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(form, "class", form_class_value =
          /*loading*/
          ctx[5] ? ' icon-loading' : '');
        },
        m: function m(target, anchor) {
          insert(target, form, anchor);
          append(form, button);
          append(button, t);

          if (!mounted) {
            dispose = listen(form, "submit", prevent_default(
            /*doImport*/
            ctx[12]));
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if (dirty[0] &
          /*loading*/
          32) {
            button.disabled =
            /*loading*/
            ctx[5];
          }

          if (dirty[0] &
          /*loading*/
          32 && form_class_value !== (form_class_value =
          /*loading*/
          ctx[5] ? ' icon-loading' : '')) {
            attr(form, "class", form_class_value);
          }
        },
        d: function d(detaching) {
          if (detaching) detach(form);
          mounted = false;
          dispose();
        }
      };
    }

    function create_fragment$1(ctx) {
      var form;
      var label0;
      var t0_value = dist_10('timemanager', 'Select delimiter') + "";
      var t0;
      var t1;
      var select;
      var option0;
      var option1;
      var t4;
      var label1;
      var t5_value = dist_10('timemanager', 'Select CSV file') + "";
      var t5;
      var t6;
      var br;
      var t7;
      var input;
      var t8;
      var button;
      var t10;
      var t11;
      var t12;
      var t13;
      var t14;
      var t15;
      var if_block4_anchor;
      var current;
      var mounted;
      var dispose;
      var if_block0 =
      /*parseError*/
      ctx[9] && create_if_block_6(ctx);
      var if_block1 =
      /*importError*/
      ctx[6] && create_if_block_5(ctx);
      var if_block2 =
      /*successMessage*/
      ctx[7] && create_if_block_4(ctx);
      var if_block3 =
      /*importPreviewData*/
      ctx[8].length && create_if_block_3(ctx);
      var each_value =
      /*importPreviewData*/
      ctx[8];
      var each_blocks = [];

      for (var i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
      }

      var if_block4 =
      /*importPreviewData*/
      ctx[8].length && create_if_block$1(ctx);
      return {
        c: function c() {
          form = element("form");
          label0 = element("label");
          t0 = text(t0_value);
          t1 = space$1();
          select = element("select");
          option0 = element("option");
          option0.textContent = ",";
          option1 = element("option");
          option1.textContent = ";";
          t4 = space$1();
          label1 = element("label");
          t5 = text(t5_value);
          t6 = space$1();
          br = element("br");
          t7 = space$1();
          input = element("input");
          t8 = space$1();
          button = element("button");
          button.textContent = "".concat(dist_10('timemanager', 'Generate preview from file'));
          t10 = space$1();
          if (if_block0) if_block0.c();
          t11 = space$1();
          if (if_block1) if_block1.c();
          t12 = space$1();
          if (if_block2) if_block2.c();
          t13 = space$1();
          if (if_block3) if_block3.c();
          t14 = space$1();

          for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {
            each_blocks[_i7].c();
          }

          t15 = space$1();
          if (if_block4) if_block4.c();
          if_block4_anchor = empty();
          option0.selected = true;
          option0.__value = ",";
          option0.value = option0.__value;
          option1.__value = ";";
          option1.value = option1.__value;
          attr(select, "name", "delimiter");
          attr(input, "type", "file");
          attr(button, "type", "submit");
        },
        m: function m(target, anchor) {
          insert(target, form, anchor);
          append(form, label0);
          append(label0, t0);
          append(label0, t1);
          append(label0, select);
          append(select, option0);
          append(select, option1);
          /*select_binding*/

          ctx[15](select);
          append(form, t4);
          append(form, label1);
          append(label1, t5);
          append(label1, t6);
          append(label1, br);
          append(label1, t7);
          append(label1, input);
          /*input_binding*/

          ctx[16](input);
          append(form, t8);
          append(form, button);
          insert(target, t10, anchor);
          if (if_block0) if_block0.m(target, anchor);
          insert(target, t11, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert(target, t12, anchor);
          if (if_block2) if_block2.m(target, anchor);
          insert(target, t13, anchor);
          if (if_block3) if_block3.m(target, anchor);
          insert(target, t14, anchor);

          for (var _i8 = 0; _i8 < each_blocks.length; _i8 += 1) {
            each_blocks[_i8].m(target, anchor);
          }

          insert(target, t15, anchor);
          if (if_block4) if_block4.m(target, anchor);
          insert(target, if_block4_anchor, anchor);
          current = true;

          if (!mounted) {
            dispose = listen(form, "submit", prevent_default(
            /*previewFile*/
            ctx[11]));
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          if (
          /*parseError*/
          ctx[9]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty[0] &
              /*parseError*/
              512) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_6(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t11.parentNode, t11);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, function () {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*importError*/
          ctx[6]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty[0] &
              /*importError*/
              64) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_5(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(t12.parentNode, t12);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, function () {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*successMessage*/
          ctx[7]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty[0] &
              /*successMessage*/
              128) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_4(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(t13.parentNode, t13);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, function () {
              if_block2 = null;
            });
            check_outros();
          }

          if (
          /*importPreviewData*/
          ctx[8].length) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
            } else {
              if_block3 = create_if_block_3(ctx);
              if_block3.c();
              if_block3.m(t14.parentNode, t14);
            }
          } else if (if_block3) {
            if_block3.d(1);
            if_block3 = null;
          }

          if (dirty[0] &
          /*allOpen, importPreviewData*/
          1280) {
            each_value =
            /*importPreviewData*/
            ctx[8];

            var _i9;

            for (_i9 = 0; _i9 < each_value.length; _i9 += 1) {
              var child_ctx = get_each_context(ctx, each_value, _i9);

              if (each_blocks[_i9]) {
                each_blocks[_i9].p(child_ctx, dirty);
              } else {
                each_blocks[_i9] = create_each_block(child_ctx);

                each_blocks[_i9].c();

                each_blocks[_i9].m(t15.parentNode, t15);
              }
            }

            for (; _i9 < each_blocks.length; _i9 += 1) {
              each_blocks[_i9].d(1);
            }

            each_blocks.length = each_value.length;
          }

          if (
          /*importPreviewData*/
          ctx[8].length) {
            if (if_block4) {
              if_block4.p(ctx, dirty);
            } else {
              if_block4 = create_if_block$1(ctx);
              if_block4.c();
              if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
            }
          } else if (if_block4) {
            if_block4.d(1);
            if_block4 = null;
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(if_block2);
          current = true;
        },
        o: function o(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(if_block2);
          current = false;
        },
        d: function d(detaching) {
          if (detaching) detach(form);
          /*select_binding*/

          ctx[15](null);
          /*input_binding*/

          ctx[16](null);
          if (detaching) detach(t10);
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach(t11);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach(t12);
          if (if_block2) if_block2.d(detaching);
          if (detaching) detach(t13);
          if (if_block3) if_block3.d(detaching);
          if (detaching) detach(t14);
          destroy_each(each_blocks, detaching);
          if (detaching) detach(t15);
          if (if_block4) if_block4.d(detaching);
          if (detaching) detach(if_block4_anchor);
          mounted = false;
          dispose();
        }
      };
    }

    function instance$1($$self, $$props, $$invalidate) {
      var parseError;
      var importError;
      var successMessage;
      var importPreviewData;
      var loading;
      var allOpen;
      var syncApiUrl = $$props.syncApiUrl;
      var requestToken = $$props.requestToken;
      var fileInput;
      var delimiterInput; // Collect updated objects in here

      var preparedClients = [];
      var preparedProjects = [];
      var preparedTasks = []; // Converts all keys of an object to lowercase

      var keysToLowerCase = function keysToLowerCase(object) {
        var result = {};

        if (object) {
          for (var _i10 = 0, _Object$entries = Object.entries(object); _i10 < _Object$entries.length; _i10++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i10], 2),
                key = _Object$entries$_i[0],
                value = _Object$entries$_i[1];

            result[key.toLowerCase()] = value;
          }
        }

        return result;
      }; // Filters a list of records for type, converts all keys to lowercase and applies a uuid to each record


      var filter = function filter(records, type) {
        return records.map(keysToLowerCase).filter(function (record) {
          return record.type && record.type.toLowerCase() === type;
        }).map(function (record) {
          return _objectSpread2(_objectSpread2({}, record), {}, {
            uuid: v4()
          });
        });
      }; // Previews a given file


      var previewFile = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var _fileInput$files, file, fileReader, contents, clients, projects, tasks, associated;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(fileInput && fileInput.files && fileInput.files.length)) {
                    _context.next = 33;
                    break;
                  }

                  $$invalidate(8, importPreviewData = []);
                  $$invalidate(9, parseError = "");
                  _fileInput$files = _slicedToArray(fileInput.files, 1), file = _fileInput$files[0];
                  fileReader = new FileReader();
                  fileReader.readAsText(file);
                  _context.next = 8;
                  return new Promise(function (resolve, reject) {
                    fileReader.onload = function () {
                      resolve(null);
                    };

                    fileReader.onerror = function (error) {
                      reject(error);
                    };
                  });

                case 8:
                  contents = [];
                  _context.prev = 9;
                  _context.next = 12;
                  return new Promise(function (resolve, reject) {
                    return parse$1(fileReader.result, {
                      delimiter: delimiterInput && delimiterInput.value ? delimiterInput.value : ",",
                      // @TODO: Make encoding configurable
                      encoding: "utf-8",
                      columns: true
                    }, function (err, records) {
                      if (err) {
                        reject(err);
                      }

                      resolve(records);
                    });
                  });

                case 12:
                  contents = _context.sent;
                  _context.next = 19;
                  break;

                case 15:
                  _context.prev = 15;
                  _context.t0 = _context["catch"](9);
                  $$invalidate(9, parseError = _context.t0);
                  return _context.abrupt("return");

                case 19:
                  if (!(!contents || !contents.length)) {
                    _context.next = 22;
                    break;
                  }

                  $$invalidate(9, parseError = dist_10("timemanager", "It looks like this file is not a CSV file or doesn't contain any clients, projects or tasks."));
                  return _context.abrupt("return");

                case 22:
                  // Filter by type and assign uuids
                  clients = filter(contents, "client");
                  projects = filter(contents, "project");
                  tasks = filter(contents, "task");

                  if (!(!clients.length && !projects.length && !tasks.length)) {
                    _context.next = 28;
                    break;
                  }

                  $$invalidate(9, parseError = dist_10("timemanager", "It looks like this file is not a CSV file or doesn't contain any clients, projects or tasks."));
                  return _context.abrupt("return");

                case 28:
                  // Empty arrays
                  $$invalidate(2, preparedClients = []);
                  $$invalidate(3, preparedProjects = []);
                  $$invalidate(4, preparedTasks = []); // Group entities

                  associated = clients.map(function (client) {
                    client.projects = projects.filter(function (project) {
                      return project.client === client.name && !preparedProjects.find(function (oneProject) {
                        return oneProject.uuid === project.uuid;
                      });
                    }).map(function (project) {
                      return _objectSpread2(_objectSpread2({}, project), {}, {
                        client_uuid: client.uuid
                      });
                    }).map(function (project) {
                      project.tasks = tasks.filter(function (task) {
                        return task.project === project.name && !preparedTasks.find(function (oneTask) {
                          return oneTask.uuid === task.uuid;
                        });
                      }).map(function (task) {
                        return _objectSpread2(_objectSpread2({}, task), {}, {
                          project_uuid: project.uuid
                        });
                      }); // Add tasks if not exists

                      project.tasks.forEach(function (task) {
                        if (!preparedTasks.find(function (oneTask) {
                          return oneTask.uuid === task.uuid;
                        })) {
                          preparedTasks.push(task);
                        }
                      }); // Add project if not exists

                      if (!preparedProjects.find(function (oneProject) {
                        return oneProject.uuid === project.uuid;
                      })) {
                        preparedProjects.push(project);
                      }

                      return project;
                    }); // Add client

                    preparedClients.push(client);
                    return client;
                  });
                  $$invalidate(8, importPreviewData = associated);

                case 33:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[9, 15]]);
        }));

        return function previewFile() {
          return _ref.apply(this, arguments);
        };
      }(); // @TODO: LOW: List unassociated elements (not in import & not in store)
      // Post data to JSON API


      var doImport = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var convertedImportData, response;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  $$invalidate(5, loading = true);
                  $$invalidate(6, importError = "");
                  convertedImportData = {
                    lastCommit: "",
                    data: {
                      clients: {
                        created: preparedClients.map(function (client) {
                          delete client.type;
                          delete client.projects;
                          return client;
                        }),
                        updated: [],
                        deleted: []
                      },
                      projects: {
                        created: preparedProjects.map(function (project) {
                          delete project.type;
                          delete project.tasks;
                          return project;
                        }),
                        updated: [],
                        deleted: []
                      },
                      tasks: {
                        created: preparedTasks.map(function (task) {
                          delete task.type;
                          return task;
                        }),
                        updated: [],
                        deleted: []
                      },
                      times: {
                        created: [],
                        updated: [],
                        deleted: []
                      }
                    }
                  };
                  _context2.prev = 3;
                  _context2.next = 6;
                  return fetch(syncApiUrl, {
                    method: "POST",
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    },
                    body: JSON.stringify(convertedImportData)
                  });

                case 6:
                  response = _context2.sent;

                  if (response.ok) {
                    $$invalidate(8, importPreviewData = []);
                    $$invalidate(7, successMessage = dist_10("timemanager", "Imported {clientsCount} client(s), {projectsCount} project(s), {tasksCount} task(s)", {
                      clientsCount: preparedClients.length,
                      projectsCount: preparedProjects.length,
                      tasksCount: preparedTasks.length
                    }));
                  }

                  _context2.next = 13;
                  break;

                case 10:
                  _context2.prev = 10;
                  _context2.t0 = _context2["catch"](3);
                  $$invalidate(6, importError = _context2.t0);

                case 13:
                  $$invalidate(5, loading = false);

                case 14:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[3, 10]]);
        }));

        return function doImport() {
          return _ref2.apply(this, arguments);
        };
      }();

      function select_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          delimiterInput = $$value;
          $$invalidate(1, delimiterInput);
        });
      }

      function input_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          fileInput = $$value;
          $$invalidate(0, fileInput);
        });
      }

      var click_handler = function click_handler() {
        $$invalidate(9, parseError = '');
      };

      var click_handler_1 = function click_handler_1() {
        $$invalidate(6, importError = '');
      };

      var click_handler_2 = function click_handler_2() {
        $$invalidate(7, successMessage = '');
      };

      var click_handler_3 = function click_handler_3() {
        return $$invalidate(10, allOpen = false);
      };

      var click_handler_4 = function click_handler_4() {
        return $$invalidate(10, allOpen = true);
      };

      $$self.$$set = function ($$props) {
        if ('syncApiUrl' in $$props) $$invalidate(13, syncApiUrl = $$props.syncApiUrl);
        if ('requestToken' in $$props) $$invalidate(14, requestToken = $$props.requestToken);
      };

      $$invalidate(9, parseError = "");

      $$invalidate(6, importError = "");

      $$invalidate(7, successMessage = "");

      $$invalidate(8, importPreviewData = []);

      $$invalidate(5, loading = false);

      $$invalidate(10, allOpen = false);

      return [fileInput, delimiterInput, preparedClients, preparedProjects, preparedTasks, loading, importError, successMessage, importPreviewData, parseError, allOpen, previewFile, doImport, syncApiUrl, requestToken, select_binding, input_binding, click_handler, click_handler_1, click_handler_2, click_handler_3, click_handler_4];
    }

    var Import = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(Import, _SvelteComponent);

      var _super = _createSuper(Import);

      function Import(options) {
        var _this;

        _classCallCheck$1(this, Import);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance$1, create_fragment$1, safe_not_equal, {
          syncApiUrl: 13,
          requestToken: 14
        }, null, [-1, -1]);
        return _this;
      }

      return _createClass$1(Import);
    }(SvelteComponent);

    function create_if_block(ctx) {
      var div;
      var userfilterselect;
      var current;
      var mounted;
      var dispose;
      userfilterselect = new UserFilterSelect({
        props: {
          isVisible:
          /*showTooltip*/
          ctx[1],
          requestToken:
          /*requestToken*/
          ctx[0]
        }
      });
      return {
        c: function c() {
          div = element("div");
          create_component(userfilterselect.$$.fragment);
          attr(div, "class", "popover");
        },
        m: function m(target, anchor) {
          insert(target, div, anchor);
          mount_component(userfilterselect, div, null);
          current = true;

          if (!mounted) {
            dispose = action_destroyer(/*popperContent*/
            ctx[4].call(null, div,
            /*extraOpts*/
            ctx[5]));
            mounted = true;
          }
        },
        p: function p(ctx, dirty) {
          var userfilterselect_changes = {};
          if (dirty &
          /*showTooltip*/
          2) userfilterselect_changes.isVisible =
          /*showTooltip*/
          ctx[1];
          if (dirty &
          /*requestToken*/
          1) userfilterselect_changes.requestToken =
          /*requestToken*/
          ctx[0];
          userfilterselect.$set(userfilterselect_changes);
        },
        i: function i(local) {
          if (current) return;
          transition_in(userfilterselect.$$.fragment, local);
          current = true;
        },
        o: function o(local) {
          transition_out(userfilterselect.$$.fragment, local);
          current = false;
        },
        d: function d(detaching) {
          if (detaching) detach(div);
          destroy_component(userfilterselect);
          mounted = false;
          dispose();
        }
      };
    }

    function create_fragment(ctx) {
      var button;
      var t0_value = dist_10('timemanager', 'Filter by person') + "";
      var t0;
      var button_class_value;
      var t1;
      var if_block_anchor;
      var current;
      var mounted;
      var dispose;
      var if_block =
      /*showTooltip*/
      ctx[1] && create_if_block(ctx);
      return {
        c: function c() {
          button = element("button");
          t0 = text(t0_value);
          t1 = space$1();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr(button, "class", button_class_value = "filter-button icon-filter button-w-icon ".concat(
          /*$isFilterSet*/
          ctx[2] ? 'active' : ''));
        },
        m: function m(target, anchor) {
          insert(target, button, anchor);
          append(button, t0);
          insert(target, t1, anchor);
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;

          if (!mounted) {
            dispose = [action_destroyer(/*popperRef*/
            ctx[3].call(null, button)), listen(button, "click",
            /*click_handler*/
            ctx[6])];
            mounted = true;
          }
        },
        p: function p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
              dirty = _ref2[0];

          if (!current || dirty &
          /*$isFilterSet*/
          4 && button_class_value !== (button_class_value = "filter-button icon-filter button-w-icon ".concat(
          /*$isFilterSet*/
          ctx[2] ? 'active' : ''))) {
            attr(button, "class", button_class_value);
          }

          if (
          /*showTooltip*/
          ctx[1]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*showTooltip*/
              2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function o(local) {
          transition_out(if_block);
          current = false;
        },
        d: function d(detaching) {
          if (detaching) detach(button);
          if (detaching) detach(t1);
          if (if_block) if_block.d(detaching);
          if (detaching) detach(if_block_anchor);
          mounted = false;
          run_all(dispose);
        }
      };
    }

    function instance($$self, $$props, $$invalidate) {
      var $isFilterSet;
      component_subscribe($$self, isFilterSet, function ($$value) {
        return $$invalidate(2, $isFilterSet = $$value);
      });
      var requestToken = $$props.requestToken;

      var _createPopperActions = createPopperActions({
        placement: "bottom",
        strategy: "fixed"
      }),
          _createPopperActions2 = _slicedToArray(_createPopperActions, 2),
          popperRef = _createPopperActions2[0],
          popperContent = _createPopperActions2[1];

      var extraOpts = {
        modifiers: [{
          name: "offset",
          options: {
            offset: [0, 8]
          }
        }]
      };
      var showTooltip = false;
      onMount(function () {
        var hideTooltip = function hideTooltip(e) {
          if (e.key === "Escape") {
            $$invalidate(1, showTooltip = false);
          }
        };

        document.addEventListener("keyup", hideTooltip);
        isFilterSet.set(false); // Parse current URL

        var urlParts = document.location.href.split("?");

        if (urlParts.length > 1) {
          var queryString = urlParts[1];
          var queryStringParts = queryString.split("&");

          var _iterator = _createForOfIteratorHelper(queryStringParts),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var part = _step.value;
              // Split query params
              var partParts = part.split("=");

              var _partParts = _slicedToArray(partParts, 2),
                  name = _partParts[0],
                  value = _partParts[1]; // Apply filters from query params


              if (name === "userFilter" && value) {
                isFilterSet.set(true);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        return function () {
          document.removeEventListener("keyup", hideTooltip);
          isFilterSet.set(false);
        };
      });

      var click_handler = function click_handler() {
        $$invalidate(1, showTooltip = !showTooltip);
      };

      $$self.$$set = function ($$props) {
        if ('requestToken' in $$props) $$invalidate(0, requestToken = $$props.requestToken);
      };

      return [requestToken, showTooltip, $isFilterSet, popperRef, popperContent, extraOpts, click_handler];
    }

    var UserFilterButton = /*#__PURE__*/function (_SvelteComponent) {
      _inherits(UserFilterButton, _SvelteComponent);

      var _super = _createSuper(UserFilterButton);

      function UserFilterButton(options) {
        var _this;

        _classCallCheck$1(this, UserFilterButton);

        _this = _super.call(this);
        init$2(_assertThisInitialized(_this), options, instance, create_fragment, safe_not_equal, {
          requestToken: 0
        });
        return _this;
      }

      return _createClass$1(UserFilterButton);
    }(SvelteComponent);

    /* global HTMLCollection: true */
    var foreachEls = function (els, fn, context) {
      if (els instanceof HTMLCollection || els instanceof NodeList || els instanceof Array) {
        return Array.prototype.forEach.call(els, fn, context);
      } // assume simple DOM element


      return fn.call(context, els);
    };

    var evalScript = function (el) {
      var code = el.text || el.textContent || el.innerHTML || "";
      var src = el.src || "";
      var parent = el.parentNode || document.querySelector("head") || document.documentElement;
      var script = document.createElement("script");

      if (code.match("document.write")) {
        if (console && console.log) {
          console.log("Script contains document.write. Canât be executed correctly. Code skipped ", el);
        }

        return false;
      }

      script.type = "text/javascript";
      script.id = el.id;
      /* istanbul ignore if */

      if (src !== "") {
        script.src = src;
        script.async = false; // force synchronous loading of peripheral JS
      }

      if (code !== "") {
        try {
          script.appendChild(document.createTextNode(code));
        } catch (e) {
          /* istanbul ignore next */
          // old IEs have funky script nodes
          script.text = code;
        }
      } // execute


      parent.appendChild(script); // avoid pollution only in head or body tags

      if ((parent instanceof HTMLHeadElement || parent instanceof HTMLBodyElement) && parent.contains(script)) {
        parent.removeChild(script);
      }

      return true;
    };

    // Finds and executes scripts (used for newly added elements)
    // Needed since innerHTML does not run scripts


    var executeScripts = function (el) {
      if (el.tagName.toLowerCase() === "script") {
        evalScript(el);
      }

      foreachEls(el.querySelectorAll("script"), function (script) {
        if (!script.type || script.type.toLowerCase() === "text/javascript") {
          if (script.parentNode) {
            script.parentNode.removeChild(script);
          }

          evalScript(script);
        }
      });
    };

    var on = function (els, events, listener, useCapture) {
      events = typeof events === "string" ? events.split(" ") : events;
      events.forEach(function (e) {
        foreachEls(els, function (el) {
          el.addEventListener(e, listener, useCapture);
        });
      });
    };

    var switches = {
      outerHTML: function (oldEl, newEl) {
        oldEl.outerHTML = newEl.outerHTML;
        this.onSwitch();
      },
      innerHTML: function (oldEl, newEl) {
        oldEl.innerHTML = newEl.innerHTML;

        if (newEl.className === "") {
          oldEl.removeAttribute("class");
        } else {
          oldEl.className = newEl.className;
        }

        this.onSwitch();
      },
      switchElementsAlt: function (oldEl, newEl) {
        oldEl.innerHTML = newEl.innerHTML; // Copy attributes from the new element to the old one

        if (newEl.hasAttributes()) {
          var attrs = newEl.attributes;

          for (var i = 0; i < attrs.length; i++) {
            oldEl.attributes.setNamedItem(attrs[i].cloneNode());
          }
        }

        this.onSwitch();
      },
      // Equivalent to outerHTML(), but doesn't require switchElementsAlt() for <head> and <body>
      replaceNode: function (oldEl, newEl) {
        oldEl.parentNode.replaceChild(newEl, oldEl);
        this.onSwitch();
      },
      sideBySide: function (oldEl, newEl, options, switchOptions) {
        var forEach = Array.prototype.forEach;
        var elsToRemove = [];
        var elsToAdd = [];
        var fragToAppend = document.createDocumentFragment();
        var animationEventNames = "animationend webkitAnimationEnd MSAnimationEnd oanimationend";
        var animatedElsNumber = 0;

        var sexyAnimationEnd = function (e) {
          if (e.target !== e.currentTarget) {
            // end triggered by an animation on a child
            return;
          }

          animatedElsNumber--;

          if (animatedElsNumber <= 0 && elsToRemove) {
            elsToRemove.forEach(function (el) {
              // browsing quickly can make the el
              // already removed by last page update ?
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
            });
            elsToAdd.forEach(function (el) {
              el.className = el.className.replace(el.getAttribute("data-pjax-classes"), "");
              el.removeAttribute("data-pjax-classes");
            });
            elsToAdd = null; // free memory

            elsToRemove = null; // free memory
            // this is to trigger some repaint (example: picturefill)

            this.onSwitch();
          }
        }.bind(this);

        switchOptions = switchOptions || {};
        forEach.call(oldEl.childNodes, function (el) {
          elsToRemove.push(el);

          if (el.classList && !el.classList.contains("js-Pjax-remove")) {
            // for fast switch, clean element that just have been added, & not cleaned yet.
            if (el.hasAttribute("data-pjax-classes")) {
              el.className = el.className.replace(el.getAttribute("data-pjax-classes"), "");
              el.removeAttribute("data-pjax-classes");
            }

            el.classList.add("js-Pjax-remove");

            if (switchOptions.callbacks && switchOptions.callbacks.removeElement) {
              switchOptions.callbacks.removeElement(el);
            }

            if (switchOptions.classNames) {
              el.className += " " + switchOptions.classNames.remove + " " + (options.backward ? switchOptions.classNames.backward : switchOptions.classNames.forward);
            }

            animatedElsNumber++;
            on(el, animationEventNames, sexyAnimationEnd, true);
          }
        });
        forEach.call(newEl.childNodes, function (el) {
          if (el.classList) {
            var addClasses = "";

            if (switchOptions.classNames) {
              addClasses = " js-Pjax-add " + switchOptions.classNames.add + " " + (options.backward ? switchOptions.classNames.forward : switchOptions.classNames.backward);
            }

            if (switchOptions.callbacks && switchOptions.callbacks.addElement) {
              switchOptions.callbacks.addElement(el);
            }

            el.className += addClasses;
            el.setAttribute("data-pjax-classes", addClasses);
            elsToAdd.push(el);
            fragToAppend.appendChild(el);
            animatedElsNumber++;
            on(el, animationEventNames, sexyAnimationEnd, true);
          }
        }); // pass all className of the parent

        oldEl.className = newEl.className;
        oldEl.appendChild(fragToAppend);
      }
    };
    switches.outerHTML;
    switches.innerHTML;
    switches.switchElementsAlt;
    switches.replaceNode;
    switches.sideBySide;

    /* global _gaq: true, ga: true */


    var parseOptions$1 = function (options) {
      options = options || {};
      options.elements = options.elements || "a[href], form[action]";
      options.selectors = options.selectors || ["title", ".js-Pjax"];
      options.switches = options.switches || {};
      options.switchesOptions = options.switchesOptions || {};
      options.history = typeof options.history === "undefined" ? true : options.history;
      options.analytics = typeof options.analytics === "function" || options.analytics === false ? options.analytics : defaultAnalytics;
      options.scrollTo = typeof options.scrollTo === "undefined" ? 0 : options.scrollTo;
      options.scrollRestoration = typeof options.scrollRestoration !== "undefined" ? options.scrollRestoration : true;
      options.cacheBust = typeof options.cacheBust === "undefined" ? true : options.cacheBust;
      options.debug = options.debug || false;
      options.timeout = options.timeout || 0;
      options.currentUrlFullReload = typeof options.currentUrlFullReload === "undefined" ? false : options.currentUrlFullReload; // We canât replace body.outerHTML or head.outerHTML.
      // It creates a bug where a new body or head are created in the DOM.
      // If you set head.outerHTML, a new body tag is appended, so the DOM has 2 body nodes, and vice versa

      if (!options.switches.head) {
        options.switches.head = switches.switchElementsAlt;
      }

      if (!options.switches.body) {
        options.switches.body = switches.switchElementsAlt;
      }

      return options;
    };
    /* istanbul ignore next */


    function defaultAnalytics() {
      if (window._gaq) {
        _gaq.push(["_trackPageview"]);
      }

      if (window.ga) {
        ga("send", "pageview", {
          page: location.pathname,
          title: document.title
        });
      }
    }

    var uniqueid = function () {
      var counter = 0;
      return function () {
        var id = "pjax" + new Date().getTime() + "_" + counter;
        counter++;
        return id;
      };
    }();

    var trigger = function (els, events, opts) {
      events = typeof events === "string" ? events.split(" ") : events;
      events.forEach(function (e) {
        var event;
        event = document.createEvent("HTMLEvents");
        event.initEvent(e, true, true);
        event.eventName = e;

        if (opts) {
          Object.keys(opts).forEach(function (key) {
            event[key] = opts[key];
          });
        }

        foreachEls(els, function (el) {
          var domFix = false;

          if (!el.parentNode && el !== document && el !== window) {
            // THANK YOU IE (9/10/11)
            // dispatchEvent doesn't work if the element is not in the DOM
            domFix = true;
            document.body.appendChild(el);
          }

          el.dispatchEvent(event);

          if (domFix) {
            el.parentNode.removeChild(el);
          }
        });
      });
    };

    var clone = function (obj) {
      /* istanbul ignore if */
      if (null === obj || "object" !== typeof obj) {
        return obj;
      }

      var copy = obj.constructor();

      for (var attr in obj) {
        if (obj.hasOwnProperty(attr)) {
          copy[attr] = obj[attr];
        }
      }

      return copy;
    };

    var contains = function contains(doc, selectors, el) {
      for (var i = 0; i < selectors.length; i++) {
        var selectedEls = doc.querySelectorAll(selectors[i]);

        for (var j = 0; j < selectedEls.length; j++) {
          if (selectedEls[j].contains(el)) {
            return true;
          }
        }
      }

      return false;
    };

    var extend = function (target) {
      if (target == null) {
        return null;
      }

      var to = Object(target);

      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        if (source != null) {
          for (var key in source) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              to[key] = source[key];
            }
          }
        }
      }

      return to;
    };

    var noop = function () {};

    var log = function () {
      if (this.options.debug && console) {
        if (typeof console.log === "function") {
          console.log.apply(console, arguments);
        } // IE is weird
        else if (console.log) {
          console.log(arguments);
        }
      }
    };

    var attrState$2 = "data-pjax-state";

    var parseElement = function (el) {
      switch (el.tagName.toLowerCase()) {
        case "a":
          // only attach link if el does not already have link attached
          if (!el.hasAttribute(attrState$2)) {
            this.attachLink(el);
          }

          break;

        case "form":
          // only attach link if el does not already have link attached
          if (!el.hasAttribute(attrState$2)) {
            this.attachForm(el);
          }

          break;

        default:
          throw "Pjax can only be applied on <a> or <form> submit";
      }
    };

    var attrState$1 = "data-pjax-state";

    var linkAction = function (el, event) {
      if (isDefaultPrevented$1(event)) {
        return;
      } // Since loadUrl modifies options and we may add our own modifications below,
      // clone it so the changes don't persist


      var options = clone(this.options);
      var attrValue = checkIfShouldAbort$1(el, event);

      if (attrValue) {
        el.setAttribute(attrState$1, attrValue);
        return;
      }

      event.preventDefault(); // donât do "nothing" if user try to reload the page by clicking the same link twice

      if (this.options.currentUrlFullReload && el.href === window.location.href.split("#")[0]) {
        el.setAttribute(attrState$1, "reload");
        this.reload();
        return;
      }

      el.setAttribute(attrState$1, "load");
      options.triggerElement = el;
      this.loadUrl(el.href, options);
    };

    function checkIfShouldAbort$1(el, event) {
      // Donât break browser special behavior on links (like page in new window)
      if (event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {
        return "modifier";
      } // we do test on href now to prevent unexpected behavior if for some reason
      // user have href that can be dynamically updated
      // Ignore external links.


      if (el.protocol !== window.location.protocol || el.host !== window.location.host) {
        return "external";
      } // Ignore anchors on the same page (keep native behavior)


      if (el.hash && el.href.replace(el.hash, "") === window.location.href.replace(location.hash, "")) {
        return "anchor";
      } // Ignore empty anchor "foo.html#"


      if (el.href === window.location.href.split("#")[0] + "#") {
        return "anchor-empty";
      }
    }

    var isDefaultPrevented$1 = function (event) {
      return event.defaultPrevented || event.returnValue === false;
    };

    var attachLink = function (el) {
      var that = this;
      el.setAttribute(attrState$1, "");
      on(el, "click", function (event) {
        linkAction.call(that, el, event);
      });
      on(el, "keyup", function (event) {
        if (event.keyCode === 13) {
          linkAction.call(that, el, event);
        }
      }.bind(this));
    };

    var attrState = "data-pjax-state";

    var formAction = function (el, event) {
      if (isDefaultPrevented(event)) {
        return;
      } // Since loadUrl modifies options and we may add our own modifications below,
      // clone it so the changes don't persist


      var options = clone(this.options); // Initialize requestOptions

      options.requestOptions = {
        requestUrl: el.getAttribute("action") || window.location.href,
        requestMethod: el.getAttribute("method") || "GET"
      }; // create a testable virtual link of the form action

      var virtLinkElement = document.createElement("a");
      virtLinkElement.setAttribute("href", options.requestOptions.requestUrl);
      var attrValue = checkIfShouldAbort(virtLinkElement, options);

      if (attrValue) {
        el.setAttribute(attrState, attrValue);
        return;
      }

      event.preventDefault();

      if (el.enctype === "multipart/form-data") {
        options.requestOptions.formData = new FormData(el);
      } else {
        options.requestOptions.requestParams = parseFormElements(el);
      }

      el.setAttribute(attrState, "submit");
      options.triggerElement = el;
      this.loadUrl(virtLinkElement.href, options);
    };

    function parseFormElements(el) {
      var requestParams = [];
      var formElements = el.elements;

      for (var i = 0; i < formElements.length; i++) {
        var element = formElements[i];
        var tagName = element.tagName.toLowerCase(); // jscs:disable disallowImplicitTypeConversion

        if (!!element.name && element.attributes !== undefined && tagName !== "button") {
          // jscs:enable disallowImplicitTypeConversion
          var type = element.attributes.type;

          if (!type || type.value !== "checkbox" && type.value !== "radio" || element.checked) {
            // Build array of values to submit
            var values = [];

            if (tagName === "select") {
              var opt;

              for (var j = 0; j < element.options.length; j++) {
                opt = element.options[j];

                if (opt.selected && !opt.disabled) {
                  values.push(opt.hasAttribute("value") ? opt.value : opt.text);
                }
              }
            } else {
              values.push(element.value);
            }

            for (var k = 0; k < values.length; k++) {
              requestParams.push({
                name: encodeURIComponent(element.name),
                value: encodeURIComponent(values[k])
              });
            }
          }
        }
      }

      return requestParams;
    }

    function checkIfShouldAbort(virtLinkElement, options) {
      // Ignore external links.
      if (virtLinkElement.protocol !== window.location.protocol || virtLinkElement.host !== window.location.host) {
        return "external";
      } // Ignore click if we are on an anchor on the same page


      if (virtLinkElement.hash && virtLinkElement.href.replace(virtLinkElement.hash, "") === window.location.href.replace(location.hash, "")) {
        return "anchor";
      } // Ignore empty anchor "foo.html#"


      if (virtLinkElement.href === window.location.href.split("#")[0] + "#") {
        return "anchor-empty";
      } // if declared as a full reload, just normally submit the form


      if (options.currentUrlFullReload && virtLinkElement.href === window.location.href.split("#")[0]) {
        return "reload";
      }
    }

    var isDefaultPrevented = function (event) {
      return event.defaultPrevented || event.returnValue === false;
    };

    var attachForm = function (el) {
      var that = this;
      el.setAttribute(attrState, "");
      on(el, "submit", function (event) {
        formAction.call(that, el, event);
      });
    };

    var foreachSelectors = function (selectors, cb, context, DOMcontext) {
      DOMcontext = DOMcontext || document;
      selectors.forEach(function (selector) {
        foreachEls(DOMcontext.querySelectorAll(selector), cb, context);
      });
    };

    var switchesSelectors = function (switches$1, switchesOptions, selectors, fromEl, toEl, options) {
      var switchesQueue = [];
      selectors.forEach(function (selector) {
        var newEls = fromEl.querySelectorAll(selector);
        var oldEls = toEl.querySelectorAll(selector);

        if (this.log) {
          this.log("Pjax switch", selector, newEls, oldEls);
        }

        if (newEls.length !== oldEls.length) {
          throw "DOM doesnât look the same on new loaded page: â" + selector + "â - new " + newEls.length + ", old " + oldEls.length;
        }

        foreachEls(newEls, function (newEl, i) {
          var oldEl = oldEls[i];

          if (this.log) {
            this.log("newEl", newEl, "oldEl", oldEl);
          }

          var callback = switches$1[selector] ? switches$1[selector].bind(this, oldEl, newEl, options, switchesOptions[selector]) : switches.outerHTML.bind(this, oldEl, newEl, options);
          switchesQueue.push(callback);
        }, this);
      }, this);
      this.state.numPendingSwitches = switchesQueue.length;
      switchesQueue.forEach(function (queuedSwitch) {
        queuedSwitch();
      });
    };

    var abortRequest = function (request) {
      if (request && request.readyState < 4) {
        request.onreadystatechange = noop;
        request.abort();
      }
    };

    var updateQueryString = function (uri, key, value) {
      var re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
      var separator = uri.indexOf("?") !== -1 ? "&" : "?";

      if (uri.match(re)) {
        return uri.replace(re, "$1" + key + "=" + value + "$2");
      } else {
        return uri + separator + key + "=" + value;
      }
    };

    var sendRequest = function (location, options, callback) {
      options = options || {};
      var queryString;
      var requestOptions = options.requestOptions || {};
      var requestMethod = (requestOptions.requestMethod || "GET").toUpperCase();
      var requestParams = requestOptions.requestParams || null;
      var formData = requestOptions.formData || null;
      var requestPayload = null;
      var request = new XMLHttpRequest();
      var timeout = options.timeout || 0;

      request.onreadystatechange = function () {
        if (request.readyState === 4) {
          if (request.status === 200) {
            callback(request.responseText, request, location, options);
          } else if (request.status !== 0) {
            callback(null, request, location, options);
          }
        }
      };

      request.onerror = function (e) {
        console.log(e);
        callback(null, request, location, options);
      };

      request.ontimeout = function () {
        callback(null, request, location, options);
      }; // Prepare the request payload for forms, if available


      if (requestParams && requestParams.length) {
        // Build query string
        queryString = requestParams.map(function (param) {
          return param.name + "=" + param.value;
        }).join("&");

        switch (requestMethod) {
          case "GET":
            // Reset query string to avoid an issue with repeat submissions where checkboxes that were
            // previously checked are incorrectly preserved
            location = location.split("?")[0]; // Append new query string

            location += "?" + queryString;
            break;

          case "POST":
            // Send query string as request payload
            requestPayload = queryString;
            break;
        }
      } else if (formData) {
        requestPayload = formData;
      } // Add a timestamp as part of the query string if cache busting is enabled


      if (options.cacheBust) {
        location = updateQueryString(location, "t", Date.now());
      }

      request.open(requestMethod, location, true);
      request.timeout = timeout;
      request.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      request.setRequestHeader("X-PJAX", "true");
      request.setRequestHeader("X-PJAX-Selectors", JSON.stringify(options.selectors)); // Send the proper header information for POST forms

      if (requestPayload && requestMethod === "POST" && !formData) {
        request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      }

      request.send(requestPayload);
      return request;
    };

    var handleResponse = function (responseText, request, href, options) {
      options = clone(options || this.options);
      options.request = request; // Fail if unable to load HTML via AJAX

      if (responseText === false) {
        trigger(document, "pjax:complete pjax:error", options);
        return;
      } // push scroll position to history


      var currentState = window.history.state || {};
      window.history.replaceState({
        url: currentState.url || window.location.href,
        title: currentState.title || document.title,
        uid: currentState.uid || uniqueid(),
        scrollPos: [document.documentElement.scrollLeft || document.body.scrollLeft, document.documentElement.scrollTop || document.body.scrollTop]
      }, document.title, window.location.href); // Check for redirects

      var oldHref = href;

      if (request.responseURL) {
        if (href !== request.responseURL) {
          href = request.responseURL;
        }
      } else if (request.getResponseHeader("X-PJAX-URL")) {
        href = request.getResponseHeader("X-PJAX-URL");
      } else if (request.getResponseHeader("X-XHR-Redirected-To")) {
        href = request.getResponseHeader("X-XHR-Redirected-To");
      } // Add back the hash if it was removed


      var a = document.createElement("a");
      a.href = oldHref;
      var oldHash = a.hash;
      a.href = href;

      if (oldHash && !a.hash) {
        a.hash = oldHash;
        href = a.href;
      }

      this.state.href = href;
      this.state.options = options;

      try {
        this.loadContent(responseText, options);
      } catch (e) {
        trigger(document, "pjax:error", options);

        if (!this.options.debug) {
          if (console && console.error) {
            console.error("Pjax switch fail: ", e);
          }

          return this.latestChance(href);
        } else {
          throw e;
        }
      }
    };

    var isSupported = function () {
      // Borrowed wholesale from https://github.com/defunkt/jquery-pjax
      return window.history && window.history.pushState && window.history.replaceState && // pushState isnât reliable on iOS until 5.
      !navigator.userAgent.match(/((iPod|iPhone|iPad).+\bOS\s+[1-4]\D|WebApps\/.+CFNetwork)/);
    };

    var pjax = createCommonjsModule$1(function (module) {
    var Pjax = function (options) {
      this.state = {
        numPendingSwitches: 0,
        href: null,
        options: null
      };
      this.options = parseOptions$1(options);
      this.log("Pjax options", this.options);

      if (this.options.scrollRestoration && "scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }

      this.maxUid = this.lastUid = uniqueid();
      this.parseDOM(document);
      on(window, "popstate", function (st) {
        if (st.state) {
          var opt = clone(this.options);
          opt.url = st.state.url;
          opt.title = st.state.title; // Since state already exists, prevent it from being pushed again

          opt.history = false;
          opt.scrollPos = st.state.scrollPos;

          if (st.state.uid < this.lastUid) {
            opt.backward = true;
          } else {
            opt.forward = true;
          }

          this.lastUid = st.state.uid; // @todo implement history cache here, based on uid

          this.loadUrl(st.state.url, opt);
        }
      }.bind(this));
    };

    Pjax.switches = switches;
    Pjax.prototype = {
      log: log,
      getElements: function (el) {
        return el.querySelectorAll(this.options.elements);
      },
      parseDOM: function (el) {
        var parseElement$1 = parseElement;

        foreachEls(this.getElements(el), parseElement$1, this);
      },
      refresh: function (el) {
        this.parseDOM(el || document);
      },
      reload: function () {
        window.location.reload();
      },
      attachLink: attachLink,
      attachForm: attachForm,
      forEachSelectors: function (cb, context, DOMcontext) {
        return foreachSelectors.bind(this)(this.options.selectors, cb, context, DOMcontext);
      },
      switchSelectors: function (selectors, fromEl, toEl, options) {
        return switchesSelectors.bind(this)(this.options.switches, this.options.switchesOptions, selectors, fromEl, toEl, options);
      },
      latestChance: function (href) {
        window.location = href;
      },
      onSwitch: function () {
        trigger(window, "resize scroll");
        this.state.numPendingSwitches--; // debounce calls, so we only run this once after all switches are finished.

        if (this.state.numPendingSwitches === 0) {
          this.afterAllSwitches();
        }
      },
      loadContent: function (html, options) {
        if (typeof html !== "string") {
          trigger(document, "pjax:complete pjax:error", options);
          return;
        }

        var tmpEl = document.implementation.createHTMLDocument("pjax"); // parse HTML attributes to copy them
        // since we are forced to use documentElement.innerHTML (outerHTML can't be used for <html>)

        var htmlRegex = /<html[^>]+>/gi;
        var htmlAttribsRegex = /\s?[a-z:]+(?:=['"][^'">]+['"])*/gi;
        var matches = html.match(htmlRegex);

        if (matches && matches.length) {
          matches = matches[0].match(htmlAttribsRegex);

          if (matches.length) {
            matches.shift();
            matches.forEach(function (htmlAttrib) {
              var attr = htmlAttrib.trim().split("=");

              if (attr.length === 1) {
                tmpEl.documentElement.setAttribute(attr[0], true);
              } else {
                tmpEl.documentElement.setAttribute(attr[0], attr[1].slice(1, -1));
              }
            });
          }
        }

        tmpEl.documentElement.innerHTML = html;
        this.log("load content", tmpEl.documentElement.attributes, tmpEl.documentElement.innerHTML.length); // Clear out any focused controls before inserting new page contents.

        if (document.activeElement && contains(document, this.options.selectors, document.activeElement)) {
          try {
            document.activeElement.blur();
          } catch (e) {} // eslint-disable-line no-empty

        }

        this.switchSelectors(this.options.selectors, tmpEl, document, options);
      },
      abortRequest: abortRequest,
      doRequest: sendRequest,
      handleResponse: handleResponse,
      loadUrl: function (href, options) {
        options = typeof options === "object" ? extend({}, this.options, options) : clone(this.options);
        this.log("load href", href, options); // Abort any previous request

        this.abortRequest(this.request);
        trigger(document, "pjax:send", options); // Do the request

        this.request = this.doRequest(href, options, this.handleResponse.bind(this));
      },
      afterAllSwitches: function () {
        // FF bug: Wonât autofocus fields that are inserted via JS.
        // This behavior is incorrect. So if theres no current focus, autofocus
        // the last field.
        //
        // http://www.w3.org/html/wg/drafts/html/master/forms.html
        var autofocusEl = Array.prototype.slice.call(document.querySelectorAll("[autofocus]")).pop();

        if (autofocusEl && document.activeElement !== autofocusEl) {
          autofocusEl.focus();
        } // execute scripts when DOM have been completely updated


        this.options.selectors.forEach(function (selector) {
          foreachEls(document.querySelectorAll(selector), function (el) {
            executeScripts(el);
          });
        });
        var state = this.state;

        if (state.options.history) {
          if (!window.history.state) {
            this.lastUid = this.maxUid = uniqueid();
            window.history.replaceState({
              url: window.location.href,
              title: document.title,
              uid: this.maxUid,
              scrollPos: [0, 0]
            }, document.title);
          } // Update browser history


          this.lastUid = this.maxUid = uniqueid();
          window.history.pushState({
            url: state.href,
            title: state.options.title,
            uid: this.maxUid,
            scrollPos: [0, 0]
          }, state.options.title, state.href);
        }

        this.forEachSelectors(function (el) {
          this.parseDOM(el);
        }, this); // Fire Events

        trigger(document, "pjax:complete pjax:success", state.options);

        if (typeof state.options.analytics === "function") {
          state.options.analytics();
        }

        if (state.options.history) {
          // First parse url and check for hash to override scroll
          var a = document.createElement("a");
          a.href = this.state.href;

          if (a.hash) {
            var name = a.hash.slice(1);
            name = decodeURIComponent(name);
            var curtop = 0;
            var target = document.getElementById(name) || document.getElementsByName(name)[0];

            if (target) {
              // http://stackoverflow.com/questions/8111094/cross-browser-javascript-function-to-find-actual-position-of-an-element-in-page
              if (target.offsetParent) {
                do {
                  curtop += target.offsetTop;
                  target = target.offsetParent;
                } while (target);
              }
            }

            window.scrollTo(0, curtop);
          } else if (state.options.scrollTo !== false) {
            // Scroll page to top on new page load
            if (state.options.scrollTo.length > 1) {
              window.scrollTo(state.options.scrollTo[0], state.options.scrollTo[1]);
            } else {
              window.scrollTo(0, state.options.scrollTo);
            }
          }
        } else if (state.options.scrollRestoration && state.options.scrollPos) {
          window.scrollTo(state.options.scrollPos[0], state.options.scrollPos[1]);
        }

        this.state = {
          numPendingSwitches: 0,
          href: null,
          options: null
        };
      }
    };
    Pjax.isSupported = isSupported; // arguably could do `if( require("./lib/is-supported")()) {` but that might be a little to simple

    if (Pjax.isSupported()) {
      module.exports = Pjax;
    } // if there isnât required browser functions, returning stupid api
    else {
      var stupidPjax = noop;

      for (var key in Pjax.prototype) {
        if (Pjax.prototype.hasOwnProperty(key) && typeof Pjax.prototype[key] === "function") {
          stupidPjax[key] = noop;
        }
      }

      module.exports = stupidPjax;
    }
    });

    var PagePjax = /*#__PURE__*/_createClass$1(function PagePjax(reload) {
      _classCallCheck$1(this, PagePjax);

      /**
       * Enable seamless page navigation with pjax.
       */
      this.pjaxInstance = new pjax({
        elements: [".timemanager-pjax-link"],
        selectors: [".app-timemanager #app-navigation ul", ".app-timemanager #app-content .container"],
        cacheBust: false,
        scrollTo: true
      });
      document.addEventListener("pjax:send", function () {
        document.body.classList.add("loading");
        document.body.classList.remove("loading-error");
        document.body.classList.remove("tm_ready");
      });
      document.addEventListener("pjax:success", function () {
        setTimeout(function () {
          document.body.classList.remove("loading");
          reload();
        }, 300);
      });
      document.addEventListener("pjax:error", function (error) {
        // Catch session timeout and redirect to login
        if (error && error.request && error.request.status === 401) {
          document.location.href = "".concat(dist_4("login"), "?redirect_url=").concat(dist_4("timemanager", "index"));
        }

        document.body.classList.remove("loading");
        document.body.classList.add("loading-error");
      });
    });

    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    // eslint-disable-next-line es-x/no-array-prototype-foreach -- safe


    _export$1({
      target: 'Array',
      proto: true,
      forced: [].forEach != arrayForEach$1
    }, {
      forEach: arrayForEach$1
    });

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = {
        exports: {}
      };
      return fn(module, module.exports), module.exports;
    }

    var check = function (it) {
      return it && it.Math == Math && it;
    }; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


    var global$1 = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
    function () {
      return this;
    }() || Function('return this')();

    var fails = function (exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    }; // Detect IE8's incomplete defineProperty implementation


    var descriptors = !fails(function () {
      // eslint-disable-next-line es/no-object-defineproperty -- required for testing
      return Object.defineProperty({}, 1, {
        get: function () {
          return 7;
        }
      })[1] != 7;
    });
    var $propertyIsEnumerable = {}.propertyIsEnumerable; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

    var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

    var NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({
      1: 2
    }, 1); // `Object.prototype.propertyIsEnumerable` method implementation
    // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable

    var f$4 = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor$2(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
    var objectPropertyIsEnumerable = {
      f: f$4
    };

    var createPropertyDescriptor = function (bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
      };
    };

    var toString = {}.toString;

    var classofRaw = function (it) {
      return toString.call(it).slice(8, -1);
    };

    var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

    var indexedObject = fails(function () {
      // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
      // eslint-disable-next-line no-prototype-builtins -- safe
      return !Object('z').propertyIsEnumerable(0);
    }) ? function (it) {
      return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
    } : Object; // `RequireObjectCoercible` abstract operation
    // https://tc39.es/ecma262/#sec-requireobjectcoercible

    var requireObjectCoercible = function (it) {
      if (it == undefined) throw TypeError("Can't call method on " + it);
      return it;
    }; // toObject with fallback for non-array-like ES3 strings


    var toIndexedObject = function (it) {
      return indexedObject(requireObjectCoercible(it));
    };

    var isObject = function (it) {
      return typeof it === 'object' ? it !== null : typeof it === 'function';
    }; // `ToPrimitive` abstract operation
    // https://tc39.es/ecma262/#sec-toprimitive
    // instead of the ES6 spec version, we didn't implement @@toPrimitive case
    // and the second argument - flag - preferred type is a string


    var toPrimitive = function (input, PREFERRED_STRING) {
      if (!isObject(input)) return input;
      var fn, val;
      if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
      if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
      if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
      throw TypeError("Can't convert object to primitive value");
    }; // `ToObject` abstract operation
    // https://tc39.es/ecma262/#sec-toobject


    var toObject = function (argument) {
      return Object(requireObjectCoercible(argument));
    };

    var hasOwnProperty = {}.hasOwnProperty;

    var has$1 = function hasOwn(it, key) {
      return hasOwnProperty.call(toObject(it), key);
    };

    var document$1 = global$1.document; // typeof document.createElement is 'object' in old IE

    var EXISTS = isObject(document$1) && isObject(document$1.createElement);

    var documentCreateElement = function (it) {
      return EXISTS ? document$1.createElement(it) : {};
    }; // Thank's IE8 for his funny defineProperty


    var ie8DomDefine = !descriptors && !fails(function () {
      // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
      return Object.defineProperty(documentCreateElement('div'), 'a', {
        get: function () {
          return 7;
        }
      }).a != 7;
    }); // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

    var f$3 = descriptors ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPrimitive(P, true);
      if (ie8DomDefine) try {
        return $getOwnPropertyDescriptor(O, P);
      } catch (error) {
        /* empty */
      }
      if (has$1(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
    };
    var objectGetOwnPropertyDescriptor = {
      f: f$3
    };

    var anObject = function (it) {
      if (!isObject(it)) {
        throw TypeError(String(it) + ' is not an object');
      }

      return it;
    }; // eslint-disable-next-line es/no-object-defineproperty -- safe


    var $defineProperty = Object.defineProperty; // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty

    var f$2 = descriptors ? $defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPrimitive(P, true);
      anObject(Attributes);
      if (ie8DomDefine) try {
        return $defineProperty(O, P, Attributes);
      } catch (error) {
        /* empty */
      }
      if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
      if ('value' in Attributes) O[P] = Attributes.value;
      return O;
    };
    var objectDefineProperty = {
      f: f$2
    };
    var createNonEnumerableProperty = descriptors ? function (object, key, value) {
      return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
    } : function (object, key, value) {
      object[key] = value;
      return object;
    };

    var setGlobal = function (key, value) {
      try {
        createNonEnumerableProperty(global$1, key, value);
      } catch (error) {
        global$1[key] = value;
      }

      return value;
    };

    var SHARED = '__core-js_shared__';
    var store$1 = global$1[SHARED] || setGlobal(SHARED, {});
    var sharedStore = store$1;
    var functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper

    if (typeof sharedStore.inspectSource != 'function') {
      sharedStore.inspectSource = function (it) {
        return functionToString.call(it);
      };
    }

    var inspectSource = sharedStore.inspectSource;
    var WeakMap$1 = global$1.WeakMap;
    var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource(WeakMap$1));
    var shared = createCommonjsModule(function (module) {
      (module.exports = function (key, value) {
        return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
      })('versions', []).push({
        version: '3.11.2',
        mode: 'global',
        copyright: 'Â© 2021 Denis Pushkarev (zloirock.ru)'
      });
    });
    var id = 0;
    var postfix = Math.random();

    var uid = function (key) {
      return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
    };

    var keys$2 = shared('keys');

    var sharedKey = function (key) {
      return keys$2[key] || (keys$2[key] = uid(key));
    };

    var hiddenKeys$1 = {};
    var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
    var WeakMap = global$1.WeakMap;
    var set, get, has;

    var enforce = function (it) {
      return has(it) ? get(it) : set(it, {});
    };

    var getterFor = function (TYPE) {
      return function (it) {
        var state;

        if (!isObject(it) || (state = get(it)).type !== TYPE) {
          throw TypeError('Incompatible receiver, ' + TYPE + ' required');
        }

        return state;
      };
    };

    if (nativeWeakMap) {
      var store = sharedStore.state || (sharedStore.state = new WeakMap());
      var wmget = store.get;
      var wmhas = store.has;
      var wmset = store.set;

      set = function (it, metadata) {
        if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        wmset.call(store, it, metadata);
        return metadata;
      };

      get = function (it) {
        return wmget.call(store, it) || {};
      };

      has = function (it) {
        return wmhas.call(store, it);
      };
    } else {
      var STATE = sharedKey('state');
      hiddenKeys$1[STATE] = true;

      set = function (it, metadata) {
        if (has$1(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };

      get = function (it) {
        return has$1(it, STATE) ? it[STATE] : {};
      };

      has = function (it) {
        return has$1(it, STATE);
      };
    }

    var internalState = {
      set: set,
      get: get,
      has: has,
      enforce: enforce,
      getterFor: getterFor
    };
    var redefine = createCommonjsModule(function (module) {
      var getInternalState = internalState.get;
      var enforceInternalState = internalState.enforce;
      var TEMPLATE = String(String).split('String');
      (module.exports = function (O, key, value, options) {
        var unsafe = options ? !!options.unsafe : false;
        var simple = options ? !!options.enumerable : false;
        var noTargetGet = options ? !!options.noTargetGet : false;
        var state;

        if (typeof value == 'function') {
          if (typeof key == 'string' && !has$1(value, 'name')) {
            createNonEnumerableProperty(value, 'name', key);
          }

          state = enforceInternalState(value);

          if (!state.source) {
            state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
          }
        }

        if (O === global$1) {
          if (simple) O[key] = value;else setGlobal(key, value);
          return;
        } else if (!unsafe) {
          delete O[key];
        } else if (!noTargetGet && O[key]) {
          simple = true;
        }

        if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
      })(Function.prototype, 'toString', function toString() {
        return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
      });
    });
    var path = global$1;

    var aFunction$1 = function (variable) {
      return typeof variable == 'function' ? variable : undefined;
    };

    var getBuiltIn = function (namespace, method) {
      return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global$1[namespace]) : path[namespace] && path[namespace][method] || global$1[namespace] && global$1[namespace][method];
    };

    var ceil = Math.ceil;
    var floor = Math.floor; // `ToInteger` abstract operation
    // https://tc39.es/ecma262/#sec-tointeger

    var toInteger = function (argument) {
      return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
    };

    var min$2 = Math.min; // `ToLength` abstract operation
    // https://tc39.es/ecma262/#sec-tolength

    var toLength = function (argument) {
      return argument > 0 ? min$2(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
    };

    var max = Math.max;
    var min$1 = Math.min; // Helper for a popular repeating case of the spec:
    // Let integer be ? ToInteger(index).
    // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

    var toAbsoluteIndex = function (index, length) {
      var integer = toInteger(index);
      return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
    }; // `Array.prototype.{ indexOf, includes }` methods implementation


    var createMethod$3 = function (IS_INCLUDES) {
      return function ($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = toLength(O.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value; // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare -- NaN check

        if (IS_INCLUDES && el != el) while (length > index) {
          value = O[index++]; // eslint-disable-next-line no-self-compare -- NaN check

          if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
        } else for (; length > index; index++) {
          if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };

    var arrayIncludes = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod$3(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod$3(false)
    };
    var indexOf = arrayIncludes.indexOf;

    var objectKeysInternal = function (object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;

      for (key in O) !has$1(hiddenKeys$1, key) && has$1(O, key) && result.push(key); // Don't enum bug & hidden keys


      while (names.length > i) if (has$1(O, key = names[i++])) {
        ~indexOf(result, key) || result.push(key);
      }

      return result;
    }; // IE8- don't enum bug keys


    var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];
    var hiddenKeys = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
    // https://tc39.es/ecma262/#sec-object.getownpropertynames
    // eslint-disable-next-line es/no-object-getownpropertynames -- safe

    var f$1 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return objectKeysInternal(O, hiddenKeys);
    };

    var objectGetOwnPropertyNames = {
      f: f$1
    }; // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe

    var f = Object.getOwnPropertySymbols;
    var objectGetOwnPropertySymbols = {
      f: f
    }; // all object keys, includes non-enumerable and symbols

    var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
      var keys = objectGetOwnPropertyNames.f(anObject(it));
      var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
      return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
    };

    var copyConstructorProperties = function (target, source) {
      var keys = ownKeys(source);
      var defineProperty = objectDefineProperty.f;
      var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!has$1(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
      }
    };

    var replacement = /#|\.prototype\./;

    var isForced = function (feature, detection) {
      var value = data[normalize(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
    };

    var normalize = isForced.normalize = function (string) {
      return String(string).replace(replacement, '.').toLowerCase();
    };

    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = 'N';
    var POLYFILL = isForced.POLYFILL = 'P';
    var isForced_1 = isForced;
    var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
    /*
      options.target      - name of the target object
      options.global      - target is the global object
      options.stat        - export as static methods of target
      options.proto       - export as prototype methods of target
      options.real        - real prototype method for the `pure` version
      options.forced      - export even if the native feature is available
      options.bind        - bind methods to the target, required for the `pure` version
      options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
      options.unsafe      - use the simple assignment of property instead of delete + defineProperty
      options.sham        - add a flag to not completely full polyfills
      options.enumerable  - export as enumerable property
      options.noTargetGet - prevent calling a getter on target
    */

    var _export = function (options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;

      if (GLOBAL) {
        target = global$1;
      } else if (STATIC) {
        target = global$1[TARGET] || setGlobal(TARGET, {});
      } else {
        target = (global$1[TARGET] || {}).prototype;
      }

      if (target) for (key in source) {
        sourceProperty = source[key];

        if (options.noTargetGet) {
          descriptor = getOwnPropertyDescriptor$1(target, key);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];

        FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

        if (!FORCED && targetProperty !== undefined) {
          if (typeof sourceProperty === typeof targetProperty) continue;
          copyConstructorProperties(sourceProperty, targetProperty);
        } // add a flag to not completely full polyfills


        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(sourceProperty, 'sham', true);
        } // extend global


        redefine(target, key, sourceProperty, options);
      }
    }; // `Number.MAX_SAFE_INTEGER` constant
    // https://tc39.es/ecma262/#sec-number.max_safe_integer


    _export({
      target: 'Number',
      stat: true
    }, {
      MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
    });

    var aPossiblePrototype = function (it) {
      if (!isObject(it) && it !== null) {
        throw TypeError("Can't set " + String(it) + ' as a prototype');
      }

      return it;
    };
    /* eslint-disable no-proto -- safe */
    // `Object.setPrototypeOf` method
    // https://tc39.es/ecma262/#sec-object.setprototypeof
    // Works with __proto__ only. Old v8 can't work with null proto objects.
    // eslint-disable-next-line es/no-object-setprototypeof -- safe


    var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;

      try {
        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
        setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
        setter.call(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
        /* empty */
      }

      return function setPrototypeOf(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
        return O;
      };
    }() : undefined); // makes subclassing work correct for wrapped built-ins

    var inheritIfRequired = function ($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if ( // it can work only with native `setPrototypeOf`
      objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
      typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);
      return $this;
    }; // `Object.keys` method
    // https://tc39.es/ecma262/#sec-object.keys
    // eslint-disable-next-line es/no-object-keys -- safe


    var objectKeys = Object.keys || function keys(O) {
      return objectKeysInternal(O, enumBugKeys);
    }; // `Object.defineProperties` method
    // https://tc39.es/ecma262/#sec-object.defineproperties
    // eslint-disable-next-line es/no-object-defineproperties -- safe


    var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var index = 0;
      var key;

      while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);

      return O;
    };
    var html = getBuiltIn('document', 'documentElement');
    var GT = '>';
    var LT = '<';
    var PROTOTYPE = 'prototype';
    var SCRIPT = 'script';
    var IE_PROTO$1 = sharedKey('IE_PROTO');

    var EmptyConstructor = function () {
      /* empty */
    };

    var scriptTag = function (content) {
      return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
    }; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


    var NullProtoObjectViaActiveX = function (activeXDocument) {
      activeXDocument.write(scriptTag(''));
      activeXDocument.close();
      var temp = activeXDocument.parentWindow.Object;
      activeXDocument = null; // avoid memory leak

      return temp;
    }; // Create object with fake `null` prototype: use iframe Object with cleared prototype


    var NullProtoObjectViaIFrame = function () {
      // Thrash, waste and sodomy: IE GC bug
      var iframe = documentCreateElement('iframe');
      var JS = 'java' + SCRIPT + ':';
      var iframeDocument;
      iframe.style.display = 'none';
      html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag('document.F=Object'));
      iframeDocument.close();
      return iframeDocument.F;
    }; // Check for document.domain and active x support
    // No need to use active x approach when document.domain is not set
    // see https://github.com/es-shims/es5-shim/issues/150
    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
    // avoid IE GC bug


    var activeXDocument;

    var NullProtoObject = function () {
      try {
        /* global ActiveXObject -- old IE */
        activeXDocument = document.domain && new ActiveXObject('htmlfile');
      } catch (error) {
        /* ignore */
      }

      NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
      var length = enumBugKeys.length;

      while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];

      return NullProtoObject();
    };

    hiddenKeys$1[IE_PROTO$1] = true; // `Object.create` method
    // https://tc39.es/ecma262/#sec-object.create

    var objectCreate = Object.create || function create(O, Properties) {
      var result;

      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

        result[IE_PROTO$1] = O;
      } else result = NullProtoObject();

      return Properties === undefined ? result : objectDefineProperties(result, Properties);
    }; // a string of all valid unicode whitespaces


    var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' + '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
    var whitespace = '[' + whitespaces + ']';
    var ltrim = RegExp('^' + whitespace + whitespace + '*');
    var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

    var createMethod$2 = function (TYPE) {
      return function ($this) {
        var string = String(requireObjectCoercible($this));
        if (TYPE & 1) string = string.replace(ltrim, '');
        if (TYPE & 2) string = string.replace(rtrim, '');
        return string;
      };
    };

    var stringTrim = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod$2(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod$2(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod$2(3)
    };
    var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    var defineProperty$3 = objectDefineProperty.f;
    var trim = stringTrim.trim;
    var NUMBER = 'Number';
    var NativeNumber = global$1[NUMBER];
    var NumberPrototype = NativeNumber.prototype; // Opera ~12 has broken Object#toString

    var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER; // `ToNumber` abstract operation
    // https://tc39.es/ecma262/#sec-tonumber

    var toNumber = function (argument) {
      var it = toPrimitive(argument, false);
      var first, third, radix, maxCode, digits, length, index, code;

      if (typeof it == 'string' && it.length > 2) {
        it = trim(it);
        first = it.charCodeAt(0);

        if (first === 43 || first === 45) {
          third = it.charCodeAt(2);
          if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
        } else if (first === 48) {
          switch (it.charCodeAt(1)) {
            case 66:
            case 98:
              radix = 2;
              maxCode = 49;
              break;
            // fast equal of /^0b[01]+$/i

            case 79:
            case 111:
              radix = 8;
              maxCode = 55;
              break;
            // fast equal of /^0o[0-7]+$/i

            default:
              return +it;
          }

          digits = it.slice(2);
          length = digits.length;

          for (index = 0; index < length; index++) {
            code = digits.charCodeAt(index); // parseInt parses a string to a first unavailable symbol
            // but ToNumber should return NaN if a string contains unavailable symbols

            if (code < 48 || code > maxCode) return NaN;
          }

          return parseInt(digits, radix);
        }
      }

      return +it;
    }; // `Number` constructor
    // https://tc39.es/ecma262/#sec-number-constructor


    if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
      var NumberWrapper = function Number(value) {
        var it = arguments.length < 1 ? 0 : value;
        var dummy = this;
        return dummy instanceof NumberWrapper // check on 1..constructor(foo) case
        && (BROKEN_CLASSOF ? fails(function () {
          NumberPrototype.valueOf.call(dummy);
        }) : classofRaw(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
      };

      for (var keys$1 = descriptors ? getOwnPropertyNames$1(NativeNumber) : ( // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,' + // ESNext
      'fromString,range').split(','), j = 0, key; keys$1.length > j; j++) {
        if (has$1(NativeNumber, key = keys$1[j]) && !has$1(NumberWrapper, key)) {
          defineProperty$3(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
        }
      }

      NumberWrapper.prototype = NumberPrototype;
      NumberPrototype.constructor = NumberWrapper;
      redefine(global$1, NUMBER, NumberWrapper);
    } // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.


    var SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH$2 = 256;
    var MAX_SAFE_INTEGER$2 = Number.MAX_SAFE_INTEGER ||
    /* istanbul ignore next */
    9007199254740991; // Max safe segment length for coercion.

    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var constants = {
      SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
      MAX_LENGTH: MAX_LENGTH$2,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2,
      MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH
    };
    var engineIsNode = classofRaw(global$1.process) == 'process';
    var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';
    var process$1 = global$1.process;
    var versions = process$1 && process$1.versions;
    var v8 = versions && versions.v8;
    var match, version;

    if (v8) {
      match = v8.split('.');
      version = match[0] + match[1];
    } else if (engineUserAgent) {
      match = engineUserAgent.match(/Edge\/(\d+)/);

      if (!match || match[1] >= 74) {
        match = engineUserAgent.match(/Chrome\/(\d+)/);
        if (match) version = match[1];
      }
    }

    var engineV8Version = version && +version; // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing

    var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
      // eslint-disable-next-line es/no-symbol -- required for testing
      return !Symbol.sham && ( // Chrome 38 Symbol has incorrect toString conversion
      // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      engineIsNode ? engineV8Version === 38 : engineV8Version > 37 && engineV8Version < 41);
    });
    /* eslint-disable es/no-symbol -- required for testing */

    var useSymbolAsUid = nativeSymbol && !Symbol.sham && typeof Symbol.iterator == 'symbol';
    var WellKnownSymbolsStore = shared('wks');
    var Symbol$1 = global$1.Symbol;
    var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

    var wellKnownSymbol = function (name) {
      if (!has$1(WellKnownSymbolsStore, name) || !(nativeSymbol || typeof WellKnownSymbolsStore[name] == 'string')) {
        if (nativeSymbol && has$1(Symbol$1, name)) {
          WellKnownSymbolsStore[name] = Symbol$1[name];
        } else {
          WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
        }
      }

      return WellKnownSymbolsStore[name];
    };

    var MATCH$1 = wellKnownSymbol('match'); // `IsRegExp` abstract operation
    // https://tc39.es/ecma262/#sec-isregexp

    var isRegexp = function (it) {
      var isRegExp;
      return isObject(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
    }; // `RegExp.prototype.flags` getter implementation
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags


    var regexpFlags = function () {
      var that = anObject(this);
      var result = '';
      if (that.global) result += 'g';
      if (that.ignoreCase) result += 'i';
      if (that.multiline) result += 'm';
      if (that.dotAll) result += 's';
      if (that.unicode) result += 'u';
      if (that.sticky) result += 'y';
      return result;
    }; // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
    // so we use an intermediate function.


    function RE(s, f) {
      return RegExp(s, f);
    }

    var UNSUPPORTED_Y$3 = fails(function () {
      // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
      var re = RE('a', 'y');
      re.lastIndex = 2;
      return re.exec('abcd') != null;
    });
    var BROKEN_CARET = fails(function () {
      // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
      var re = RE('^r', 'gy');
      re.lastIndex = 2;
      return re.exec('str') != null;
    });
    var regexpStickyHelpers = {
      UNSUPPORTED_Y: UNSUPPORTED_Y$3,
      BROKEN_CARET: BROKEN_CARET
    };
    var SPECIES$4 = wellKnownSymbol('species');

    var setSpecies = function (CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      var defineProperty = objectDefineProperty.f;

      if (descriptors && Constructor && !Constructor[SPECIES$4]) {
        defineProperty(Constructor, SPECIES$4, {
          configurable: true,
          get: function () {
            return this;
          }
        });
      }
    };

    var defineProperty$2 = objectDefineProperty.f;
    var getOwnPropertyNames = objectGetOwnPropertyNames.f;
    var enforceInternalState = internalState.enforce;
    var MATCH = wellKnownSymbol('match');
    var NativeRegExp = global$1.RegExp;
    var RegExpPrototype$1 = NativeRegExp.prototype;
    var re1 = /a/g;
    var re2 = /a/g; // "new" should create a new object, old webkit bug

    var CORRECT_NEW = new NativeRegExp(re1) !== re1;
    var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y;
    var FORCED$1 = descriptors && isForced_1('RegExp', !CORRECT_NEW || UNSUPPORTED_Y$2 || fails(function () {
      re2[MATCH] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

      return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
    })); // `RegExp` constructor
    // https://tc39.es/ecma262/#sec-regexp-constructor

    if (FORCED$1) {
      var RegExpWrapper = function RegExp(pattern, flags) {
        var thisIsRegExp = this instanceof RegExpWrapper;
        var patternIsRegExp = isRegexp(pattern);
        var flagsAreUndefined = flags === undefined;
        var sticky;

        if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
          return pattern;
        }

        if (CORRECT_NEW) {
          if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
        } else if (pattern instanceof RegExpWrapper) {
          if (flagsAreUndefined) flags = regexpFlags.call(pattern);
          pattern = pattern.source;
        }

        if (UNSUPPORTED_Y$2) {
          sticky = !!flags && flags.indexOf('y') > -1;
          if (sticky) flags = flags.replace(/y/g, '');
        }

        var result = inheritIfRequired(CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype$1, RegExpWrapper);

        if (UNSUPPORTED_Y$2 && sticky) {
          var state = enforceInternalState(result);
          state.sticky = true;
        }

        return result;
      };

      var proxy = function (key) {
        key in RegExpWrapper || defineProperty$2(RegExpWrapper, key, {
          configurable: true,
          get: function () {
            return NativeRegExp[key];
          },
          set: function (it) {
            NativeRegExp[key] = it;
          }
        });
      };

      var keys = getOwnPropertyNames(NativeRegExp);
      var index = 0;

      while (keys.length > index) proxy(keys[index++]);

      RegExpPrototype$1.constructor = RegExpWrapper;
      RegExpWrapper.prototype = RegExpPrototype$1;
      redefine(global$1, 'RegExp', RegExpWrapper);
    } // https://tc39.es/ecma262/#sec-get-regexp-@@species


    setSpecies('RegExp');
    var nativeExec = RegExp.prototype.exec;
    var nativeReplace = shared('native-string-replace', String.prototype.replace);
    var patchedExec = nativeExec;

    var UPDATES_LAST_INDEX_WRONG = function () {
      var re1 = /a/;
      var re2 = /b*/g;
      nativeExec.call(re1, 'a');
      nativeExec.call(re2, 'a');
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();

    var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET; // nonparticipating capturing group, copied from es5-shim's String#split patch.
    // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing

    var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;

    if (PATCH) {
      patchedExec = function exec(str) {
        var re = this;
        var lastIndex, reCopy, match, i;
        var sticky = UNSUPPORTED_Y$1 && re.sticky;
        var flags = regexpFlags.call(re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;

        if (sticky) {
          flags = flags.replace('y', '');

          if (flags.indexOf('g') === -1) {
            flags += 'g';
          }

          strCopy = String(str).slice(re.lastIndex); // Support anchored sticky behavior.

          if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
            source = '(?: ' + source + ')';
            strCopy = ' ' + strCopy;
            charsAdded++;
          } // ^(? + rx + ) is needed, in combination with some str slicing, to
          // simulate the 'y' flag.


          reCopy = new RegExp('^(?:' + source + ')', flags);
        }

        if (NPCG_INCLUDED) {
          reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
        }

        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
        match = nativeExec.call(sticky ? reCopy : re, strCopy);

        if (sticky) {
          if (match) {
            match.input = match.input.slice(charsAdded);
            match[0] = match[0].slice(charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
          } else re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
        }

        if (NPCG_INCLUDED && match && match.length > 1) {
          // Fix browsers whose `exec` methods don't consistently return `undefined`
          // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
          nativeReplace.call(match[0], reCopy, function () {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undefined) match[i] = undefined;
            }
          });
        }

        return match;
      };
    }

    var regexpExec = patchedExec; // `RegExp.prototype.exec` method
    // https://tc39.es/ecma262/#sec-regexp.prototype.exec

    _export({
      target: 'RegExp',
      proto: true,
      forced: /./.exec !== regexpExec
    }, {
      exec: regexpExec
    });

    var TO_STRING = 'toString';
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING];
    var NOT_GENERIC = fails(function () {
      return nativeToString.call({
        source: 'a',
        flags: 'b'
      }) != '/a/b';
    }); // FF44- RegExp#toString has a wrong name

    var INCORRECT_NAME = nativeToString.name != TO_STRING; // `RegExp.prototype.toString` method
    // https://tc39.es/ecma262/#sec-regexp.prototype.tostring

    if (NOT_GENERIC || INCORRECT_NAME) {
      redefine(RegExp.prototype, TO_STRING, function toString() {
        var R = anObject(this);
        var p = String(R.source);
        var rf = R.flags;
        var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? regexpFlags.call(R) : rf);
        return '/' + p + '/' + f;
      }, {
        unsafe: true
      });
    } // `IsArray` abstract operation
    // https://tc39.es/ecma262/#sec-isarray
    // eslint-disable-next-line es/no-array-isarray -- safe


    var isArray = Array.isArray || function isArray(arg) {
      return classofRaw(arg) == 'Array';
    };

    var createProperty = function (object, key, value) {
      var propertyKey = toPrimitive(key);
      if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
    };

    var SPECIES$3 = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation
    // https://tc39.es/ecma262/#sec-arrayspeciescreate

    var arraySpeciesCreate = function (originalArray, length) {
      var C;

      if (isArray(originalArray)) {
        C = originalArray.constructor; // cross-realm fallback

        if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
          C = C[SPECIES$3];
          if (C === null) C = undefined;
        }
      }

      return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
    };

    var SPECIES$2 = wellKnownSymbol('species');

    var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
      // We can't use this feature detection in V8 since it causes
      // deoptimization and serious performance degradation
      // https://github.com/zloirock/core-js/issues/677
      return engineV8Version >= 51 || !fails(function () {
        var array = [];
        var constructor = array.constructor = {};

        constructor[SPECIES$2] = function () {
          return {
            foo: 1
          };
        };

        return array[METHOD_NAME](Boolean).foo !== 1;
      });
    };

    var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
    var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
    var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded'; // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/679

    var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
      var array = [];
      array[IS_CONCAT_SPREADABLE] = false;
      return array.concat()[0] !== array;
    });
    var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

    var isConcatSpreadable = function (O) {
      if (!isObject(O)) return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== undefined ? !!spreadable : isArray(O);
    };

    var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
    // https://tc39.es/ecma262/#sec-array.prototype.concat
    // with adding support of @@isConcatSpreadable and @@species

    _export({
      target: 'Array',
      proto: true,
      forced: FORCED
    }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      concat: function concat(arg) {
        var O = toObject(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length, len, E;

        for (i = -1, length = arguments.length; i < length; i++) {
          E = i === -1 ? O : arguments[i];

          if (isConcatSpreadable(E)) {
            len = toLength(E.length);
            if (n + len > MAX_SAFE_INTEGER$1) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

            for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
          } else {
            if (n >= MAX_SAFE_INTEGER$1) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
            createProperty(A, n++, E);
          }
        }

        A.length = n;
        return A;
      }
    });

    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    var debug = (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () {
      var _console;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
    } : function () {};
    var debug_1 = debug;
    var re_1 = createCommonjsModule(function (module, exports) {
      var MAX_SAFE_COMPONENT_LENGTH = constants.MAX_SAFE_COMPONENT_LENGTH;
      exports = module.exports = {}; // The actual regexps go on exports.re

      var re = exports.re = [];
      var src = exports.src = [];
      var t = exports.t = {};
      var R = 0;

      var createToken = function createToken(name, value, isGlobal) {
        var index = R++;
        debug_1(index, value);
        t[name] = index;
        src[index] = value;
        re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
      }; // The following Regular Expressions can be used for tokenizing,
      // validating, and parsing SemVer version strings.
      // ## Numeric Identifier
      // A single `0`, or a non-zero digit followed by zero or more digits.


      createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
      createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+'); // ## Non-numeric Identifier
      // Zero or more digits, followed by a letter or hyphen, and then zero or
      // more letters, digits, or hyphens.

      createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*'); // ## Main Version
      // Three dot-separated numeric identifiers.

      createToken('MAINVERSION', "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIER], ")"));
      createToken('MAINVERSIONLOOSE', "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(src[t.NUMERICIDENTIFIERLOOSE], ")")); // ## Pre-release Version Identifier
      // A numeric identifier, or a non-numeric identifier.

      createToken('PRERELEASEIDENTIFIER', "(?:".concat(src[t.NUMERICIDENTIFIER], "|").concat(src[t.NONNUMERICIDENTIFIER], ")"));
      createToken('PRERELEASEIDENTIFIERLOOSE', "(?:".concat(src[t.NUMERICIDENTIFIERLOOSE], "|").concat(src[t.NONNUMERICIDENTIFIER], ")")); // ## Pre-release Version
      // Hyphen, followed by one or more dot-separated pre-release version
      // identifiers.

      createToken('PRERELEASE', "(?:-(".concat(src[t.PRERELEASEIDENTIFIER], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIER], ")*))"));
      createToken('PRERELEASELOOSE', "(?:-?(".concat(src[t.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(src[t.PRERELEASEIDENTIFIERLOOSE], ")*))")); // ## Build Metadata Identifier
      // Any combination of digits, letters, or hyphens.

      createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+'); // ## Build Metadata
      // Plus sign, followed by one or more period-separated build metadata
      // identifiers.

      createToken('BUILD', "(?:\\+(".concat(src[t.BUILDIDENTIFIER], "(?:\\.").concat(src[t.BUILDIDENTIFIER], ")*))")); // ## Full Version String
      // A main version, followed optionally by a pre-release version and
      // build metadata.
      // Note that the only major, minor, patch, and pre-release sections of
      // the version string are capturing groups.  The build metadata is not a
      // capturing group, because it should not ever be used in version
      // comparison.

      createToken('FULLPLAIN', "v?".concat(src[t.MAINVERSION]).concat(src[t.PRERELEASE], "?").concat(src[t.BUILD], "?"));
      createToken('FULL', "^".concat(src[t.FULLPLAIN], "$")); // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
      // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
      // common in the npm registry.

      createToken('LOOSEPLAIN', "[v=\\s]*".concat(src[t.MAINVERSIONLOOSE]).concat(src[t.PRERELEASELOOSE], "?").concat(src[t.BUILD], "?"));
      createToken('LOOSE', "^".concat(src[t.LOOSEPLAIN], "$"));
      createToken('GTLT', '((?:<|>)?=?)'); // Something like "2.*" or "1.2.x".
      // Note that "x.x" is a valid xRange identifer, meaning "any version"
      // Only the first item is strictly required.

      createToken('XRANGEIDENTIFIERLOOSE', "".concat(src[t.NUMERICIDENTIFIERLOOSE], "|x|X|\\*"));
      createToken('XRANGEIDENTIFIER', "".concat(src[t.NUMERICIDENTIFIER], "|x|X|\\*"));
      createToken('XRANGEPLAIN', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIER], ")") + "(?:".concat(src[t.PRERELEASE], ")?").concat(src[t.BUILD], "?") + ")?)?");
      createToken('XRANGEPLAINLOOSE', "[v=\\s]*(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(src[t.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(src[t.PRERELEASELOOSE], ")?").concat(src[t.BUILD], "?") + ")?)?");
      createToken('XRANGE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAIN], "$"));
      createToken('XRANGELOOSE', "^".concat(src[t.GTLT], "\\s*").concat(src[t.XRANGEPLAINLOOSE], "$")); // Coercion.
      // Extract anything that could conceivably be a part of a valid semver

      createToken('COERCE', "".concat('(^|[^\\d])' + '(\\d{1,').concat(MAX_SAFE_COMPONENT_LENGTH, "})") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") + "(?:\\.(\\d{1,".concat(MAX_SAFE_COMPONENT_LENGTH, "}))?") + "(?:$|[^\\d])");
      createToken('COERCERTL', src[t.COERCE], true); // Tilde ranges.
      // Meaning is "reasonably at or greater than"

      createToken('LONETILDE', '(?:~>?)');
      createToken('TILDETRIM', "(\\s*)".concat(src[t.LONETILDE], "\\s+"), true);
      exports.tildeTrimReplace = '$1~';
      createToken('TILDE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAIN], "$"));
      createToken('TILDELOOSE', "^".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAINLOOSE], "$")); // Caret ranges.
      // Meaning is "at least and backwards compatible with"

      createToken('LONECARET', '(?:\\^)');
      createToken('CARETTRIM', "(\\s*)".concat(src[t.LONECARET], "\\s+"), true);
      exports.caretTrimReplace = '$1^';
      createToken('CARET', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAIN], "$"));
      createToken('CARETLOOSE', "^".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAINLOOSE], "$")); // A simple gt/lt/eq thing, or just "" to indicate "any version"

      createToken('COMPARATORLOOSE', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], ")$|^$"));
      createToken('COMPARATOR', "^".concat(src[t.GTLT], "\\s*(").concat(src[t.FULLPLAIN], ")$|^$")); // An expression to strip any whitespace between the gtlt and the thing
      // it modifies, so that `> 1.2.3` ==> `>1.2.3`

      createToken('COMPARATORTRIM', "(\\s*)".concat(src[t.GTLT], "\\s*(").concat(src[t.LOOSEPLAIN], "|").concat(src[t.XRANGEPLAIN], ")"), true);
      exports.comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`
      // Note that these all use the loose form, because they'll be
      // checked against either the strict or loose comparator form
      // later.

      createToken('HYPHENRANGE', "^\\s*(".concat(src[t.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAIN], ")") + "\\s*$");
      createToken('HYPHENRANGELOOSE', "^\\s*(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(src[t.XRANGEPLAINLOOSE], ")") + "\\s*$"); // Star ranges basically just allow anything at all.

      createToken('STAR', '(<|>)?=?\\s*\\*'); // >=0.0.0 is like a star

      createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$');
      createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$');
    }); // TODO: Remove from `core-js@4` since it's moved to entry points

    var SPECIES$1 = wellKnownSymbol('species');
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
      // #replace needs built-in support for named groups.
      // #match works fine because it just return the exec results, even if it has
      // a "grops" property.
      var re = /./;

      re.exec = function () {
        var result = [];
        result.groups = {
          a: '7'
        };
        return result;
      };

      return ''.replace(re, '$<a>') !== '7';
    }); // IE <= 11 replaces $0 with the whole match, as if it was $&
    // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0

    var REPLACE_KEEPS_$0 = function () {
      // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
      return 'a'.replace(/./, '$0') === '$0';
    }();

    var REPLACE = wellKnownSymbol('replace'); // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string

    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
      if (/./[REPLACE]) {
        return /./[REPLACE]('a', '$0') === '';
      }

      return false;
    }(); // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
    // Weex JS has frozen built-in prototypes, so use try / catch wrapper


    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
      // eslint-disable-next-line regexp/no-empty-group -- required for testing
      var re = /(?:)/;
      var originalExec = re.exec;

      re.exec = function () {
        return originalExec.apply(this, arguments);
      };

      var result = 'ab'.split(re);
      return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
    });

    var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function () {
        // String methods call symbol-named RegEp methods
        var O = {};

        O[SYMBOL] = function () {
          return 7;
        };

        return ''[KEY](O) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
        // Symbol-named RegExp methods call .exec
        var execCalled = false;
        var re = /a/;

        if (KEY === 'split') {
          // We can't use real regex here since it causes deoptimization
          // and serious performance degradation in V8
          // https://github.com/zloirock/core-js/issues/306
          re = {}; // RegExp[@@split] doesn't call the regex's exec method, but first creates
          // a new one. We need to return the patched regex when creating the new one.

          re.constructor = {};

          re.constructor[SPECIES$1] = function () {
            return re;
          };

          re.flags = '';
          re[SYMBOL] = /./[SYMBOL];
        }

        re.exec = function () {
          execCalled = true;
          return null;
        };

        re[SYMBOL]('');
        return !execCalled;
      });

      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
          if (regexp.exec === RegExp.prototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              // The native String method already delegates to @@method (this
              // polyfilled function), leasing to infinite recursion.
              // We avoid it by directly calling the native @@method method.
              return {
                done: true,
                value: nativeRegExpMethod.call(regexp, str, arg2)
              };
            }

            return {
              done: true,
              value: nativeMethod.call(str, regexp, arg2)
            };
          }

          return {
            done: false
          };
        }, {
          REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
          REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
        });
        var stringMethod = methods[0];
        var regexMethod = methods[1];
        redefine(String.prototype, KEY, stringMethod);
        redefine(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
        // 21.2.5.11 RegExp.prototype[@@split](string, limit)
        ? function (string, arg) {
          return regexMethod.call(string, this, arg);
        } // 21.2.5.6 RegExp.prototype[@@match](string)
        // 21.2.5.9 RegExp.prototype[@@search](string)
        : function (string) {
          return regexMethod.call(string, this);
        });
      }

      if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
    }; // `String.prototype.{ codePointAt, at }` methods implementation


    var createMethod$1 = function (CONVERT_TO_STRING) {
      return function ($this, pos) {
        var S = String(requireObjectCoercible($this));
        var position = toInteger(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
        first = S.charCodeAt(position);
        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
      };
    };

    var stringMultibyte = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod$1(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod$1(true)
    };
    var charAt$1 = stringMultibyte.charAt; // `AdvanceStringIndex` abstract operation
    // https://tc39.es/ecma262/#sec-advancestringindex

    var advanceStringIndex = function (S, index, unicode) {
      return index + (unicode ? charAt$1(S, index).length : 1);
    }; // `RegExpExec` abstract operation
    // https://tc39.es/ecma262/#sec-regexpexec


    var regexpExecAbstract = function (R, S) {
      var exec = R.exec;

      if (typeof exec === 'function') {
        var result = exec.call(R, S);

        if (typeof result !== 'object') {
          throw TypeError('RegExp exec method returned something other than an Object or null');
        }

        return result;
      }

      if (classofRaw(R) !== 'RegExp') {
        throw TypeError('RegExp#exec called on incompatible receiver');
      }

      return regexpExec.call(R, S);
    }; // @@match logic


    fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
      return [// `String.prototype.match` method
      // https://tc39.es/ecma262/#sec-string.prototype.match
      function match(regexp) {
        var O = requireObjectCoercible(this);
        var matcher = regexp == undefined ? undefined : regexp[MATCH];
        return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
      }, // `RegExp.prototype[@@match]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
      function (regexp) {
        var res = maybeCallNative(nativeMatch, regexp, this);
        if (res.done) return res.value;
        var rx = anObject(regexp);
        var S = String(this);
        if (!rx.global) return regexpExecAbstract(rx, S);
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;

        while ((result = regexpExecAbstract(rx, S)) !== null) {
          var matchStr = String(result[0]);
          A[n] = matchStr;
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          n++;
        }

        return n === 0 ? null : A;
      }];
    });
    var non = '\u200B\u0085\u180E'; // check that a method works with the correct list
    // of whitespaces and has a correct name

    var stringTrimForced = function (METHOD_NAME) {
      return fails(function () {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };

    var $trim = stringTrim.trim; // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim

    _export({
      target: 'String',
      proto: true,
      forced: stringTrimForced('trim')
    }, {
      trim: function trim() {
        return $trim(this);
      }
    });

    var aFunction = function (it) {
      if (typeof it != 'function') {
        throw TypeError(String(it) + ' is not a function');
      }

      return it;
    }; // optional / simple context binding


    var functionBindContext = function (fn, that, length) {
      aFunction(fn);
      if (that === undefined) return fn;

      switch (length) {
        case 0:
          return function () {
            return fn.call(that);
          };

        case 1:
          return function (a) {
            return fn.call(that, a);
          };

        case 2:
          return function (a, b) {
            return fn.call(that, a, b);
          };

        case 3:
          return function (a, b, c) {
            return fn.call(that, a, b, c);
          };
      }

      return function
        /* ...args */
      () {
        return fn.apply(that, arguments);
      };
    };

    var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation

    var createMethod = function (TYPE) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var IS_FILTER_OUT = TYPE == 7;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      return function ($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self = indexedObject(O);
        var boundFunction = functionBindContext(callbackfn, that, 3);
        var length = toLength(self.length);
        var index = 0;
        var create = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
        var value, result;

        for (; length > index; index++) if (NO_HOLES || index in self) {
          value = self[index];
          result = boundFunction(value, index, O);

          if (TYPE) {
            if (IS_MAP) target[index] = result; // map
            else if (result) switch (TYPE) {
              case 3:
                return true;
              // some

              case 5:
                return value;
              // find

              case 6:
                return index;
              // findIndex

              case 2:
                push.call(target, value);
              // filter
            } else switch (TYPE) {
              case 4:
                return false;
              // every

              case 7:
                push.call(target, value);
              // filterOut
            }
          }
        }

        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };

    var arrayIteration = {
      // `Array.prototype.forEach` method
      // https://tc39.es/ecma262/#sec-array.prototype.foreach
      forEach: createMethod(0),
      // `Array.prototype.map` method
      // https://tc39.es/ecma262/#sec-array.prototype.map
      map: createMethod(1),
      // `Array.prototype.filter` method
      // https://tc39.es/ecma262/#sec-array.prototype.filter
      filter: createMethod(2),
      // `Array.prototype.some` method
      // https://tc39.es/ecma262/#sec-array.prototype.some
      some: createMethod(3),
      // `Array.prototype.every` method
      // https://tc39.es/ecma262/#sec-array.prototype.every
      every: createMethod(4),
      // `Array.prototype.find` method
      // https://tc39.es/ecma262/#sec-array.prototype.find
      find: createMethod(5),
      // `Array.prototype.findIndex` method
      // https://tc39.es/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod(6),
      // `Array.prototype.filterOut` method
      // https://github.com/tc39/proposal-array-filtering
      filterOut: createMethod(7)
    };
    var $map = arrayIteration.map;
    var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('map'); // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    // with adding support of @@species

    _export({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT$1
    }, {
      map: function map(callbackfn
      /* , thisArg */
      ) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });

    var SPECIES = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
    // https://tc39.es/ecma262/#sec-speciesconstructor

    var speciesConstructor = function (O, defaultConstructor) {
      var C = anObject(O).constructor;
      var S;
      return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
    };

    var UNSUPPORTED_Y = regexpStickyHelpers.UNSUPPORTED_Y;
    var arrayPush = [].push;
    var min = Math.min;
    var MAX_UINT32 = 0xFFFFFFFF; // @@split logic

    fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit;

      if ('abbc'.split(/(b)*/)[1] == 'c' || // eslint-disable-next-line regexp/no-empty-group -- required for testing
      'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
      '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
        // based on es5-shim implementation, need to rework it
        internalSplit = function (separator, limit) {
          var string = String(requireObjectCoercible(this));
          var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
          if (lim === 0) return [];
          if (separator === undefined) return [string]; // If `separator` is not a regex, use native split

          if (!isRegexp(separator)) {
            return nativeSplit.call(string, separator, lim);
          }

          var output = [];
          var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
          var lastLastIndex = 0; // Make `global` and avoid `lastIndex` issues by working with a copy

          var separatorCopy = new RegExp(separator.source, flags + 'g');
          var match, lastIndex, lastLength;

          while (match = regexpExec.call(separatorCopy, string)) {
            lastIndex = separatorCopy.lastIndex;

            if (lastIndex > lastLastIndex) {
              output.push(string.slice(lastLastIndex, match.index));
              if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
              lastLength = match[0].length;
              lastLastIndex = lastIndex;
              if (output.length >= lim) break;
            }

            if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
          }

          if (lastLastIndex === string.length) {
            if (lastLength || !separatorCopy.test('')) output.push('');
          } else output.push(string.slice(lastLastIndex));

          return output.length > lim ? output.slice(0, lim) : output;
        }; // Chakra, V8

      } else if ('0'.split(undefined, 0).length) {
        internalSplit = function (separator, limit) {
          return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
        };
      } else internalSplit = nativeSplit;

      return [// `String.prototype.split` method
      // https://tc39.es/ecma262/#sec-string.prototype.split
      function split(separator, limit) {
        var O = requireObjectCoercible(this);
        var splitter = separator == undefined ? undefined : separator[SPLIT];
        return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
      }, // `RegExp.prototype[@@split]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function (regexp, limit) {
        var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
        if (res.done) return res.value;
        var rx = anObject(regexp);
        var S = String(this);
        var C = speciesConstructor(rx, RegExp);
        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (UNSUPPORTED_Y ? 'g' : 'y'); // ^(? + rx + ) is needed, in combination with some S slicing, to
        // simulate the 'y' flag.

        var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];

        while (q < S.length) {
          splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
          var z = regexpExecAbstract(splitter, UNSUPPORTED_Y ? S.slice(q) : S);
          var e;

          if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            A.push(S.slice(p, q));
            if (A.length === lim) return A;

            for (var i = 1; i <= z.length - 1; i++) {
              A.push(z[i]);
              if (A.length === lim) return A;
            }

            q = p = e;
          }
        }

        A.push(S.slice(p));
        return A;
      }];
    }, UNSUPPORTED_Y);

    var arrayMethodIsStrict = function (METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function () {
        // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
        method.call(null, argument || function () {
          throw 1;
        }, 1);
      });
    };

    var nativeJoin = [].join;
    var ES3_STRINGS = indexedObject != Object;
    var STRICT_METHOD$1 = arrayMethodIsStrict('join', ','); // `Array.prototype.join` method
    // https://tc39.es/ecma262/#sec-array.prototype.join

    _export({
      target: 'Array',
      proto: true,
      forced: ES3_STRINGS || !STRICT_METHOD$1
    }, {
      join: function join(separator) {
        return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
      }
    });

    var $filter = arrayIteration.filter;
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter'); // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    // with adding support of @@species

    _export({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT
    }, {
      filter: function filter(callbackfn
      /* , thisArg */
      ) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    }); // parse out just the options we care about so we always get a consistent
    // obj with keys in a consistent order.


    var opts = ['includePrerelease', 'loose', 'rtl'];

    var parseOptions = function parseOptions(options) {
      return !options ? {} : _typeof(options) !== 'object' ? {
        loose: true
      } : opts.filter(function (k) {
        return options[k];
      }).reduce(function (options, k) {
        options[k] = true;
        return options;
      }, {});
    };

    var parseOptions_1 = parseOptions;
    var numeric = /^[0-9]+$/;

    var compareIdentifiers$1 = function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };

    var rcompareIdentifiers = function rcompareIdentifiers(a, b) {
      return compareIdentifiers$1(b, a);
    };

    var identifiers = {
      compareIdentifiers: compareIdentifiers$1,
      rcompareIdentifiers: rcompareIdentifiers
    };
    var MAX_LENGTH$1 = constants.MAX_LENGTH,
        MAX_SAFE_INTEGER = constants.MAX_SAFE_INTEGER;
    var re$1 = re_1.re,
        t$1 = re_1.t;
    var compareIdentifiers = identifiers.compareIdentifiers;

    var SemVer = /*#__PURE__*/function () {
      function SemVer(version, options) {
        _classCallCheck(this, SemVer);

        options = parseOptions_1(options);

        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== 'string') {
          throw new TypeError("Invalid Version: ".concat(version));
        }

        if (version.length > MAX_LENGTH$1) {
          throw new TypeError("version is longer than ".concat(MAX_LENGTH$1, " characters"));
        }

        debug_1('SemVer', version, options);
        this.options = options;
        this.loose = !!options.loose; // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.

        this.includePrerelease = !!options.includePrerelease;
        var m = version.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);

        if (!m) {
          throw new TypeError("Invalid Version: ".concat(version));
        }

        this.raw = version; // these are actually numbers

        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];

        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError('Invalid major version');
        }

        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError('Invalid minor version');
        }

        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError('Invalid patch version');
        } // numberify any prerelease numeric ids


        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split('.').map(function (id) {
            if (/^[0-9]+$/.test(id)) {
              var num = +id;

              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }

            return id;
          });
        }

        this.build = m[5] ? m[5].split('.') : [];
        this.format();
      }

      _createClass(SemVer, [{
        key: "format",
        value: function format() {
          this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);

          if (this.prerelease.length) {
            this.version += "-".concat(this.prerelease.join('.'));
          }

          return this.version;
        }
      }, {
        key: "toString",
        value: function toString() {
          return this.version;
        }
      }, {
        key: "compare",
        value: function compare(other) {
          debug_1('SemVer.compare', this.version, this.options, other);

          if (!(other instanceof SemVer)) {
            if (typeof other === 'string' && other === this.version) {
              return 0;
            }

            other = new SemVer(other, this.options);
          }

          if (other.version === this.version) {
            return 0;
          }

          return this.compareMain(other) || this.comparePre(other);
        }
      }, {
        key: "compareMain",
        value: function compareMain(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }

          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
      }, {
        key: "comparePre",
        value: function comparePre(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          } // NOT having a prerelease is > having one


          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }

          var i = 0;

          do {
            var a = this.prerelease[i];
            var b = other.prerelease[i];
            debug_1('prerelease compare', i, a, b);

            if (a === undefined && b === undefined) {
              return 0;
            } else if (b === undefined) {
              return 1;
            } else if (a === undefined) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
      }, {
        key: "compareBuild",
        value: function compareBuild(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }

          var i = 0;

          do {
            var a = this.build[i];
            var b = other.build[i];
            debug_1('prerelease compare', i, a, b);

            if (a === undefined && b === undefined) {
              return 0;
            } else if (b === undefined) {
              return 1;
            } else if (a === undefined) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        } // preminor will bump the version up to the next minor release, and immediately
        // down to pre-release. premajor and prepatch work the same way.

      }, {
        key: "inc",
        value: function inc(release, identifier) {
          switch (release) {
            case 'premajor':
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc('pre', identifier);
              break;

            case 'preminor':
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc('pre', identifier);
              break;

            case 'prepatch':
              // If this is already a prerelease, it will bump to the next version
              // drop any prereleases that might already exist, since they are not
              // relevant at this point.
              this.prerelease.length = 0;
              this.inc('patch', identifier);
              this.inc('pre', identifier);
              break;
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.

            case 'prerelease':
              if (this.prerelease.length === 0) {
                this.inc('patch', identifier);
              }

              this.inc('pre', identifier);
              break;

            case 'major':
              // If this is a pre-major version, bump up to the same major version.
              // Otherwise increment major.
              // 1.0.0-5 bumps to 1.0.0
              // 1.1.0 bumps to 2.0.0
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }

              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;

            case 'minor':
              // If this is a pre-minor version, bump up to the same minor version.
              // Otherwise increment minor.
              // 1.2.0-5 bumps to 1.2.0
              // 1.2.1 bumps to 1.3.0
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }

              this.patch = 0;
              this.prerelease = [];
              break;

            case 'patch':
              // If this is not a pre-release version, it will increment the patch.
              // If it is a pre-release it will bump up to the same patch version.
              // 1.2.0-5 patches to 1.2.0
              // 1.2.0 patches to 1.2.1
              if (this.prerelease.length === 0) {
                this.patch++;
              }

              this.prerelease = [];
              break;
            // This probably shouldn't be used publicly.
            // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.

            case 'pre':
              if (this.prerelease.length === 0) {
                this.prerelease = [0];
              } else {
                var i = this.prerelease.length;

                while (--i >= 0) {
                  if (typeof this.prerelease[i] === 'number') {
                    this.prerelease[i]++;
                    i = -2;
                  }
                }

                if (i === -1) {
                  // didn't increment anything
                  this.prerelease.push(0);
                }
              }

              if (identifier) {
                // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                if (this.prerelease[0] === identifier) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = [identifier, 0];
                  }
                } else {
                  this.prerelease = [identifier, 0];
                }
              }

              break;

            default:
              throw new Error("invalid increment argument: ".concat(release));
          }

          this.format();
          this.raw = this.version;
          return this;
        }
      }]);

      return SemVer;
    }();

    var semver = SemVer;
    var MAX_LENGTH = constants.MAX_LENGTH;
    var re = re_1.re,
        t = re_1.t;

    var parse = function parse(version, options) {
      options = parseOptions_1(options);

      if (version instanceof semver) {
        return version;
      }

      if (typeof version !== 'string') {
        return null;
      }

      if (version.length > MAX_LENGTH) {
        return null;
      }

      var r = options.loose ? re[t.LOOSE] : re[t.FULL];

      if (!r.test(version)) {
        return null;
      }

      try {
        return new semver(version, options);
      } catch (er) {
        return null;
      }
    };

    var parse_1 = parse;

    var valid = function valid(version, options) {
      var v = parse_1(version, options);
      return v ? v.version : null;
    };

    var valid_1 = valid;

    var major = function major(a, loose) {
      return new semver(a, loose).major;
    };

    var major_1 = major;
    var packageJson$1 = {
      name: "@nextcloud/event-bus",
      version: "1.3.0",
      description: "",
      main: "dist/index.js",
      module: "dist/index.es.js",
      types: "dist/index.d.ts",
      scripts: {
        build: "NODE_ENV=production rollup -c",
        "build:doc": "typedoc --out dist/doc lib/index.ts && touch dist/doc/.nojekyll",
        "check-types": "tsc",
        dev: "NODE_ENV=development rollup -c --watch",
        test: "jest",
        "test:watch": "jest --watchAll"
      },
      keywords: ["nextcloud"],
      homepage: "https://github.com/nextcloud/nextcloud-event-bus#readme",
      author: "Christoph Wurst",
      license: "GPL-3.0-or-later",
      repository: {
        type: "git",
        url: "https://github.com/nextcloud/nextcloud-event-bus"
      },
      dependencies: {
        "@types/semver": "^7.3.5",
        "core-js": "^3.11.2",
        semver: "^7.3.5"
      },
      devDependencies: {
        "@babel/cli": "^7.13.16",
        "@babel/core": "^7.14.0",
        "@babel/plugin-proposal-class-properties": "^7.13.0",
        "@babel/preset-env": "^7.14.1",
        "@babel/preset-typescript": "^7.13.0",
        "@nextcloud/browserslist-config": "^1.0.0",
        "@rollup/plugin-babel": "^5.3.0",
        "@rollup/plugin-commonjs": "^18.0.0",
        "@rollup/plugin-node-resolve": "^11.2.1",
        "babel-jest": "^26.6.3",
        "babel-plugin-inline-json-import": "^0.3.2",
        jest: "^26.6.3",
        rollup: "^2.47.0",
        "rollup-plugin-inject-process-env": "^1.3.1",
        "rollup-plugin-typescript2": "^0.30.0",
        typedoc: "^0.20.36",
        typescript: "^4.2.4"
      },
      browserslist: ["extends @nextcloud/browserslist-config"]
    };

    var ProxyBus =
    /** @class */
    function () {
      function ProxyBus(bus) {
        if (typeof bus.getVersion !== 'function' || !valid_1(bus.getVersion())) {
          console.warn('Proxying an event bus with an unknown or invalid version');
        } else if (major_1(bus.getVersion()) !== major_1(this.getVersion())) {
          console.warn('Proxying an event bus of version ' + bus.getVersion() + ' with ' + this.getVersion());
        }

        this.bus = bus;
      }

      ProxyBus.prototype.getVersion = function () {
        return packageJson$1.version;
      };

      ProxyBus.prototype.subscribe = function (name, handler) {
        this.bus.subscribe(name, handler);
      };

      ProxyBus.prototype.unsubscribe = function (name, handler) {
        this.bus.unsubscribe(name, handler);
      };

      ProxyBus.prototype.emit = function (name, event) {
        this.bus.emit(name, event);
      };

      return ProxyBus;
    }();

    var UNSCOPABLES = wellKnownSymbol('unscopables');
    var ArrayPrototype$1 = Array.prototype; // Array.prototype[@@unscopables]
    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

    if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
      objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {
        configurable: true,
        value: objectCreate(null)
      });
    } // add a key to Array.prototype[@@unscopables]


    var addToUnscopables = function (key) {
      ArrayPrototype$1[UNSCOPABLES][key] = true;
    };

    var iterators = {};
    var correctPrototypeGetter = !fails(function () {
      function F() {
        /* empty */
      }

      F.prototype.constructor = null; // eslint-disable-next-line es/no-object-getprototypeof -- required for testing

      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
    var IE_PROTO = sharedKey('IE_PROTO');
    var ObjectPrototype = Object.prototype; // `Object.getPrototypeOf` method
    // https://tc39.es/ecma262/#sec-object.getprototypeof
    // eslint-disable-next-line es/no-object-getprototypeof -- safe

    var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
      O = toObject(O);
      if (has$1(O, IE_PROTO)) return O[IE_PROTO];

      if (typeof O.constructor == 'function' && O instanceof O.constructor) {
        return O.constructor.prototype;
      }

      return O instanceof Object ? ObjectPrototype : null;
    };
    var ITERATOR$5 = wellKnownSymbol('iterator');
    var BUGGY_SAFARI_ITERATORS$1 = false;

    var returnThis$2 = function () {
      return this;
    }; // `%IteratorPrototype%` object
    // https://tc39.es/ecma262/#sec-%iteratorprototype%-object


    var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;
    /* eslint-disable es/no-array-prototype-keys -- safe */

    if ([].keys) {
      arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

      if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;else {
        PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
      }
    }

    var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails(function () {
      var test = {}; // FF44- legacy iterators case

      return IteratorPrototype$2[ITERATOR$5].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

    if (!has$1(IteratorPrototype$2, ITERATOR$5)) {
      createNonEnumerableProperty(IteratorPrototype$2, ITERATOR$5, returnThis$2);
    }

    var iteratorsCore = {
      IteratorPrototype: IteratorPrototype$2,
      BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
    };
    var defineProperty$1 = objectDefineProperty.f;
    var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');

    var setToStringTag = function (it, TAG, STATIC) {
      if (it && !has$1(it = STATIC ? it : it.prototype, TO_STRING_TAG$3)) {
        defineProperty$1(it, TO_STRING_TAG$3, {
          configurable: true,
          value: TAG
        });
      }
    };

    var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;

    var returnThis$1 = function () {
      return this;
    };

    var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
      var TO_STRING_TAG = NAME + ' Iterator';
      IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
        next: createPropertyDescriptor(1, next)
      });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
      iterators[TO_STRING_TAG] = returnThis$1;
      return IteratorConstructor;
    };

    var IteratorPrototype = iteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = iteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR$4 = wellKnownSymbol('iterator');
    var KEYS = 'keys';
    var VALUES = 'values';
    var ENTRIES = 'entries';

    var returnThis = function () {
      return this;
    };

    var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);

      var getIterationMethod = function (KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];

        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };

          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };

          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }

        return function () {
          return new IteratorConstructor(this);
        };
      };

      var TO_STRING_TAG = NAME + ' Iterator';
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY; // fix native

      if (anyNativeIterator) {
        CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

        if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (objectSetPrototypeOf) {
              objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (typeof CurrentIteratorPrototype[ITERATOR$4] != 'function') {
              createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$4, returnThis);
            }
          } // Set @@toStringTag to native iterators


          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
        }
      } // fix Array#{values, @@iterator}.name in V8 / FF


      if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        INCORRECT_VALUES_NAME = true;

        defaultIterator = function values() {
          return nativeIterator.call(this);
        };
      } // define iterator


      if (IterablePrototype[ITERATOR$4] !== defaultIterator) {
        createNonEnumerableProperty(IterablePrototype, ITERATOR$4, defaultIterator);
      }

      iterators[NAME] = defaultIterator; // export additional methods

      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            redefine(IterablePrototype, KEY, methods[KEY]);
          }
        } else _export({
          target: NAME,
          proto: true,
          forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
        }, methods);
      }

      return methods;
    };

    var ARRAY_ITERATOR = 'Array Iterator';
    var setInternalState$2 = internalState.set;
    var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
    // https://tc39.es/ecma262/#sec-array.prototype.entries
    // `Array.prototype.keys` method
    // https://tc39.es/ecma262/#sec-array.prototype.keys
    // `Array.prototype.values` method
    // https://tc39.es/ecma262/#sec-array.prototype.values
    // `Array.prototype[@@iterator]` method
    // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
    // `CreateArrayIterator` internal method
    // https://tc39.es/ecma262/#sec-createarrayiterator

    var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
      setInternalState$2(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind: kind // kind

      }); // `%ArrayIteratorPrototype%.next` method
      // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
    }, function () {
      var state = getInternalState$1(this);
      var target = state.target;
      var kind = state.kind;
      var index = state.index++;

      if (!target || index >= target.length) {
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      }

      if (kind == 'keys') return {
        value: index,
        done: false
      };
      if (kind == 'values') return {
        value: target[index],
        done: false
      };
      return {
        value: [index, target[index]],
        done: false
      };
    }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
    // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
    // https://tc39.es/ecma262/#sec-createmappedargumentsobject

    iterators.Arguments = iterators.Array; // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

    addToUnscopables('keys');
    addToUnscopables('values');
    addToUnscopables('entries');
    var freezing = !fails(function () {
      // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
      return Object.isExtensible(Object.preventExtensions({}));
    });
    var internalMetadata = createCommonjsModule(function (module) {
      var defineProperty = objectDefineProperty.f;
      var METADATA = uid('meta');
      var id = 0; // eslint-disable-next-line es/no-object-isextensible -- safe

      var isExtensible = Object.isExtensible || function () {
        return true;
      };

      var setMetadata = function (it) {
        defineProperty(it, METADATA, {
          value: {
            objectID: 'O' + ++id,
            // object ID
            weakData: {} // weak collections IDs

          }
        });
      };

      var fastKey = function (it, create) {
        // return a primitive with prefix
        if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

        if (!has$1(it, METADATA)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) return 'F'; // not necessary to add metadata

          if (!create) return 'E'; // add missing metadata

          setMetadata(it); // return object ID
        }

        return it[METADATA].objectID;
      };

      var getWeakData = function (it, create) {
        if (!has$1(it, METADATA)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) return true; // not necessary to add metadata

          if (!create) return false; // add missing metadata

          setMetadata(it); // return the store of weak collections IDs
        }

        return it[METADATA].weakData;
      }; // add metadata on freeze-family methods calling


      var onFreeze = function (it) {
        if (freezing && meta.REQUIRED && isExtensible(it) && !has$1(it, METADATA)) setMetadata(it);
        return it;
      };

      var meta = module.exports = {
        REQUIRED: false,
        fastKey: fastKey,
        getWeakData: getWeakData,
        onFreeze: onFreeze
      };
      hiddenKeys$1[METADATA] = true;
    });
    var ITERATOR$3 = wellKnownSymbol('iterator');
    var ArrayPrototype = Array.prototype; // check on default Array iterator

    var isArrayIteratorMethod = function (it) {
      return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR$3] === it);
    };

    var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
    var test = {};
    test[TO_STRING_TAG$2] = 'z';
    var toStringTagSupport = String(test) === '[object z]';
    var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag'); // ES3 wrong here

    var CORRECT_ARGUMENTS = classofRaw(function () {
      return arguments;
    }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

    var tryGet = function (it, key) {
      try {
        return it[key];
      } catch (error) {
        /* empty */
      }
    }; // getting tag from ES6+ `Object.prototype.toString`


    var classof = toStringTagSupport ? classofRaw : function (it) {
      var O, tag, result;
      return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
      : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag // builtinTag case
      : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
      : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
    };
    var ITERATOR$2 = wellKnownSymbol('iterator');

    var getIteratorMethod = function (it) {
      if (it != undefined) return it[ITERATOR$2] || it['@@iterator'] || iterators[classof(it)];
    };

    var iteratorClose = function (iterator) {
      var returnMethod = iterator['return'];

      if (returnMethod !== undefined) {
        return anObject(returnMethod.call(iterator)).value;
      }
    };

    var Result = function (stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };

    var iterate = function (iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = functionBindContext(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
      var iterator, iterFn, index, length, result, next, step;

      var stop = function (condition) {
        if (iterator) iteratorClose(iterator);
        return new Result(true, condition);
      };

      var callFn = function (value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }

        return INTERRUPTED ? fn(value, stop) : fn(value);
      };

      if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = toLength(iterable.length); length > index; index++) {
            result = callFn(iterable[index]);
            if (result && result instanceof Result) return result;
          }

          return new Result(false);
        }

        iterator = iterFn.call(iterable);
      }

      next = iterator.next;

      while (!(step = next.call(iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator);
          throw error;
        }

        if (typeof result == 'object' && result && result instanceof Result) return result;
      }

      return new Result(false);
    };

    var anInstance = function (it, Constructor, name) {
      if (!(it instanceof Constructor)) {
        throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
      }

      return it;
    };

    var ITERATOR$1 = wellKnownSymbol('iterator');
    var SAFE_CLOSING = false;

    try {
      var called = 0;
      var iteratorWithReturn = {
        next: function () {
          return {
            done: !!called++
          };
        },
        'return': function () {
          SAFE_CLOSING = true;
        }
      };

      iteratorWithReturn[ITERATOR$1] = function () {
        return this;
      }; // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing


      Array.from(iteratorWithReturn, function () {
        throw 2;
      });
    } catch (error) {
      /* empty */
    }

    var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
      if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
      var ITERATION_SUPPORT = false;

      try {
        var object = {};

        object[ITERATOR$1] = function () {
          return {
            next: function () {
              return {
                done: ITERATION_SUPPORT = true
              };
            }
          };
        };

        exec(object);
      } catch (error) {
        /* empty */
      }

      return ITERATION_SUPPORT;
    };

    var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
      var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
      var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
      var ADDER = IS_MAP ? 'set' : 'add';
      var NativeConstructor = global$1[CONSTRUCTOR_NAME];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      var Constructor = NativeConstructor;
      var exported = {};

      var fixMethod = function (KEY) {
        var nativeMethod = NativePrototype[KEY];
        redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
          nativeMethod.call(this, value === 0 ? 0 : value);
          return this;
        } : KEY == 'delete' ? function (key) {
          return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
        } : KEY == 'get' ? function get(key) {
          return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
        } : KEY == 'has' ? function has(key) {
          return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
        } : function set(key, value) {
          nativeMethod.call(this, key === 0 ? 0 : key, value);
          return this;
        });
      };

      var REPLACE = isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
        new NativeConstructor().entries().next();
      })));

      if (REPLACE) {
        // create collection constructor
        Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        internalMetadata.REQUIRED = true;
      } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
        var instance = new Constructor(); // early implementations not supports chaining

        var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false

        var THROWS_ON_PRIMITIVES = fails(function () {
          instance.has(1);
        }); // most early implementations doesn't supports iterables, most modern - not close it correctly
        // eslint-disable-next-line no-new -- required for testing

        var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
          new NativeConstructor(iterable);
        }); // for early implementations -0 and +0 not the same

        var BUGGY_ZERO = !IS_WEAK && fails(function () {
          // V8 ~ Chromium 42- fails only with 5+ elements
          var $instance = new NativeConstructor();
          var index = 5;

          while (index--) $instance[ADDER](index, index);

          return !$instance.has(-0);
        });

        if (!ACCEPT_ITERABLES) {
          Constructor = wrapper(function (dummy, iterable) {
            anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
            var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
            if (iterable != undefined) iterate(iterable, that[ADDER], {
              that: that,
              AS_ENTRIES: IS_MAP
            });
            return that;
          });
          Constructor.prototype = NativePrototype;
          NativePrototype.constructor = Constructor;
        }

        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
          fixMethod('delete');
          fixMethod('has');
          IS_MAP && fixMethod('get');
        }

        if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

        if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
      }

      exported[CONSTRUCTOR_NAME] = Constructor;

      _export({
        global: true,
        forced: Constructor != NativeConstructor
      }, exported);

      setToStringTag(Constructor, CONSTRUCTOR_NAME);
      if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
      return Constructor;
    };

    var redefineAll = function (target, src, options) {
      for (var key in src) redefine(target, key, src[key], options);

      return target;
    };

    var defineProperty = objectDefineProperty.f;
    var fastKey = internalMetadata.fastKey;
    var setInternalState$1 = internalState.set;
    var internalStateGetterFor = internalState.getterFor;
    var collectionStrong = {
      getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var C = wrapper(function (that, iterable) {
          anInstance(that, C, CONSTRUCTOR_NAME);
          setInternalState$1(that, {
            type: CONSTRUCTOR_NAME,
            index: objectCreate(null),
            first: undefined,
            last: undefined,
            size: 0
          });
          if (!descriptors) that.size = 0;
          if (iterable != undefined) iterate(iterable, that[ADDER], {
            that: that,
            AS_ENTRIES: IS_MAP
          });
        });
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

        var define = function (that, key, value) {
          var state = getInternalState(that);
          var entry = getEntry(that, key);
          var previous, index; // change existing entry

          if (entry) {
            entry.value = value; // create new entry
          } else {
            state.last = entry = {
              index: index = fastKey(key, true),
              key: key,
              value: value,
              previous: previous = state.last,
              next: undefined,
              removed: false
            };
            if (!state.first) state.first = entry;
            if (previous) previous.next = entry;
            if (descriptors) state.size++;else that.size++; // add to index

            if (index !== 'F') state.index[index] = entry;
          }

          return that;
        };

        var getEntry = function (that, key) {
          var state = getInternalState(that); // fast case

          var index = fastKey(key);
          var entry;
          if (index !== 'F') return state.index[index]; // frozen object case

          for (entry = state.first; entry; entry = entry.next) {
            if (entry.key == key) return entry;
          }
        };

        redefineAll(C.prototype, {
          // 23.1.3.1 Map.prototype.clear()
          // 23.2.3.2 Set.prototype.clear()
          clear: function clear() {
            var that = this;
            var state = getInternalState(that);
            var data = state.index;
            var entry = state.first;

            while (entry) {
              entry.removed = true;
              if (entry.previous) entry.previous = entry.previous.next = undefined;
              delete data[entry.index];
              entry = entry.next;
            }

            state.first = state.last = undefined;
            if (descriptors) state.size = 0;else that.size = 0;
          },
          // 23.1.3.3 Map.prototype.delete(key)
          // 23.2.3.4 Set.prototype.delete(value)
          'delete': function (key) {
            var that = this;
            var state = getInternalState(that);
            var entry = getEntry(that, key);

            if (entry) {
              var next = entry.next;
              var prev = entry.previous;
              delete state.index[entry.index];
              entry.removed = true;
              if (prev) prev.next = next;
              if (next) next.previous = prev;
              if (state.first == entry) state.first = next;
              if (state.last == entry) state.last = prev;
              if (descriptors) state.size--;else that.size--;
            }

            return !!entry;
          },
          // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
          // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
          forEach: function forEach(callbackfn
          /* , that = undefined */
          ) {
            var state = getInternalState(this);
            var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
            var entry;

            while (entry = entry ? entry.next : state.first) {
              boundFunction(entry.value, entry.key, this); // revert to the last existing entry

              while (entry && entry.removed) entry = entry.previous;
            }
          },
          // 23.1.3.7 Map.prototype.has(key)
          // 23.2.3.7 Set.prototype.has(value)
          has: function has(key) {
            return !!getEntry(this, key);
          }
        });
        redefineAll(C.prototype, IS_MAP ? {
          // 23.1.3.6 Map.prototype.get(key)
          get: function get(key) {
            var entry = getEntry(this, key);
            return entry && entry.value;
          },
          // 23.1.3.9 Map.prototype.set(key, value)
          set: function set(key, value) {
            return define(this, key === 0 ? 0 : key, value);
          }
        } : {
          // 23.2.3.1 Set.prototype.add(value)
          add: function add(value) {
            return define(this, value = value === 0 ? 0 : value, value);
          }
        });
        if (descriptors) defineProperty(C.prototype, 'size', {
          get: function () {
            return getInternalState(this).size;
          }
        });
        return C;
      },
      setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
        var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
        var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); // add .keys, .values, .entries, [@@iterator]
        // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11

        defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
          setInternalState$1(this, {
            type: ITERATOR_NAME,
            target: iterated,
            state: getInternalCollectionState(iterated),
            kind: kind,
            last: undefined
          });
        }, function () {
          var state = getInternalIteratorState(this);
          var kind = state.kind;
          var entry = state.last; // revert to the last existing entry

          while (entry && entry.removed) entry = entry.previous; // get next entry


          if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
            // or finish the iteration
            state.target = undefined;
            return {
              value: undefined,
              done: true
            };
          } // return step by kind


          if (kind == 'keys') return {
            value: entry.key,
            done: false
          };
          if (kind == 'values') return {
            value: entry.value,
            done: false
          };
          return {
            value: [entry.key, entry.value],
            done: false
          };
        }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

        setSpecies(CONSTRUCTOR_NAME);
      }
    }; // `Map` constructor
    // https://tc39.es/ecma262/#sec-map-objects

    collection('Map', function (init) {
      return function Map() {
        return init(this, arguments.length ? arguments[0] : undefined);
      };
    }, collectionStrong); // `Object.prototype.toString` method implementation
    // https://tc39.es/ecma262/#sec-object.prototype.tostring

    var objectToString = toStringTagSupport ? {}.toString : function toString() {
      return '[object ' + classof(this) + ']';
    }; // `Object.prototype.toString` method
    // https://tc39.es/ecma262/#sec-object.prototype.tostring

    if (!toStringTagSupport) {
      redefine(Object.prototype, 'toString', objectToString, {
        unsafe: true
      });
    }

    var charAt = stringMultibyte.charAt;
    var STRING_ITERATOR = 'String Iterator';
    var setInternalState = internalState.set;
    var getInternalState = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
    // https://tc39.es/ecma262/#sec-string.prototype-@@iterator

    defineIterator(String, 'String', function (iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: String(iterated),
        index: 0
      }); // `%StringIteratorPrototype%.next` method
      // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
    }, function next() {
      var state = getInternalState(this);
      var string = state.string;
      var index = state.index;
      var point;
      if (index >= string.length) return {
        value: undefined,
        done: true
      };
      point = charAt(string, index);
      state.index += point.length;
      return {
        value: point,
        done: false
      };
    }); // iterable DOM collections
    // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods

    var domIterables = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
    var ITERATOR = wellKnownSymbol('iterator');
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var ArrayValues = es_array_iterator.values;

    for (var COLLECTION_NAME$1 in domIterables) {
      var Collection$1 = global$1[COLLECTION_NAME$1];
      var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;

      if (CollectionPrototype$1) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype$1[ITERATOR] !== ArrayValues) try {
          createNonEnumerableProperty(CollectionPrototype$1, ITERATOR, ArrayValues);
        } catch (error) {
          CollectionPrototype$1[ITERATOR] = ArrayValues;
        }

        if (!CollectionPrototype$1[TO_STRING_TAG]) {
          createNonEnumerableProperty(CollectionPrototype$1, TO_STRING_TAG, COLLECTION_NAME$1);
        }

        if (domIterables[COLLECTION_NAME$1]) for (var METHOD_NAME in es_array_iterator) {
          // some Chrome versions have non-configurable methods on DOMTokenList
          if (CollectionPrototype$1[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
            createNonEnumerableProperty(CollectionPrototype$1, METHOD_NAME, es_array_iterator[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype$1[METHOD_NAME] = es_array_iterator[METHOD_NAME];
          }
        }
      }
    }

    var $forEach = arrayIteration.forEach;
    var STRICT_METHOD = arrayMethodIsStrict('forEach'); // `Array.prototype.forEach` method implementation
    // https://tc39.es/ecma262/#sec-array.prototype.foreach

    var arrayForEach = !STRICT_METHOD ? function forEach(callbackfn
    /* , thisArg */
    ) {
      return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); // eslint-disable-next-line es/no-array-prototype-foreach -- safe
    } : [].forEach;

    for (var COLLECTION_NAME in domIterables) {
      var Collection = global$1[COLLECTION_NAME];
      var CollectionPrototype = Collection && Collection.prototype; // some Chrome versions have non-configurable methods on DOMTokenList

      if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
        createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
      } catch (error) {
        CollectionPrototype.forEach = arrayForEach;
      }
    }

    var packageJson = {
      name: "@nextcloud/event-bus",
      version: "1.3.0",
      description: "",
      main: "dist/index.js",
      module: "dist/index.es.js",
      types: "dist/index.d.ts",
      scripts: {
        build: "NODE_ENV=production rollup -c",
        "build:doc": "typedoc --out dist/doc lib/index.ts && touch dist/doc/.nojekyll",
        "check-types": "tsc",
        dev: "NODE_ENV=development rollup -c --watch",
        test: "jest",
        "test:watch": "jest --watchAll"
      },
      keywords: ["nextcloud"],
      homepage: "https://github.com/nextcloud/nextcloud-event-bus#readme",
      author: "Christoph Wurst",
      license: "GPL-3.0-or-later",
      repository: {
        type: "git",
        url: "https://github.com/nextcloud/nextcloud-event-bus"
      },
      dependencies: {
        "@types/semver": "^7.3.5",
        "core-js": "^3.11.2",
        semver: "^7.3.5"
      },
      devDependencies: {
        "@babel/cli": "^7.13.16",
        "@babel/core": "^7.14.0",
        "@babel/plugin-proposal-class-properties": "^7.13.0",
        "@babel/preset-env": "^7.14.1",
        "@babel/preset-typescript": "^7.13.0",
        "@nextcloud/browserslist-config": "^1.0.0",
        "@rollup/plugin-babel": "^5.3.0",
        "@rollup/plugin-commonjs": "^18.0.0",
        "@rollup/plugin-node-resolve": "^11.2.1",
        "babel-jest": "^26.6.3",
        "babel-plugin-inline-json-import": "^0.3.2",
        jest: "^26.6.3",
        rollup: "^2.47.0",
        "rollup-plugin-inject-process-env": "^1.3.1",
        "rollup-plugin-typescript2": "^0.30.0",
        typedoc: "^0.20.36",
        typescript: "^4.2.4"
      },
      browserslist: ["extends @nextcloud/browserslist-config"]
    };

    var SimpleBus =
    /** @class */
    function () {
      function SimpleBus() {
        this.handlers = new Map();
      }

      SimpleBus.prototype.getVersion = function () {
        return packageJson.version;
      };

      SimpleBus.prototype.subscribe = function (name, handler) {
        this.handlers.set(name, (this.handlers.get(name) || []).concat(handler));
      };

      SimpleBus.prototype.unsubscribe = function (name, handler) {
        this.handlers.set(name, (this.handlers.get(name) || []).filter(function (h) {
          return h != handler;
        }));
      };

      SimpleBus.prototype.emit = function (name, event) {
        (this.handlers.get(name) || []).forEach(function (h) {
          try {
            h(event);
          } catch (e) {
            console.error('could not invoke event listener', e);
          }
        });
      };

      return SimpleBus;
    }();

    function getBus() {
      if (typeof window.OC !== 'undefined' && window.OC._eventBus && typeof window._nc_event_bus === 'undefined') {
        console.warn('found old event bus instance at OC._eventBus. Update your version!');
        window._nc_event_bus = window.OC._eventBus;
      } // Either use an existing event bus instance or create one


      if (typeof window._nc_event_bus !== 'undefined') {
        return new ProxyBus(window._nc_event_bus);
      } else {
        return window._nc_event_bus = new SimpleBus();
      }
    }

    var bus = getBus();
    /**
     * Register an event listener
     *
     * @param name name of the event
     * @param handler callback invoked for every matching event emitted on the bus
     */

    function subscribe(name, handler) {
      bus.subscribe(name, handler);
    }
    /**
     * Unregister a previously registered event listener
     *
     * Note: doesn't work with anonymous functions (closures). Use method of an object or store listener function in variable.
     *
     * @param name name of the event
     * @param handler callback passed to `subscribed`
     */


    function unsubscribe(name, handler) {
      bus.unsubscribe(name, handler);
    }
    /**
     * Emit an event
     *
     * @param name name of the event
     * @param event event payload
     */


    function emit(name, event) {
      bus.emit(name, event);
    }

    var index_es = /*#__PURE__*/Object.freeze({
        __proto__: null,
        emit: emit,
        subscribe: subscribe,
        unsubscribe: unsubscribe
    });

    var requesttoken = createCommonjsModule$1(function (module, exports) {



    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getRequestToken = getRequestToken;
    exports.onRequestTokenUpdate = onRequestTokenUpdate;



    var tokenElement = document.getElementsByTagName('head')[0];
    var token = tokenElement ? tokenElement.getAttribute('data-requesttoken') : null;
    var observers = [];

    function getRequestToken() {
      return token;
    }

    function onRequestTokenUpdate(observer) {
      observers.push(observer);
    } // Listen to server event and keep token in sync


    (0, index_es.subscribe)('csrf-token-update', function (e) {
      token = e.token;
      observers.forEach(function (observer) {
        try {
          observer(e.token);
        } catch (e) {
          console.error('error updating CSRF token observer', e);
        }
      });
    });
    });

    unwrapExports(requesttoken);
    requesttoken.getRequestToken;
    requesttoken.onRequestTokenUpdate;

    var user = createCommonjsModule$1(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getCurrentUser = getCurrentUser; /// <reference types="@nextcloud/typings" />

    var uidElement = document.getElementsByTagName('head')[0];
    var uid = uidElement ? uidElement.getAttribute('data-user') : null;
    var displayNameElement = document.getElementsByTagName('head')[0];
    var displayName = displayNameElement ? displayNameElement.getAttribute('data-user-displayname') : null;
    var isAdmin = typeof OC === 'undefined' ? false : OC.isUserAdmin();

    function getCurrentUser() {
      if (uid === null) {
        return null;
      }

      return {
        uid: uid,
        displayName: displayName,
        isAdmin: isAdmin
      };
    }
    });

    unwrapExports(user);
    user.getCurrentUser;

    var dist = createCommonjsModule$1(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getRequestToken", {
      enumerable: true,
      get: function get() {
        return requesttoken.getRequestToken;
      }
    });
    Object.defineProperty(exports, "onRequestTokenUpdate", {
      enumerable: true,
      get: function get() {
        return requesttoken.onRequestTokenUpdate;
      }
    });
    Object.defineProperty(exports, "getCurrentUser", {
      enumerable: true,
      get: function get() {
        return user.getCurrentUser;
      }
    });
    });

    var auth = unwrapExports(dist);

    var token = auth.getRequestToken();
    var components = []; // let QuickAdd = QuickAddLegacy;
    // if (process.env.FEATURE_QUICK_ADD_NEXT) {
    // 	QuickAdd = QuickAddNext;
    // }

    $(document).ready(function () {
      if ($('input[name="duration"]').length > 0) {
        $('input[name="duration"]')[0].focus();
      }
    });

    var safelyCreateComponent = function safelyCreateComponent(_ref) {
      var Component = _ref.component,
          selector = _ref.selector,
          _ref$props = _ref.props,
          props = _ref$props === void 0 ? {} : _ref$props;
      var node = document.querySelector(selector);

      if (node) {
        return new Component({
          target: Helpers.replaceNode(node),
          props: props
        });
      }
    };

    var init = function init() {
      // Destroy all previous components
      while (components.length) {
        var component = components.pop();

        if (!component) {
          continue;
        }

        try {
          component.$destroy();
        } catch (error) {
          console.error(error);
        }
      }

      var store = {};
      var storeElement = document.querySelector("#content.app-timemanager [data-store]");

      if (storeElement) {
        try {
          store = JSON.parse(storeElement.getAttribute("data-store"));
        } catch (error) {
          console.error(error);
        }
      }

      components.push(safelyCreateComponent({
        component: Statistics,
        selector: "#content.app-timemanager [data-svelte='Statistics.svelte']",
        props: _objectSpread2({}, store)
      }));
      components.push(safelyCreateComponent({
        component: Filters,
        selector: "#content.app-timemanager [data-svelte='Filters.svelte']",
        props: _objectSpread2({}, store)
      }));
      components.push(safelyCreateComponent({
        component: Timerange,
        selector: "#content.app-timemanager [data-svelte='Timerange.svelte']",
        props: _objectSpread2({}, store)
      }));
      components.push(safelyCreateComponent({
        component: ClientEditorDialog,
        selector: "#content.app-timemanager [data-svelte='ClientEditorDialog.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          action: "",
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: ProjectEditorDialog,
        selector: "#content.app-timemanager [data-svelte='ProjectEditorDialog.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: TaskEditorDialog,
        selector: "#content.app-timemanager [data-svelte='TaskEditorDialog.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: TimeEditorDialog,
        selector: "#content.app-timemanager [data-svelte='TimeEditorDialog.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: DeleteButton,
        selector: "#content.app-timemanager [data-svelte='DeleteButton.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: ShareDialog,
        selector: "#content.app-timemanager [data-svelte='ShareDialog.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: ShareStatus,
        selector: "#content.app-timemanager [data-svelte='ShareStatus.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      var deleteTimeEntryButtons = document.querySelectorAll("#content.app-timemanager [data-svelte='DeleteTimeEntryButton.svelte']");

      if (deleteTimeEntryButtons && deleteTimeEntryButtons.length > 0) {
        deleteTimeEntryButtons.forEach(function (button) {
          components.push(new DeleteTimeEntryButton({
            target: Helpers.replaceNode(button),
            props: _objectSpread2(_objectSpread2({}, store), {}, {
              deleteTimeEntryUuid: button.getAttribute("data-uuid"),
              requestToken: token
            })
          }));
        });
      }

      var editTimeEntryButtons = document.querySelectorAll("#content.app-timemanager [data-svelte='EditTimeEntryButton.svelte']");

      if (editTimeEntryButtons && editTimeEntryButtons.length > 0) {
        editTimeEntryButtons.forEach(function (button) {
          components.push(new TimeEditorDialog({
            target: Helpers.replaceNode(button),
            props: _objectSpread2(_objectSpread2({}, store), {}, {
              timeUuid: button.getAttribute("data-uuid"),
              editTimeEntryData: JSON.parse(button.getAttribute("data-edit-data")),
              timeEditorButtonCaption: dist_10("timemanager", "Edit"),
              timeEditorCaption: dist_10("timemanager", "Edit time entry"),
              requestToken: token
            })
          }));
        });
      }

      components.push(safelyCreateComponent({
        component: QuickAdd,
        selector: "#content.app-timemanager [data-svelte='QuickAdd.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      var checkmarkButtons = document.querySelectorAll("#content.app-timemanager [data-svelte='Checkmark.svelte']");

      if (checkmarkButtons && checkmarkButtons.length > 0) {
        checkmarkButtons.forEach(function (button) {
          components.push(new Checkmark({
            target: Helpers.replaceNode(button),
            props: _objectSpread2(_objectSpread2({}, store), {}, {
              uuid: button.getAttribute("data-uuid"),
              action: button.getAttribute("data-action"),
              initialState: button.getAttribute("data-initialState"),
              requestToken: token
            })
          }));
        });
      }

      components.push(safelyCreateComponent({
        component: PrintButton,
        selector: "#content.app-timemanager [data-svelte='PrintButton.svelte']"
      }));
      components.push(safelyCreateComponent({
        component: Import,
        selector: "#content.app-timemanager [data-svelte='Import.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: UserFilterButton,
        selector: "#content.app-timemanager [data-svelte='UserFilterButton.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      })); // components.push(
      // 	new Settings({
      // 		target: Helpers.replaceNode(document.querySelector("#content.app-timemanager [data-svelte='Settings.svelte']")),
      // 		props: {
      // 			...store,
      // 			requestToken: token,
      // 		},
      // 	})
      // );

      document.body.classList.add("tm_ready");
    };

    init();
    new PagePjax(init);

})();
