(function () {
    'use strict';

    (function() {
        const env = {"NODE_ENV":"production"};
        try {
            if (process) {
                process.env = Object.assign({}, process.env);
                Object.assign(process.env, env);
                return;
            }
        } catch (e) {} // avoid ReferenceError: process is not defined
        globalThis.process = { env:env };
    })();

    function _iterableToArrayLimit(arr, i) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s,
          _e,
          _x,
          _r,
          _arr = [],
          _n = !0,
          _d = !1;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i) {
            if (Object(_i) !== _i) return;
            _n = !1;
          } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
    }
    function ownKeys$1(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
          _defineProperty$1(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _regeneratorRuntime() {
      _regeneratorRuntime = function () {
        return exports;
      };
      var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        defineProperty = Object.defineProperty || function (obj, key, desc) {
          obj[key] = desc.value;
        },
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value: value,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function (obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
          generator = Object.create(protoGenerator.prototype),
          context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self, context)
        }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg,
              value = result.value;
            return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function (unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function (error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
          value: function (method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function (resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self, context) {
        var state = "suspendedStart";
        return function (method, arg) {
          if ("executing" === state) throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method) throw arg;
            return doneResult();
          }
          for (context.method = method, context.arg = arg;;) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }
            if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
              if ("suspendedStart" === state) throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
              return {
                value: record.arg,
                done: context.done
              };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method,
          method = delegate.iterator[methodName];
        if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next) return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1,
              next = function next() {
                for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                return next.value = undefined, next.done = !0, next;
              };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: undefined,
          done: !0
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: !0
      }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: !0
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports.mark = function (genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports.awrap = function (arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
        return this;
      }), define(Gp, "toString", function () {
        return "[object Generator]";
      }), exports.keys = function (val) {
        var object = Object(val),
          keys = [];
        for (var key in object) keys.push(key);
        return keys.reverse(), function next() {
          for (; keys.length;) {
            var key = keys.pop();
            if (key in object) return next.value = key, next.done = !1, next;
          }
          return next.done = !0, next;
        };
      }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function (skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
        },
        stop: function () {
          this.done = !0;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type) throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function (exception) {
          if (this.done) throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i],
              record = entry.completion;
            if ("root" === entry.tryLoc) return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"),
                hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              } else {
                if (!hasFinally) throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function (type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function (record, afterLoc) {
          if ("throw" === record.type) throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function (finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        catch: function (tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function (iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
      }, exports;
    }
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
          args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(undefined);
        });
      };
    }
    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$1(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
      }
    }
    function _createClass$1(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$1(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _defineProperty$1(obj, key, value) {
      key = _toPropertyKey$1(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _inherits$1(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf$1(subClass, superClass);
    }
    function _getPrototypeOf$1(o) {
      _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$1(o);
    }
    function _setPrototypeOf$1(o, p) {
      _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf$1(o, p);
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _assertThisInitialized$1(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _possibleConstructorReturn$1(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized$1(self);
    }
    function _createSuper$1(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$1(Derived),
          result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$1(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn$1(this, result);
      };
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _unsupportedIterableToArray$1(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _createForOfIteratorHelper$1(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike) {
          if (it) o = it;
          var i = 0;
          var F = function () {};
          return {
            s: F,
            n: function () {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function (e) {
              throw e;
            },
            f: F
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true,
        didErr = false,
        err;
      return {
        s: function () {
          it = it.call(o);
        },
        n: function () {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function (e) {
          didErr = true;
          err = e;
        },
        f: function () {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }
    function _toPrimitive$1(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey$1(arg) {
      var key = _toPrimitive$1(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var check = function (it) {
      return it && it.Math == Math && it;
    };

    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
    var global_1 =
    // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) ||
    // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
    // eslint-disable-next-line no-new-func -- fallback
    function () {
      return this;
    }() || commonjsGlobal || Function('return this')();

    var fails = function (exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };

    // Detect IE8's incomplete defineProperty implementation
    var descriptors = !fails(function () {
      // eslint-disable-next-line es/no-object-defineproperty -- required for testing
      return Object.defineProperty({}, 1, {
        get: function () {
          return 7;
        }
      })[1] != 7;
    });

    var functionBindNative = !fails(function () {
      // eslint-disable-next-line es/no-function-prototype-bind -- safe
      var test = function () {/* empty */}.bind();
      // eslint-disable-next-line no-prototype-builtins -- safe
      return typeof test != 'function' || test.hasOwnProperty('prototype');
    });

    var call$2 = Function.prototype.call;
    var functionCall = functionBindNative ? call$2.bind(call$2) : function () {
      return call$2.apply(call$2, arguments);
    };

    var $propertyIsEnumerable$1 = {}.propertyIsEnumerable;
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    var getOwnPropertyDescriptor$4 = Object.getOwnPropertyDescriptor;

    // Nashorn ~ JDK8 bug
    var NASHORN_BUG = getOwnPropertyDescriptor$4 && !$propertyIsEnumerable$1.call({
      1: 2
    }, 1);

    // `Object.prototype.propertyIsEnumerable` method implementation
    // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
    var f$6 = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor$4(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable$1;

    var objectPropertyIsEnumerable = {
    	f: f$6
    };

    var createPropertyDescriptor = function (bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
      };
    };

    var FunctionPrototype$2 = Function.prototype;
    var call$1 = FunctionPrototype$2.call;
    var uncurryThisWithBind = functionBindNative && FunctionPrototype$2.bind.bind(call$1, call$1);
    var functionUncurryThis = functionBindNative ? uncurryThisWithBind : function (fn) {
      return function () {
        return call$1.apply(fn, arguments);
      };
    };

    var toString$3 = functionUncurryThis({}.toString);
    var stringSlice$4 = functionUncurryThis(''.slice);
    var classofRaw = function (it) {
      return stringSlice$4(toString$3(it), 8, -1);
    };

    var $Object$4 = Object;
    var split = functionUncurryThis(''.split);

    // fallback for non-array-like ES3 and non-enumerable old V8 strings
    var indexedObject = fails(function () {
      // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
      // eslint-disable-next-line no-prototype-builtins -- safe
      return !$Object$4('z').propertyIsEnumerable(0);
    }) ? function (it) {
      return classofRaw(it) == 'String' ? split(it, '') : $Object$4(it);
    } : $Object$4;

    // we can't use just `it == null` since of `document.all` special case
    // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
    var isNullOrUndefined = function (it) {
      return it === null || it === undefined;
    };

    var $TypeError$g = TypeError;

    // `RequireObjectCoercible` abstract operation
    // https://tc39.es/ecma262/#sec-requireobjectcoercible
    var requireObjectCoercible = function (it) {
      if (isNullOrUndefined(it)) throw $TypeError$g("Can't call method on " + it);
      return it;
    };

    // toObject with fallback for non-array-like ES3 strings


    var toIndexedObject = function (it) {
      return indexedObject(requireObjectCoercible(it));
    };

    var documentAll$2 = typeof document == 'object' && document.all;

    // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
    // eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
    var IS_HTMLDDA = typeof documentAll$2 == 'undefined' && documentAll$2 !== undefined;
    var documentAll_1 = {
      all: documentAll$2,
      IS_HTMLDDA: IS_HTMLDDA
    };

    var documentAll$1 = documentAll_1.all;

    // `IsCallable` abstract operation
    // https://tc39.es/ecma262/#sec-iscallable
    var isCallable = documentAll_1.IS_HTMLDDA ? function (argument) {
      return typeof argument == 'function' || argument === documentAll$1;
    } : function (argument) {
      return typeof argument == 'function';
    };

    var documentAll = documentAll_1.all;
    var isObject$2 = documentAll_1.IS_HTMLDDA ? function (it) {
      return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;
    } : function (it) {
      return typeof it == 'object' ? it !== null : isCallable(it);
    };

    var aFunction = function (argument) {
      return isCallable(argument) ? argument : undefined;
    };
    var getBuiltIn = function (namespace, method) {
      return arguments.length < 2 ? aFunction(global_1[namespace]) : global_1[namespace] && global_1[namespace][method];
    };

    var objectIsPrototypeOf = functionUncurryThis({}.isPrototypeOf);

    var engineUserAgent = typeof navigator != 'undefined' && String(navigator.userAgent) || '';

    var process$4 = global_1.process;
    var Deno$1 = global_1.Deno;
    var versions$1 = process$4 && process$4.versions || Deno$1 && Deno$1.version;
    var v8 = versions$1 && versions$1.v8;
    var match$4, version$1;
    if (v8) {
      match$4 = v8.split('.');
      // in old Chrome, versions of V8 isn't V8 = Chrome / 10
      // but their correct versions are not interesting for us
      version$1 = match$4[0] > 0 && match$4[0] < 4 ? 1 : +(match$4[0] + match$4[1]);
    }

    // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
    // so check `userAgent` even if `.v8` exists, but 0
    if (!version$1 && engineUserAgent) {
      match$4 = engineUserAgent.match(/Edge\/(\d+)/);
      if (!match$4 || match$4[1] >= 74) {
        match$4 = engineUserAgent.match(/Chrome\/(\d+)/);
        if (match$4) version$1 = +match$4[1];
      }
    }
    var engineV8Version = version$1;

    /* eslint-disable es/no-symbol -- required for testing */



    var $String$4 = global_1.String;

    // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
    var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails(function () {
      var symbol = Symbol();
      // Chrome 38 Symbol has incorrect toString conversion
      // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
      // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
      // of course, fail.
      return !$String$4(symbol) || !(Object(symbol) instanceof Symbol) ||
      // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && engineV8Version && engineV8Version < 41;
    });

    /* eslint-disable es/no-symbol -- required for testing */

    var useSymbolAsUid = symbolConstructorDetection && !Symbol.sham && typeof Symbol.iterator == 'symbol';

    var $Object$3 = Object;
    var isSymbol = useSymbolAsUid ? function (it) {
      return typeof it == 'symbol';
    } : function (it) {
      var $Symbol = getBuiltIn('Symbol');
      return isCallable($Symbol) && objectIsPrototypeOf($Symbol.prototype, $Object$3(it));
    };

    var $String$3 = String;
    var tryToString = function (argument) {
      try {
        return $String$3(argument);
      } catch (error) {
        return 'Object';
      }
    };

    var $TypeError$f = TypeError;

    // `Assert: IsCallable(argument) is true`
    var aCallable = function (argument) {
      if (isCallable(argument)) return argument;
      throw $TypeError$f(tryToString(argument) + ' is not a function');
    };

    // `GetMethod` abstract operation
    // https://tc39.es/ecma262/#sec-getmethod
    var getMethod = function (V, P) {
      var func = V[P];
      return isNullOrUndefined(func) ? undefined : aCallable(func);
    };

    var $TypeError$e = TypeError;

    // `OrdinaryToPrimitive` abstract operation
    // https://tc39.es/ecma262/#sec-ordinarytoprimitive
    var ordinaryToPrimitive = function (input, pref) {
      var fn, val;
      if (isCallable(fn = input.toString) && !isObject$2(val = functionCall(fn, input))) return val;
      if (isCallable(fn = input.valueOf) && !isObject$2(val = functionCall(fn, input))) return val;
      throw $TypeError$e("Can't convert object to primitive value");
    };

    // eslint-disable-next-line es/no-object-defineproperty -- safe
    var defineProperty$3 = Object.defineProperty;
    var defineGlobalProperty = function (key, value) {
      try {
        defineProperty$3(global_1, key, {
          value: value,
          configurable: true,
          writable: true
        });
      } catch (error) {
        global_1[key] = value;
      }
      return value;
    };

    var SHARED = '__core-js_shared__';
    var store$1 = global_1[SHARED] || defineGlobalProperty(SHARED, {});
    var sharedStore = store$1;

    var shared = createCommonjsModule(function (module) {
    (module.exports = function (key, value) {
      return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
    })('versions', []).push({
      version: '3.31.0',
      mode: 'global',
      copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',
      license: 'https://github.com/zloirock/core-js/blob/v3.31.0/LICENSE',
      source: 'https://github.com/zloirock/core-js'
    });
    });

    var $Object$2 = Object;

    // `ToObject` abstract operation
    // https://tc39.es/ecma262/#sec-toobject
    var toObject = function (argument) {
      return $Object$2(requireObjectCoercible(argument));
    };

    var hasOwnProperty$1 = functionUncurryThis({}.hasOwnProperty);

    // `HasOwnProperty` abstract operation
    // https://tc39.es/ecma262/#sec-hasownproperty
    // eslint-disable-next-line es/no-object-hasown -- safe
    var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty$1(toObject(it), key);
    };

    var id = 0;
    var postfix = Math.random();
    var toString$2 = functionUncurryThis(1.0.toString);
    var uid = function (key) {
      return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$2(++id + postfix, 36);
    };

    var Symbol$2 = global_1.Symbol;
    var WellKnownSymbolsStore = shared('wks');
    var createWellKnownSymbol = useSymbolAsUid ? Symbol$2['for'] || Symbol$2 : Symbol$2 && Symbol$2.withoutSetter || uid;
    var wellKnownSymbol = function (name) {
      if (!hasOwnProperty_1(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = symbolConstructorDetection && hasOwnProperty_1(Symbol$2, name) ? Symbol$2[name] : createWellKnownSymbol('Symbol.' + name);
      }
      return WellKnownSymbolsStore[name];
    };

    var $TypeError$d = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

    // `ToPrimitive` abstract operation
    // https://tc39.es/ecma262/#sec-toprimitive
    var toPrimitive = function (input, pref) {
      if (!isObject$2(input) || isSymbol(input)) return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        result = functionCall(exoticToPrim, input, pref);
        if (!isObject$2(result) || isSymbol(result)) return result;
        throw $TypeError$d("Can't convert object to primitive value");
      }
      return ordinaryToPrimitive(input);
    };

    // `ToPropertyKey` abstract operation
    // https://tc39.es/ecma262/#sec-topropertykey
    var toPropertyKey = function (argument) {
      var key = toPrimitive(argument, 'string');
      return isSymbol(key) ? key : key + '';
    };

    var document$3 = global_1.document;
    // typeof document.createElement is 'object' in old IE
    var EXISTS$1 = isObject$2(document$3) && isObject$2(document$3.createElement);
    var documentCreateElement = function (it) {
      return EXISTS$1 ? document$3.createElement(it) : {};
    };

    // Thanks to IE8 for its funny defineProperty
    var ie8DomDefine = !descriptors && !fails(function () {
      // eslint-disable-next-line es/no-object-defineproperty -- required for testing
      return Object.defineProperty(documentCreateElement('div'), 'a', {
        get: function () {
          return 7;
        }
      }).a != 7;
    });

    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
    var f$5 = descriptors ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey(P);
      if (ie8DomDefine) try {
        return $getOwnPropertyDescriptor$1(O, P);
      } catch (error) {/* empty */}
      if (hasOwnProperty_1(O, P)) return createPropertyDescriptor(!functionCall(objectPropertyIsEnumerable.f, O, P), O[P]);
    };

    var objectGetOwnPropertyDescriptor = {
    	f: f$5
    };

    // V8 ~ Chrome 36-
    // https://bugs.chromium.org/p/v8/issues/detail?id=3334
    var v8PrototypeDefineBug = descriptors && fails(function () {
      // eslint-disable-next-line es/no-object-defineproperty -- required for testing
      return Object.defineProperty(function () {/* empty */}, 'prototype', {
        value: 42,
        writable: false
      }).prototype != 42;
    });

    var $String$2 = String;
    var $TypeError$c = TypeError;

    // `Assert: Type(argument) is Object`
    var anObject = function (argument) {
      if (isObject$2(argument)) return argument;
      throw $TypeError$c($String$2(argument) + ' is not an object');
    };

    var $TypeError$b = TypeError;
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    var $defineProperty = Object.defineProperty;
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = 'enumerable';
    var CONFIGURABLE$1 = 'configurable';
    var WRITABLE = 'writable';

    // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty
    var f$4 = descriptors ? v8PrototypeDefineBug ? function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (ie8DomDefine) try {
        return $defineProperty(O, P, Attributes);
      } catch (error) {/* empty */}
      if ('get' in Attributes || 'set' in Attributes) throw $TypeError$b('Accessors not supported');
      if ('value' in Attributes) O[P] = Attributes.value;
      return O;
    };

    var objectDefineProperty = {
    	f: f$4
    };

    var createNonEnumerableProperty = descriptors ? function (object, key, value) {
      return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
    } : function (object, key, value) {
      object[key] = value;
      return object;
    };

    var FunctionPrototype$1 = Function.prototype;
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    var getDescriptor = descriptors && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwnProperty_1(FunctionPrototype$1, 'name');
    // additional protection from minified / mangled / dropped function names
    var PROPER = EXISTS && function something() {/* empty */}.name === 'something';
    var CONFIGURABLE = EXISTS && (!descriptors || descriptors && getDescriptor(FunctionPrototype$1, 'name').configurable);
    var functionName = {
      EXISTS: EXISTS,
      PROPER: PROPER,
      CONFIGURABLE: CONFIGURABLE
    };

    var functionToString = functionUncurryThis(Function.toString);

    // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
    if (!isCallable(sharedStore.inspectSource)) {
      sharedStore.inspectSource = function (it) {
        return functionToString(it);
      };
    }
    var inspectSource = sharedStore.inspectSource;

    var WeakMap$1 = global_1.WeakMap;
    var weakMapBasicDetection = isCallable(WeakMap$1) && /native code/.test(String(WeakMap$1));

    var keys$1 = shared('keys');
    var sharedKey = function (key) {
      return keys$1[key] || (keys$1[key] = uid(key));
    };

    var hiddenKeys$1 = {};

    var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
    var TypeError$2 = global_1.TypeError;
    var WeakMap = global_1.WeakMap;
    var set$1, get$1, has;
    var enforce = function (it) {
      return has(it) ? get$1(it) : set$1(it, {});
    };
    var getterFor = function (TYPE) {
      return function (it) {
        var state;
        if (!isObject$2(it) || (state = get$1(it)).type !== TYPE) {
          throw TypeError$2('Incompatible receiver, ' + TYPE + ' required');
        }
        return state;
      };
    };
    if (weakMapBasicDetection || sharedStore.state) {
      var store = sharedStore.state || (sharedStore.state = new WeakMap());
      /* eslint-disable no-self-assign -- prototype methods protection */
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      /* eslint-enable no-self-assign -- prototype methods protection */
      set$1 = function (it, metadata) {
        if (store.has(it)) throw TypeError$2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get$1 = function (it) {
        return store.get(it) || {};
      };
      has = function (it) {
        return store.has(it);
      };
    } else {
      var STATE = sharedKey('state');
      hiddenKeys$1[STATE] = true;
      set$1 = function (it, metadata) {
        if (hasOwnProperty_1(it, STATE)) throw TypeError$2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get$1 = function (it) {
        return hasOwnProperty_1(it, STATE) ? it[STATE] : {};
      };
      has = function (it) {
        return hasOwnProperty_1(it, STATE);
      };
    }
    var internalState = {
      set: set$1,
      get: get$1,
      has: has,
      enforce: enforce,
      getterFor: getterFor
    };

    var makeBuiltIn_1 = createCommonjsModule(function (module) {
    var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;


    var enforceInternalState = internalState.enforce;
    var getInternalState = internalState.get;
    var $String = String;
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    var defineProperty = Object.defineProperty;
    var stringSlice = functionUncurryThis(''.slice);
    var replace = functionUncurryThis(''.replace);
    var join = functionUncurryThis([].join);
    var CONFIGURABLE_LENGTH = descriptors && !fails(function () {
      return defineProperty(function () {/* empty */}, 'length', {
        value: 8
      }).length !== 8;
    });
    var TEMPLATE = String(String).split('String');
    var makeBuiltIn = module.exports = function (value, name, options) {
      if (stringSlice($String(name), 0, 7) === 'Symbol(') {
        name = '[' + replace($String(name), /^Symbol\(([^)]*)\)/, '$1') + ']';
      }
      if (options && options.getter) name = 'get ' + name;
      if (options && options.setter) name = 'set ' + name;
      if (!hasOwnProperty_1(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (descriptors) defineProperty(value, 'name', {
          value: name,
          configurable: true
        });else value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwnProperty_1(options, 'arity') && value.length !== options.arity) {
        defineProperty(value, 'length', {
          value: options.arity
        });
      }
      try {
        if (options && hasOwnProperty_1(options, 'constructor') && options.constructor) {
          if (descriptors) defineProperty(value, 'prototype', {
            writable: false
          });
          // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
        } else if (value.prototype) value.prototype = undefined;
      } catch (error) {/* empty */}
      var state = enforceInternalState(value);
      if (!hasOwnProperty_1(state, 'source')) {
        state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
      }
      return value;
    };

    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
    // eslint-disable-next-line no-extend-native -- required
    Function.prototype.toString = makeBuiltIn(function toString() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, 'toString');
    });

    var defineBuiltIn = function (O, key, value, options) {
      if (!options) options = {};
      var simple = options.enumerable;
      var name = options.name !== undefined ? options.name : key;
      if (isCallable(value)) makeBuiltIn_1(value, name, options);
      if (options.global) {
        if (simple) O[key] = value;else defineGlobalProperty(key, value);
      } else {
        try {
          if (!options.unsafe) delete O[key];else if (O[key]) simple = true;
        } catch (error) {/* empty */}
        if (simple) O[key] = value;else objectDefineProperty.f(O, key, {
          value: value,
          enumerable: false,
          configurable: !options.nonConfigurable,
          writable: !options.nonWritable
        });
      }
      return O;
    };

    var ceil = Math.ceil;
    var floor$2 = Math.floor;

    // `Math.trunc` method
    // https://tc39.es/ecma262/#sec-math.trunc
    // eslint-disable-next-line es/no-math-trunc -- safe
    var mathTrunc = Math.trunc || function trunc(x) {
      var n = +x;
      return (n > 0 ? floor$2 : ceil)(n);
    };

    // `ToIntegerOrInfinity` abstract operation
    // https://tc39.es/ecma262/#sec-tointegerorinfinity
    var toIntegerOrInfinity = function (argument) {
      var number = +argument;
      // eslint-disable-next-line no-self-compare -- NaN check
      return number !== number || number === 0 ? 0 : mathTrunc(number);
    };

    var max$4 = Math.max;
    var min$4 = Math.min;

    // Helper for a popular repeating case of the spec:
    // Let integer be ? ToInteger(index).
    // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
    var toAbsoluteIndex = function (index, length) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max$4(integer + length, 0) : min$4(integer, length);
    };

    var min$3 = Math.min;

    // `ToLength` abstract operation
    // https://tc39.es/ecma262/#sec-tolength
    var toLength = function (argument) {
      return argument > 0 ? min$3(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
    };

    // `LengthOfArrayLike` abstract operation
    // https://tc39.es/ecma262/#sec-lengthofarraylike
    var lengthOfArrayLike = function (obj) {
      return toLength(obj.length);
    };

    // `Array.prototype.{ indexOf, includes }` methods implementation
    var createMethod$4 = function (IS_INCLUDES) {
      return function ($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare -- NaN check
        if (IS_INCLUDES && el != el) while (length > index) {
          value = O[index++];
          // eslint-disable-next-line no-self-compare -- NaN check
          if (value != value) return true;
          // Array#indexOf ignores holes, Array#includes - not
        } else for (; length > index; index++) {
          if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    var arrayIncludes = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod$4(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod$4(false)
    };

    var indexOf$2 = arrayIncludes.indexOf;

    var push$4 = functionUncurryThis([].push);
    var objectKeysInternal = function (object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O) !hasOwnProperty_1(hiddenKeys$1, key) && hasOwnProperty_1(O, key) && push$4(result, key);
      // Don't enum bug & hidden keys
      while (names.length > i) if (hasOwnProperty_1(O, key = names[i++])) {
        ~indexOf$2(result, key) || push$4(result, key);
      }
      return result;
    };

    // IE8- don't enum bug keys
    var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

    var hiddenKeys = enumBugKeys.concat('length', 'prototype');

    // `Object.getOwnPropertyNames` method
    // https://tc39.es/ecma262/#sec-object.getownpropertynames
    // eslint-disable-next-line es/no-object-getownpropertynames -- safe
    var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return objectKeysInternal(O, hiddenKeys);
    };

    var objectGetOwnPropertyNames = {
    	f: f$3
    };

    // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
    var f$2 = Object.getOwnPropertySymbols;

    var objectGetOwnPropertySymbols = {
    	f: f$2
    };

    var concat$1 = functionUncurryThis([].concat);

    // all object keys, includes non-enumerable and symbols
    var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
      var keys = objectGetOwnPropertyNames.f(anObject(it));
      var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
      return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;
    };

    var copyConstructorProperties = function (target, source, exceptions) {
      var keys = ownKeys(source);
      var defineProperty = objectDefineProperty.f;
      var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!hasOwnProperty_1(target, key) && !(exceptions)) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };

    var replacement = /#|\.prototype\./;
    var isForced = function (feature, detection) {
      var value = data[normalize(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function (string) {
      return String(string).replace(replacement, '.').toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = 'N';
    var POLYFILL = isForced.POLYFILL = 'P';
    var isForced_1 = isForced;

    var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;






    /*
      options.target         - name of the target object
      options.global         - target is the global object
      options.stat           - export as static methods of target
      options.proto          - export as prototype methods of target
      options.real           - real prototype method for the `pure` version
      options.forced         - export even if the native feature is available
      options.bind           - bind methods to the target, required for the `pure` version
      options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
      options.unsafe         - use the simple assignment of property instead of delete + defineProperty
      options.sham           - add a flag to not completely full polyfills
      options.enumerable     - export as enumerable property
      options.dontCallGetSet - prevent calling a getter on target
      options.name           - the .name of the function if it does not match the key
    */
    var _export = function (options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global_1;
      } else if (STATIC) {
        target = global_1[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = (global_1[TARGET] || {}).prototype;
      }
      if (target) for (key in source) {
        sourceProperty = source[key];
        if (options.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor$3(target, key);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];
        FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
        // contained in target
        if (!FORCED && targetProperty !== undefined) {
          if (typeof sourceProperty == typeof targetProperty) continue;
          copyConstructorProperties(sourceProperty, targetProperty);
        }
        // add a flag to not completely full polyfills
        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(sourceProperty, 'sham', true);
        }
        defineBuiltIn(target, key, sourceProperty, options);
      }
    };

    // `Object.keys` method
    // https://tc39.es/ecma262/#sec-object.keys
    // eslint-disable-next-line es/no-object-keys -- safe
    var objectKeys = Object.keys || function keys(O) {
      return objectKeysInternal(O, enumBugKeys);
    };

    var FAILS_ON_PRIMITIVES = fails(function () {
      objectKeys(1);
    });

    // `Object.keys` method
    // https://tc39.es/ecma262/#sec-object.keys
    _export({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES
    }, {
      keys: function keys(it) {
        return objectKeys(toObject(it));
      }
    });

    var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
    var test$1 = {};
    test$1[TO_STRING_TAG$3] = 'z';
    var toStringTagSupport = String(test$1) === '[object z]';

    var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
    var $Object$1 = Object;

    // ES3 wrong here
    var CORRECT_ARGUMENTS = classofRaw(function () {
      return arguments;
    }()) == 'Arguments';

    // fallback for IE11 Script Access Denied error
    var tryGet = function (it, key) {
      try {
        return it[key];
      } catch (error) {/* empty */}
    };

    // getting tag from ES6+ `Object.prototype.toString`
    var classof = toStringTagSupport ? classofRaw : function (it) {
      var O, tag, result;
      return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$2)) == 'string' ? tag
      // builtinTag case
      : CORRECT_ARGUMENTS ? classofRaw(O)
      // ES3 arguments fallback
      : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
    };

    // `Object.prototype.toString` method implementation
    // https://tc39.es/ecma262/#sec-object.prototype.tostring
    var objectToString$1 = toStringTagSupport ? {}.toString : function toString() {
      return '[object ' + classof(this) + ']';
    };

    // `Object.prototype.toString` method
    // https://tc39.es/ecma262/#sec-object.prototype.tostring
    if (!toStringTagSupport) {
      defineBuiltIn(Object.prototype, 'toString', objectToString$1, {
        unsafe: true
      });
    }

    // iterable DOM collections
    // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
    var domIterables = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };

    // in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`

    var classList = documentCreateElement('span').classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
    var domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;

    var functionUncurryThisClause = function (fn) {
      // Nashorn bug:
      //   https://github.com/zloirock/core-js/issues/1128
      //   https://github.com/zloirock/core-js/issues/1130
      if (classofRaw(fn) === 'Function') return functionUncurryThis(fn);
    };

    var bind$2 = functionUncurryThisClause(functionUncurryThisClause.bind);

    // optional / simple context binding
    var functionBindContext = function (fn, that) {
      aCallable(fn);
      return that === undefined ? fn : functionBindNative ? bind$2(fn, that) : function /* ...args */
      () {
        return fn.apply(that, arguments);
      };
    };

    // `IsArray` abstract operation
    // https://tc39.es/ecma262/#sec-isarray
    // eslint-disable-next-line es/no-array-isarray -- safe
    var isArray$3 = Array.isArray || function isArray(argument) {
      return classofRaw(argument) == 'Array';
    };

    var noop$3 = function () {/* empty */};
    var empty$1 = [];
    var construct$1 = getBuiltIn('Reflect', 'construct');
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = functionUncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$3);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument)) return false;
      try {
        construct$1(noop$3, empty$1, argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument)) return false;
      switch (classof(argument)) {
        case 'AsyncFunction':
        case 'GeneratorFunction':
        case 'AsyncGeneratorFunction':
          return false;
      }
      try {
        // we can't check .prototype since constructors produced by .bind haven't it
        // `Function#toString` throws on some built-it function in some legacy engines
        // (for example, `DOMQuad` and similar in FF41-)
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;

    // `IsConstructor` abstract operation
    // https://tc39.es/ecma262/#sec-isconstructor
    var isConstructor = !construct$1 || fails(function () {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;

    var SPECIES$6 = wellKnownSymbol('species');
    var $Array$3 = Array;

    // a part of `ArraySpeciesCreate` abstract operation
    // https://tc39.es/ecma262/#sec-arrayspeciescreate
    var arraySpeciesConstructor = function (originalArray) {
      var C;
      if (isArray$3(originalArray)) {
        C = originalArray.constructor;
        // cross-realm fallback
        if (isConstructor(C) && (C === $Array$3 || isArray$3(C.prototype))) C = undefined;else if (isObject$2(C)) {
          C = C[SPECIES$6];
          if (C === null) C = undefined;
        }
      }
      return C === undefined ? $Array$3 : C;
    };

    // `ArraySpeciesCreate` abstract operation
    // https://tc39.es/ecma262/#sec-arrayspeciescreate
    var arraySpeciesCreate = function (originalArray, length) {
      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };

    var push$3 = functionUncurryThis([].push);

    // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
    var createMethod$3 = function (TYPE) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var IS_FILTER_REJECT = TYPE == 7;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      return function ($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self = indexedObject(O);
        var boundFunction = functionBindContext(callbackfn, that);
        var length = lengthOfArrayLike(self);
        var index = 0;
        var create = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
        var value, result;
        for (; length > index; index++) if (NO_HOLES || index in self) {
          value = self[index];
          result = boundFunction(value, index, O);
          if (TYPE) {
            if (IS_MAP) target[index] = result; // map
            else if (result) switch (TYPE) {
              case 3:
                return true;
              // some
              case 5:
                return value;
              // find
              case 6:
                return index;
              // findIndex
              case 2:
                push$3(target, value);
              // filter
            } else switch (TYPE) {
              case 4:
                return false;
              // every
              case 7:
                push$3(target, value);
              // filterReject
            }
          }
        }

        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    var arrayIteration = {
      // `Array.prototype.forEach` method
      // https://tc39.es/ecma262/#sec-array.prototype.foreach
      forEach: createMethod$3(0),
      // `Array.prototype.map` method
      // https://tc39.es/ecma262/#sec-array.prototype.map
      map: createMethod$3(1),
      // `Array.prototype.filter` method
      // https://tc39.es/ecma262/#sec-array.prototype.filter
      filter: createMethod$3(2),
      // `Array.prototype.some` method
      // https://tc39.es/ecma262/#sec-array.prototype.some
      some: createMethod$3(3),
      // `Array.prototype.every` method
      // https://tc39.es/ecma262/#sec-array.prototype.every
      every: createMethod$3(4),
      // `Array.prototype.find` method
      // https://tc39.es/ecma262/#sec-array.prototype.find
      find: createMethod$3(5),
      // `Array.prototype.findIndex` method
      // https://tc39.es/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod$3(6),
      // `Array.prototype.filterReject` method
      // https://github.com/tc39/proposal-array-filtering
      filterReject: createMethod$3(7)
    };

    var arrayMethodIsStrict = function (METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function () {
        // eslint-disable-next-line no-useless-call -- required for testing
        method.call(null, argument || function () {
          return 1;
        }, 1);
      });
    };

    var $forEach = arrayIteration.forEach;

    var STRICT_METHOD$1 = arrayMethodIsStrict('forEach');

    // `Array.prototype.forEach` method implementation
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    var arrayForEach$1 = !STRICT_METHOD$1 ? function forEach(callbackfn /* , thisArg */) {
      return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      // eslint-disable-next-line es/no-array-prototype-foreach -- safe
    } : [].forEach;

    var handlePrototype$1 = function (CollectionPrototype) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach$1) try {
        createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach$1);
      } catch (error) {
        CollectionPrototype.forEach = arrayForEach$1;
      }
    };
    for (var COLLECTION_NAME$1 in domIterables) {
      if (domIterables[COLLECTION_NAME$1]) {
        handlePrototype$1(global_1[COLLECTION_NAME$1] && global_1[COLLECTION_NAME$1].prototype);
      }
    }
    handlePrototype$1(domTokenListPrototype);

    // `Object.defineProperties` method
    // https://tc39.es/ecma262/#sec-object.defineproperties
    // eslint-disable-next-line es/no-object-defineproperties -- safe
    var f$1 = descriptors && !v8PrototypeDefineBug ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var props = toIndexedObject(Properties);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var index = 0;
      var key;
      while (length > index) objectDefineProperty.f(O, key = keys[index++], props[key]);
      return O;
    };

    var objectDefineProperties = {
    	f: f$1
    };

    var html$2 = getBuiltIn('document', 'documentElement');

    /* global ActiveXObject -- old IE, WSH */







    var GT = '>';
    var LT = '<';
    var PROTOTYPE = 'prototype';
    var SCRIPT = 'script';
    var IE_PROTO$1 = sharedKey('IE_PROTO');
    var EmptyConstructor = function () {/* empty */};
    var scriptTag = function (content) {
      return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
    };

    // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
    var NullProtoObjectViaActiveX = function (activeXDocument) {
      activeXDocument.write(scriptTag(''));
      activeXDocument.close();
      var temp = activeXDocument.parentWindow.Object;
      activeXDocument = null; // avoid memory leak
      return temp;
    };

    // Create object with fake `null` prototype: use iframe Object with cleared prototype
    var NullProtoObjectViaIFrame = function () {
      // Thrash, waste and sodomy: IE GC bug
      var iframe = documentCreateElement('iframe');
      var JS = 'java' + SCRIPT + ':';
      var iframeDocument;
      iframe.style.display = 'none';
      html$2.appendChild(iframe);
      // https://github.com/zloirock/core-js/issues/475
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag('document.F=Object'));
      iframeDocument.close();
      return iframeDocument.F;
    };

    // Check for document.domain and active x support
    // No need to use active x approach when document.domain is not set
    // see https://github.com/es-shims/es5-shim/issues/150
    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
    // avoid IE GC bug
    var activeXDocument;
    var NullProtoObject = function () {
      try {
        activeXDocument = new ActiveXObject('htmlfile');
      } catch (error) {/* ignore */}
      NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument); // WSH
      var length = enumBugKeys.length;
      while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys$1[IE_PROTO$1] = true;

    // `Object.create` method
    // https://tc39.es/ecma262/#sec-object.create
    // eslint-disable-next-line es/no-object-create -- safe
    var objectCreate = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        // add "__proto__" for Object.getPrototypeOf polyfill
        result[IE_PROTO$1] = O;
      } else result = NullProtoObject();
      return Properties === undefined ? result : objectDefineProperties.f(result, Properties);
    };

    var defineProperty$2 = objectDefineProperty.f;
    var UNSCOPABLES = wellKnownSymbol('unscopables');
    var ArrayPrototype$1 = Array.prototype;

    // Array.prototype[@@unscopables]
    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
    if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
      defineProperty$2(ArrayPrototype$1, UNSCOPABLES, {
        configurable: true,
        value: objectCreate(null)
      });
    }

    // add a key to Array.prototype[@@unscopables]
    var addToUnscopables = function (key) {
      ArrayPrototype$1[UNSCOPABLES][key] = true;
    };

    var $includes = arrayIncludes.includes;



    // FF99+ bug
    var BROKEN_ON_SPARSE = fails(function () {
      // eslint-disable-next-line es/no-array-prototype-includes -- detection
      return !Array(1).includes();
    });

    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    _export({
      target: 'Array',
      proto: true,
      forced: BROKEN_ON_SPARSE
    }, {
      includes: function includes(el /* , fromIndex = 0 */) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
      }
    });

    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
    addToUnscopables('includes');

    var MATCH$1 = wellKnownSymbol('match');

    // `IsRegExp` abstract operation
    // https://tc39.es/ecma262/#sec-isregexp
    var isRegexp = function (it) {
      var isRegExp;
      return isObject$2(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
    };

    var $TypeError$a = TypeError;
    var notARegexp = function (it) {
      if (isRegexp(it)) {
        throw $TypeError$a("The method doesn't accept regular expressions");
      }
      return it;
    };

    var $String$1 = String;
    var toString_1 = function (argument) {
      if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
      return $String$1(argument);
    };

    var MATCH = wellKnownSymbol('match');
    var correctIsRegexpLogic = function (METHOD_NAME) {
      var regexp = /./;
      try {
        '/./'[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH] = false;
          return '/./'[METHOD_NAME](regexp);
        } catch (error2) {/* empty */}
      }
      return false;
    };

    var stringIndexOf$2 = functionUncurryThis(''.indexOf);

    // `String.prototype.includes` method
    // https://tc39.es/ecma262/#sec-string.prototype.includes
    _export({
      target: 'String',
      proto: true,
      forced: !correctIsRegexpLogic('includes')
    }, {
      includes: function includes(searchString /* , position = 0 */) {
        return !!~stringIndexOf$2(toString_1(requireObjectCoercible(this)), toString_1(notARegexp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
      }
    });

    var createProperty = function (object, key, value) {
      var propertyKey = toPropertyKey(key);
      if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
    };

    var SPECIES$5 = wellKnownSymbol('species');
    var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
      // We can't use this feature detection in V8 since it causes
      // deoptimization and serious performance degradation
      // https://github.com/zloirock/core-js/issues/677
      return engineV8Version >= 51 || !fails(function () {
        var array = [];
        var constructor = array.constructor = {};
        constructor[SPECIES$5] = function () {
          return {
            foo: 1
          };
        };
        return array[METHOD_NAME](Boolean).foo !== 1;
      });
    };

    var arraySlice = functionUncurryThis([].slice);

    var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('slice');
    var SPECIES$4 = wellKnownSymbol('species');
    var $Array$2 = Array;
    var max$3 = Math.max;

    // `Array.prototype.slice` method
    // https://tc39.es/ecma262/#sec-array.prototype.slice
    // fallback for not array-like ES3 strings and DOM objects
    _export({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT$2
    }, {
      slice: function slice(start, end) {
        var O = toIndexedObject(this);
        var length = lengthOfArrayLike(O);
        var k = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === undefined ? length : end, length);
        // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
        var Constructor, result, n;
        if (isArray$3(O)) {
          Constructor = O.constructor;
          // cross-realm fallback
          if (isConstructor(Constructor) && (Constructor === $Array$2 || isArray$3(Constructor.prototype))) {
            Constructor = undefined;
          } else if (isObject$2(Constructor)) {
            Constructor = Constructor[SPECIES$4];
            if (Constructor === null) Constructor = undefined;
          }
          if (Constructor === $Array$2 || Constructor === undefined) {
            return arraySlice(O, k, fin);
          }
        }
        result = new (Constructor === undefined ? $Array$2 : Constructor)(max$3(fin - k, 0));
        for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
        result.length = n;
        return result;
      }
    });

    var iteratorClose = function (iterator, kind, value) {
      var innerResult;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, 'return');
        if (!innerResult) {
          if (kind === 'throw') throw value;
          return value;
        }
        innerResult = functionCall(innerResult, iterator);
      } catch (error) {
        innerResult = error;
      }
      throw value;
    };

    // call something on iterator step with safe closing on error
    var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
      try {
        return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
      } catch (error) {
        iteratorClose(iterator, 'throw', error);
      }
    };

    var iterators = {};

    var ITERATOR$6 = wellKnownSymbol('iterator');
    var ArrayPrototype = Array.prototype;

    // check on default Array iterator
    var isArrayIteratorMethod = function (it) {
      return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR$6] === it);
    };

    var ITERATOR$5 = wellKnownSymbol('iterator');
    var getIteratorMethod = function (it) {
      if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR$5) || getMethod(it, '@@iterator') || iterators[classof(it)];
    };

    var $TypeError$9 = TypeError;
    var getIterator = function (argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod)) return anObject(functionCall(iteratorMethod, argument));
      throw $TypeError$9(tryToString(argument) + ' is not iterable');
    };

    var $Array$1 = Array;

    // `Array.from` method implementation
    // https://tc39.es/ecma262/#sec-array.from
    var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
      var O = toObject(arrayLike);
      var IS_CONSTRUCTOR = isConstructor(this);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
      var iteratorMethod = getIteratorMethod(O);
      var index = 0;
      var length, result, step, iterator, next, value;
      // if the target is not iterable or it's an array with the default iterator - use a simple case
      if (iteratorMethod && !(this === $Array$1 && isArrayIteratorMethod(iteratorMethod))) {
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        result = IS_CONSTRUCTOR ? new this() : [];
        for (; !(step = functionCall(next, iterator)).done; index++) {
          value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
          createProperty(result, index, value);
        }
      } else {
        length = lengthOfArrayLike(O);
        result = IS_CONSTRUCTOR ? new this(length) : $Array$1(length);
        for (; length > index; index++) {
          value = mapping ? mapfn(O[index], index) : O[index];
          createProperty(result, index, value);
        }
      }
      result.length = index;
      return result;
    };

    var ITERATOR$4 = wellKnownSymbol('iterator');
    var SAFE_CLOSING = false;
    try {
      var called = 0;
      var iteratorWithReturn = {
        next: function () {
          return {
            done: !!called++
          };
        },
        'return': function () {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR$4] = function () {
        return this;
      };
      // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
      Array.from(iteratorWithReturn, function () {
        throw 2;
      });
    } catch (error) {/* empty */}
    var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
      if (!SAFE_CLOSING) return false;
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR$4] = function () {
          return {
            next: function () {
              return {
                done: ITERATION_SUPPORT = true
              };
            }
          };
        };
        exec(object);
      } catch (error) {/* empty */}
      return ITERATION_SUPPORT;
    };

    var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
      // eslint-disable-next-line es/no-array-from -- required for testing
      Array.from(iterable);
    });

    // `Array.from` method
    // https://tc39.es/ecma262/#sec-array.from
    _export({
      target: 'Array',
      stat: true,
      forced: INCORRECT_ITERATION
    }, {
      from: arrayFrom
    });

    var charAt$5 = functionUncurryThis(''.charAt);
    var charCodeAt = functionUncurryThis(''.charCodeAt);
    var stringSlice$3 = functionUncurryThis(''.slice);
    var createMethod$2 = function (CONVERT_TO_STRING) {
      return function ($this, pos) {
        var S = toString_1(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
        first = charCodeAt(S, position);
        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt$5(S, position) : first : CONVERT_TO_STRING ? stringSlice$3(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
      };
    };
    var stringMultibyte = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod$2(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod$2(true)
    };

    var correctPrototypeGetter = !fails(function () {
      function F() {/* empty */}
      F.prototype.constructor = null;
      // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });

    var IE_PROTO = sharedKey('IE_PROTO');
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;

    // `Object.getPrototypeOf` method
    // https://tc39.es/ecma262/#sec-object.getprototypeof
    // eslint-disable-next-line es/no-object-getprototypeof -- safe
    var objectGetPrototypeOf = correctPrototypeGetter ? $Object.getPrototypeOf : function (O) {
      var object = toObject(O);
      if (hasOwnProperty_1(object, IE_PROTO)) return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };

    var ITERATOR$3 = wellKnownSymbol('iterator');
    var BUGGY_SAFARI_ITERATORS$1 = false;

    // `%IteratorPrototype%` object
    // https://tc39.es/ecma262/#sec-%iteratorprototype%-object
    var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

    /* eslint-disable es/no-array-prototype-keys -- safe */
    if ([].keys) {
      arrayIterator = [].keys();
      // Safari 8 has buggy iterators w/o `next`
      if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;else {
        PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject$2(IteratorPrototype$2) || fails(function () {
      var test = {};
      // FF44- legacy iterators case
      return IteratorPrototype$2[ITERATOR$3].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};

    // `%IteratorPrototype%[@@iterator]()` method
    // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
    if (!isCallable(IteratorPrototype$2[ITERATOR$3])) {
      defineBuiltIn(IteratorPrototype$2, ITERATOR$3, function () {
        return this;
      });
    }
    var iteratorsCore = {
      IteratorPrototype: IteratorPrototype$2,
      BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
    };

    var defineProperty$1 = objectDefineProperty.f;


    var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
    var setToStringTag = function (target, TAG, STATIC) {
      if (target && !STATIC) target = target.prototype;
      if (target && !hasOwnProperty_1(target, TO_STRING_TAG$1)) {
        defineProperty$1(target, TO_STRING_TAG$1, {
          configurable: true,
          value: TAG
        });
      }
    };

    var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;




    var returnThis$1 = function () {
      return this;
    };
    var iteratorCreateConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + ' Iterator';
      IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
        next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next)
      });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
      iterators[TO_STRING_TAG] = returnThis$1;
      return IteratorConstructor;
    };

    var functionUncurryThisAccessor = function (object, key, method) {
      try {
        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
        return functionUncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
      } catch (error) {/* empty */}
    };

    var $String = String;
    var $TypeError$8 = TypeError;
    var aPossiblePrototype = function (argument) {
      if (typeof argument == 'object' || isCallable(argument)) return argument;
      throw $TypeError$8("Can't set " + $String(argument) + ' as a prototype');
    };

    /* eslint-disable no-proto -- safe */




    // `Object.setPrototypeOf` method
    // https://tc39.es/ecma262/#sec-object.setprototypeof
    // Works with __proto__ only. Old v8 can't work with null proto objects.
    // eslint-disable-next-line es/no-object-setprototypeof -- safe
    var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = functionUncurryThisAccessor(Object.prototype, '__proto__', 'set');
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {/* empty */}
      return function setPrototypeOf(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
        return O;
      };
    }() : undefined);

    var PROPER_FUNCTION_NAME = functionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
    var IteratorPrototype = iteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = iteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR$2 = wellKnownSymbol('iterator');
    var KEYS = 'keys';
    var VALUES = 'values';
    var ENTRIES = 'entries';
    var returnThis = function () {
      return this;
    };
    var iteratorDefine = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      iteratorCreateConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = function (KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function () {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME + ' Iterator';
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR$2] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods;

      // fix native
      if (anyNativeIterator) {
        CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (objectSetPrototypeOf) {
              objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$2])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR$2, returnThis);
            }
          }
          // Set @@toStringTag to native iterators
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
        }
      }

      // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
      if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return functionCall(nativeIterator, this);
          };
        }
      }

      // export additional methods
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        _export({
          target: NAME,
          proto: true,
          forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
        }, methods);
      }

      // define iterator
      if (IterablePrototype[ITERATOR$2] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR$2, defaultIterator, {
          name: DEFAULT
        });
      }
      iterators[NAME] = defaultIterator;
      return methods;
    };

    // `CreateIterResultObject` abstract operation
    // https://tc39.es/ecma262/#sec-createiterresultobject
    var createIterResultObject = function (value, done) {
      return {
        value: value,
        done: done
      };
    };

    var charAt$4 = stringMultibyte.charAt;




    var STRING_ITERATOR = 'String Iterator';
    var setInternalState$2 = internalState.set;
    var getInternalState$2 = internalState.getterFor(STRING_ITERATOR);

    // `String.prototype[@@iterator]` method
    // https://tc39.es/ecma262/#sec-string.prototype-@@iterator
    iteratorDefine(String, 'String', function (iterated) {
      setInternalState$2(this, {
        type: STRING_ITERATOR,
        string: toString_1(iterated),
        index: 0
      });
      // `%StringIteratorPrototype%.next` method
      // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
    }, function next() {
      var state = getInternalState$2(this);
      var string = state.string;
      var index = state.index;
      var point;
      if (index >= string.length) return createIterResultObject(undefined, true);
      point = charAt$4(string, index);
      state.index += point.length;
      return createIterResultObject(point, false);
    });

    var defineProperty = objectDefineProperty.f;




    var ARRAY_ITERATOR = 'Array Iterator';
    var setInternalState$1 = internalState.set;
    var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

    // `Array.prototype.entries` method
    // https://tc39.es/ecma262/#sec-array.prototype.entries
    // `Array.prototype.keys` method
    // https://tc39.es/ecma262/#sec-array.prototype.keys
    // `Array.prototype.values` method
    // https://tc39.es/ecma262/#sec-array.prototype.values
    // `Array.prototype[@@iterator]` method
    // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
    // `CreateArrayIterator` internal method
    // https://tc39.es/ecma262/#sec-createarrayiterator
    var es_array_iterator = iteratorDefine(Array, 'Array', function (iterated, kind) {
      setInternalState$1(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind: kind // kind
      });
      // `%ArrayIteratorPrototype%.next` method
      // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
    }, function () {
      var state = getInternalState$1(this);
      var target = state.target;
      var kind = state.kind;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = undefined;
        return createIterResultObject(undefined, true);
      }
      if (kind == 'keys') return createIterResultObject(index, false);
      if (kind == 'values') return createIterResultObject(target[index], false);
      return createIterResultObject([index, target[index]], false);
    }, 'values');

    // argumentsList[@@iterator] is %ArrayProto_values%
    // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
    // https://tc39.es/ecma262/#sec-createmappedargumentsobject
    var values = iterators.Arguments = iterators.Array;

    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
    addToUnscopables('keys');
    addToUnscopables('values');
    addToUnscopables('entries');

    // V8 ~ Chrome 45- bug
    if (descriptors && values.name !== 'values') try {
      defineProperty(values, 'name', {
        value: 'values'
      });
    } catch (error) {/* empty */}

    var ITERATOR$1 = wellKnownSymbol('iterator');
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var ArrayValues = es_array_iterator.values;
    var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
      if (CollectionPrototype) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype[ITERATOR$1] !== ArrayValues) try {
          createNonEnumerableProperty(CollectionPrototype, ITERATOR$1, ArrayValues);
        } catch (error) {
          CollectionPrototype[ITERATOR$1] = ArrayValues;
        }
        if (!CollectionPrototype[TO_STRING_TAG]) {
          createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
        }
        if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
          // some Chrome versions have non-configurable methods on DOMTokenList
          if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
          }
        }
      }
    };
    for (var COLLECTION_NAME in domIterables) {
      handlePrototype(global_1[COLLECTION_NAME] && global_1[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    handlePrototype(domTokenListPrototype, 'DOMTokenList');

    var $map = arrayIteration.map;

    var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('map');

    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    // with adding support of @@species
    _export({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT$1
    }, {
      map: function map(callbackfn /* , thisArg */) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });

    var $TypeError$7 = TypeError;
    var MAX_SAFE_INTEGER$2 = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

    var doesNotExceedSafeInteger = function (it) {
      if (it > MAX_SAFE_INTEGER$2) throw $TypeError$7('Maximum allowed index exceeded');
      return it;
    };

    var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

    // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/679
    var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
      var array = [];
      array[IS_CONCAT_SPREADABLE] = false;
      return array.concat()[0] !== array;
    });
    var isConcatSpreadable = function (O) {
      if (!isObject$2(O)) return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== undefined ? !!spreadable : isArray$3(O);
    };
    var FORCED$3 = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

    // `Array.prototype.concat` method
    // https://tc39.es/ecma262/#sec-array.prototype.concat
    // with adding support of @@isConcatSpreadable and @@species
    _export({
      target: 'Array',
      proto: true,
      arity: 1,
      forced: FORCED$3
    }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      concat: function concat(arg) {
        var O = toObject(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length, len, E;
        for (i = -1, length = arguments.length; i < length; i++) {
          E = i === -1 ? O : arguments[i];
          if (isConcatSpreadable(E)) {
            len = lengthOfArrayLike(E);
            doesNotExceedSafeInteger(n + len);
            for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
          } else {
            doesNotExceedSafeInteger(n + 1);
            createProperty(A, n++, E);
          }
        }
        A.length = n;
        return A;
      }
    });

    var global$1 = (typeof global !== "undefined" ? global :
      typeof self !== "undefined" ? self :
      typeof window !== "undefined" ? window : {});

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue$3 = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue$3 = currentQueue.concat(queue$3);
        } else {
            queueIndex = -1;
        }
        if (queue$3.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue$3.length;
        while(len) {
            currentQueue = queue$3;
            queue$3 = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue$3.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue$3.push(new Item$1(fun, args));
        if (queue$3.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item$1(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item$1.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop$2() {}

    var on$1 = noop$2;
    var addListener = noop$2;
    var once = noop$2;
    var off = noop$2;
    var removeListener = noop$2;
    var removeAllListeners = noop$2;
    var emit = noop$2;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var browser$1 = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on$1,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var engineIsNode = typeof browser$1 != 'undefined' && classofRaw(browser$1) == 'process';

    var defineBuiltInAccessor = function (target, name, descriptor) {
      if (descriptor.get) makeBuiltIn_1(descriptor.get, name, {
        getter: true
      });
      if (descriptor.set) makeBuiltIn_1(descriptor.set, name, {
        setter: true
      });
      return objectDefineProperty.f(target, name, descriptor);
    };

    var SPECIES$3 = wellKnownSymbol('species');
    var setSpecies = function (CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      if (descriptors && Constructor && !Constructor[SPECIES$3]) {
        defineBuiltInAccessor(Constructor, SPECIES$3, {
          configurable: true,
          get: function () {
            return this;
          }
        });
      }
    };

    var $TypeError$6 = TypeError;
    var anInstance = function (it, Prototype) {
      if (objectIsPrototypeOf(Prototype, it)) return it;
      throw $TypeError$6('Incorrect invocation');
    };

    var $TypeError$5 = TypeError;

    // `Assert: IsConstructor(argument) is true`
    var aConstructor = function (argument) {
      if (isConstructor(argument)) return argument;
      throw $TypeError$5(tryToString(argument) + ' is not a constructor');
    };

    var SPECIES$2 = wellKnownSymbol('species');

    // `SpeciesConstructor` abstract operation
    // https://tc39.es/ecma262/#sec-speciesconstructor
    var speciesConstructor = function (O, defaultConstructor) {
      var C = anObject(O).constructor;
      var S;
      return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES$2]) ? defaultConstructor : aConstructor(S);
    };

    var FunctionPrototype = Function.prototype;
    var apply$1 = FunctionPrototype.apply;
    var call = FunctionPrototype.call;

    // eslint-disable-next-line es/no-reflect -- safe
    var functionApply = typeof Reflect == 'object' && Reflect.apply || (functionBindNative ? call.bind(apply$1) : function () {
      return call.apply(apply$1, arguments);
    });

    var $TypeError$4 = TypeError;
    var validateArgumentsLength = function (passed, required) {
      if (passed < required) throw $TypeError$4('Not enough arguments');
      return passed;
    };

    // eslint-disable-next-line redos/no-vulnerable -- safe
    var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(engineUserAgent);

    var set = global_1.setImmediate;
    var clear = global_1.clearImmediate;
    var process$3 = global_1.process;
    var Dispatch = global_1.Dispatch;
    var Function$1 = global_1.Function;
    var MessageChannel = global_1.MessageChannel;
    var String$1 = global_1.String;
    var counter = 0;
    var queue$2 = {};
    var ONREADYSTATECHANGE = 'onreadystatechange';
    var $location, defer, channel, port;
    fails(function () {
      // Deno throws a ReferenceError on `location` access without `--location` flag
      $location = global_1.location;
    });
    var run$1 = function (id) {
      if (hasOwnProperty_1(queue$2, id)) {
        var fn = queue$2[id];
        delete queue$2[id];
        fn();
      }
    };
    var runner = function (id) {
      return function () {
        run$1(id);
      };
    };
    var eventListener = function (event) {
      run$1(event.data);
    };
    var globalPostMessageDefer = function (id) {
      // old engines have not location.origin
      global_1.postMessage(String$1(id), $location.protocol + '//' + $location.host);
    };

    // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
    if (!set || !clear) {
      set = function setImmediate(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function$1(handler);
        var args = arraySlice(arguments, 1);
        queue$2[++counter] = function () {
          functionApply(fn, undefined, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id) {
        delete queue$2[id];
      };
      // Node.js 0.8-
      if (engineIsNode) {
        defer = function (id) {
          process$3.nextTick(runner(id));
        };
        // Sphere (JS game engine) Dispatch API
      } else if (Dispatch && Dispatch.now) {
        defer = function (id) {
          Dispatch.now(runner(id));
        };
        // Browsers with MessageChannel, includes WebWorkers
        // except iOS - https://github.com/zloirock/core-js/issues/624
      } else if (MessageChannel && !engineIsIos) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = functionBindContext(port.postMessage, port);
        // Browsers with postMessage, skip WebWorkers
        // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
      } else if (global_1.addEventListener && isCallable(global_1.postMessage) && !global_1.importScripts && $location && $location.protocol !== 'file:' && !fails(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        global_1.addEventListener('message', eventListener, false);
        // IE8-
      } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
        defer = function (id) {
          html$2.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
            html$2.removeChild(this);
            run$1(id);
          };
        };
        // Rest old browsers
      } else {
        defer = function (id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    var task$1 = {
      set: set,
      clear: clear
    };

    var Queue = function () {
      this.head = null;
      this.tail = null;
    };
    Queue.prototype = {
      add: function (item) {
        var entry = {
          item: item,
          next: null
        };
        var tail = this.tail;
        if (tail) tail.next = entry;else this.head = entry;
        this.tail = entry;
      },
      get: function () {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null) this.tail = null;
          return entry.item;
        }
      }
    };
    var queue$1 = Queue;

    var engineIsIosPebble = /ipad|iphone|ipod/i.test(engineUserAgent) && typeof Pebble != 'undefined';

    var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent);

    var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
    var macrotask = task$1.set;





    var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
    var document$2 = global_1.document;
    var process$2 = global_1.process;
    var Promise$1 = global_1.Promise;
    // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
    var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global_1, 'queueMicrotask');
    var microtask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
    var notify$1, toggle, node, promise, then;

    // modern engines have queueMicrotask method
    if (!microtask) {
      var queue = new queue$1();
      var flush$1 = function () {
        var parent, fn;
        if (engineIsNode && (parent = process$2.domain)) parent.exit();
        while (fn = queue.get()) try {
          fn();
        } catch (error) {
          if (queue.head) notify$1();
          throw error;
        }
        if (parent) parent.enter();
      };

      // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
      // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
      if (!engineIsIos && !engineIsNode && !engineIsWebosWebkit && MutationObserver && document$2) {
        toggle = true;
        node = document$2.createTextNode('');
        new MutationObserver(flush$1).observe(node, {
          characterData: true
        });
        notify$1 = function () {
          node.data = toggle = !toggle;
        };
        // environments with maybe non-completely correct, but existent Promise
      } else if (!engineIsIosPebble && Promise$1 && Promise$1.resolve) {
        // Promise.resolve without an argument throws an error in LG WebOS 2
        promise = Promise$1.resolve(undefined);
        // workaround of WebKit ~ iOS Safari 10.1 bug
        promise.constructor = Promise$1;
        then = functionBindContext(promise.then, promise);
        notify$1 = function () {
          then(flush$1);
        };
        // Node.js without promises
      } else if (engineIsNode) {
        notify$1 = function () {
          process$2.nextTick(flush$1);
        };
        // for other environments - macrotask based on:
        // - setImmediate
        // - MessageChannel
        // - window.postMessage
        // - onreadystatechange
        // - setTimeout
      } else {
        // `webpack` dev server bug on IE global methods - use bind(fn, global)
        macrotask = functionBindContext(macrotask, global_1);
        notify$1 = function () {
          macrotask(flush$1);
        };
      }
      microtask = function (fn) {
        if (!queue.head) notify$1();
        queue.add(fn);
      };
    }
    var microtask_1 = microtask;

    var hostReportErrors = function (a, b) {
      try {
        // eslint-disable-next-line no-console -- safe
        arguments.length == 1 ? console.error(a) : console.error(a, b);
      } catch (error) {/* empty */}
    };

    var perform = function (exec) {
      try {
        return {
          error: false,
          value: exec()
        };
      } catch (error) {
        return {
          error: true,
          value: error
        };
      }
    };

    var promiseNativeConstructor = global_1.Promise;

    /* global Deno -- Deno case */
    var engineIsDeno = typeof Deno == 'object' && Deno && typeof Deno.version == 'object';

    var engineIsBrowser = !engineIsDeno && !engineIsNode && typeof window == 'object' && typeof document == 'object';

    promiseNativeConstructor && promiseNativeConstructor.prototype;
    var SPECIES$1 = wellKnownSymbol('species');
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable(global_1.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR$5 = isForced_1('Promise', function () {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(promiseNativeConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(promiseNativeConstructor);
      // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // We can't detect it synchronously, so just check versions
      if (!GLOBAL_CORE_JS_PROMISE && engineV8Version === 66) return true;
      // We can't use @@species feature detection in V8 since it causes
      // deoptimization and performance degradation
      // https://github.com/zloirock/core-js/issues/679
      if (!engineV8Version || engineV8Version < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        // Detect correctness of subclassing with @@species support
        var promise = new promiseNativeConstructor(function (resolve) {
          resolve(1);
        });
        var FakePromise = function (exec) {
          exec(function () {/* empty */}, function () {/* empty */});
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES$1] = FakePromise;
        SUBCLASSING = promise.then(function () {/* empty */}) instanceof FakePromise;
        if (!SUBCLASSING) return true;
        // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
      }
      return !GLOBAL_CORE_JS_PROMISE && (engineIsBrowser || engineIsDeno) && !NATIVE_PROMISE_REJECTION_EVENT$1;
    });
    var promiseConstructorDetection = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
      SUBCLASSING: SUBCLASSING
    };

    var $TypeError$3 = TypeError;
    var PromiseCapability = function (C) {
      var resolve, reject;
      this.promise = new C(function ($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw $TypeError$3('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable(resolve);
      this.reject = aCallable(reject);
    };

    // `NewPromiseCapability` abstract operation
    // https://tc39.es/ecma262/#sec-newpromisecapability
    var f = function (C) {
      return new PromiseCapability(C);
    };

    var newPromiseCapability$1 = {
    	f: f
    };

    var task = task$1.set;








    var PROMISE = 'Promise';
    var FORCED_PROMISE_CONSTRUCTOR$4 = promiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = promiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = promiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = internalState.getterFor(PROMISE);
    var setInternalState = internalState.set;
    var NativePromisePrototype$1 = promiseNativeConstructor && promiseNativeConstructor.prototype;
    var PromiseConstructor = promiseNativeConstructor;
    var PromisePrototype = NativePromisePrototype$1;
    var TypeError$1 = global_1.TypeError;
    var document$1 = global_1.document;
    var process$1 = global_1.process;
    var newPromiseCapability = newPromiseCapability$1.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global_1.dispatchEvent);
    var UNHANDLED_REJECTION = 'unhandledrejection';
    var REJECTION_HANDLED = 'rejectionhandled';
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

    // helpers
    var isThenable = function (it) {
      var then;
      return isObject$2(it) && isCallable(then = it.then) ? then : false;
    };
    var callReaction = function (reaction, state) {
      var value = state.value;
      var ok = state.state == FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError$1('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            functionCall(then, result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    };
    var notify = function (state, isReject) {
      if (state.notified) return;
      state.notified = true;
      microtask_1(function () {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection) onUnhandled(state);
      });
    };
    var dispatchEvent = function (name, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document$1.createEvent('Event');
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global_1.dispatchEvent(event);
      } else event = {
        promise: promise,
        reason: reason
      };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global_1['on' + name])) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
    };
    var onUnhandled = function (state) {
      functionCall(task, global_1, function () {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function () {
            if (engineIsNode) {
              process$1.emit('unhandledRejection', value, promise);
            } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
          state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error) throw result.value;
        }
      });
    };
    var isUnhandled = function (state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function (state) {
      functionCall(task, global_1, function () {
        var promise = state.facade;
        if (engineIsNode) {
          process$1.emit('rejectionHandled', promise);
        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    var bind$1 = function (fn, state, unwrap) {
      return function (value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject = function (state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var internalResolve = function (state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      try {
        if (state.facade === value) throw TypeError$1("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask_1(function () {
            var wrapper = {
              done: false
            };
            try {
              functionCall(then, value, bind$1(internalResolve, wrapper, state), bind$1(internalReject, wrapper, state));
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({
          done: false
        }, error, state);
      }
    };

    // constructor polyfill
    if (FORCED_PROMISE_CONSTRUCTOR$4) {
      // 25.4.3.1 Promise(executor)
      PromiseConstructor = function Promise(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        functionCall(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind$1(internalResolve, state), bind$1(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;

      // eslint-disable-next-line no-unused-vars -- required for `.length`
      Internal = function Promise(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new queue$1(),
          rejection: false,
          state: PENDING,
          value: undefined
        });
      };

      // `Promise.prototype.then` method
      // https://tc39.es/ecma262/#sec-promise.prototype.then
      Internal.prototype = defineBuiltIn(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable(onRejected) && onRejected;
        reaction.domain = engineIsNode ? process$1.domain : undefined;
        if (state.state == PENDING) state.reactions.add(reaction);else microtask_1(function () {
          callReaction(reaction, state);
        });
        return reaction.promise;
      });
      OwnPromiseCapability = function () {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind$1(internalResolve, state);
        this.reject = bind$1(internalReject, state);
      };
      newPromiseCapability$1.f = newPromiseCapability = function (C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };
      if (isCallable(promiseNativeConstructor) && NativePromisePrototype$1 !== Object.prototype) {
        nativeThen = NativePromisePrototype$1.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
          defineBuiltIn(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function (resolve, reject) {
              functionCall(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected);
            // https://github.com/zloirock/core-js/issues/640
          }, {
            unsafe: true
          });
        }

        // make `.constructor === Promise` work for native promise-based APIs
        try {
          delete NativePromisePrototype$1.constructor;
        } catch (error) {/* empty */}

        // make `instanceof Promise` work for native promise-based APIs
        if (objectSetPrototypeOf) {
          objectSetPrototypeOf(NativePromisePrototype$1, PromisePrototype);
        }
      }
    }
    _export({
      global: true,
      constructor: true,
      wrap: true,
      forced: FORCED_PROMISE_CONSTRUCTOR$4
    }, {
      Promise: PromiseConstructor
    });
    setToStringTag(PromiseConstructor, PROMISE, false);
    setSpecies(PROMISE);

    var $TypeError$2 = TypeError;
    var Result = function (stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    var iterate = function (iterable, unboundFunction, options) {
      var that = options;
      var fn = functionBindContext(unboundFunction, that);
      var iterator, iterFn, index, length, result, next, step;
      var callFn = function (value) {
        return fn(value);
      };
      {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn) throw $TypeError$2(tryToString(iterable) + ' is not iterable');
        // optimisation for array iterators
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
            result = callFn(iterable[index]);
            if (result && objectIsPrototypeOf(ResultPrototype, result)) return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = iterator.next;
      while (!(step = functionCall(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, 'throw', error);
        }
        if (typeof result == 'object' && result && objectIsPrototypeOf(ResultPrototype, result)) return result;
      }
      return new Result(false);
    };

    var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
    var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {
      promiseNativeConstructor.all(iterable).then(undefined, function () {/* empty */});
    });

    // `Promise.all` method
    // https://tc39.es/ecma262/#sec-promise.all
    _export({
      target: 'Promise',
      stat: true,
      forced: promiseStaticsIncorrectIteration
    }, {
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability$1.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function () {
          var $promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function (promise) {
            var index = counter++;
            var alreadyCalled = false;
            remaining++;
            functionCall($promiseResolve, C, promise).then(function (value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              values[index] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });

    var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;




    var NativePromisePrototype = promiseNativeConstructor && promiseNativeConstructor.prototype;

    // `Promise.prototype.catch` method
    // https://tc39.es/ecma262/#sec-promise.prototype.catch
    _export({
      target: 'Promise',
      proto: true,
      forced: FORCED_PROMISE_CONSTRUCTOR$2,
      real: true
    }, {
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    });

    // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
    if (isCallable(promiseNativeConstructor)) {
      var method$1 = getBuiltIn('Promise').prototype['catch'];
      if (NativePromisePrototype['catch'] !== method$1) {
        defineBuiltIn(NativePromisePrototype, 'catch', method$1, {
          unsafe: true
        });
      }
    }

    // `Promise.race` method
    // https://tc39.es/ecma262/#sec-promise.race
    _export({
      target: 'Promise',
      stat: true,
      forced: promiseStaticsIncorrectIteration
    }, {
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability$1.f(C);
        var reject = capability.reject;
        var result = perform(function () {
          var $promiseResolve = aCallable(C.resolve);
          iterate(iterable, function (promise) {
            functionCall($promiseResolve, C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });

    var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;

    // `Promise.reject` method
    // https://tc39.es/ecma262/#sec-promise.reject
    _export({
      target: 'Promise',
      stat: true,
      forced: FORCED_PROMISE_CONSTRUCTOR$1
    }, {
      reject: function reject(r) {
        var capability = newPromiseCapability$1.f(this);
        functionCall(capability.reject, undefined, r);
        return capability.promise;
      }
    });

    var promiseResolve = function (C, x) {
      anObject(C);
      if (isObject$2(x) && x.constructor === C) return x;
      var promiseCapability = newPromiseCapability$1.f(C);
      var resolve = promiseCapability.resolve;
      resolve(x);
      return promiseCapability.promise;
    };

    var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;

    getBuiltIn('Promise');

    // `Promise.resolve` method
    // https://tc39.es/ecma262/#sec-promise.resolve
    _export({
      target: 'Promise',
      stat: true,
      forced: FORCED_PROMISE_CONSTRUCTOR
    }, {
      resolve: function resolve(x) {
        return promiseResolve(this, x);
      }
    });

    /** @returns {void} */
    function noop$1() {}

    /**
     * @template T
     * @template S
     * @param {T} tar
     * @param {S} src
     * @returns {T & S}
     */
    function assign$1(tar, src) {
      // @ts-ignore
      for (const k in src) tar[k] = src[k];
      return (/** @type {T & S} */tar
      );
    }
    function run(fn) {
      return fn();
    }
    function blank_object() {
      return Object.create(null);
    }

    /**
     * @param {Function[]} fns
     * @returns {void}
     */
    function run_all(fns) {
      fns.forEach(run);
    }

    /**
     * @param {any} thing
     * @returns {thing is Function}
     */
    function is_function(thing) {
      return typeof thing === 'function';
    }

    /** @returns {boolean} */
    function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
    }
    let src_url_equal_anchor;

    /**
     * @param {string} element_src
     * @param {string} url
     * @returns {boolean}
     */
    function src_url_equal(element_src, url) {
      if (element_src === url) return true;
      if (!src_url_equal_anchor) {
        src_url_equal_anchor = document.createElement('a');
      }
      // This is actually faster than doing URL(..).href
      src_url_equal_anchor.href = url;
      return element_src === src_url_equal_anchor.href;
    }

    /** @param {string} srcset */
    function split_srcset(srcset) {
      return srcset.split(',').map(src => src.trim().split(' ').filter(Boolean));
    }

    /**
     * @param {HTMLSourceElement | HTMLImageElement} element_srcset
     * @param {string | undefined | null} srcset
     * @returns {boolean}
     */
    function srcset_url_equal(element_srcset, srcset) {
      const element_urls = split_srcset(element_srcset.srcset);
      const urls = split_srcset(srcset || '');
      return urls.length === element_urls.length && urls.every(([url, width], i) => width === element_urls[i][1] && (
      // We need to test both ways because Vite will create an a full URL with
      // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
      // relative URLs inside srcset are not automatically resolved to absolute URLs by
      // browsers (in contrast to img.src). This means both SSR and DOM code could
      // contain relative or absolute URLs.
      src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0])));
    }

    /** @returns {boolean} */
    function is_empty(obj) {
      return Object.keys(obj).length === 0;
    }
    function subscribe$1(store, ...callbacks) {
      if (store == null) {
        for (const callback of callbacks) {
          callback(undefined);
        }
        return noop$1;
      }
      const unsub = store.subscribe(...callbacks);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }

    /** @returns {void} */
    function component_subscribe(component, store, callback) {
      component.$$.on_destroy.push(subscribe$1(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
      if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
      }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
      return definition[1] && fn ? assign$1($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
      if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
          return lets;
        }
        if (typeof lets === 'object') {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);
          for (let i = 0; i < len; i += 1) {
            merged[i] = $$scope.dirty[i] | lets[i];
          }
          return merged;
        }
        return $$scope.dirty | lets;
      }
      return $$scope.dirty;
    }

    /** @returns {void} */
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
      if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
      }
    }

    /** @returns {any[] | -1} */
    function get_all_dirty_from_scope($$scope) {
      if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
          dirty[i] = -1;
        }
        return dirty;
      }
      return -1;
    }
    function action_destroyer(action_result) {
      return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
    }

    /**
     * @param {Node} target
     * @param {Node} node
     * @returns {void}
     */
    function append(target, node) {
      target.appendChild(node);
    }

    /**
     * @param {Node} target
     * @param {string} style_sheet_id
     * @param {string} styles
     * @returns {void}
     */
    function append_styles(target, style_sheet_id, styles) {
      const append_styles_to = get_root_for_style(target);
      if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
      }
    }

    /**
     * @param {Node} node
     * @returns {ShadowRoot | Document}
     */
    function get_root_for_style(node) {
      if (!node) return document;
      const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
      if (root && /** @type {ShadowRoot} */root.host) {
        return (/** @type {ShadowRoot} */root
        );
      }
      return node.ownerDocument;
    }

    /**
     * @param {ShadowRoot | Document} node
     * @param {HTMLStyleElement} style
     * @returns {CSSStyleSheet}
     */
    function append_stylesheet(node, style) {
      append( /** @type {Document} */node.head || node, style);
      return style.sheet;
    }

    /**
     * @param {Node} target
     * @param {Node} node
     * @param {Node} [anchor]
     * @returns {void}
     */
    function insert(target, node, anchor) {
      target.insertBefore(node, anchor || null);
    }

    /**
     * @param {Node} node
     * @returns {void}
     */
    function detach(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }

    /**
     * @returns {void} */
    function destroy_each(iterations, detaching) {
      for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i]) iterations[i].d(detaching);
      }
    }

    /**
     * @template {keyof HTMLElementTagNameMap} K
     * @param {K} name
     * @returns {HTMLElementTagNameMap[K]}
     */
    function element(name) {
      return document.createElement(name);
    }

    /**
     * @template {keyof SVGElementTagNameMap} K
     * @param {K} name
     * @returns {SVGElement}
     */
    function svg_element(name) {
      return document.createElementNS('http://www.w3.org/2000/svg', name);
    }

    /**
     * @param {string} data
     * @returns {Text}
     */
    function text$1(data) {
      return document.createTextNode(data);
    }

    /**
     * @returns {Text} */
    function space$1() {
      return text$1(' ');
    }

    /**
     * @returns {Text} */
    function empty() {
      return text$1('');
    }

    /**
     * @param {EventTarget} node
     * @param {string} event
     * @param {EventListenerOrEventListenerObject} handler
     * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
     * @returns {() => void}
     */
    function listen(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
    }

    /**
     * @returns {(event: any) => any} */
    function prevent_default(fn) {
      return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
      };
    }

    /**
     * @param {Element} node
     * @param {string} attribute
     * @param {string} [value]
     * @returns {void}
     */
    function attr(node, attribute, value) {
      if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
    }
    /**
     * List of attributes that should always be set through the attr method,
     * because updating them through the property setter doesn't work reliably.
     * In the example of `width`/`height`, the problem is that the setter only
     * accepts numeric values, but the attribute can also be set to a string like `50%`.
     * If this list becomes too big, rethink this approach.
     */
    const always_set_through_set_attribute = ['width', 'height'];

    /**
     * @param {Element & ElementCSSInlineStyle} node
     * @param {{ [x: string]: string }} attributes
     * @returns {void}
     */
    function set_attributes(node, attributes) {
      // @ts-ignore
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
      for (const key in attributes) {
        if (attributes[key] == null) {
          node.removeAttribute(key);
        } else if (key === 'style') {
          node.style.cssText = attributes[key];
        } else if (key === '__value') {
          /** @type {any} */node.value = node[key] = attributes[key];
        } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
          node[key] = attributes[key];
        } else {
          attr(node, key, attributes[key]);
        }
      }
    }

    /**
     * @returns {void} */
    function set_custom_element_data(node, prop, value) {
      const lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first
      if (lower in node) {
        node[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;
      } else if (prop in node) {
        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
      } else {
        attr(node, prop, value);
      }
    }

    /**
     * @param {Element} element
     * @returns {ChildNode[]}
     */
    function children(element) {
      return Array.from(element.childNodes);
    }

    /**
     * @param {Text} text
     * @param {unknown} data
     * @returns {void}
     */
    function set_data(text, data) {
      data = '' + data;
      if (text.data === data) return;
      text.data = /** @type {string} */data;
    }

    /**
     * @returns {void} */
    function set_input_value(input, value) {
      input.value = value == null ? '' : value;
    }

    /**
     * @returns {void} */
    function set_style(node, key, value, important) {
      if (value == null) {
        node.style.removeProperty(key);
      } else {
        node.style.setProperty(key, value, '');
      }
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead

    /**
     * @type {boolean} */
    let crossorigin;

    /**
     * @returns {boolean} */
    function is_crossorigin() {
      if (crossorigin === undefined) {
        crossorigin = false;
        try {
          if (typeof window !== 'undefined' && window.parent) {
            void window.parent.document;
          }
        } catch (error) {
          crossorigin = true;
        }
      }
      return crossorigin;
    }

    /**
     * @param {HTMLElement} node
     * @param {() => void} fn
     * @returns {() => void}
     */
    function add_iframe_resize_listener(node, fn) {
      const computed_style = getComputedStyle(node);
      if (computed_style.position === 'static') {
        node.style.position = 'relative';
      }
      const iframe = element('iframe');
      iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' + 'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
      iframe.setAttribute('aria-hidden', 'true');
      iframe.tabIndex = -1;
      const crossorigin = is_crossorigin();

      /**
       * @type {() => void}
       */
      let unsubscribe;
      if (crossorigin) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
        unsubscribe = listen(window, 'message', /** @param {MessageEvent} event */event => {
          if (event.source === iframe.contentWindow) fn();
        });
      } else {
        iframe.src = 'about:blank';
        iframe.onload = () => {
          unsubscribe = listen(iframe.contentWindow, 'resize', fn);
          // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)
          // see https://github.com/sveltejs/svelte/issues/4233
          fn();
        };
      }
      append(node, iframe);
      return () => {
        if (crossorigin) {
          unsubscribe();
        } else if (unsubscribe && iframe.contentWindow) {
          unsubscribe();
        }
        detach(iframe);
      };
    }

    /**
     * @returns {void} */
    function toggle_class(element, name, toggle) {
      // The `!!` is required because an `undefined` flag means flipping the current state.
      element.classList.toggle(name, !!toggle);
    }

    /**
     * @template T
     * @param {string} type
     * @param {T} [detail]
     * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
     * @returns {CustomEvent<T>}
     */
    function custom_event(type, detail, {
      bubbles = false,
      cancelable = false
    } = {}) {
      return new CustomEvent(type, {
        detail,
        bubbles,
        cancelable
      });
    }
    /** */
    class HtmlTag {
      /**
       * @private
       * @default false
       */
      is_svg = false;
      /** parent for creating node */
      e = undefined;
      /** html tag nodes */
      n = undefined;
      /** target */
      t = undefined;
      /** anchor */
      a = undefined;
      constructor(is_svg = false) {
        this.is_svg = is_svg;
        this.e = this.n = null;
      }

      /**
       * @param {string} html
       * @returns {void}
       */
      c(html) {
        this.h(html);
      }

      /**
       * @param {string} html
       * @param {HTMLElement | SVGElement} target
       * @param {HTMLElement | SVGElement} anchor
       * @returns {void}
       */
      m(html, target, anchor = null) {
        if (!this.e) {
          if (this.is_svg) this.e = svg_element( /** @type {keyof SVGElementTagNameMap} */target.nodeName);
          /** #7364  target for <template> may be provided as #document-fragment(11) */else this.e = element( /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? 'TEMPLATE' : target.nodeName);
          this.t = target.tagName !== 'TEMPLATE' ? target : /** @type {HTMLTemplateElement} */target.content;
          this.c(html);
        }
        this.i(anchor);
      }

      /**
       * @param {string} html
       * @returns {void}
       */
      h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);
      }

      /**
       * @returns {void} */
      i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
          insert(this.t, this.n[i], anchor);
        }
      }

      /**
       * @param {string} html
       * @returns {void}
       */
      p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
      }

      /**
       * @returns {void} */
      d() {
        this.n.forEach(detach);
      }
    }
    function construct_svelte_component(component, props) {
      return new component(props);
    }

    /**
     * @typedef {Node & {
     * 	claim_order?: number;
     * 	hydrate_init?: true;
     * 	actual_end_child?: NodeEx;
     * 	childNodes: NodeListOf<NodeEx>;
     * }} NodeEx
     */

    /** @typedef {ChildNode & NodeEx} ChildNodeEx */

    /** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

    /**
     * @typedef {ChildNodeEx[] & {
     * 	claim_info?: {
     * 		last_index: number;
     * 		total_claimed: number;
     * 	};
     * }} ChildNodeArray
     */

    let current_component;

    /** @returns {void} */
    function set_current_component(component) {
      current_component = component;
    }
    function get_current_component() {
      if (!current_component) throw new Error('Function called outside component initialization');
      return current_component;
    }

    /**
     * Schedules a callback to run immediately before the component is updated after any state change.
     *
     * The first time the callback runs will be before the initial `onMount`
     *
     * https://svelte.dev/docs/svelte#beforeupdate
     * @param {() => any} fn
     * @returns {void}
     */
    function beforeUpdate(fn) {
      get_current_component().$$.before_update.push(fn);
    }

    /**
     * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
     * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
     * it can be called from an external module).
     *
     * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
     *
     * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).
     *
     * https://svelte.dev/docs/svelte#onmount
     * @template T
     * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
     * @returns {void}
     */
    function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
    }

    /**
     * Schedules a callback to run immediately before the component is unmounted.
     *
     * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
     * only one that runs inside a server-side component.
     *
     * https://svelte.dev/docs/svelte#ondestroy
     * @param {() => any} fn
     * @returns {void}
     */
    function onDestroy(fn) {
      get_current_component().$$.on_destroy.push(fn);
    }

    /**
     * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).
     * Event dispatchers are functions that can take two arguments: `name` and `detail`.
     *
     * Component events created with `createEventDispatcher` create a
     * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
     * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
     * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
     * property and can contain any type of data.
     *
     * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
     * ```ts
     * const dispatch = createEventDispatcher<{
     *  loaded: never; // does not take a detail argument
     *  change: string; // takes a detail argument of type string, which is required
     *  optional: number | null; // takes an optional detail argument of type number
     * }>();
     * ```
     *
     * https://svelte.dev/docs/svelte#createeventdispatcher
     * @template {Record<string, any>} [EventMap=any]
     * @returns {import('./public.js').EventDispatcher<EventMap>}
     */
    function createEventDispatcher() {
      const component = get_current_component();
      return (type, detail, {
        cancelable = false
      } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
          // TODO are there situations where events could be dispatched
          // in a server (non-DOM) environment?
          const event = custom_event( /** @type {string} */type, detail, {
            cancelable
          });
          callbacks.slice().forEach(fn => {
            fn.call(component, event);
          });
          return !event.defaultPrevented;
        }
        return true;
      };
    }

    const dirty_components = [];
    const binding_callbacks = [];
    let render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = /* @__PURE__ */Promise.resolve();
    let update_scheduled = false;

    /** @returns {void} */
    function schedule_update() {
      if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
      }
    }

    /** @returns {Promise<void>} */
    function tick() {
      schedule_update();
      return resolved_promise;
    }

    /** @returns {void} */
    function add_render_callback(fn) {
      render_callbacks.push(fn);
    }

    /** @returns {void} */
    function add_flush_callback(fn) {
      flush_callbacks.push(fn);
    }

    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function

    /** @returns {void} */
    function flush() {
      // Do not reenter flush while dirty components are updated, as this can
      // result in an infinite loop. Instead, let the inner flush handle it.
      // Reentrancy is ok afterwards for bindings etc.
      if (flushidx !== 0) {
        return;
      }
      const saved_component = current_component;
      do {
        // first, call beforeUpdate functions
        // and update components
        try {
          while (flushidx < dirty_components.length) {
            const component = dirty_components[flushidx];
            flushidx++;
            set_current_component(component);
            update(component.$$);
          }
        } catch (e) {
          // reset dirty state to not end up in a deadlocked state and then rethrow
          dirty_components.length = 0;
          flushidx = 0;
          throw e;
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length) binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
          const callback = render_callbacks[i];
          if (!seen_callbacks.has(callback)) {
            // ...so guard against infinite loops
            seen_callbacks.add(callback);
            callback();
          }
        }
        render_callbacks.length = 0;
      } while (dirty_components.length);
      while (flush_callbacks.length) {
        flush_callbacks.pop()();
      }
      update_scheduled = false;
      seen_callbacks.clear();
      set_current_component(saved_component);
    }

    /** @returns {void} */
    function update($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
      }
    }

    /**
     * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
     * @param {Function[]} fns
     * @returns {void}
     */
    function flush_render_callbacks(fns) {
      const filtered = [];
      const targets = [];
      render_callbacks.forEach(c => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
      targets.forEach(c => c());
      render_callbacks = filtered;
    }

    const outroing = new Set();

    /**
     * @type {Outro}
     */
    let outros;

    /**
     * @returns {void} */
    function group_outros() {
      outros = {
        r: 0,
        c: [],
        p: outros // parent group
      };
    }

    /**
     * @returns {void} */
    function check_outros() {
      if (!outros.r) {
        run_all(outros.c);
      }
      outros = outros.p;
    }

    /**
     * @param {import('./private.js').Fragment} block
     * @param {0 | 1} [local]
     * @returns {void}
     */
    function transition_in(block, local) {
      if (block && block.i) {
        outroing.delete(block);
        block.i(local);
      }
    }

    /**
     * @param {import('./private.js').Fragment} block
     * @param {0 | 1} local
     * @param {0 | 1} [detach]
     * @param {() => void} [callback]
     * @returns {void}
     */
    function transition_out(block, local, detach, callback) {
      if (block && block.o) {
        if (outroing.has(block)) return;
        outroing.add(block);
        outros.c.push(() => {
          outroing.delete(block);
          if (callback) {
            if (detach) block.d(1);
            callback();
          }
        });
        block.o(local);
      } else if (callback) {
        callback();
      }
    }

    /** @typedef {1} INTRO */
    /** @typedef {0} OUTRO */
    /** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
    /** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

    /**
     * @typedef {Object} Outro
     * @property {number} r
     * @property {Function[]} c
     * @property {Object} p
     */

    /**
     * @typedef {Object} PendingProgram
     * @property {number} start
     * @property {INTRO|OUTRO} b
     * @property {Outro} [group]
     */

    /**
     * @typedef {Object} Program
     * @property {number} a
     * @property {INTRO|OUTRO} b
     * @property {1|-1} d
     * @property {number} duration
     * @property {number} start
     * @property {number} end
     * @property {Outro} [group]
     */

    // general each functions:

    function ensure_array_like(array_like_or_iterator) {
      return array_like_or_iterator?.length !== undefined ? array_like_or_iterator : Array.from(array_like_or_iterator);
    }

    /** @returns {void} */
    function outro_and_destroy_block(block, lookup) {
      transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
      });
    }

    /** @returns {any[]} */
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
      let o = old_blocks.length;
      let n = list.length;
      let i = o;
      const old_indexes = {};
      while (i--) old_indexes[old_blocks[i].key] = i;
      const new_blocks = [];
      const new_lookup = new Map();
      const deltas = new Map();
      const updates = [];
      i = n;
      while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
          block = create_each_block(key, child_ctx);
          block.c();
        } else {
          // defer updates until all the DOM shuffling is done
          updates.push(() => block.p(child_ctx, dirty));
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
      }
      const will_move = new Set();
      const did_move = new Set();
      /** @returns {void} */
      function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
      }
      while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
          // do nothing
          next = new_block.first;
          o--;
          n--;
        } else if (!new_lookup.has(old_key)) {
          // remove old block
          destroy(old_block, lookup);
          o--;
        } else if (!lookup.has(new_key) || will_move.has(new_key)) {
          insert(new_block);
        } else if (did_move.has(old_key)) {
          o--;
        } else if (deltas.get(new_key) > deltas.get(old_key)) {
          did_move.add(new_key);
          insert(new_block);
        } else {
          will_move.add(old_key);
          o--;
        }
      }
      while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
      }
      while (n) insert(new_blocks[n - 1]);
      run_all(updates);
      return new_blocks;
    }

    /** @returns {{}} */
    function get_spread_update(levels, updates) {
      const update = {};
      const to_null_out = {};
      const accounted_for = {
        $$scope: 1
      };
      let i = levels.length;
      while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
          for (const key in o) {
            if (!(key in n)) to_null_out[key] = 1;
          }
          for (const key in n) {
            if (!accounted_for[key]) {
              update[key] = n[key];
              accounted_for[key] = 1;
            }
          }
          levels[i] = n;
        } else {
          for (const key in o) {
            accounted_for[key] = 1;
          }
        }
      }
      for (const key in to_null_out) {
        if (!(key in update)) update[key] = undefined;
      }
      return update;
    }
    function get_spread_object(spread_props) {
      return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    /** @returns {void} */
    function bind(component, name, callback) {
      const index = component.$$.props[name];
      if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
      }
    }

    /** @returns {void} */
    function create_component(block) {
      block && block.c();
    }

    /** @returns {void} */
    function mount_component(component, target, anchor) {
      const {
        fragment,
        after_update
      } = component.$$;
      fragment && fragment.m(target, anchor);
      // onMount happens before the initial afterUpdate
      add_render_callback(() => {
        const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
        // if the component was destroyed immediately
        // it will update the `$$.on_destroy` reference to `null`.
        // the destructured on_destroy may still reference to the old array
        if (component.$$.on_destroy) {
          component.$$.on_destroy.push(...new_on_destroy);
        } else {
          // Edge case - component was destroyed immediately,
          // most likely as a result of a binding initialising
          run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
      });
      after_update.forEach(add_render_callback);
    }

    /** @returns {void} */
    function destroy_component(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
        flush_render_callbacks($$.after_update);
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }

    /** @returns {void} */
    function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
      }
      component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
    }

    // TODO: Document the other params
    /**
     * @param {SvelteComponent} component
     * @param {import('./public.js').ComponentConstructorOptions} options
     *
     * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
     * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
     * This will be the `add_css` function from the compiled component.
     *
     * @returns {void}
     */
    function init$2(component, options, instance, create_fragment, not_equal, props, append_styles = null, dirty = [-1]) {
      const parent_component = current_component;
      set_current_component(component);
      /** @type {import('./private.js').T$$} */
      const $$ = component.$$ = {
        fragment: null,
        ctx: [],
        // state
        props,
        update: noop$1,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
      };
      append_styles && append_styles($$.root);
      let ready = false;
      $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
          if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
          if (ready) make_dirty(component, i);
        }
        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all($$.before_update);
      // `false` as a special case of no DOM component
      $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
      if (options.target) {
        if (options.hydrate) {
          // TODO: what is the correct type here?
          // @ts-expect-error
          const nodes = children(options.target);
          $$.fragment && $$.fragment.l(nodes);
          nodes.forEach(detach);
        } else {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          $$.fragment && $$.fragment.c();
        }
        if (options.intro) transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
      }
      set_current_component(parent_component);
    }

    /**
     * Base class for Svelte components. Used when dev=false.
     *
     * @template {Record<string, any>} [Props=any]
     * @template {Record<string, any>} [Events=any]
     */
    class SvelteComponent {
      /**
       * ### PRIVATE API
       *
       * Do not use, may change at any time
       *
       * @type {any}
       */
      $$ = undefined;
      /**
       * ### PRIVATE API
       *
       * Do not use, may change at any time
       *
       * @type {any}
       */
      $$set = undefined;

      /** @returns {void} */
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop$1;
      }

      /**
       * @template {Extract<keyof Events, string>} K
       * @param {K} type
       * @param {((e: Events[K]) => void) | null | undefined} callback
       * @returns {() => void}
       */
      $on(type, callback) {
        if (!is_function(callback)) {
          return noop$1;
        }
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1) callbacks.splice(index, 1);
        };
      }

      /**
       * @param {Partial<Props>} props
       * @returns {void}
       */
      $set(props) {
        if (this.$$set && !is_empty(props)) {
          this.$$.skip_bound = true;
          this.$$set(props);
          this.$$.skip_bound = false;
        }
      }
    }

    /**
     * @typedef {Object} CustomElementPropDefinition
     * @property {string} [attribute]
     * @property {boolean} [reflect]
     * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
     */

    const PUBLIC_VERSION = '4';

    if (typeof window !== 'undefined')
      // @ts-ignore
      (window.__svelte || (window.__svelte = {
        v: new Set()
      })).v.add(PUBLIC_VERSION);

    function _typeof(obj) {
      "@babel/helpers - typeof";

      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, _typeof(obj);
    }

    function toInteger(dirtyNumber) {
      if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
        return NaN;
      }
      var number = Number(dirtyNumber);
      if (isNaN(number)) {
        return number;
      }
      return number < 0 ? Math.ceil(number) : Math.floor(number);
    }

    function requiredArgs(required, args) {
      if (args.length < required) {
        throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
      }
    }

    /**
     * @name toDate
     * @category Common Helpers
     * @summary Convert the given argument to an instance of Date.
     *
     * @description
     * Convert the given argument to an instance of Date.
     *
     * If the argument is an instance of Date, the function returns its clone.
     *
     * If the argument is a number, it is treated as a timestamp.
     *
     * If the argument is none of the above, the function returns Invalid Date.
     *
     * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
     *
     * @param {Date|Number} argument - the value to convert
     * @returns {Date} the parsed date in the local time zone
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Clone the date:
     * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
     * //=> Tue Feb 11 2014 11:30:30
     *
     * @example
     * // Convert the timestamp to date:
     * const result = toDate(1392098430000)
     * //=> Tue Feb 11 2014 11:30:30
     */
    function toDate(argument) {
      requiredArgs(1, arguments);
      var argStr = Object.prototype.toString.call(argument);

      // Clone the date
      if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new Date(argument.getTime());
      } else if (typeof argument === 'number' || argStr === '[object Number]') {
        return new Date(argument);
      } else {
        if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
          // eslint-disable-next-line no-console
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
          // eslint-disable-next-line no-console
          console.warn(new Error().stack);
        }
        return new Date(NaN);
      }
    }

    /**
     * @name addDays
     * @category Day Helpers
     * @summary Add the specified number of days to the given date.
     *
     * @description
     * Add the specified number of days to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} - the new date with the days added
     * @throws {TypeError} - 2 arguments required
     *
     * @example
     * // Add 10 days to 1 September 2014:
     * const result = addDays(new Date(2014, 8, 1), 10)
     * //=> Thu Sep 11 2014 00:00:00
     */
    function addDays(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var date = toDate(dirtyDate);
      var amount = toInteger(dirtyAmount);
      if (isNaN(amount)) {
        return new Date(NaN);
      }
      if (!amount) {
        // If 0 days, no-op to avoid changing times in the hour before end of DST
        return date;
      }
      date.setDate(date.getDate() + amount);
      return date;
    }

    /**
     * @name addMonths
     * @category Month Helpers
     * @summary Add the specified number of months to the given date.
     *
     * @description
     * Add the specified number of months to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the months added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 5 months to 1 September 2014:
     * const result = addMonths(new Date(2014, 8, 1), 5)
     * //=> Sun Feb 01 2015 00:00:00
     */
    function addMonths(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var date = toDate(dirtyDate);
      var amount = toInteger(dirtyAmount);
      if (isNaN(amount)) {
        return new Date(NaN);
      }
      if (!amount) {
        // If 0 months, no-op to avoid changing times in the hour before end of DST
        return date;
      }
      var dayOfMonth = date.getDate();

      // The JS Date object supports date math by accepting out-of-bounds values for
      // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
      // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
      // want except that dates will wrap around the end of a month, meaning that
      // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
      // we'll default to the end of the desired month by adding 1 to the desired
      // month and using a date of 0 to back up one day to the end of the desired
      // month.
      var endOfDesiredMonth = new Date(date.getTime());
      endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
      var daysInMonth = endOfDesiredMonth.getDate();
      if (dayOfMonth >= daysInMonth) {
        // If we're already at the end of the month, then this is the correct date
        // and we're done.
        return endOfDesiredMonth;
      } else {
        // Otherwise, we now know that setting the original day-of-month value won't
        // cause an overflow, so set the desired day-of-month. Note that we can't
        // just set the date of `endOfDesiredMonth` because that object may have had
        // its time changed in the unusual case where where a DST transition was on
        // the last day of the month and its local time was in the hour skipped or
        // repeated next to a DST transition.  So we use `date` instead which is
        // guaranteed to still have the original time.
        date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
        return date;
      }
    }

    /**
     * @name addMilliseconds
     * @category Millisecond Helpers
     * @summary Add the specified number of milliseconds to the given date.
     *
     * @description
     * Add the specified number of milliseconds to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
     * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:30.750
     */
    function addMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var timestamp = toDate(dirtyDate).getTime();
      var amount = toInteger(dirtyAmount);
      return new Date(timestamp + amount);
    }

    var defaultOptions = {};
    function getDefaultOptions() {
      return defaultOptions;
    }

    /**
     * @name startOfWeek
     * @category Week Helpers
     * @summary Return the start of a week for the given date.
     *
     * @description
     * Return the start of a week for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @returns {Date} the start of a week
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     *
     * @example
     * // The start of a week for 2 September 2014 11:55:00:
     * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Sun Aug 31 2014 00:00:00
     *
     * @example
     * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
     * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
     * //=> Mon Sep 01 2014 00:00:00
     */
    function startOfWeek(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

      // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }
      var date = toDate(dirtyDate);
      var day = date.getDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setDate(date.getDate() - diff);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
     * They usually appear for dates that denote time before the timezones were introduced
     * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
     * and GMT+01:00:00 after that date)
     *
     * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
     * which would lead to incorrect calculations.
     *
     * This function returns the timezone offset in milliseconds that takes seconds in account.
     */
    function getTimezoneOffsetInMilliseconds(date) {
      var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      utcDate.setUTCFullYear(date.getFullYear());
      return date.getTime() - utcDate.getTime();
    }

    /**
     * @name startOfDay
     * @category Day Helpers
     * @summary Return the start of a day for the given date.
     *
     * @description
     * Return the start of a day for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a day
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a day for 2 September 2014 11:55:00:
     * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 02 2014 00:00:00
     */
    function startOfDay(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    var MILLISECONDS_IN_DAY$1 = 86400000;

    /**
     * @name differenceInCalendarDays
     * @category Day Helpers
     * @summary Get the number of calendar days between the given dates.
     *
     * @description
     * Get the number of calendar days between the given dates. This means that the times are removed
     * from the dates and then the difference in days is calculated.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of calendar days
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many calendar days are between
     * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
     * const result = differenceInCalendarDays(
     *   new Date(2012, 6, 2, 0, 0),
     *   new Date(2011, 6, 2, 23, 0)
     * )
     * //=> 366
     * // How many calendar days are between
     * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
     * const result = differenceInCalendarDays(
     *   new Date(2011, 6, 3, 0, 1),
     *   new Date(2011, 6, 2, 23, 59)
     * )
     * //=> 1
     */
    function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var startOfDayLeft = startOfDay(dirtyDateLeft);
      var startOfDayRight = startOfDay(dirtyDateRight);
      var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
      var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);

      // Round the number of days to the nearest integer
      // because the number of milliseconds in a day is not constant
      // (e.g. it's different in the day of the daylight saving time clock shift)
      return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
    }

    var MILLISECONDS_IN_MINUTE = 60000;

    /**
     * @name addMinutes
     * @category Minute Helpers
     * @summary Add the specified number of minutes to the given date.
     *
     * @description
     * Add the specified number of minutes to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of minutes to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the minutes added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 30 minutes to 10 July 2014 12:00:00:
     * const result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
     * //=> Thu Jul 10 2014 12:30:00
     */
    function addMinutes(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger(dirtyAmount);
      return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
    }

    /**
     * @name addWeeks
     * @category Week Helpers
     * @summary Add the specified number of weeks to the given date.
     *
     * @description
     * Add the specified number of week to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of weeks to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the weeks added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 4 weeks to 1 September 2014:
     * const result = addWeeks(new Date(2014, 8, 1), 4)
     * //=> Mon Sep 29 2014 00:00:00
     */
    function addWeeks(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger(dirtyAmount);
      var days = amount * 7;
      return addDays(dirtyDate, days);
    }

    /**
     * @name addYears
     * @category Year Helpers
     * @summary Add the specified number of years to the given date.
     *
     * @description
     * Add the specified number of years to the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the years added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 5 years to 1 September 2014:
     * const result = addYears(new Date(2014, 8, 1), 5)
     * //=> Sun Sep 01 2019 00:00:00
     */
    function addYears(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger(dirtyAmount);
      return addMonths(dirtyDate, amount * 12);
    }

    /**
     * @name compareAsc
     * @category Common Helpers
     * @summary Compare the two dates and return -1, 0 or 1.
     *
     * @description
     * Compare the two dates and return 1 if the first date is after the second,
     * -1 if the first date is before the second or 0 if dates are equal.
     *
     * @param {Date|Number} dateLeft - the first date to compare
     * @param {Date|Number} dateRight - the second date to compare
     * @returns {Number} the result of the comparison
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Compare 11 February 1987 and 10 July 1989:
     * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
     * //=> -1
     *
     * @example
     * // Sort the array of dates:
     * const result = [
     *   new Date(1995, 6, 2),
     *   new Date(1987, 1, 11),
     *   new Date(1989, 6, 10)
     * ].sort(compareAsc)
     * //=> [
     * //   Wed Feb 11 1987 00:00:00,
     * //   Mon Jul 10 1989 00:00:00,
     * //   Sun Jul 02 1995 00:00:00
     * // ]
     */
    function compareAsc(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var diff = dateLeft.getTime() - dateRight.getTime();
      if (diff < 0) {
        return -1;
      } else if (diff > 0) {
        return 1;
        // Return 0 if diff is 0; return NaN if diff is NaN
      } else {
        return diff;
      }
    }

    /**
     * Milliseconds in 1 minute
     *
     * @name millisecondsInMinute
     * @constant
     * @type {number}
     * @default
     */
    var millisecondsInMinute = 60000;

    /**
     * Milliseconds in 1 hour
     *
     * @name millisecondsInHour
     * @constant
     * @type {number}
     * @default
     */
    var millisecondsInHour = 3600000;

    /**
     * Milliseconds in 1 second
     *
     * @name millisecondsInSecond
     * @constant
     * @type {number}
     * @default
     */
    var millisecondsInSecond = 1000;

    /**
     * @name isSameDay
     * @category Day Helpers
     * @summary Are the given dates in the same day (and year and month)?
     *
     * @description
     * Are the given dates in the same day (and year and month)?
     *
     * @param {Date|Number} dateLeft - the first date to check
     * @param {Date|Number} dateRight - the second date to check
     * @returns {Boolean} the dates are in the same day (and year and month)
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
     * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
     * //=> true
     *
     * @example
     * // Are 4 September and 4 October in the same day?
     * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
     * //=> false
     *
     * @example
     * // Are 4 September, 2014 and 4 September, 2015 in the same day?
     * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
     * //=> false
     */
    function isSameDay(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
      var dateRightStartOfDay = startOfDay(dirtyDateRight);
      return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
    }

    /**
     * @name isDate
     * @category Common Helpers
     * @summary Is the given value a date?
     *
     * @description
     * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
     *
     * @param {*} value - the value to check
     * @returns {boolean} true if the given value is a date
     * @throws {TypeError} 1 arguments required
     *
     * @example
     * // For a valid date:
     * const result = isDate(new Date())
     * //=> true
     *
     * @example
     * // For an invalid date:
     * const result = isDate(new Date(NaN))
     * //=> true
     *
     * @example
     * // For some value:
     * const result = isDate('2014-02-31')
     * //=> false
     *
     * @example
     * // For an object:
     * const result = isDate({})
     * //=> false
     */
    function isDate$1(value) {
      requiredArgs(1, arguments);
      return value instanceof Date || _typeof(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
    }

    /**
     * @name isValid
     * @category Common Helpers
     * @summary Is the given date valid?
     *
     * @description
     * Returns false if argument is Invalid Date and true otherwise.
     * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
     * Invalid Date is a Date, whose time value is NaN.
     *
     * Time value of Date: http://es5.github.io/#x15.9.1.1
     *
     * @param {*} date - the date to check
     * @returns {Boolean} the date is valid
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // For the valid date:
     * const result = isValid(new Date(2014, 1, 31))
     * //=> true
     *
     * @example
     * // For the value, convertable into a date:
     * const result = isValid(1393804800000)
     * //=> true
     *
     * @example
     * // For the invalid date:
     * const result = isValid(new Date(''))
     * //=> false
     */
    function isValid(dirtyDate) {
      requiredArgs(1, arguments);
      if (!isDate$1(dirtyDate) && typeof dirtyDate !== 'number') {
        return false;
      }
      var date = toDate(dirtyDate);
      return !isNaN(Number(date));
    }

    /**
     * @name differenceInCalendarMonths
     * @category Month Helpers
     * @summary Get the number of calendar months between the given dates.
     *
     * @description
     * Get the number of calendar months between the given dates.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of calendar months
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many calendar months are between 31 January 2014 and 1 September 2014?
     * const result = differenceInCalendarMonths(
     *   new Date(2014, 8, 1),
     *   new Date(2014, 0, 31)
     * )
     * //=> 8
     */
    function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
      var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
      return yearDiff * 12 + monthDiff;
    }

    /**
     * @name differenceInCalendarYears
     * @category Year Helpers
     * @summary Get the number of calendar years between the given dates.
     *
     * @description
     * Get the number of calendar years between the given dates.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of calendar years
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many calendar years are between 31 December 2013 and 11 February 2015?
     * const result = differenceInCalendarYears(
     *   new Date(2015, 1, 11),
     *   new Date(2013, 11, 31)
     * )
     * //=> 2
     */
    function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      return dateLeft.getFullYear() - dateRight.getFullYear();
    }

    // for accurate equality comparisons of UTC timestamps that end up
    // having the same representation in local time, e.g. one hour before
    // DST ends vs. the instant that DST ends.
    function compareLocalAsc(dateLeft, dateRight) {
      var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
      if (diff < 0) {
        return -1;
      } else if (diff > 0) {
        return 1;
        // Return 0 if diff is 0; return NaN if diff is NaN
      } else {
        return diff;
      }
    }

    /**
     * @name differenceInDays
     * @category Day Helpers
     * @summary Get the number of full days between the given dates.
     *
     * @description
     * Get the number of full day periods between two dates. Fractional days are
     * truncated towards zero.
     *
     * One "full day" is the distance between a local time in one day to the same
     * local time on the next or previous day. A full day can sometimes be less than
     * or more than 24 hours if a daylight savings change happens between two dates.
     *
     * To ignore DST and only measure exact 24-hour periods, use this instead:
     * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
     *
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of full days according to the local timezone
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many full days are between
     * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
     * const result = differenceInDays(
     *   new Date(2012, 6, 2, 0, 0),
     *   new Date(2011, 6, 2, 23, 0)
     * )
     * //=> 365
     * // How many full days are between
     * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
     * const result = differenceInDays(
     *   new Date(2011, 6, 3, 0, 1),
     *   new Date(2011, 6, 2, 23, 59)
     * )
     * //=> 0
     * // How many full days are between
     * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
     * // Note: because local time is used, the
     * // result will always be 92 days, even in
     * // time zones where DST starts and the
     * // period has only 92*24-1 hours.
     * const result = differenceInDays(
     *   new Date(2020, 5, 1),
     *   new Date(2020, 2, 1)
     * )
    //=> 92
     */
    function differenceInDays(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var sign = compareLocalAsc(dateLeft, dateRight);
      var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
      dateLeft.setDate(dateLeft.getDate() - sign * difference);

      // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
      // If so, result must be decreased by 1 in absolute value
      var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);
      var result = sign * (difference - isLastDayNotFull);
      // Prevent negative zero
      return result === 0 ? 0 : result;
    }

    /**
     * @name differenceInMilliseconds
     * @category Millisecond Helpers
     * @summary Get the number of milliseconds between the given dates.
     *
     * @description
     * Get the number of milliseconds between the given dates.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of milliseconds
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many milliseconds are between
     * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
     * const result = differenceInMilliseconds(
     *   new Date(2014, 6, 2, 12, 30, 21, 700),
     *   new Date(2014, 6, 2, 12, 30, 20, 600)
     * )
     * //=> 1100
     */
    function differenceInMilliseconds(dateLeft, dateRight) {
      requiredArgs(2, arguments);
      return toDate(dateLeft).getTime() - toDate(dateRight).getTime();
    }

    var roundingMap = {
      ceil: Math.ceil,
      round: Math.round,
      floor: Math.floor,
      trunc: function trunc(value) {
        return value < 0 ? Math.ceil(value) : Math.floor(value);
      } // Math.trunc is not supported by IE
    };

    var defaultRoundingMethod = 'trunc';
    function getRoundingMethod(method) {
      return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
    }

    /**
     * @name differenceInMinutes
     * @category Minute Helpers
     * @summary Get the number of minutes between the given dates.
     *
     * @description
     * Get the signed number of full (rounded towards 0) minutes between the given dates.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @param {Object} [options] - an object with options.
     * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
     * @returns {Number} the number of minutes
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many minutes are between 2 July 2014 12:07:59 and 2 July 2014 12:20:00?
     * const result = differenceInMinutes(
     *   new Date(2014, 6, 2, 12, 20, 0),
     *   new Date(2014, 6, 2, 12, 7, 59)
     * )
     * //=> 12
     *
     * @example
     * // How many minutes are between 10:01:59 and 10:00:00
     * const result = differenceInMinutes(
     *   new Date(2000, 0, 1, 10, 0, 0),
     *   new Date(2000, 0, 1, 10, 1, 59)
     * )
     * //=> -1
     */
    function differenceInMinutes(dateLeft, dateRight, options) {
      requiredArgs(2, arguments);
      var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
      return getRoundingMethod(void 0 )(diff);
    }

    /**
     * @name endOfDay
     * @category Day Helpers
     * @summary Return the end of a day for the given date.
     *
     * @description
     * Return the end of a day for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the end of a day
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The end of a day for 2 September 2014 11:55:00:
     * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 02 2014 23:59:59.999
     */
    function endOfDay(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      date.setHours(23, 59, 59, 999);
      return date;
    }

    /**
     * @name endOfMonth
     * @category Month Helpers
     * @summary Return the end of a month for the given date.
     *
     * @description
     * Return the end of a month for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the end of a month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The end of a month for 2 September 2014 11:55:00:
     * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 30 2014 23:59:59.999
     */
    function endOfMonth(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var month = date.getMonth();
      date.setFullYear(date.getFullYear(), month + 1, 0);
      date.setHours(23, 59, 59, 999);
      return date;
    }

    /**
     * @name isLastDayOfMonth
     * @category Month Helpers
     * @summary Is the given date the last day of a month?
     *
     * @description
     * Is the given date the last day of a month?
     *
     * @param {Date|Number} date - the date to check
     * @returns {Boolean} the date is the last day of a month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Is 28 February 2014 the last day of a month?
     * const result = isLastDayOfMonth(new Date(2014, 1, 28))
     * //=> true
     */
    function isLastDayOfMonth(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      return endOfDay(date).getTime() === endOfMonth(date).getTime();
    }

    /**
     * @name differenceInMonths
     * @category Month Helpers
     * @summary Get the number of full months between the given dates.
     *
     * @description
     * Get the number of full months between the given dates using trunc as a default rounding method.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of full months
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many full months are between 31 January 2014 and 1 September 2014?
     * const result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
     * //=> 7
     */
    function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var sign = compareAsc(dateLeft, dateRight);
      var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
      var result;

      // Check for the difference of less than month
      if (difference < 1) {
        result = 0;
      } else {
        if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
          // This will check if the date is end of Feb and assign a higher end of month date
          // to compare it with Jan
          dateLeft.setDate(30);
        }
        dateLeft.setMonth(dateLeft.getMonth() - sign * difference);

        // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
        // If so, result must be decreased by 1 in absolute value
        var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign;

        // Check for cases of one full calendar month
        if (isLastDayOfMonth(toDate(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
          isLastMonthNotFull = false;
        }
        result = sign * (difference - Number(isLastMonthNotFull));
      }

      // Prevent negative zero
      return result === 0 ? 0 : result;
    }

    /**
     * @name differenceInWeeks
     * @category Week Helpers
     * @summary Get the number of full weeks between the given dates.
     *
     * @description
     * Get the number of full weeks between two dates. Fractional weeks are
     * truncated towards zero by default.
     *
     * One "full week" is the distance between a local time in one day to the same
     * local time 7 days earlier or later. A full week can sometimes be less than
     * or more than 7*24 hours if a daylight savings change happens between two dates.
     *
     * To ignore DST and only measure exact 7*24-hour periods, use this instead:
     * `Math.floor(differenceInHours(dateLeft, dateRight)/(7*24))|0`.
     *
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @param {Object} [options] - an object with options.
     * @param {String} [options.roundingMethod='trunc'] - a rounding method (`ceil`, `floor`, `round` or `trunc`)
     * @returns {Number} the number of full weeks
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many full weeks are between 5 July 2014 and 20 July 2014?
     * const result = differenceInWeeks(new Date(2014, 6, 20), new Date(2014, 6, 5))
     * //=> 2
     *
     * // How many full weeks are between
     * // 1 March 2020 0:00 and 6 June 2020 0:00 ?
     * // Note: because local time is used, the
     * // result will always be 8 weeks (54 days),
     * // even if DST starts and the period has
     * // only 54*24-1 hours.
     * const result = differenceInWeeks(
     *   new Date(2020, 5, 1),
     *   new Date(2020, 2, 6)
     * )
     * //=> 8
     */
    function differenceInWeeks(dateLeft, dateRight, options) {
      requiredArgs(2, arguments);
      var diff = differenceInDays(dateLeft, dateRight) / 7;
      return getRoundingMethod(void 0 )(diff);
    }

    /**
     * @name differenceInYears
     * @category Year Helpers
     * @summary Get the number of full years between the given dates.
     *
     * @description
     * Get the number of full years between the given dates.
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of full years
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many full years are between 31 December 2013 and 11 February 2015?
     * const result = differenceInYears(new Date(2015, 1, 11), new Date(2013, 11, 31))
     * //=> 1
     */
    function differenceInYears(dirtyDateLeft, dirtyDateRight) {
      requiredArgs(2, arguments);
      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var sign = compareAsc(dateLeft, dateRight);
      var difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight));

      // Set both dates to a valid leap year for accurate comparison when dealing
      // with leap days
      dateLeft.setFullYear(1584);
      dateRight.setFullYear(1584);

      // Math.abs(diff in full years - diff in calendar years) === 1 if last calendar year is not full
      // If so, result must be decreased by 1 in absolute value
      var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign;
      var result = sign * (difference - Number(isLastYearNotFull));
      // Prevent negative zero
      return result === 0 ? 0 : result;
    }

    /**
     * @name startOfMonth
     * @category Month Helpers
     * @summary Return the start of a month for the given date.
     *
     * @description
     * Return the start of a month for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a month
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a month for 2 September 2014 11:55:00:
     * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Mon Sep 01 2014 00:00:00
     */
    function startOfMonth(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * @name endOfYear
     * @category Year Helpers
     * @summary Return the end of a year for the given date.
     *
     * @description
     * Return the end of a year for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the end of a year
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The end of a year for 2 September 2014 11:55:00:
     * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))
     * //=> Wed Dec 31 2014 23:59:59.999
     */
    function endOfYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getFullYear();
      date.setFullYear(year + 1, 0, 0);
      date.setHours(23, 59, 59, 999);
      return date;
    }

    /**
     * @name startOfYear
     * @category Year Helpers
     * @summary Return the start of a year for the given date.
     *
     * @description
     * Return the start of a year for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a year
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a year for 2 September 2014 11:55:00:
     * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
     * //=> Wed Jan 01 2014 00:00:00
     */
    function startOfYear(dirtyDate) {
      requiredArgs(1, arguments);
      var cleanDate = toDate(dirtyDate);
      var date = new Date(0);
      date.setFullYear(cleanDate.getFullYear(), 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * @name endOfWeek
     * @category Week Helpers
     * @summary Return the end of a week for the given date.
     *
     * @description
     * Return the end of a week for the given date.
     * The result will be in the local timezone.
     *
     * @param {Date|Number} date - the original date
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @returns {Date} the end of a week
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     *
     * @example
     * // The end of a week for 2 September 2014 11:55:00:
     * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Sat Sep 06 2014 23:59:59.999
     *
     * @example
     * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
     * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
     * //=> Sun Sep 07 2014 23:59:59.999
     */
    function endOfWeek(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

      // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }
      var date = toDate(dirtyDate);
      var day = date.getDay();
      var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
      date.setDate(date.getDate() + diff);
      date.setHours(23, 59, 59, 999);
      return date;
    }

    /**
     * @name subMilliseconds
     * @category Millisecond Helpers
     * @summary Subtract the specified number of milliseconds from the given date.
     *
     * @description
     * Subtract the specified number of milliseconds from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
     * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:29.250
     */
    function subMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger(dirtyAmount);
      return addMilliseconds(dirtyDate, -amount);
    }

    var MILLISECONDS_IN_DAY = 86400000;
    function getUTCDayOfYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var timestamp = date.getTime();
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
      var startOfYearTimestamp = date.getTime();
      var difference = timestamp - startOfYearTimestamp;
      return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
    }

    function startOfUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var weekStartsOn = 1;
      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    function getUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getUTCFullYear();
      var fourthOfJanuaryOfNextYear = new Date(0);
      fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
      var fourthOfJanuaryOfThisYear = new Date(0);
      fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    function startOfUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var year = getUTCISOWeekYear(dirtyDate);
      var fourthOfJanuary = new Date(0);
      fourthOfJanuary.setUTCFullYear(year, 0, 4);
      fourthOfJanuary.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCISOWeek(fourthOfJanuary);
      return date;
    }

    var MILLISECONDS_IN_WEEK$2 = 604800000;
    function getUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();

      // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)
      return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1;
    }

    function startOfUTCWeek(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

      // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }
      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    function getUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getUTCFullYear();
      var defaultOptions = getDefaultOptions();
      var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);

      // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }
      var firstWeekOfNextYear = new Date(0);
      firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
      var firstWeekOfThisYear = new Date(0);
      firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    function startOfUTCWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      var year = getUTCWeekYear(dirtyDate, options);
      var firstWeek = new Date(0);
      firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCWeek(firstWeek, options);
      return date;
    }

    var MILLISECONDS_IN_WEEK$1 = 604800000;
    function getUTCWeek(dirtyDate, options) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();

      // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)
      return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
    }

    function addLeadingZeros(number, targetLength) {
      var sign = number < 0 ? '-' : '';
      var output = Math.abs(number).toString();
      while (output.length < targetLength) {
        output = '0' + output;
      }
      return sign + output;
    }

    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* |                                |
     * |  d  | Day of month                   |  D  |                                |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  m  | Minute                         |  M  | Month                          |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  y  | Year (abs)                     |  Y  |                                |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     */
    var formatters$1 = {
      // Year
      y: function y(date, token) {
        // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
        // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
        // |----------|-------|----|-------|-------|-------|
        // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
        // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
        // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
        // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
        // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

        var signedYear = date.getUTCFullYear();
        // Returns 1 for 1 BC (which is year 0 in JavaScript)
        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
      },
      // Month
      M: function M(date, token) {
        var month = date.getUTCMonth();
        return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
      },
      // Day of the month
      d: function d(date, token) {
        return addLeadingZeros(date.getUTCDate(), token.length);
      },
      // AM or PM
      a: function a(date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';
        switch (token) {
          case 'a':
          case 'aa':
            return dayPeriodEnumValue.toUpperCase();
          case 'aaa':
            return dayPeriodEnumValue;
          case 'aaaaa':
            return dayPeriodEnumValue[0];
          case 'aaaa':
          default:
            return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
        }
      },
      // Hour [1-12]
      h: function h(date, token) {
        return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H: function H(date, token) {
        return addLeadingZeros(date.getUTCHours(), token.length);
      },
      // Minute
      m: function m(date, token) {
        return addLeadingZeros(date.getUTCMinutes(), token.length);
      },
      // Second
      s: function s(date, token) {
        return addLeadingZeros(date.getUTCSeconds(), token.length);
      },
      // Fraction of second
      S: function S(date, token) {
        var numberOfDigits = token.length;
        var milliseconds = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros(fractionalSeconds, token.length);
      }
    };

    var dayPeriodEnum = {
      am: 'am',
      pm: 'pm',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    };
    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* | Milliseconds in day            |
     * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
     * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
     * |  d  | Day of month                   |  D  | Day of year                    |
     * |  e  | Local day of week              |  E  | Day of week                    |
     * |  f  |                                |  F* | Day of week in month           |
     * |  g* | Modified Julian day            |  G  | Era                            |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  i! | ISO day of week                |  I! | ISO week of year               |
     * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
     * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
     * |  l* | (deprecated)                   |  L  | Stand-alone month              |
     * |  m  | Minute                         |  M  | Month                          |
     * |  n  |                                |  N  |                                |
     * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
     * |  p! | Long localized time            |  P! | Long localized date            |
     * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
     * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
     * |  u  | Extended year                  |  U* | Cyclic year                    |
     * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
     * |  w  | Local week of year             |  W* | Week of month                  |
     * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
     * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
     * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     *
     * Letters marked by ! are non-standard, but implemented by date-fns:
     * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
     * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
     *   i.e. 7 for Sunday, 1 for Monday, etc.
     * - `I` is ISO week of year, as opposed to `w` which is local week of year.
     * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
     *   `R` is supposed to be used in conjunction with `I` and `i`
     *   for universal ISO week-numbering date, whereas
     *   `Y` is supposed to be used in conjunction with `w` and `e`
     *   for week-numbering date specific to the locale.
     * - `P` is long localized date format
     * - `p` is long localized time format
     */

    var formatters = {
      // Era
      G: function G(date, token, localize) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;
        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return localize.era(era, {
              width: 'abbreviated'
            });
          // A, B
          case 'GGGGG':
            return localize.era(era, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ
          case 'GGGG':
          default:
            return localize.era(era, {
              width: 'wide'
            });
        }
      },
      // Year
      y: function y(date, token, localize) {
        // Ordinal number
        if (token === 'yo') {
          var signedYear = date.getUTCFullYear();
          // Returns 1 for 1 BC (which is year 0 in JavaScript)
          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize.ordinalNumber(year, {
            unit: 'year'
          });
        }
        return formatters$1.y(date, token);
      },
      // Local week-numbering year
      Y: function Y(date, token, localize, options) {
        var signedWeekYear = getUTCWeekYear(date, options);
        // Returns 1 for 1 BC (which is year 0 in JavaScript)
        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

        // Two digit year
        if (token === 'YY') {
          var twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        }

        // Ordinal number
        if (token === 'Yo') {
          return localize.ordinalNumber(weekYear, {
            unit: 'year'
          });
        }

        // Padding
        return addLeadingZeros(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function R(date, token) {
        var isoWeekYear = getUTCISOWeekYear(date);

        // Padding
        return addLeadingZeros(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function u(date, token) {
        var year = date.getUTCFullYear();
        return addLeadingZeros(year, token.length);
      },
      // Quarter
      Q: function Q(date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
            return String(quarter);
          // 01, 02, 03, 04
          case 'QQ':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th
          case 'Qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4
          case 'QQQ':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)
          case 'QQQQQ':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...
          case 'QQQQ':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone quarter
      q: function q(date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch (token) {
          // 1, 2, 3, 4
          case 'q':
            return String(quarter);
          // 01, 02, 03, 04
          case 'qq':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th
          case 'qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4
          case 'qqq':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)
          case 'qqqqq':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...
          case 'qqqq':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Month
      M: function M(date, token, localize) {
        var month = date.getUTCMonth();
        switch (token) {
          case 'M':
          case 'MM':
            return formatters$1.M(date, token);
          // 1st, 2nd, ..., 12th
          case 'Mo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec
          case 'MMM':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // J, F, ..., D
          case 'MMMMM':
            return localize.month(month, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December
          case 'MMMM':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone month
      L: function L(date, token, localize) {
        var month = date.getUTCMonth();
        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return String(month + 1);
          // 01, 02, ..., 12
          case 'LL':
            return addLeadingZeros(month + 1, 2);
          // 1st, 2nd, ..., 12th
          case 'Lo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec
          case 'LLL':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // J, F, ..., D
          case 'LLLLL':
            return localize.month(month, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December
          case 'LLLL':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Local week of year
      w: function w(date, token, localize, options) {
        var week = getUTCWeek(date, options);
        if (token === 'wo') {
          return localize.ordinalNumber(week, {
            unit: 'week'
          });
        }
        return addLeadingZeros(week, token.length);
      },
      // ISO week of year
      I: function I(date, token, localize) {
        var isoWeek = getUTCISOWeek(date);
        if (token === 'Io') {
          return localize.ordinalNumber(isoWeek, {
            unit: 'week'
          });
        }
        return addLeadingZeros(isoWeek, token.length);
      },
      // Day of the month
      d: function d(date, token, localize) {
        if (token === 'do') {
          return localize.ordinalNumber(date.getUTCDate(), {
            unit: 'date'
          });
        }
        return formatters$1.d(date, token);
      },
      // Day of year
      D: function D(date, token, localize) {
        var dayOfYear = getUTCDayOfYear(date);
        if (token === 'Do') {
          return localize.ordinalNumber(dayOfYear, {
            unit: 'dayOfYear'
          });
        }
        return addLeadingZeros(dayOfYear, token.length);
      },
      // Day of week
      E: function E(date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T
          case 'EEEEE':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu
          case 'EEEEEE':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday
          case 'EEEE':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Local day of week
      e: function e(date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          // Numerical value (Nth day of week with current locale or weekStartsOn)
          case 'e':
            return String(localDayOfWeek);
          // Padded numerical value
          case 'ee':
            return addLeadingZeros(localDayOfWeek, 2);
          // 1st, 2nd, ..., 7th
          case 'eo':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });
          case 'eee':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T
          case 'eeeee':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu
          case 'eeeeee':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday
          case 'eeee':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone local day of week
      c: function c(date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          // Numerical value (same as in `e`)
          case 'c':
            return String(localDayOfWeek);
          // Padded numerical value
          case 'cc':
            return addLeadingZeros(localDayOfWeek, token.length);
          // 1st, 2nd, ..., 7th
          case 'co':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });
          case 'ccc':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // T
          case 'ccccc':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu
          case 'cccccc':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'standalone'
            });
          // Tuesday
          case 'cccc':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // ISO day of week
      i: function i(date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token) {
          // 2
          case 'i':
            return String(isoDayOfWeek);
          // 02
          case 'ii':
            return addLeadingZeros(isoDayOfWeek, token.length);
          // 2nd
          case 'io':
            return localize.ordinalNumber(isoDayOfWeek, {
              unit: 'day'
            });
          // Tue
          case 'iii':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T
          case 'iiiii':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu
          case 'iiiiii':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday
          case 'iiii':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM or PM
      a: function a(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
        switch (token) {
          case 'a':
          case 'aa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });
          case 'aaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            }).toLowerCase();
          case 'aaaaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });
          case 'aaaa':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM, PM, midnight, noon
      b: function b(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
        }
        switch (token) {
          case 'b':
          case 'bb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });
          case 'bbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            }).toLowerCase();
          case 'bbbbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });
          case 'bbbb':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function B(date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });
          case 'BBBBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });
          case 'BBBB':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Hour [1-12]
      h: function h(date, token, localize) {
        if (token === 'ho') {
          var hours = date.getUTCHours() % 12;
          if (hours === 0) hours = 12;
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }
        return formatters$1.h(date, token);
      },
      // Hour [0-23]
      H: function H(date, token, localize) {
        if (token === 'Ho') {
          return localize.ordinalNumber(date.getUTCHours(), {
            unit: 'hour'
          });
        }
        return formatters$1.H(date, token);
      },
      // Hour [0-11]
      K: function K(date, token, localize) {
        var hours = date.getUTCHours() % 12;
        if (token === 'Ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }
        return addLeadingZeros(hours, token.length);
      },
      // Hour [1-24]
      k: function k(date, token, localize) {
        var hours = date.getUTCHours();
        if (hours === 0) hours = 24;
        if (token === 'ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }
        return addLeadingZeros(hours, token.length);
      },
      // Minute
      m: function m(date, token, localize) {
        if (token === 'mo') {
          return localize.ordinalNumber(date.getUTCMinutes(), {
            unit: 'minute'
          });
        }
        return formatters$1.m(date, token);
      },
      // Second
      s: function s(date, token, localize) {
        if (token === 'so') {
          return localize.ordinalNumber(date.getUTCSeconds(), {
            unit: 'second'
          });
        }
        return formatters$1.s(date, token);
      },
      // Fraction of second
      S: function S(date, token) {
        return formatters$1.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function X(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        if (timezoneOffset === 0) {
          return 'Z';
        }
        switch (token) {
          // Hours and optional minutes
          case 'X':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);

          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XX`
          case 'XXXX':
          case 'XX':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);

          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XXX`
          case 'XXXXX':
          case 'XXX': // Hours and minutes with `:` delimiter
          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function x(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          // Hours and optional minutes
          case 'x':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);

          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xx`
          case 'xxxx':
          case 'xx':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);

          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xxx`
          case 'xxxxx':
          case 'xxx': // Hours and minutes with `:` delimiter
          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (GMT)
      O: function O(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          // Short
          case 'O':
          case 'OO':
          case 'OOO':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long
          case 'OOOO':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (specific non-location)
      z: function z(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          // Short
          case 'z':
          case 'zz':
          case 'zzz':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long
          case 'zzzz':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Seconds timestamp
      t: function t(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1000);
        return addLeadingZeros(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function T(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return addLeadingZeros(timestamp, token.length);
      }
    };
    function formatTimezoneShort(offset, dirtyDelimiter) {
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = Math.floor(absOffset / 60);
      var minutes = absOffset % 60;
      if (minutes === 0) {
        return sign + String(hours);
      }
      var delimiter = dirtyDelimiter;
      return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
    }
    function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
      if (offset % 60 === 0) {
        var sign = offset > 0 ? '-' : '+';
        return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
      }
      return formatTimezone(offset, dirtyDelimiter);
    }
    function formatTimezone(offset, dirtyDelimiter) {
      var delimiter = dirtyDelimiter || '';
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
      var minutes = addLeadingZeros(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }

    var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
      switch (pattern) {
        case 'P':
          return formatLong.date({
            width: 'short'
          });
        case 'PP':
          return formatLong.date({
            width: 'medium'
          });
        case 'PPP':
          return formatLong.date({
            width: 'long'
          });
        case 'PPPP':
        default:
          return formatLong.date({
            width: 'full'
          });
      }
    };
    var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
      switch (pattern) {
        case 'p':
          return formatLong.time({
            width: 'short'
          });
        case 'pp':
          return formatLong.time({
            width: 'medium'
          });
        case 'ppp':
          return formatLong.time({
            width: 'long'
          });
        case 'pppp':
        default:
          return formatLong.time({
            width: 'full'
          });
      }
    };
    var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
      var matchResult = pattern.match(/(P+)(p+)?/) || [];
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];
      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong);
      }
      var dateTimeFormat;
      switch (datePattern) {
        case 'P':
          dateTimeFormat = formatLong.dateTime({
            width: 'short'
          });
          break;
        case 'PP':
          dateTimeFormat = formatLong.dateTime({
            width: 'medium'
          });
          break;
        case 'PPP':
          dateTimeFormat = formatLong.dateTime({
            width: 'long'
          });
          break;
        case 'PPPP':
        default:
          dateTimeFormat = formatLong.dateTime({
            width: 'full'
          });
          break;
      }
      return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
    };
    var longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };

    var protectedDayOfYearTokens = ['D', 'DD'];
    var protectedWeekYearTokens = ['YY', 'YYYY'];
    function isProtectedDayOfYearToken(token) {
      return protectedDayOfYearTokens.indexOf(token) !== -1;
    }
    function isProtectedWeekYearToken(token) {
      return protectedWeekYearTokens.indexOf(token) !== -1;
    }
    function throwProtectedError(token, format, input) {
      if (token === 'YYYY') {
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'YY') {
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'D') {
        throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      } else if (token === 'DD') {
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
      }
    }

    var formatDistanceLocale$3 = {
      lessThanXSeconds: {
        one: 'less than a second',
        other: 'less than {{count}} seconds'
      },
      xSeconds: {
        one: '1 second',
        other: '{{count}} seconds'
      },
      halfAMinute: 'half a minute',
      lessThanXMinutes: {
        one: 'less than a minute',
        other: 'less than {{count}} minutes'
      },
      xMinutes: {
        one: '1 minute',
        other: '{{count}} minutes'
      },
      aboutXHours: {
        one: 'about 1 hour',
        other: 'about {{count}} hours'
      },
      xHours: {
        one: '1 hour',
        other: '{{count}} hours'
      },
      xDays: {
        one: '1 day',
        other: '{{count}} days'
      },
      aboutXWeeks: {
        one: 'about 1 week',
        other: 'about {{count}} weeks'
      },
      xWeeks: {
        one: '1 week',
        other: '{{count}} weeks'
      },
      aboutXMonths: {
        one: 'about 1 month',
        other: 'about {{count}} months'
      },
      xMonths: {
        one: '1 month',
        other: '{{count}} months'
      },
      aboutXYears: {
        one: 'about 1 year',
        other: 'about {{count}} years'
      },
      xYears: {
        one: '1 year',
        other: '{{count}} years'
      },
      overXYears: {
        one: 'over 1 year',
        other: 'over {{count}} years'
      },
      almostXYears: {
        one: 'almost 1 year',
        other: 'almost {{count}} years'
      }
    };
    var formatDistance$3 = function formatDistance(token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale$3[token];
      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', count.toString());
      }
      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'in ' + result;
        } else {
          return result + ' ago';
        }
      }
      return result;
    };

    function buildFormatLongFn(args) {
      return function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // TODO: Remove String()
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
      };
    }

    var dateFormats$3 = {
      full: 'EEEE, MMMM do, y',
      long: 'MMMM do, y',
      medium: 'MMM d, y',
      short: 'MM/dd/yyyy'
    };
    var timeFormats$3 = {
      full: 'h:mm:ss a zzzz',
      long: 'h:mm:ss a z',
      medium: 'h:mm:ss a',
      short: 'h:mm a'
    };
    var dateTimeFormats$3 = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$3 = {
      date: buildFormatLongFn({
        formats: dateFormats$3,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats$3,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$3,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$3 = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: 'P'
    };
    var formatRelative$3 = function formatRelative(token, _date, _baseDate, _options) {
      return formatRelativeLocale$3[token];
    };

    function buildLocalizeFn(args) {
      return function (dirtyIndex, options) {
        var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
        var valuesArray;
        if (context === 'formatting' && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;
          var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }
        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
        // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
        return valuesArray[index];
      };
    }

    var eraValues$3 = {
      narrow: ['B', 'A'],
      abbreviated: ['BC', 'AD'],
      wide: ['Before Christ', 'Anno Domini']
    };
    var quarterValues$3 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
    };

    // Note: in English, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.
    var monthValues$3 = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    };
    var dayValues$3 = {
      narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
      short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
      abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    };
    var dayPeriodValues$3 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      }
    };
    var formattingDayPeriodValues$2 = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      }
    };
    var ordinalNumber$3 = function ordinalNumber(dirtyNumber, _options) {
      var number = Number(dirtyNumber);

      // If ordinal numbers depend on context, for example,
      // if they are different for different grammatical genders,
      // use `options.unit`.
      //
      // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
      // 'day', 'hour', 'minute', 'second'.

      var rem100 = number % 100;
      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + 'st';
          case 2:
            return number + 'nd';
          case 3:
            return number + 'rd';
        }
      }
      return number + 'th';
    };
    var localize$3 = {
      ordinalNumber: ordinalNumber$3,
      era: buildLocalizeFn({
        values: eraValues$3,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$3,
        defaultWidth: 'wide',
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues$3,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues$3,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$3,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$2,
        defaultFormattingWidth: 'wide'
      })
    };

    function buildMatchFn(args) {
      return function (string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);
        if (!matchResult) {
          return null;
        }
        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
          return pattern.test(matchedString);
        }) : findKey(parsePatterns, function (pattern) {
          return pattern.test(matchedString);
        });
        var value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value: value,
          rest: rest
        };
      };
    }
    function findKey(object, predicate) {
      for (var key in object) {
        if (object.hasOwnProperty(key) && predicate(object[key])) {
          return key;
        }
      }
      return undefined;
    }
    function findIndex(array, predicate) {
      for (var key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }
      return undefined;
    }

    function buildMatchPatternFn(args) {
      return function (string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var matchResult = string.match(args.matchPattern);
        if (!matchResult) return null;
        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);
        if (!parseResult) return null;
        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
          value: value,
          rest: rest
        };
      };
    }

    var matchOrdinalNumberPattern$3 = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern$3 = /\d+/i;
    var matchEraPatterns$3 = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns$3 = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns$3 = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns$3 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$3 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns$3 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$3 = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns$3 = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns$3 = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns$3 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match$3 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$3,
        parsePattern: parseOrdinalNumberPattern$3,
        valueCallback: function valueCallback(value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$3,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$3,
        defaultParseWidth: 'any',
        valueCallback: function valueCallback(index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$3,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$3,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$3,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$3,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$3,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary English locale (United States).
     * @language English
     * @iso-639-2 eng
     * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
     * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
     */
    var locale$3 = {
      code: 'en-US',
      formatDistance: formatDistance$3,
      formatLong: formatLong$3,
      formatRelative: formatRelative$3,
      localize: localize$3,
      match: match$3,
      options: {
        weekStartsOn: 0 /* Sunday */,
        firstWeekContainsDate: 1
      }
    };

    // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
    //   (one of the certain letters followed by `o`)
    // - (\w)\1* matches any sequences of the same letter
    // - '' matches two quote characters in a row
    // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
    //   except a single quote symbol, which ends the sequence.
    //   Two quote characters do not end the sequence.
    //   If there is no matching single quote
    //   then the sequence will continue until the end of the string.
    // - . matches any single character unmatched by previous parts of the RegExps
    var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

    // This RegExp catches symbols escaped by quotes, and also
    // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
    var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp$1 = /^'([^]*?)'?$/;
    var doubleQuoteRegExp$1 = /''/g;
    var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;

    /**
     * @name format
     * @category Common Helpers
     * @summary Format the date.
     *
     * @description
     * Return the formatted date string in the given format. The result may vary by locale.
     *
     * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
     * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * The characters wrapped between two single quotes characters (') are escaped.
     * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
     * (see the last example)
     *
     * Format of the string is based on Unicode Technical Standard #35:
     * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * with a few additions (see note 7 below the table).
     *
     * Accepted patterns:
     * | Unit                            | Pattern | Result examples                   | Notes |
     * |---------------------------------|---------|-----------------------------------|-------|
     * | Era                             | G..GGG  | AD, BC                            |       |
     * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
     * |                                 | GGGGG   | A, B                              |       |
     * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
     * |                                 | yy      | 44, 01, 00, 17                    | 5     |
     * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
     * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
     * |                                 | yyyyy   | ...                               | 3,5   |
     * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
     * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
     * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
     * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
     * |                                 | YYYYY   | ...                               | 3,5   |
     * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
     * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
     * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
     * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
     * |                                 | RRRRR   | ...                               | 3,5,7 |
     * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
     * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
     * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
     * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
     * |                                 | uuuuu   | ...                               | 3,5   |
     * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
     * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | QQ      | 01, 02, 03, 04                    |       |
     * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
     * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
     * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | qq      | 01, 02, 03, 04                    |       |
     * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
     * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
     * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | MM      | 01, 02, ..., 12                   |       |
     * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
     * |                                 | MMMM    | January, February, ..., December  | 2     |
     * |                                 | MMMMM   | J, F, ..., D                      |       |
     * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
     * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | LL      | 01, 02, ..., 12                   |       |
     * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
     * |                                 | LLLL    | January, February, ..., December  | 2     |
     * |                                 | LLLLL   | J, F, ..., D                      |       |
     * | Local week of year              | w       | 1, 2, ..., 53                     |       |
     * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | ww      | 01, 02, ..., 53                   |       |
     * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
     * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | II      | 01, 02, ..., 53                   | 7     |
     * | Day of month                    | d       | 1, 2, ..., 31                     |       |
     * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
     * |                                 | dd      | 01, 02, ..., 31                   |       |
     * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
     * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
     * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
     * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
     * |                                 | DDDD    | ...                               | 3     |
     * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
     * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
     * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
     * |                                 | ii      | 01, 02, ..., 07                   | 7     |
     * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
     * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
     * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
     * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
     * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
     * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | ee      | 02, 03, ..., 01                   |       |
     * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
     * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
     * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | cc      | 02, 03, ..., 01                   |       |
     * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
     * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | AM, PM                          | a..aa   | AM, PM                            |       |
     * |                                 | aaa     | am, pm                            |       |
     * |                                 | aaaa    | a.m., p.m.                        | 2     |
     * |                                 | aaaaa   | a, p                              |       |
     * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
     * |                                 | bbb     | am, pm, noon, midnight            |       |
     * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
     * |                                 | bbbbb   | a, p, n, mi                       |       |
     * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
     * |                                 | BBBB    | at night, in the morning, ...     | 2     |
     * |                                 | BBBBB   | at night, in the morning, ...     |       |
     * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
     * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
     * |                                 | hh      | 01, 02, ..., 11, 12               |       |
     * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
     * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
     * |                                 | HH      | 00, 01, 02, ..., 23               |       |
     * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
     * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
     * |                                 | KK      | 01, 02, ..., 11, 00               |       |
     * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
     * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
     * |                                 | kk      | 24, 01, 02, ..., 23               |       |
     * | Minute                          | m       | 0, 1, ..., 59                     |       |
     * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | mm      | 00, 01, ..., 59                   |       |
     * | Second                          | s       | 0, 1, ..., 59                     |       |
     * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | ss      | 00, 01, ..., 59                   |       |
     * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
     * |                                 | SS      | 00, 01, ..., 99                   |       |
     * |                                 | SSS     | 000, 001, ..., 999                |       |
     * |                                 | SSSS    | ...                               | 3     |
     * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
     * |                                 | XX      | -0800, +0530, Z                   |       |
     * |                                 | XXX     | -08:00, +05:30, Z                 |       |
     * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
     * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
     * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
     * |                                 | xx      | -0800, +0530, +0000               |       |
     * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
     * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
     * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
     * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
     * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
     * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
     * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
     * | Seconds timestamp               | t       | 512969520                         | 7     |
     * |                                 | tt      | ...                               | 3,7   |
     * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
     * |                                 | TT      | ...                               | 3,7   |
     * | Long localized date             | P       | 04/29/1453                        | 7     |
     * |                                 | PP      | Apr 29, 1453                      | 7     |
     * |                                 | PPP     | April 29th, 1453                  | 7     |
     * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
     * | Long localized time             | p       | 12:00 AM                          | 7     |
     * |                                 | pp      | 12:00:00 AM                       | 7     |
     * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
     * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
     * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
     * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
     * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
     * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
     * Notes:
     * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
     *    are the same as "stand-alone" units, but are different in some languages.
     *    "Formatting" units are declined according to the rules of the language
     *    in the context of a date. "Stand-alone" units are always nominative singular:
     *
     *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
     *
     *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
     *
     * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
     *    the single quote characters (see below).
     *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
     *    the output will be the same as default pattern for this unit, usually
     *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
     *    are marked with "2" in the last column of the table.
     *
     *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
     *
     * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
     *    The output will be padded with zeros to match the length of the pattern.
     *
     *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
     *
     * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
     *    These tokens represent the shortest form of the quarter.
     *
     * 5. The main difference between `y` and `u` patterns are B.C. years:
     *
     *    | Year | `y` | `u` |
     *    |------|-----|-----|
     *    | AC 1 |   1 |   1 |
     *    | BC 1 |   1 |   0 |
     *    | BC 2 |   2 |  -1 |
     *
     *    Also `yy` always returns the last two digits of a year,
     *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
     *
     *    | Year | `yy` | `uu` |
     *    |------|------|------|
     *    | 1    |   01 |   01 |
     *    | 14   |   14 |   14 |
     *    | 376  |   76 |  376 |
     *    | 1453 |   53 | 1453 |
     *
     *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
     *    except local week-numbering years are dependent on `options.weekStartsOn`
     *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
     *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
     *
     * 6. Specific non-location timezones are currently unavailable in `date-fns`,
     *    so right now these tokens fall back to GMT timezones.
     *
     * 7. These patterns are not in the Unicode Technical Standard #35:
     *    - `i`: ISO day of week
     *    - `I`: ISO week of year
     *    - `R`: ISO week-numbering year
     *    - `t`: seconds timestamp
     *    - `T`: milliseconds timestamp
     *    - `o`: ordinal number modifier
     *    - `P`: long localized date
     *    - `p`: long localized time
     *
     * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
     *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
     *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * @param {Date|Number} date - the original date
     * @param {String} format - the string of tokens
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
     * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @returns {String} the formatted date string
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `date` must not be Invalid Date
     * @throws {RangeError} `options.locale` must contain `localize` property
     * @throws {RangeError} `options.locale` must contain `formatLong` property
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} format string contains an unescaped latin alphabet character
     *
     * @example
     * // Represent 11 February 2014 in middle-endian format:
     * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
     * //=> '02/11/2014'
     *
     * @example
     * // Represent 2 July 2014 in Esperanto:
     * import { eoLocale } from 'date-fns/locale/eo'
     * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
     *   locale: eoLocale
     * })
     * //=> '2-a de julio 2014'
     *
     * @example
     * // Escape string by single quote characters:
     * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
     * //=> "3 o'clock"
     */

    function format$2(dirtyDate, dirtyFormatStr, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
      requiredArgs(2, arguments);
      var formatStr = String(dirtyFormatStr);
      var defaultOptions = getDefaultOptions();
      var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : locale$3;
      var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

      // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }
      var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

      // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }
      if (!locale.localize) {
        throw new RangeError('locale must contain localize property');
      }
      if (!locale.formatLong) {
        throw new RangeError('locale must contain formatLong property');
      }
      var originalDate = toDate(dirtyDate);
      if (!isValid(originalDate)) {
        throw new RangeError('Invalid time value');
      }

      // Convert the date in system timezone to the same date in UTC+00:00 timezone.
      // This ensures that when UTC functions will be implemented, locales will be compatible with them.
      // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
      var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
      var utcDate = subMilliseconds(originalDate, timezoneOffset);
      var formatterOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale,
        _originalDate: originalDate
      };
      var result = formatStr.match(longFormattingTokensRegExp$1).map(function (substring) {
        var firstCharacter = substring[0];
        if (firstCharacter === 'p' || firstCharacter === 'P') {
          var longFormatter = longFormatters[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }
        return substring;
      }).join('').match(formattingTokensRegExp$1).map(function (substring) {
        // Replace two single quote characters with one single quote character
        if (substring === "''") {
          return "'";
        }
        var firstCharacter = substring[0];
        if (firstCharacter === "'") {
          return cleanEscapedString$1(substring);
        }
        var formatter = formatters[firstCharacter];
        if (formatter) {
          if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
          }
          if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
          }
          return formatter(utcDate, substring, locale.localize, formatterOptions);
        }
        if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        }
        return substring;
      }).join('');
      return result;
    }
    function cleanEscapedString$1(input) {
      var matched = input.match(escapedStringRegExp$1);
      if (!matched) {
        return input;
      }
      return matched[1].replace(doubleQuoteRegExp$1, "'");
    }

    function assign(target, object) {
      if (target == null) {
        throw new TypeError('assign requires that input parameter not be null or undefined');
      }
      for (var property in object) {
        if (Object.prototype.hasOwnProperty.call(object, property)) {
          target[property] = object[property];
        }
      }
      return target;
    }

    /**
     * @name getWeekYear
     * @category Week-Numbering Year Helpers
     * @summary Get the local week-numbering year of the given date.
     *
     * @description
     * Get the local week-numbering year of the given date.
     * The exact calculation depends on the values of
     * `options.weekStartsOn` (which is the index of the first day of the week)
     * and `options.firstWeekContainsDate` (which is the day of January, which is always in
     * the first week of the week-numbering year)
     *
     * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
     *
     * @param {Date|Number} date - the given date
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
     * @returns {Number} the local week-numbering year
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     *
     * @example
     * // Which week numbering year is 26 December 2004 with the default settings?
     * const result = getWeekYear(new Date(2004, 11, 26))
     * //=> 2005
     *
     * @example
     * // Which week numbering year is 26 December 2004 if week starts on Saturday?
     * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
     * //=> 2004
     *
     * @example
     * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
     * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
     * //=> 2004
     */
    function getWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getFullYear();
      var defaultOptions = getDefaultOptions();
      var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);

      // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }
      var firstWeekOfNextYear = new Date(0);
      firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setHours(0, 0, 0, 0);
      var startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
      var firstWeekOfThisYear = new Date(0);
      firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setHours(0, 0, 0, 0);
      var startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    /**
     * @name startOfWeekYear
     * @category Week-Numbering Year Helpers
     * @summary Return the start of a local week-numbering year for the given date.
     *
     * @description
     * Return the start of a local week-numbering year.
     * The exact calculation depends on the values of
     * `options.weekStartsOn` (which is the index of the first day of the week)
     * and `options.firstWeekContainsDate` (which is the day of January, which is always in
     * the first week of the week-numbering year)
     *
     * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
     *
     * @param {Date|Number} date - the original date
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
     * @returns {Date} the start of a week-numbering year
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     *
     * @example
     * // The start of an a week-numbering year for 2 July 2005 with default settings:
     * const result = startOfWeekYear(new Date(2005, 6, 2))
     * //=> Sun Dec 26 2004 00:00:00
     *
     * @example
     * // The start of a week-numbering year for 2 July 2005
     * // if Monday is the first day of week
     * // and 4 January is always in the first week of the year:
     * const result = startOfWeekYear(new Date(2005, 6, 2), {
     *   weekStartsOn: 1,
     *   firstWeekContainsDate: 4
     * })
     * //=> Mon Jan 03 2005 00:00:00
     */
    function startOfWeekYear(dirtyDate, options) {
      var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(1, arguments);
      var defaultOptions = getDefaultOptions();
      var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
      var year = getWeekYear(dirtyDate, options);
      var firstWeek = new Date(0);
      firstWeek.setFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setHours(0, 0, 0, 0);
      var date = startOfWeek(firstWeek, options);
      return date;
    }

    var MILLISECONDS_IN_WEEK = 604800000;

    /**
     * @name getWeek
     * @category Week Helpers
     * @summary Get the local week index of the given date.
     *
     * @description
     * Get the local week index of the given date.
     * The exact calculation depends on the values of
     * `options.weekStartsOn` (which is the index of the first day of the week)
     * and `options.firstWeekContainsDate` (which is the day of January, which is always in
     * the first week of the week-numbering year)
     *
     * Week numbering: https://en.wikipedia.org/wiki/Week#Week_numbering
     *
     * @param {Date|Number} date - the given date
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
     * @returns {Number} the week
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     *
     * @example
     * // Which week of the local week numbering year is 2 January 2005 with default options?
     * const result = getWeek(new Date(2005, 0, 2))
     * //=> 2
     *
     * // Which week of the local week numbering year is 2 January 2005,
     * // if Monday is the first day of the week,
     * // and the first week of the year always contains 4 January?
     * const result = getWeek(new Date(2005, 0, 2), {
     *   weekStartsOn: 1,
     *   firstWeekContainsDate: 4
     * })
     * //=> 53
     */

    function getWeek(dirtyDate, options) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfWeek(date, options).getTime() - startOfWeekYear(date, options).getTime();

      // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)
      return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
          if (it) o = it;
          var i = 0;
          var F = function F() {};
          return {
            s: F,
            n: function n() {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function e(_e) {
              throw _e;
            },
            f: F
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true,
        didErr = false,
        err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function f() {
          try {
            if (!normalCompletion && it["return"] != null) it["return"]();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
          result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }

    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }

    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }

    var TIMEZONE_UNIT_PRIORITY = 10;
    var Setter = /*#__PURE__*/function () {
      function Setter() {
        _classCallCheck(this, Setter);
        _defineProperty(this, "priority", void 0);
        _defineProperty(this, "subPriority", 0);
      }
      _createClass(Setter, [{
        key: "validate",
        value: function validate(_utcDate, _options) {
          return true;
        }
      }]);
      return Setter;
    }();
    var ValueSetter = /*#__PURE__*/function (_Setter) {
      _inherits(ValueSetter, _Setter);
      var _super = _createSuper(ValueSetter);
      function ValueSetter(value, validateValue, setValue, priority, subPriority) {
        var _this;
        _classCallCheck(this, ValueSetter);
        _this = _super.call(this);
        _this.value = value;
        _this.validateValue = validateValue;
        _this.setValue = setValue;
        _this.priority = priority;
        if (subPriority) {
          _this.subPriority = subPriority;
        }
        return _this;
      }
      _createClass(ValueSetter, [{
        key: "validate",
        value: function validate(utcDate, options) {
          return this.validateValue(utcDate, this.value, options);
        }
      }, {
        key: "set",
        value: function set(utcDate, flags, options) {
          return this.setValue(utcDate, flags, this.value, options);
        }
      }]);
      return ValueSetter;
    }(Setter);
    var DateToSystemTimezoneSetter = /*#__PURE__*/function (_Setter2) {
      _inherits(DateToSystemTimezoneSetter, _Setter2);
      var _super2 = _createSuper(DateToSystemTimezoneSetter);
      function DateToSystemTimezoneSetter() {
        var _this2;
        _classCallCheck(this, DateToSystemTimezoneSetter);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this2 = _super2.call.apply(_super2, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
        _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
        return _this2;
      }
      _createClass(DateToSystemTimezoneSetter, [{
        key: "set",
        value: function set(date, flags) {
          if (flags.timestampIsSet) {
            return date;
          }
          var convertedDate = new Date(0);
          convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
          convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
          return convertedDate;
        }
      }]);
      return DateToSystemTimezoneSetter;
    }(Setter);

    var Parser$1 = /*#__PURE__*/function () {
      function Parser() {
        _classCallCheck(this, Parser);
        _defineProperty(this, "incompatibleTokens", void 0);
        _defineProperty(this, "priority", void 0);
        _defineProperty(this, "subPriority", void 0);
      }
      _createClass(Parser, [{
        key: "run",
        value: function run(dateString, token, match, options) {
          var result = this.parse(dateString, token, match, options);
          if (!result) {
            return null;
          }
          return {
            setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
            rest: result.rest
          };
        }
      }, {
        key: "validate",
        value: function validate(_utcDate, _value, _options) {
          return true;
        }
      }]);
      return Parser;
    }();

    var EraParser = /*#__PURE__*/function (_Parser) {
      _inherits(EraParser, _Parser);
      var _super = _createSuper(EraParser);
      function EraParser() {
        var _this;
        _classCallCheck(this, EraParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 140);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);
        return _this;
      }
      _createClass(EraParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            // AD, BC
            case 'G':
            case 'GG':
            case 'GGG':
              return match.era(dateString, {
                width: 'abbreviated'
              }) || match.era(dateString, {
                width: 'narrow'
              });
            // A, B
            case 'GGGGG':
              return match.era(dateString, {
                width: 'narrow'
              });
            // Anno Domini, Before Christ
            case 'GGGG':
            default:
              return match.era(dateString, {
                width: 'wide'
              }) || match.era(dateString, {
                width: 'abbreviated'
              }) || match.era(dateString, {
                width: 'narrow'
              });
          }
        }
      }, {
        key: "set",
        value: function set(date, flags, value) {
          flags.era = value;
          date.setUTCFullYear(value, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return EraParser;
    }(Parser$1);

    var numericPatterns = {
      month: /^(1[0-2]|0?\d)/,
      // 0 to 12
      date: /^(3[0-1]|[0-2]?\d)/,
      // 0 to 31
      dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
      // 0 to 366
      week: /^(5[0-3]|[0-4]?\d)/,
      // 0 to 53
      hour23h: /^(2[0-3]|[0-1]?\d)/,
      // 0 to 23
      hour24h: /^(2[0-4]|[0-1]?\d)/,
      // 0 to 24
      hour11h: /^(1[0-1]|0?\d)/,
      // 0 to 11
      hour12h: /^(1[0-2]|0?\d)/,
      // 0 to 12
      minute: /^[0-5]?\d/,
      // 0 to 59
      second: /^[0-5]?\d/,
      // 0 to 59

      singleDigit: /^\d/,
      // 0 to 9
      twoDigits: /^\d{1,2}/,
      // 0 to 99
      threeDigits: /^\d{1,3}/,
      // 0 to 999
      fourDigits: /^\d{1,4}/,
      // 0 to 9999

      anyDigitsSigned: /^-?\d+/,
      singleDigitSigned: /^-?\d/,
      // 0 to 9, -0 to -9
      twoDigitsSigned: /^-?\d{1,2}/,
      // 0 to 99, -0 to -99
      threeDigitsSigned: /^-?\d{1,3}/,
      // 0 to 999, -0 to -999
      fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999
    };

    var timezonePatterns = {
      basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
      basic: /^([+-])(\d{2})(\d{2})|Z/,
      basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
      extended: /^([+-])(\d{2}):(\d{2})|Z/,
      extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
    };

    function mapValue(parseFnResult, mapFn) {
      if (!parseFnResult) {
        return parseFnResult;
      }
      return {
        value: mapFn(parseFnResult.value),
        rest: parseFnResult.rest
      };
    }
    function parseNumericPattern(pattern, dateString) {
      var matchResult = dateString.match(pattern);
      if (!matchResult) {
        return null;
      }
      return {
        value: parseInt(matchResult[0], 10),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseTimezonePattern(pattern, dateString) {
      var matchResult = dateString.match(pattern);
      if (!matchResult) {
        return null;
      }

      // Input is 'Z'
      if (matchResult[0] === 'Z') {
        return {
          value: 0,
          rest: dateString.slice(1)
        };
      }
      var sign = matchResult[1] === '+' ? 1 : -1;
      var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
      var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
      var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
      return {
        value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
        rest: dateString.slice(matchResult[0].length)
      };
    }
    function parseAnyDigitsSigned(dateString) {
      return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
    }
    function parseNDigits(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(numericPatterns.singleDigit, dateString);
        case 2:
          return parseNumericPattern(numericPatterns.twoDigits, dateString);
        case 3:
          return parseNumericPattern(numericPatterns.threeDigits, dateString);
        case 4:
          return parseNumericPattern(numericPatterns.fourDigits, dateString);
        default:
          return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
      }
    }
    function parseNDigitsSigned(n, dateString) {
      switch (n) {
        case 1:
          return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
        case 2:
          return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
        case 3:
          return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
        case 4:
          return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
        default:
          return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
      }
    }
    function dayPeriodEnumToHours(dayPeriod) {
      switch (dayPeriod) {
        case 'morning':
          return 4;
        case 'evening':
          return 17;
        case 'pm':
        case 'noon':
        case 'afternoon':
          return 12;
        case 'am':
        case 'midnight':
        case 'night':
        default:
          return 0;
      }
    }
    function normalizeTwoDigitYear(twoDigitYear, currentYear) {
      var isCommonEra = currentYear > 0;
      // Absolute number of the current year:
      // 1 -> 1 AC
      // 0 -> 1 BC
      // -1 -> 2 BC
      var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
      var result;
      if (absCurrentYear <= 50) {
        result = twoDigitYear || 100;
      } else {
        var rangeEnd = absCurrentYear + 50;
        var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
        var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
        result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
      }
      return isCommonEra ? result : 1 - result;
    }
    function isLeapYearIndex$1(year) {
      return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
    }

    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var YearParser = /*#__PURE__*/function (_Parser) {
      _inherits(YearParser, _Parser);
      var _super = _createSuper(YearParser);
      function YearParser() {
        var _this;
        _classCallCheck(this, YearParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
        return _this;
      }
      _createClass(YearParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          var valueCallback = function valueCallback(year) {
            return {
              year: year,
              isTwoDigitYear: token === 'yy'
            };
          };
          switch (token) {
            case 'y':
              return mapValue(parseNDigits(4, dateString), valueCallback);
            case 'yo':
              return mapValue(match.ordinalNumber(dateString, {
                unit: 'year'
              }), valueCallback);
            default:
              return mapValue(parseNDigits(token.length, dateString), valueCallback);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value.isTwoDigitYear || value.year > 0;
        }
      }, {
        key: "set",
        value: function set(date, flags, value) {
          var currentYear = date.getUTCFullYear();
          if (value.isTwoDigitYear) {
            var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
            date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
            date.setUTCHours(0, 0, 0, 0);
            return date;
          }
          var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
          date.setUTCFullYear(year, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return YearParser;
    }(Parser$1);

    // Local week-numbering year
    var LocalWeekYearParser = /*#__PURE__*/function (_Parser) {
      _inherits(LocalWeekYearParser, _Parser);
      var _super = _createSuper(LocalWeekYearParser);
      function LocalWeekYearParser() {
        var _this;
        _classCallCheck(this, LocalWeekYearParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
        return _this;
      }
      _createClass(LocalWeekYearParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          var valueCallback = function valueCallback(year) {
            return {
              year: year,
              isTwoDigitYear: token === 'YY'
            };
          };
          switch (token) {
            case 'Y':
              return mapValue(parseNDigits(4, dateString), valueCallback);
            case 'Yo':
              return mapValue(match.ordinalNumber(dateString, {
                unit: 'year'
              }), valueCallback);
            default:
              return mapValue(parseNDigits(token.length, dateString), valueCallback);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value.isTwoDigitYear || value.year > 0;
        }
      }, {
        key: "set",
        value: function set(date, flags, value, options) {
          var currentYear = getUTCWeekYear(date, options);
          if (value.isTwoDigitYear) {
            var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
            date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
            date.setUTCHours(0, 0, 0, 0);
            return startOfUTCWeek(date, options);
          }
          var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
          date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
          date.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek(date, options);
        }
      }]);
      return LocalWeekYearParser;
    }(Parser$1);

    var ISOWeekYearParser = /*#__PURE__*/function (_Parser) {
      _inherits(ISOWeekYearParser, _Parser);
      var _super = _createSuper(ISOWeekYearParser);
      function ISOWeekYearParser() {
        var _this;
        _classCallCheck(this, ISOWeekYearParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
        return _this;
      }
      _createClass(ISOWeekYearParser, [{
        key: "parse",
        value: function parse(dateString, token) {
          if (token === 'R') {
            return parseNDigitsSigned(4, dateString);
          }
          return parseNDigitsSigned(token.length, dateString);
        }
      }, {
        key: "set",
        value: function set(_date, _flags, value) {
          var firstWeekOfYear = new Date(0);
          firstWeekOfYear.setUTCFullYear(value, 0, 4);
          firstWeekOfYear.setUTCHours(0, 0, 0, 0);
          return startOfUTCISOWeek(firstWeekOfYear);
        }
      }]);
      return ISOWeekYearParser;
    }(Parser$1);

    var ExtendedYearParser = /*#__PURE__*/function (_Parser) {
      _inherits(ExtendedYearParser, _Parser);
      var _super = _createSuper(ExtendedYearParser);
      function ExtendedYearParser() {
        var _this;
        _classCallCheck(this, ExtendedYearParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
        return _this;
      }
      _createClass(ExtendedYearParser, [{
        key: "parse",
        value: function parse(dateString, token) {
          if (token === 'u') {
            return parseNDigitsSigned(4, dateString);
          }
          return parseNDigitsSigned(token.length, dateString);
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCFullYear(value, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return ExtendedYearParser;
    }(Parser$1);

    var QuarterParser = /*#__PURE__*/function (_Parser) {
      _inherits(QuarterParser, _Parser);
      var _super = _createSuper(QuarterParser);
      function QuarterParser() {
        var _this;
        _classCallCheck(this, QuarterParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 120);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
        return _this;
      }
      _createClass(QuarterParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            // 1, 2, 3, 4
            case 'Q':
            case 'QQ':
              // 01, 02, 03, 04
              return parseNDigits(token.length, dateString);
            // 1st, 2nd, 3rd, 4th
            case 'Qo':
              return match.ordinalNumber(dateString, {
                unit: 'quarter'
              });
            // Q1, Q2, Q3, Q4
            case 'QQQ':
              return match.quarter(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.quarter(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case 'QQQQQ':
              return match.quarter(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            // 1st quarter, 2nd quarter, ...
            case 'QQQQ':
            default:
              return match.quarter(dateString, {
                width: 'wide',
                context: 'formatting'
              }) || match.quarter(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.quarter(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 4;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCMonth((value - 1) * 3, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return QuarterParser;
    }(Parser$1);

    var StandAloneQuarterParser = /*#__PURE__*/function (_Parser) {
      _inherits(StandAloneQuarterParser, _Parser);
      var _super = _createSuper(StandAloneQuarterParser);
      function StandAloneQuarterParser() {
        var _this;
        _classCallCheck(this, StandAloneQuarterParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 120);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
        return _this;
      }
      _createClass(StandAloneQuarterParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            // 1, 2, 3, 4
            case 'q':
            case 'qq':
              // 01, 02, 03, 04
              return parseNDigits(token.length, dateString);
            // 1st, 2nd, 3rd, 4th
            case 'qo':
              return match.ordinalNumber(dateString, {
                unit: 'quarter'
              });
            // Q1, Q2, Q3, Q4
            case 'qqq':
              return match.quarter(dateString, {
                width: 'abbreviated',
                context: 'standalone'
              }) || match.quarter(dateString, {
                width: 'narrow',
                context: 'standalone'
              });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case 'qqqqq':
              return match.quarter(dateString, {
                width: 'narrow',
                context: 'standalone'
              });
            // 1st quarter, 2nd quarter, ...
            case 'qqqq':
            default:
              return match.quarter(dateString, {
                width: 'wide',
                context: 'standalone'
              }) || match.quarter(dateString, {
                width: 'abbreviated',
                context: 'standalone'
              }) || match.quarter(dateString, {
                width: 'narrow',
                context: 'standalone'
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 4;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCMonth((value - 1) * 3, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return StandAloneQuarterParser;
    }(Parser$1);

    var MonthParser = /*#__PURE__*/function (_Parser) {
      _inherits(MonthParser, _Parser);
      var _super = _createSuper(MonthParser);
      function MonthParser() {
        var _this;
        _classCallCheck(this, MonthParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
        _defineProperty(_assertThisInitialized(_this), "priority", 110);
        return _this;
      }
      _createClass(MonthParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          var valueCallback = function valueCallback(value) {
            return value - 1;
          };
          switch (token) {
            // 1, 2, ..., 12
            case 'M':
              return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
            // 01, 02, ..., 12
            case 'MM':
              return mapValue(parseNDigits(2, dateString), valueCallback);
            // 1st, 2nd, ..., 12th
            case 'Mo':
              return mapValue(match.ordinalNumber(dateString, {
                unit: 'month'
              }), valueCallback);
            // Jan, Feb, ..., Dec
            case 'MMM':
              return match.month(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.month(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            // J, F, ..., D
            case 'MMMMM':
              return match.month(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            // January, February, ..., December
            case 'MMMM':
            default:
              return match.month(dateString, {
                width: 'wide',
                context: 'formatting'
              }) || match.month(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.month(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCMonth(value, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return MonthParser;
    }(Parser$1);

    var StandAloneMonthParser = /*#__PURE__*/function (_Parser) {
      _inherits(StandAloneMonthParser, _Parser);
      var _super = _createSuper(StandAloneMonthParser);
      function StandAloneMonthParser() {
        var _this;
        _classCallCheck(this, StandAloneMonthParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 110);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
        return _this;
      }
      _createClass(StandAloneMonthParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          var valueCallback = function valueCallback(value) {
            return value - 1;
          };
          switch (token) {
            // 1, 2, ..., 12
            case 'L':
              return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
            // 01, 02, ..., 12
            case 'LL':
              return mapValue(parseNDigits(2, dateString), valueCallback);
            // 1st, 2nd, ..., 12th
            case 'Lo':
              return mapValue(match.ordinalNumber(dateString, {
                unit: 'month'
              }), valueCallback);
            // Jan, Feb, ..., Dec
            case 'LLL':
              return match.month(dateString, {
                width: 'abbreviated',
                context: 'standalone'
              }) || match.month(dateString, {
                width: 'narrow',
                context: 'standalone'
              });
            // J, F, ..., D
            case 'LLLLL':
              return match.month(dateString, {
                width: 'narrow',
                context: 'standalone'
              });
            // January, February, ..., December
            case 'LLLL':
            default:
              return match.month(dateString, {
                width: 'wide',
                context: 'standalone'
              }) || match.month(dateString, {
                width: 'abbreviated',
                context: 'standalone'
              }) || match.month(dateString, {
                width: 'narrow',
                context: 'standalone'
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCMonth(value, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return StandAloneMonthParser;
    }(Parser$1);

    function setUTCWeek(dirtyDate, dirtyWeek, options) {
      requiredArgs(2, arguments);
      var date = toDate(dirtyDate);
      var week = toInteger(dirtyWeek);
      var diff = getUTCWeek(date, options) - week;
      date.setUTCDate(date.getUTCDate() - diff * 7);
      return date;
    }

    var LocalWeekParser = /*#__PURE__*/function (_Parser) {
      _inherits(LocalWeekParser, _Parser);
      var _super = _createSuper(LocalWeekParser);
      function LocalWeekParser() {
        var _this;
        _classCallCheck(this, LocalWeekParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 100);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
        return _this;
      }
      _createClass(LocalWeekParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'w':
              return parseNumericPattern(numericPatterns.week, dateString);
            case 'wo':
              return match.ordinalNumber(dateString, {
                unit: 'week'
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 53;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value, options) {
          return startOfUTCWeek(setUTCWeek(date, value, options), options);
        }
      }]);
      return LocalWeekParser;
    }(Parser$1);

    function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
      requiredArgs(2, arguments);
      var date = toDate(dirtyDate);
      var isoWeek = toInteger(dirtyISOWeek);
      var diff = getUTCISOWeek(date) - isoWeek;
      date.setUTCDate(date.getUTCDate() - diff * 7);
      return date;
    }

    var ISOWeekParser = /*#__PURE__*/function (_Parser) {
      _inherits(ISOWeekParser, _Parser);
      var _super = _createSuper(ISOWeekParser);
      function ISOWeekParser() {
        var _this;
        _classCallCheck(this, ISOWeekParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 100);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
        return _this;
      }
      _createClass(ISOWeekParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'I':
              return parseNumericPattern(numericPatterns.week, dateString);
            case 'Io':
              return match.ordinalNumber(dateString, {
                unit: 'week'
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 53;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          return startOfUTCISOWeek(setUTCISOWeek(date, value));
        }
      }]);
      return ISOWeekParser;
    }(Parser$1);

    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

    // Day of the month
    var DateParser = /*#__PURE__*/function (_Parser) {
      _inherits(DateParser, _Parser);
      var _super = _createSuper(DateParser);
      function DateParser() {
        var _this;
        _classCallCheck(this, DateParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
        return _this;
      }
      _createClass(DateParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'd':
              return parseNumericPattern(numericPatterns.date, dateString);
            case 'do':
              return match.ordinalNumber(dateString, {
                unit: 'date'
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(date, value) {
          var year = date.getUTCFullYear();
          var isLeapYear = isLeapYearIndex$1(year);
          var month = date.getUTCMonth();
          if (isLeapYear) {
            return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
          } else {
            return value >= 1 && value <= DAYS_IN_MONTH[month];
          }
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCDate(value);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return DateParser;
    }(Parser$1);

    var DayOfYearParser = /*#__PURE__*/function (_Parser) {
      _inherits(DayOfYearParser, _Parser);
      var _super = _createSuper(DayOfYearParser);
      function DayOfYearParser() {
        var _this;
        _classCallCheck(this, DayOfYearParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);
        return _this;
      }
      _createClass(DayOfYearParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'D':
            case 'DD':
              return parseNumericPattern(numericPatterns.dayOfYear, dateString);
            case 'Do':
              return match.ordinalNumber(dateString, {
                unit: 'date'
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(date, value) {
          var year = date.getUTCFullYear();
          var isLeapYear = isLeapYearIndex$1(year);
          if (isLeapYear) {
            return value >= 1 && value <= 366;
          } else {
            return value >= 1 && value <= 365;
          }
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCMonth(0, value);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return DayOfYearParser;
    }(Parser$1);

    function setUTCDay(dirtyDate, dirtyDay, options) {
      var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
      requiredArgs(2, arguments);
      var defaultOptions = getDefaultOptions();
      var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

      // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }
      var date = toDate(dirtyDate);
      var day = toInteger(dirtyDay);
      var currentDay = date.getUTCDay();
      var remainder = day % 7;
      var dayIndex = (remainder + 7) % 7;
      var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date;
    }

    var DayParser = /*#__PURE__*/function (_Parser) {
      _inherits(DayParser, _Parser);
      var _super = _createSuper(DayParser);
      function DayParser() {
        var _this;
        _classCallCheck(this, DayParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);
        return _this;
      }
      _createClass(DayParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            // Tue
            case 'E':
            case 'EE':
            case 'EEE':
              return match.day(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'short',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            // T
            case 'EEEEE':
              return match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            // Tu
            case 'EEEEEE':
              return match.day(dateString, {
                width: 'short',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            // Tuesday
            case 'EEEE':
            default:
              return match.day(dateString, {
                width: 'wide',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'short',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value, options) {
          date = setUTCDay(date, value, options);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return DayParser;
    }(Parser$1);

    var LocalDayParser = /*#__PURE__*/function (_Parser) {
      _inherits(LocalDayParser, _Parser);
      var _super = _createSuper(LocalDayParser);
      function LocalDayParser() {
        var _this;
        _classCallCheck(this, LocalDayParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);
        return _this;
      }
      _createClass(LocalDayParser, [{
        key: "parse",
        value: function parse(dateString, token, match, options) {
          var valueCallback = function valueCallback(value) {
            var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
          };
          switch (token) {
            // 3
            case 'e':
            case 'ee':
              // 03
              return mapValue(parseNDigits(token.length, dateString), valueCallback);
            // 3rd
            case 'eo':
              return mapValue(match.ordinalNumber(dateString, {
                unit: 'day'
              }), valueCallback);
            // Tue
            case 'eee':
              return match.day(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'short',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            // T
            case 'eeeee':
              return match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            // Tu
            case 'eeeeee':
              return match.day(dateString, {
                width: 'short',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            // Tuesday
            case 'eeee':
            default:
              return match.day(dateString, {
                width: 'wide',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'short',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value, options) {
          date = setUTCDay(date, value, options);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return LocalDayParser;
    }(Parser$1);

    var StandAloneLocalDayParser = /*#__PURE__*/function (_Parser) {
      _inherits(StandAloneLocalDayParser, _Parser);
      var _super = _createSuper(StandAloneLocalDayParser);
      function StandAloneLocalDayParser() {
        var _this;
        _classCallCheck(this, StandAloneLocalDayParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);
        return _this;
      }
      _createClass(StandAloneLocalDayParser, [{
        key: "parse",
        value: function parse(dateString, token, match, options) {
          var valueCallback = function valueCallback(value) {
            var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
          };
          switch (token) {
            // 3
            case 'c':
            case 'cc':
              // 03
              return mapValue(parseNDigits(token.length, dateString), valueCallback);
            // 3rd
            case 'co':
              return mapValue(match.ordinalNumber(dateString, {
                unit: 'day'
              }), valueCallback);
            // Tue
            case 'ccc':
              return match.day(dateString, {
                width: 'abbreviated',
                context: 'standalone'
              }) || match.day(dateString, {
                width: 'short',
                context: 'standalone'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'standalone'
              });
            // T
            case 'ccccc':
              return match.day(dateString, {
                width: 'narrow',
                context: 'standalone'
              });
            // Tu
            case 'cccccc':
              return match.day(dateString, {
                width: 'short',
                context: 'standalone'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'standalone'
              });
            // Tuesday
            case 'cccc':
            default:
              return match.day(dateString, {
                width: 'wide',
                context: 'standalone'
              }) || match.day(dateString, {
                width: 'abbreviated',
                context: 'standalone'
              }) || match.day(dateString, {
                width: 'short',
                context: 'standalone'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'standalone'
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value, options) {
          date = setUTCDay(date, value, options);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return StandAloneLocalDayParser;
    }(Parser$1);

    function setUTCISODay(dirtyDate, dirtyDay) {
      requiredArgs(2, arguments);
      var day = toInteger(dirtyDay);
      if (day % 7 === 0) {
        day = day - 7;
      }
      var weekStartsOn = 1;
      var date = toDate(dirtyDate);
      var currentDay = date.getUTCDay();
      var remainder = day % 7;
      var dayIndex = (remainder + 7) % 7;
      var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date;
    }

    var ISODayParser = /*#__PURE__*/function (_Parser) {
      _inherits(ISODayParser, _Parser);
      var _super = _createSuper(ISODayParser);
      function ISODayParser() {
        var _this;
        _classCallCheck(this, ISODayParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);
        return _this;
      }
      _createClass(ISODayParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          var valueCallback = function valueCallback(value) {
            if (value === 0) {
              return 7;
            }
            return value;
          };
          switch (token) {
            // 2
            case 'i':
            case 'ii':
              // 02
              return parseNDigits(token.length, dateString);
            // 2nd
            case 'io':
              return match.ordinalNumber(dateString, {
                unit: 'day'
              });
            // Tue
            case 'iii':
              return mapValue(match.day(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'short',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              }), valueCallback);
            // T
            case 'iiiii':
              return mapValue(match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              }), valueCallback);
            // Tu
            case 'iiiiii':
              return mapValue(match.day(dateString, {
                width: 'short',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              }), valueCallback);
            // Tuesday
            case 'iiii':
            default:
              return mapValue(match.day(dateString, {
                width: 'wide',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'short',
                context: 'formatting'
              }) || match.day(dateString, {
                width: 'narrow',
                context: 'formatting'
              }), valueCallback);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 7;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date = setUTCISODay(date, value);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return ISODayParser;
    }(Parser$1);

    var AMPMParser = /*#__PURE__*/function (_Parser) {
      _inherits(AMPMParser, _Parser);
      var _super = _createSuper(AMPMParser);
      function AMPMParser() {
        var _this;
        _classCallCheck(this, AMPMParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);
        return _this;
      }
      _createClass(AMPMParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'a':
            case 'aa':
            case 'aaa':
              return match.dayPeriod(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.dayPeriod(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            case 'aaaaa':
              return match.dayPeriod(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            case 'aaaa':
            default:
              return match.dayPeriod(dateString, {
                width: 'wide',
                context: 'formatting'
              }) || match.dayPeriod(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.dayPeriod(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
          }
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date;
        }
      }]);
      return AMPMParser;
    }(Parser$1);

    var AMPMMidnightParser = /*#__PURE__*/function (_Parser) {
      _inherits(AMPMMidnightParser, _Parser);
      var _super = _createSuper(AMPMMidnightParser);
      function AMPMMidnightParser() {
        var _this;
        _classCallCheck(this, AMPMMidnightParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);
        return _this;
      }
      _createClass(AMPMMidnightParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'b':
            case 'bb':
            case 'bbb':
              return match.dayPeriod(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.dayPeriod(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            case 'bbbbb':
              return match.dayPeriod(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            case 'bbbb':
            default:
              return match.dayPeriod(dateString, {
                width: 'wide',
                context: 'formatting'
              }) || match.dayPeriod(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.dayPeriod(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
          }
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date;
        }
      }]);
      return AMPMMidnightParser;
    }(Parser$1);

    var DayPeriodParser = /*#__PURE__*/function (_Parser) {
      _inherits(DayPeriodParser, _Parser);
      var _super = _createSuper(DayPeriodParser);
      function DayPeriodParser() {
        var _this;
        _classCallCheck(this, DayPeriodParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);
        return _this;
      }
      _createClass(DayPeriodParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'B':
            case 'BB':
            case 'BBB':
              return match.dayPeriod(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.dayPeriod(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            case 'BBBBB':
              return match.dayPeriod(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
            case 'BBBB':
            default:
              return match.dayPeriod(dateString, {
                width: 'wide',
                context: 'formatting'
              }) || match.dayPeriod(dateString, {
                width: 'abbreviated',
                context: 'formatting'
              }) || match.dayPeriod(dateString, {
                width: 'narrow',
                context: 'formatting'
              });
          }
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date;
        }
      }]);
      return DayPeriodParser;
    }(Parser$1);

    var Hour1to12Parser = /*#__PURE__*/function (_Parser) {
      _inherits(Hour1to12Parser, _Parser);
      var _super = _createSuper(Hour1to12Parser);
      function Hour1to12Parser() {
        var _this;
        _classCallCheck(this, Hour1to12Parser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);
        return _this;
      }
      _createClass(Hour1to12Parser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'h':
              return parseNumericPattern(numericPatterns.hour12h, dateString);
            case 'ho':
              return match.ordinalNumber(dateString, {
                unit: 'hour'
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 12;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          var isPM = date.getUTCHours() >= 12;
          if (isPM && value < 12) {
            date.setUTCHours(value + 12, 0, 0, 0);
          } else if (!isPM && value === 12) {
            date.setUTCHours(0, 0, 0, 0);
          } else {
            date.setUTCHours(value, 0, 0, 0);
          }
          return date;
        }
      }]);
      return Hour1to12Parser;
    }(Parser$1);

    var Hour0to23Parser = /*#__PURE__*/function (_Parser) {
      _inherits(Hour0to23Parser, _Parser);
      var _super = _createSuper(Hour0to23Parser);
      function Hour0to23Parser() {
        var _this;
        _classCallCheck(this, Hour0to23Parser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);
        return _this;
      }
      _createClass(Hour0to23Parser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'H':
              return parseNumericPattern(numericPatterns.hour23h, dateString);
            case 'Ho':
              return match.ordinalNumber(dateString, {
                unit: 'hour'
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 23;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCHours(value, 0, 0, 0);
          return date;
        }
      }]);
      return Hour0to23Parser;
    }(Parser$1);

    var Hour0To11Parser = /*#__PURE__*/function (_Parser) {
      _inherits(Hour0To11Parser, _Parser);
      var _super = _createSuper(Hour0To11Parser);
      function Hour0To11Parser() {
        var _this;
        _classCallCheck(this, Hour0To11Parser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);
        return _this;
      }
      _createClass(Hour0To11Parser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'K':
              return parseNumericPattern(numericPatterns.hour11h, dateString);
            case 'Ko':
              return match.ordinalNumber(dateString, {
                unit: 'hour'
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          var isPM = date.getUTCHours() >= 12;
          if (isPM && value < 12) {
            date.setUTCHours(value + 12, 0, 0, 0);
          } else {
            date.setUTCHours(value, 0, 0, 0);
          }
          return date;
        }
      }]);
      return Hour0To11Parser;
    }(Parser$1);

    var Hour1To24Parser = /*#__PURE__*/function (_Parser) {
      _inherits(Hour1To24Parser, _Parser);
      var _super = _createSuper(Hour1To24Parser);
      function Hour1To24Parser() {
        var _this;
        _classCallCheck(this, Hour1To24Parser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);
        return _this;
      }
      _createClass(Hour1To24Parser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'k':
              return parseNumericPattern(numericPatterns.hour24h, dateString);
            case 'ko':
              return match.ordinalNumber(dateString, {
                unit: 'hour'
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 24;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          var hours = value <= 24 ? value % 24 : value;
          date.setUTCHours(hours, 0, 0, 0);
          return date;
        }
      }]);
      return Hour1To24Parser;
    }(Parser$1);

    var MinuteParser = /*#__PURE__*/function (_Parser) {
      _inherits(MinuteParser, _Parser);
      var _super = _createSuper(MinuteParser);
      function MinuteParser() {
        var _this;
        _classCallCheck(this, MinuteParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 60);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
        return _this;
      }
      _createClass(MinuteParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 'm':
              return parseNumericPattern(numericPatterns.minute, dateString);
            case 'mo':
              return match.ordinalNumber(dateString, {
                unit: 'minute'
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 59;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCMinutes(value, 0, 0);
          return date;
        }
      }]);
      return MinuteParser;
    }(Parser$1);

    var SecondParser = /*#__PURE__*/function (_Parser) {
      _inherits(SecondParser, _Parser);
      var _super = _createSuper(SecondParser);
      function SecondParser() {
        var _this;
        _classCallCheck(this, SecondParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 50);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
        return _this;
      }
      _createClass(SecondParser, [{
        key: "parse",
        value: function parse(dateString, token, match) {
          switch (token) {
            case 's':
              return parseNumericPattern(numericPatterns.second, dateString);
            case 'so':
              return match.ordinalNumber(dateString, {
                unit: 'second'
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 59;
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCSeconds(value, 0);
          return date;
        }
      }]);
      return SecondParser;
    }(Parser$1);

    var FractionOfSecondParser = /*#__PURE__*/function (_Parser) {
      _inherits(FractionOfSecondParser, _Parser);
      var _super = _createSuper(FractionOfSecondParser);
      function FractionOfSecondParser() {
        var _this;
        _classCallCheck(this, FractionOfSecondParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 30);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
        return _this;
      }
      _createClass(FractionOfSecondParser, [{
        key: "parse",
        value: function parse(dateString, token) {
          var valueCallback = function valueCallback(value) {
            return Math.floor(value * Math.pow(10, -token.length + 3));
          };
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        }
      }, {
        key: "set",
        value: function set(date, _flags, value) {
          date.setUTCMilliseconds(value);
          return date;
        }
      }]);
      return FractionOfSecondParser;
    }(Parser$1);

    var ISOTimezoneWithZParser = /*#__PURE__*/function (_Parser) {
      _inherits(ISOTimezoneWithZParser, _Parser);
      var _super = _createSuper(ISOTimezoneWithZParser);
      function ISOTimezoneWithZParser() {
        var _this;
        _classCallCheck(this, ISOTimezoneWithZParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 10);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T', 'x']);
        return _this;
      }
      _createClass(ISOTimezoneWithZParser, [{
        key: "parse",
        value: function parse(dateString, token) {
          switch (token) {
            case 'X':
              return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
            case 'XX':
              return parseTimezonePattern(timezonePatterns.basic, dateString);
            case 'XXXX':
              return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
            case 'XXXXX':
              return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
            case 'XXX':
            default:
              return parseTimezonePattern(timezonePatterns.extended, dateString);
          }
        }
      }, {
        key: "set",
        value: function set(date, flags, value) {
          if (flags.timestampIsSet) {
            return date;
          }
          return new Date(date.getTime() - value);
        }
      }]);
      return ISOTimezoneWithZParser;
    }(Parser$1);

    var ISOTimezoneParser = /*#__PURE__*/function (_Parser) {
      _inherits(ISOTimezoneParser, _Parser);
      var _super = _createSuper(ISOTimezoneParser);
      function ISOTimezoneParser() {
        var _this;
        _classCallCheck(this, ISOTimezoneParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 10);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T', 'X']);
        return _this;
      }
      _createClass(ISOTimezoneParser, [{
        key: "parse",
        value: function parse(dateString, token) {
          switch (token) {
            case 'x':
              return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
            case 'xx':
              return parseTimezonePattern(timezonePatterns.basic, dateString);
            case 'xxxx':
              return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
            case 'xxxxx':
              return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
            case 'xxx':
            default:
              return parseTimezonePattern(timezonePatterns.extended, dateString);
          }
        }
      }, {
        key: "set",
        value: function set(date, flags, value) {
          if (flags.timestampIsSet) {
            return date;
          }
          return new Date(date.getTime() - value);
        }
      }]);
      return ISOTimezoneParser;
    }(Parser$1);

    var TimestampSecondsParser = /*#__PURE__*/function (_Parser) {
      _inherits(TimestampSecondsParser, _Parser);
      var _super = _createSuper(TimestampSecondsParser);
      function TimestampSecondsParser() {
        var _this;
        _classCallCheck(this, TimestampSecondsParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 40);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');
        return _this;
      }
      _createClass(TimestampSecondsParser, [{
        key: "parse",
        value: function parse(dateString) {
          return parseAnyDigitsSigned(dateString);
        }
      }, {
        key: "set",
        value: function set(_date, _flags, value) {
          return [new Date(value * 1000), {
            timestampIsSet: true
          }];
        }
      }]);
      return TimestampSecondsParser;
    }(Parser$1);

    var TimestampMillisecondsParser = /*#__PURE__*/function (_Parser) {
      _inherits(TimestampMillisecondsParser, _Parser);
      var _super = _createSuper(TimestampMillisecondsParser);
      function TimestampMillisecondsParser() {
        var _this;
        _classCallCheck(this, TimestampMillisecondsParser);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 20);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');
        return _this;
      }
      _createClass(TimestampMillisecondsParser, [{
        key: "parse",
        value: function parse(dateString) {
          return parseAnyDigitsSigned(dateString);
        }
      }, {
        key: "set",
        value: function set(_date, _flags, value) {
          return [new Date(value), {
            timestampIsSet: true
          }];
        }
      }]);
      return TimestampMillisecondsParser;
    }(Parser$1);

    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* | Milliseconds in day            |
     * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
     * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
     * |  d  | Day of month                   |  D  | Day of year                    |
     * |  e  | Local day of week              |  E  | Day of week                    |
     * |  f  |                                |  F* | Day of week in month           |
     * |  g* | Modified Julian day            |  G  | Era                            |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  i! | ISO day of week                |  I! | ISO week of year               |
     * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
     * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
     * |  l* | (deprecated)                   |  L  | Stand-alone month              |
     * |  m  | Minute                         |  M  | Month                          |
     * |  n  |                                |  N  |                                |
     * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
     * |  p  |                                |  P  |                                |
     * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
     * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
     * |  u  | Extended year                  |  U* | Cyclic year                    |
     * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
     * |  w  | Local week of year             |  W* | Week of month                  |
     * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
     * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
     * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     *
     * Letters marked by ! are non-standard, but implemented by date-fns:
     * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
     * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
     *   i.e. 7 for Sunday, 1 for Monday, etc.
     * - `I` is ISO week of year, as opposed to `w` which is local week of year.
     * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
     *   `R` is supposed to be used in conjunction with `I` and `i`
     *   for universal ISO week-numbering date, whereas
     *   `Y` is supposed to be used in conjunction with `w` and `e`
     *   for week-numbering date specific to the locale.
     */
    var parsers = {
      G: new EraParser(),
      y: new YearParser(),
      Y: new LocalWeekYearParser(),
      R: new ISOWeekYearParser(),
      u: new ExtendedYearParser(),
      Q: new QuarterParser(),
      q: new StandAloneQuarterParser(),
      M: new MonthParser(),
      L: new StandAloneMonthParser(),
      w: new LocalWeekParser(),
      I: new ISOWeekParser(),
      d: new DateParser(),
      D: new DayOfYearParser(),
      E: new DayParser(),
      e: new LocalDayParser(),
      c: new StandAloneLocalDayParser(),
      i: new ISODayParser(),
      a: new AMPMParser(),
      b: new AMPMMidnightParser(),
      B: new DayPeriodParser(),
      h: new Hour1to12Parser(),
      H: new Hour0to23Parser(),
      K: new Hour0To11Parser(),
      k: new Hour1To24Parser(),
      m: new MinuteParser(),
      s: new SecondParser(),
      S: new FractionOfSecondParser(),
      X: new ISOTimezoneWithZParser(),
      x: new ISOTimezoneParser(),
      t: new TimestampSecondsParser(),
      T: new TimestampMillisecondsParser()
    };

    // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
    //   (one of the certain letters followed by `o`)
    // - (\w)\1* matches any sequences of the same letter
    // - '' matches two quote characters in a row
    // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
    //   except a single quote symbol, which ends the sequence.
    //   Two quote characters do not end the sequence.
    //   If there is no matching single quote
    //   then the sequence will continue until the end of the string.
    // - . matches any single character unmatched by previous parts of the RegExps
    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

    // This RegExp catches symbols escaped by quotes, and also
    // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var notWhitespaceRegExp = /\S/;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;

    /**
     * @name parse
     * @category Common Helpers
     * @summary Parse the date.
     *
     * @description
     * Return the date parsed from string using the given format string.
     *
     * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
     * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * The characters in the format string wrapped between two single quotes characters (') are escaped.
     * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
     *
     * Format of the format string is based on Unicode Technical Standard #35:
     * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * with a few additions (see note 5 below the table).
     *
     * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
     * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
     *
     * ```javascript
     * parse('23 AM', 'HH a', new Date())
     * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
     * ```
     *
     * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
     *
     * Accepted format string patterns:
     * | Unit                            |Prior| Pattern | Result examples                   | Notes |
     * |---------------------------------|-----|---------|-----------------------------------|-------|
     * | Era                             | 140 | G..GGG  | AD, BC                            |       |
     * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
     * |                                 |     | GGGGG   | A, B                              |       |
     * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
     * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
     * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
     * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
     * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
     * |                                 |     | yyyyy   | ...                               | 2,4   |
     * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
     * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
     * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
     * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
     * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
     * |                                 |     | YYYYY   | ...                               | 2,4   |
     * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
     * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
     * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
     * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
     * |                                 |     | RRRRR   | ...                               | 2,4,5 |
     * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
     * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
     * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
     * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
     * |                                 |     | uuuuu   | ...                               | 2,4   |
     * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
     * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
     * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
     * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
     * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
     * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
     * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
     * |                                 |     | qq      | 01, 02, 03, 04                    |       |
     * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
     * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
     * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
     * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
     * |                                 |     | MM      | 01, 02, ..., 12                   |       |
     * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
     * |                                 |     | MMMM    | January, February, ..., December  | 2     |
     * |                                 |     | MMMMM   | J, F, ..., D                      |       |
     * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
     * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
     * |                                 |     | LL      | 01, 02, ..., 12                   |       |
     * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
     * |                                 |     | LLLL    | January, February, ..., December  | 2     |
     * |                                 |     | LLLLL   | J, F, ..., D                      |       |
     * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
     * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
     * |                                 |     | ww      | 01, 02, ..., 53                   |       |
     * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
     * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
     * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
     * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
     * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
     * |                                 |     | dd      | 01, 02, ..., 31                   |       |
     * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
     * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
     * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
     * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
     * |                                 |     | DDDD    | ...                               | 2     |
     * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
     * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
     * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
     * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
     * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
     * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
     * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
     * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
     * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
     * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
     * |                                 |     | ee      | 02, 03, ..., 01                   |       |
     * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
     * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
     * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
     * |                                 |     | cc      | 02, 03, ..., 01                   |       |
     * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
     * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
     * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
     * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
     * |                                 |     | aaaaa   | a, p                              |       |
     * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
     * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
     * |                                 |     | bbbbb   | a, p, n, mi                       |       |
     * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
     * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
     * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
     * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
     * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
     * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
     * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
     * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
     * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
     * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
     * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
     * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
     * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
     * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
     * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
     * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
     * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
     * |                                 |     | mm      | 00, 01, ..., 59                   |       |
     * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
     * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
     * |                                 |     | ss      | 00, 01, ..., 59                   |       |
     * | Seconds timestamp               |  40 | t       | 512969520                         |       |
     * |                                 |     | tt      | ...                               | 2     |
     * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
     * |                                 |     | SS      | 00, 01, ..., 99                   |       |
     * |                                 |     | SSS     | 000, 001, ..., 999                |       |
     * |                                 |     | SSSS    | ...                               | 2     |
     * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
     * |                                 |     | TT      | ...                               | 2     |
     * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
     * |                                 |     | XX      | -0800, +0530, Z                   |       |
     * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
     * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
     * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
     * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
     * |                                 |     | xx      | -0800, +0530, +0000               |       |
     * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
     * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
     * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
     * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
     * |                                 |     | PP      | May 29, 1453                      |       |
     * |                                 |     | PPP     | May 29th, 1453                    |       |
     * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
     * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
     * |                                 |     | pp      | 12:00:00 AM                       |       |
     * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
     * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
     * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
     * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
     * Notes:
     * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
     *    are the same as "stand-alone" units, but are different in some languages.
     *    "Formatting" units are declined according to the rules of the language
     *    in the context of a date. "Stand-alone" units are always nominative singular.
     *    In `format` function, they will produce different result:
     *
     *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
     *
     *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
     *
     *    `parse` will try to match both formatting and stand-alone units interchangably.
     *
     * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
     *    the single quote characters (see below).
     *    If the sequence is longer than listed in table:
     *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
     *      as wide as the sequence
     *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
     *      These variations are marked with "2" in the last column of the table.
     *
     * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
     *    These tokens represent the shortest form of the quarter.
     *
     * 4. The main difference between `y` and `u` patterns are B.C. years:
     *
     *    | Year | `y` | `u` |
     *    |------|-----|-----|
     *    | AC 1 |   1 |   1 |
     *    | BC 1 |   1 |   0 |
     *    | BC 2 |   2 |  -1 |
     *
     *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
     *
     *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
     *
     *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
     *
     *    while `uu` will just assign the year as is:
     *
     *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
     *
     *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
     *
     *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
     *    except local week-numbering years are dependent on `options.weekStartsOn`
     *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
     *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
     *
     * 5. These patterns are not in the Unicode Technical Standard #35:
     *    - `i`: ISO day of week
     *    - `I`: ISO week of year
     *    - `R`: ISO week-numbering year
     *    - `o`: ordinal number modifier
     *    - `P`: long localized date
     *    - `p`: long localized time
     *
     * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
     *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
     *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     *
     * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
     *    on the given locale.
     *
     *    using `en-US` locale: `P` => `MM/dd/yyyy`
     *    using `en-US` locale: `p` => `hh:mm a`
     *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
     *    using `pt-BR` locale: `p` => `HH:mm`
     *
     * Values will be assigned to the date in the descending order of its unit's priority.
     * Units of an equal priority overwrite each other in the order of appearance.
     *
     * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
     * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
     *
     * `referenceDate` must be passed for correct work of the function.
     * If you're not sure which `referenceDate` to supply, create a new instance of Date:
     * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
     * In this case parsing will be done in the context of the current date.
     * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
     * then `Invalid Date` will be returned.
     *
     * The result may vary by locale.
     *
     * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
     *
     * If parsing failed, `Invalid Date` will be returned.
     * Invalid Date is a Date, whose time value is NaN.
     * Time value of Date: http://es5.github.io/#x15.9.1.1
     *
     * @param {String} dateString - the string to parse
     * @param {String} formatString - the string of tokens
     * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
     * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
     *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @returns {Date} the parsed date
     * @throws {TypeError} 3 arguments required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     * @throws {RangeError} `options.locale` must contain `match` property
     * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
     * @throws {RangeError} format string contains an unescaped latin alphabet character
     *
     * @example
     * // Parse 11 February 2014 from middle-endian format:
     * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
     * //=> Tue Feb 11 2014 00:00:00
     *
     * @example
     * // Parse 28th of February in Esperanto locale in the context of 2010 year:
     * import eo from 'date-fns/locale/eo'
     * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
     *   locale: eo
     * })
     * //=> Sun Feb 28 2010 00:00:00
     */
    function parse$3(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
      var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
      requiredArgs(3, arguments);
      var dateString = String(dirtyDateString);
      var formatString = String(dirtyFormatString);
      var defaultOptions = getDefaultOptions();
      var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : locale$3;
      if (!locale.match) {
        throw new RangeError('locale must contain match property');
      }
      var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

      // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }
      var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

      // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }
      if (formatString === '') {
        if (dateString === '') {
          return toDate(dirtyReferenceDate);
        } else {
          return new Date(NaN);
        }
      }
      var subFnOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale
      };

      // If timezone isn't specified, it will be set to the system timezone
      var setters = [new DateToSystemTimezoneSetter()];
      var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
        var firstCharacter = substring[0];
        if (firstCharacter in longFormatters) {
          var longFormatter = longFormatters[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }
        return substring;
      }).join('').match(formattingTokensRegExp);
      var usedTokens = [];
      var _iterator = _createForOfIteratorHelper(tokens),
        _step;
      try {
        var _loop = function _loop() {
          var token = _step.value;
          if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
            throwProtectedError(token, formatString, dirtyDateString);
          }
          if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
            throwProtectedError(token, formatString, dirtyDateString);
          }
          var firstCharacter = token[0];
          var parser = parsers[firstCharacter];
          if (parser) {
            var incompatibleTokens = parser.incompatibleTokens;
            if (Array.isArray(incompatibleTokens)) {
              var incompatibleToken = usedTokens.find(function (usedToken) {
                return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
              });
              if (incompatibleToken) {
                throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
              }
            } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
              throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
            }
            usedTokens.push({
              token: firstCharacter,
              fullToken: token
            });
            var parseResult = parser.run(dateString, token, locale.match, subFnOptions);
            if (!parseResult) {
              return {
                v: new Date(NaN)
              };
            }
            setters.push(parseResult.setter);
            dateString = parseResult.rest;
          } else {
            if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
              throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
            }

            // Replace two single quote characters with one single quote character
            if (token === "''") {
              token = "'";
            } else if (firstCharacter === "'") {
              token = cleanEscapedString(token);
            }

            // Cut token from string, or, if string doesn't match the token, return Invalid Date
            if (dateString.indexOf(token) === 0) {
              dateString = dateString.slice(token.length);
            } else {
              return {
                v: new Date(NaN)
              };
            }
          }
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _ret = _loop();
          if (_typeof(_ret) === "object") return _ret.v;
        }

        // Check if the remaining input contains something other than whitespace
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
        return new Date(NaN);
      }
      var uniquePrioritySetters = setters.map(function (setter) {
        return setter.priority;
      }).sort(function (a, b) {
        return b - a;
      }).filter(function (priority, index, array) {
        return array.indexOf(priority) === index;
      }).map(function (priority) {
        return setters.filter(function (setter) {
          return setter.priority === priority;
        }).sort(function (a, b) {
          return b.subPriority - a.subPriority;
        });
      }).map(function (setterArray) {
        return setterArray[0];
      });
      var date = toDate(dirtyReferenceDate);
      if (isNaN(date.getTime())) {
        return new Date(NaN);
      }

      // Convert the date in system timezone to the same date in UTC+00:00 timezone.
      var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
      var flags = {};
      var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var setter = _step2.value;
          if (!setter.validate(utcDate, subFnOptions)) {
            return new Date(NaN);
          }
          var result = setter.set(utcDate, flags, subFnOptions);
          // Result is tuple (date, flags)
          if (Array.isArray(result)) {
            utcDate = result[0];
            assign(flags, result[1]);
            // Result is date
          } else {
            utcDate = result;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return utcDate;
    }
    function cleanEscapedString(input) {
      return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
    }

    /**
     * @name subDays
     * @category Day Helpers
     * @summary Subtract the specified number of days from the given date.
     *
     * @description
     * Subtract the specified number of days from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of days to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the days subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 10 days from 1 September 2014:
     * const result = subDays(new Date(2014, 8, 1), 10)
     * //=> Fri Aug 22 2014 00:00:00
     */
    function subDays(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger(dirtyAmount);
      return addDays(dirtyDate, -amount);
    }

    /**
     * @name parseISO
     * @category Common Helpers
     * @summary Parse ISO string
     *
     * @description
     * Parse the given string in ISO 8601 format and return an instance of Date.
     *
     * Function accepts complete ISO 8601 formats as well as partial implementations.
     * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
     *
     * If the argument isn't a string, the function cannot parse the string or
     * the values are invalid, it returns Invalid Date.
     *
     * @param {String} argument - the value to convert
     * @param {Object} [options] - an object with options.
     * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
     * @returns {Date} the parsed date in the local time zone
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
     *
     * @example
     * // Convert string '2014-02-11T11:30:30' to date:
     * const result = parseISO('2014-02-11T11:30:30')
     * //=> Tue Feb 11 2014 11:30:30
     *
     * @example
     * // Convert string '+02014101' to date,
     * // if the additional number of digits in the extended year format is 1:
     * const result = parseISO('+02014101', { additionalDigits: 1 })
     * //=> Fri Apr 11 2014 00:00:00
     */
    function parseISO(argument, options) {
      var _options$additionalDi;
      requiredArgs(1, arguments);
      var additionalDigits = toInteger((_options$additionalDi = void 0 ) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
      if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
        throw new RangeError('additionalDigits must be 0, 1 or 2');
      }
      if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
        return new Date(NaN);
      }
      var dateStrings = splitDateString(argument);
      var date;
      if (dateStrings.date) {
        var parseYearResult = parseYear(dateStrings.date, additionalDigits);
        date = parseDate(parseYearResult.restDateString, parseYearResult.year);
      }
      if (!date || isNaN(date.getTime())) {
        return new Date(NaN);
      }
      var timestamp = date.getTime();
      var time = 0;
      var offset;
      if (dateStrings.time) {
        time = parseTime(dateStrings.time);
        if (isNaN(time)) {
          return new Date(NaN);
        }
      }
      if (dateStrings.timezone) {
        offset = parseTimezone(dateStrings.timezone);
        if (isNaN(offset)) {
          return new Date(NaN);
        }
      } else {
        var dirtyDate = new Date(timestamp + time);
        // js parsed string assuming it's in UTC timezone
        // but we need it to be parsed in our timezone
        // so we use utc values to build date in our timezone.
        // Year values from 0 to 99 map to the years 1900 to 1999
        // so set year explicitly with setFullYear.
        var result = new Date(0);
        result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
        result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
        return result;
      }
      return new Date(timestamp + time + offset);
    }
    var patterns = {
      dateTimeDelimiter: /[T ]/,
      timeZoneDelimiter: /[Z ]/i,
      timezone: /([Z+-].*)$/
    };
    var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
    var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
    var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
    function splitDateString(dateString) {
      var dateStrings = {};
      var array = dateString.split(patterns.dateTimeDelimiter);
      var timeString;

      // The regex match should only return at maximum two array elements.
      // [date], [time], or [date, time].
      if (array.length > 2) {
        return dateStrings;
      }
      if (/:/.test(array[0])) {
        timeString = array[0];
      } else {
        dateStrings.date = array[0];
        timeString = array[1];
        if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
          dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
          timeString = dateString.substr(dateStrings.date.length, dateString.length);
        }
      }
      if (timeString) {
        var token = patterns.timezone.exec(timeString);
        if (token) {
          dateStrings.time = timeString.replace(token[1], '');
          dateStrings.timezone = token[1];
        } else {
          dateStrings.time = timeString;
        }
      }
      return dateStrings;
    }
    function parseYear(dateString, additionalDigits) {
      var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
      var captures = dateString.match(regex);
      // Invalid ISO-formatted year
      if (!captures) return {
        year: NaN,
        restDateString: ''
      };
      var year = captures[1] ? parseInt(captures[1]) : null;
      var century = captures[2] ? parseInt(captures[2]) : null;

      // either year or century is null, not both
      return {
        year: century === null ? year : century * 100,
        restDateString: dateString.slice((captures[1] || captures[2]).length)
      };
    }
    function parseDate(dateString, year) {
      // Invalid ISO-formatted year
      if (year === null) return new Date(NaN);
      var captures = dateString.match(dateRegex);
      // Invalid ISO-formatted string
      if (!captures) return new Date(NaN);
      var isWeekDate = !!captures[4];
      var dayOfYear = parseDateUnit(captures[1]);
      var month = parseDateUnit(captures[2]) - 1;
      var day = parseDateUnit(captures[3]);
      var week = parseDateUnit(captures[4]);
      var dayOfWeek = parseDateUnit(captures[5]) - 1;
      if (isWeekDate) {
        if (!validateWeekDate(year, week, dayOfWeek)) {
          return new Date(NaN);
        }
        return dayOfISOWeekYear(year, week, dayOfWeek);
      } else {
        var date = new Date(0);
        if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
          return new Date(NaN);
        }
        date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
        return date;
      }
    }
    function parseDateUnit(value) {
      return value ? parseInt(value) : 1;
    }
    function parseTime(timeString) {
      var captures = timeString.match(timeRegex);
      if (!captures) return NaN; // Invalid ISO-formatted time

      var hours = parseTimeUnit(captures[1]);
      var minutes = parseTimeUnit(captures[2]);
      var seconds = parseTimeUnit(captures[3]);
      if (!validateTime(hours, minutes, seconds)) {
        return NaN;
      }
      return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000;
    }
    function parseTimeUnit(value) {
      return value && parseFloat(value.replace(',', '.')) || 0;
    }
    function parseTimezone(timezoneString) {
      if (timezoneString === 'Z') return 0;
      var captures = timezoneString.match(timezoneRegex);
      if (!captures) return 0;
      var sign = captures[1] === '+' ? -1 : 1;
      var hours = parseInt(captures[2]);
      var minutes = captures[3] && parseInt(captures[3]) || 0;
      if (!validateTimezone(hours, minutes)) {
        return NaN;
      }
      return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
    }
    function dayOfISOWeekYear(isoWeekYear, week, day) {
      var date = new Date(0);
      date.setUTCFullYear(isoWeekYear, 0, 4);
      var fourthOfJanuaryDay = date.getUTCDay() || 7;
      var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date;
    }

    // Validation functions

    // February is null to handle the leap year (using ||)
    var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function isLeapYearIndex(year) {
      return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
    }
    function validateDate(year, month, date) {
      return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
    }
    function validateDayOfYearDate(year, dayOfYear) {
      return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
    }
    function validateWeekDate(_year, week, day) {
      return week >= 1 && week <= 53 && day >= 0 && day <= 6;
    }
    function validateTime(hours, minutes, seconds) {
      if (hours === 24) {
        return minutes === 0 && seconds === 0;
      }
      return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
    }
    function validateTimezone(_hours, minutes) {
      return minutes >= 0 && minutes <= 59;
    }

    /**
     * @name startOfToday
     * @category Day Helpers
     * @summary Return the start of today.
     * @pure false
     *
     * @description
     * Return the start of today.
     *
     * > ⚠️ Please note that this function is not present in the FP submodule as
     * > it uses `Date.now()` internally hence impure and can't be safely curried.
     *
     * @returns {Date} the start of today
     *
     * @example
     * // If today is 6 October 2014:
     * const result = startOfToday()
     * //=> Mon Oct 6 2014 00:00:00
     */
    function startOfToday() {
      return startOfDay(Date.now());
    }

    /**
     * @name startOfYesterday
     * @category Day Helpers
     * @summary Return the start of yesterday.
     * @pure false
     *
     * @description
     * Return the start of yesterday.
     *
     * > ⚠️ Please note that this function is not present in the FP submodule as
     * > it uses `new Date()` internally hence impure and can't be safely curried.
     *
     * @returns {Date} the start of yesterday
     *
     * @example
     * // If today is 6 October 2014:
     * const result = startOfYesterday()
     * //=> Sun Oct 5 2014 00:00:00
     */
    function startOfYesterday() {
      var now = new Date();
      var year = now.getFullYear();
      var month = now.getMonth();
      var day = now.getDate();
      var date = new Date(0);
      date.setFullYear(year, month, day - 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    /**
     * @name subMonths
     * @category Month Helpers
     * @summary Subtract the specified number of months from the given date.
     *
     * @description
     * Subtract the specified number of months from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of months to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the months subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 5 months from 1 February 2015:
     * const result = subMonths(new Date(2015, 1, 1), 5)
     * //=> Mon Sep 01 2014 00:00:00
     */
    function subMonths(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger(dirtyAmount);
      return addMonths(dirtyDate, -amount);
    }

    /**
     * @name sub
     * @category Common Helpers
     * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
     *
     * @description
     * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Duration} duration - the object with years, months, weeks, days, hours, minutes and seconds to be subtracted
     *
     * | Key     | Description                        |
     * |---------|------------------------------------|
     * | years   | Amount of years to be subtracted   |
     * | months  | Amount of months to be subtracted  |
     * | weeks   | Amount of weeks to be subtracted   |
     * | days    | Amount of days to be subtracted    |
     * | hours   | Amount of hours to be subtracted   |
     * | minutes | Amount of minutes to be subtracted |
     * | seconds | Amount of seconds to be subtracted |
     *
     * All values default to 0
     *
     * @returns {Date} the new date with the seconds subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract the following duration from 15 June 2017 15:29:20
     * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
     *   years: 2,
     *   months: 9,
     *   weeks: 1,
     *   days: 7,
     *   hours: 5,
     *   minutes: 9,
     *   seconds: 30
     * })
     * //=> Mon Sep 1 2014 10:19:50
     */
    function sub(date, duration) {
      requiredArgs(2, arguments);
      if (!duration || _typeof(duration) !== 'object') return new Date(NaN);
      var years = duration.years ? toInteger(duration.years) : 0;
      var months = duration.months ? toInteger(duration.months) : 0;
      var weeks = duration.weeks ? toInteger(duration.weeks) : 0;
      var days = duration.days ? toInteger(duration.days) : 0;
      var hours = duration.hours ? toInteger(duration.hours) : 0;
      var minutes = duration.minutes ? toInteger(duration.minutes) : 0;
      var seconds = duration.seconds ? toInteger(duration.seconds) : 0;

      // Subtract years and months
      var dateWithoutMonths = subMonths(date, months + years * 12);

      // Subtract weeks and days
      var dateWithoutDays = subDays(dateWithoutMonths, days + weeks * 7);

      // Subtract hours, minutes and seconds
      var minutestoSub = minutes + hours * 60;
      var secondstoSub = seconds + minutestoSub * 60;
      var mstoSub = secondstoSub * 1000;
      var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
      return finalDate;
    }

    /**
     * @name subWeeks
     * @category Week Helpers
     * @summary Subtract the specified number of weeks from the given date.
     *
     * @description
     * Subtract the specified number of weeks from the given date.
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of weeks to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the weeks subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 4 weeks from 1 September 2014:
     * const result = subWeeks(new Date(2014, 8, 1), 4)
     * //=> Mon Aug 04 2014 00:00:00
     */
    function subWeeks(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger(dirtyAmount);
      return addWeeks(dirtyDate, -amount);
    }

    /*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */

    const {
      entries,
      setPrototypeOf,
      isFrozen,
      getPrototypeOf,
      getOwnPropertyDescriptor: getOwnPropertyDescriptor$1
    } = Object;
    let {
      freeze,
      seal,
      create
    } = Object; // eslint-disable-line import/no-mutable-exports
    let {
      apply,
      construct
    } = typeof Reflect !== 'undefined' && Reflect;
    if (!freeze) {
      freeze = function freeze(x) {
        return x;
      };
    }
    if (!seal) {
      seal = function seal(x) {
        return x;
      };
    }
    if (!apply) {
      apply = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    if (!construct) {
      construct = function construct(Func, args) {
        return new Func(...args);
      };
    }
    const arrayForEach = unapply(Array.prototype.forEach);
    const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
    const arrayPop = unapply(Array.prototype.pop);
    const arrayPush = unapply(Array.prototype.push);
    const arraySplice = unapply(Array.prototype.splice);
    const stringToLowerCase = unapply(String.prototype.toLowerCase);
    const stringToString = unapply(String.prototype.toString);
    const stringMatch = unapply(String.prototype.match);
    const stringReplace = unapply(String.prototype.replace);
    const stringIndexOf$1 = unapply(String.prototype.indexOf);
    const stringTrim$1 = unapply(String.prototype.trim);
    const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
    const regExpTest = unapply(RegExp.prototype.test);
    const typeErrorCreate = unconstruct(TypeError);
    /**
     * Creates a new function that calls the given function with a specified thisArg and arguments.
     *
     * @param func - The function to be wrapped and called.
     * @returns A new function that calls the given function with a specified thisArg and arguments.
     */
    function unapply(func) {
      return function (thisArg) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return apply(func, thisArg, args);
      };
    }
    /**
     * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
     *
     * @param func - The constructor function to be wrapped and called.
     * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
     */
    function unconstruct(func) {
      return function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return construct(func, args);
      };
    }
    /**
     * Add properties to a lookup table
     *
     * @param set - The set to which elements will be added.
     * @param array - The array containing elements to be added to the set.
     * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
     * @returns The modified set with added elements.
     */
    function addToSet(set, array) {
      let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
      if (setPrototypeOf) {
        // Make 'in' and truthy checks like Boolean(set.constructor)
        // independent of any properties defined on Object.prototype.
        // Prevent prototype setters from intercepting set as a this value.
        setPrototypeOf(set, null);
      }
      let l = array.length;
      while (l--) {
        let element = array[l];
        if (typeof element === 'string') {
          const lcElement = transformCaseFunc(element);
          if (lcElement !== element) {
            // Config presets (e.g. tags.js, attrs.js) are immutable.
            if (!isFrozen(array)) {
              array[l] = lcElement;
            }
            element = lcElement;
          }
        }
        set[element] = true;
      }
      return set;
    }
    /**
     * Clean up an array to harden against CSPP
     *
     * @param array - The array to be cleaned.
     * @returns The cleaned version of the array
     */
    function cleanArray(array) {
      for (let index = 0; index < array.length; index++) {
        const isPropertyExist = objectHasOwnProperty(array, index);
        if (!isPropertyExist) {
          array[index] = null;
        }
      }
      return array;
    }
    /**
     * Shallow clone an object
     *
     * @param object - The object to be cloned.
     * @returns A new object that copies the original.
     */
    function clone$1(object) {
      const newObject = create(null);
      for (const [property, value] of entries(object)) {
        const isPropertyExist = objectHasOwnProperty(object, property);
        if (isPropertyExist) {
          if (Array.isArray(value)) {
            newObject[property] = cleanArray(value);
          } else if (value && typeof value === 'object' && value.constructor === Object) {
            newObject[property] = clone$1(value);
          } else {
            newObject[property] = value;
          }
        }
      }
      return newObject;
    }
    /**
     * This method automatically checks if the prop is function or getter and behaves accordingly.
     *
     * @param object - The object to look up the getter function in its prototype chain.
     * @param prop - The property name for which to find the getter function.
     * @returns The getter function found in the prototype chain or a fallback function.
     */
    function lookupGetter(object, prop) {
      while (object !== null) {
        const desc = getOwnPropertyDescriptor$1(object, prop);
        if (desc) {
          if (desc.get) {
            return unapply(desc.get);
          }
          if (typeof desc.value === 'function') {
            return unapply(desc.value);
          }
        }
        object = getPrototypeOf(object);
      }
      function fallbackValue() {
        return null;
      }
      return fallbackValue;
    }

    const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
    const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
    const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
    // List of SVG elements that are disallowed by default.
    // We still need to know them so that we can do namespace
    // checks properly in case one wants to add them to
    // allow-list.
    const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
    const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
    // Similarly to SVG, we want to know all MathML elements,
    // even those that we disallow by default.
    const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
    const text = freeze(['#text']);

    const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
    const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
    const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
    const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

    // eslint-disable-next-line unicorn/better-regex
    const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
    const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
    const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm); // eslint-disable-line unicorn/better-regex
    const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
    const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
    );
    const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
    );
    const DOCTYPE_NAME = seal(/^html$/i);
    const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

    var EXPRESSIONS = /*#__PURE__*/Object.freeze({
      __proto__: null,
      ARIA_ATTR: ARIA_ATTR,
      ATTR_WHITESPACE: ATTR_WHITESPACE,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT,
      DATA_ATTR: DATA_ATTR,
      DOCTYPE_NAME: DOCTYPE_NAME,
      ERB_EXPR: ERB_EXPR,
      IS_ALLOWED_URI: IS_ALLOWED_URI,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
      MUSTACHE_EXPR: MUSTACHE_EXPR,
      TMPLIT_EXPR: TMPLIT_EXPR
    });

    /* eslint-disable @typescript-eslint/indent */
    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
    const NODE_TYPE = {
      element: 1,
      attribute: 2,
      text: 3,
      cdataSection: 4,
      entityReference: 5,
      // Deprecated
      entityNode: 6,
      // Deprecated
      progressingInstruction: 7,
      comment: 8,
      document: 9,
      documentType: 10,
      documentFragment: 11,
      notation: 12 // Deprecated
    };
    const getGlobal = function getGlobal() {
      return typeof window === 'undefined' ? null : window;
    };
    /**
     * Creates a no-op policy for internal use only.
     * Don't export this function outside this module!
     * @param trustedTypes The policy factory.
     * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
     * @return The policy created (or null, if Trusted Types
     * are not supported or creating the policy failed).
     */
    const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
      if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
        return null;
      }
      // Allow the callers to control the unique policy name
      // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
      // Policy creation with duplicate names throws in Trusted Types.
      let suffix = null;
      const ATTR_NAME = 'data-tt-policy-suffix';
      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
        suffix = purifyHostElement.getAttribute(ATTR_NAME);
      }
      const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML(html) {
            return html;
          },
          createScriptURL(scriptUrl) {
            return scriptUrl;
          }
        });
      } catch (_) {
        // Policy creation failed (most likely another DOMPurify script has
        // already run). Skip creating the policy, as this will only cause errors
        // if TT are enforced.
        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
        return null;
      }
    };
    const _createHooksMap = function _createHooksMap() {
      return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
      };
    };
    function createDOMPurify() {
      let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
      const DOMPurify = root => createDOMPurify(root);
      DOMPurify.version = '3.2.4';
      DOMPurify.removed = [];
      if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document || !window.Element) {
        // Not running in a browser, provide a factory function
        // so that you can pass your own Window
        DOMPurify.isSupported = false;
        return DOMPurify;
      }
      let {
        document
      } = window;
      const originalDocument = document;
      const currentScript = originalDocument.currentScript;
      const {
        DocumentFragment,
        HTMLTemplateElement,
        Node,
        Element,
        NodeFilter,
        NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
        HTMLFormElement,
        DOMParser,
        trustedTypes
      } = window;
      const ElementPrototype = Element.prototype;
      const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
      const remove = lookupGetter(ElementPrototype, 'remove');
      const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
      const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
      const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
      // As per issue #47, the web-components registry is inherited by a
      // new document created via createHTMLDocument. As per the spec
      // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
      // a new empty registry is used when creating a template contents owner
      // document, so we use that as our parent document to ensure nothing
      // is inherited.
      if (typeof HTMLTemplateElement === 'function') {
        const template = document.createElement('template');
        if (template.content && template.content.ownerDocument) {
          document = template.content.ownerDocument;
        }
      }
      let trustedTypesPolicy;
      let emptyHTML = '';
      const {
        implementation,
        createNodeIterator,
        createDocumentFragment,
        getElementsByTagName
      } = document;
      const {
        importNode
      } = originalDocument;
      let hooks = _createHooksMap();
      /**
       * Expose whether this browser supports running the full DOMPurify.
       */
      DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
      const {
        MUSTACHE_EXPR,
        ERB_EXPR,
        TMPLIT_EXPR,
        DATA_ATTR,
        ARIA_ATTR,
        IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE,
        CUSTOM_ELEMENT
      } = EXPRESSIONS;
      let {
        IS_ALLOWED_URI: IS_ALLOWED_URI$1
      } = EXPRESSIONS;
      /**
       * We consider the elements and attributes below to be safe. Ideally
       * don't add any new ones but feel free to remove unwanted ones.
       */
      /* allowed element names */
      let ALLOWED_TAGS = null;
      const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
      /* Allowed attribute names */
      let ALLOWED_ATTR = null;
      const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
      /*
       * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
       * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
       * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
       * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
       */
      let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
        tagNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: false
        }
      }));
      /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
      let FORBID_TAGS = null;
      /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
      let FORBID_ATTR = null;
      /* Decide if ARIA attributes are okay */
      let ALLOW_ARIA_ATTR = true;
      /* Decide if custom data attributes are okay */
      let ALLOW_DATA_ATTR = true;
      /* Decide if unknown protocols are okay */
      let ALLOW_UNKNOWN_PROTOCOLS = false;
      /* Decide if self-closing tags in attributes are allowed.
       * Usually removed due to a mXSS issue in jQuery 3.0 */
      let ALLOW_SELF_CLOSE_IN_ATTR = true;
      /* Output should be safe for common template engines.
       * This means, DOMPurify removes data attributes, mustaches and ERB
       */
      let SAFE_FOR_TEMPLATES = false;
      /* Output should be safe even for XML used within HTML and alike.
       * This means, DOMPurify removes comments when containing risky content.
       */
      let SAFE_FOR_XML = true;
      /* Decide if document with <html>... should be returned */
      let WHOLE_DOCUMENT = false;
      /* Track whether config is already set on this instance of DOMPurify. */
      let SET_CONFIG = false;
      /* Decide if all elements (e.g. style, script) must be children of
       * document.body. By default, browsers might move them to document.head */
      let FORCE_BODY = false;
      /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
       * string (or a TrustedHTML object if Trusted Types are supported).
       * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
       */
      let RETURN_DOM = false;
      /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
       * string  (or a TrustedHTML object if Trusted Types are supported) */
      let RETURN_DOM_FRAGMENT = false;
      /* Try to return a Trusted Type object instead of a string, return a string in
       * case Trusted Types are not supported  */
      let RETURN_TRUSTED_TYPE = false;
      /* Output should be free from DOM clobbering attacks?
       * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
       */
      let SANITIZE_DOM = true;
      /* Achieve full DOM Clobbering protection by isolating the namespace of named
       * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
       *
       * HTML/DOM spec rules that enable DOM Clobbering:
       *   - Named Access on Window (§7.3.3)
       *   - DOM Tree Accessors (§3.1.5)
       *   - Form Element Parent-Child Relations (§4.10.3)
       *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
       *   - HTMLCollection (§4.2.10.2)
       *
       * Namespace isolation is implemented by prefixing `id` and `name` attributes
       * with a constant string, i.e., `user-content-`
       */
      let SANITIZE_NAMED_PROPS = false;
      const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
      /* Keep element content when removing element? */
      let KEEP_CONTENT = true;
      /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
       * of importing it into a new Document and returning a sanitized copy */
      let IN_PLACE = false;
      /* Allow usage of profiles like html, svg and mathMl */
      let USE_PROFILES = {};
      /* Tags to ignore content of when KEEP_CONTENT is true */
      let FORBID_CONTENTS = null;
      const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
      /* Tags that are safe for data: URIs */
      let DATA_URI_TAGS = null;
      const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
      /* Attributes safe for values like "javascript:" */
      let URI_SAFE_ATTRIBUTES = null;
      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
      const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
      const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
      const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
      /* Document namespace */
      let NAMESPACE = HTML_NAMESPACE;
      let IS_EMPTY_INPUT = false;
      /* Allowed XHTML+XML namespaces */
      let ALLOWED_NAMESPACES = null;
      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
      let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
      let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
      // Certain elements are allowed in both SVG and HTML
      // namespace. We need to specify them explicitly
      // so that they don't get erroneously deleted from
      // HTML namespace.
      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
      /* Parsing of strict XHTML documents */
      let PARSER_MEDIA_TYPE = null;
      const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
      const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
      let transformCaseFunc = null;
      /* Keep a reference to config to pass to hooks */
      let CONFIG = null;
      /* Ideally, do not touch anything below this line */
      /* ______________________________________________ */
      const formElement = document.createElement('form');
      const isRegexOrFunction = function isRegexOrFunction(testValue) {
        return testValue instanceof RegExp || testValue instanceof Function;
      };
      /**
       * _parseConfig
       *
       * @param cfg optional config literal
       */
      // eslint-disable-next-line complexity
      const _parseConfig = function _parseConfig() {
        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        /* Shield configuration object from tampering */
        if (!cfg || typeof cfg !== 'object') {
          cfg = {};
        }
        /* Shield configuration object from prototype pollution */
        cfg = clone$1(cfg);
        PARSER_MEDIA_TYPE =
        // eslint-disable-next-line unicorn/prefer-includes
        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
        /* Set configuration parameters */
        ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone$1(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone$1(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
        FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
        FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
        FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
        USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
        RETURN_DOM = cfg.RETURN_DOM || false; // Default false
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
        FORCE_BODY = cfg.FORCE_BODY || false; // Default false
        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
        IN_PLACE = cfg.IN_PLACE || false; // Default false
        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
        }
        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }
        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        /* Parse profile info */
        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, text);
          ALLOWED_ATTR = [];
          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html$1);
            addToSet(ALLOWED_ATTR, html);
          }
          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg$1);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl$1);
            addToSet(ALLOWED_ATTR, mathMl);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        /* Merge configuration parameters */
        if (cfg.ADD_TAGS) {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone$1(ALLOWED_TAGS);
          }
          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
        }
        if (cfg.ADD_ATTR) {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone$1(ALLOWED_ATTR);
          }
          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
        }
        if (cfg.FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone$1(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
        }
        /* Add #text in case KEEP_CONTENT is set to true */
        if (KEEP_CONTENT) {
          ALLOWED_TAGS['#text'] = true;
        }
        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
        }
        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ['tbody']);
          delete FORBID_TAGS.tbody;
        }
        if (cfg.TRUSTED_TYPES_POLICY) {
          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          }
          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          }
          // Overwrite existing TrustedTypes policy.
          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
          // Sign local variables required by `sanitize`.
          emptyHTML = trustedTypesPolicy.createHTML('');
        } else {
          // Uninitialized policy, attempt to initialize the internal dompurify policy.
          if (trustedTypesPolicy === undefined) {
            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
          }
          // If creating the internal policy succeeded sign internal variables.
          if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
            emptyHTML = trustedTypesPolicy.createHTML('');
          }
        }
        // Prevent further manipulation of configuration.
        // Not available in IE8, Safari 5, etc.
        if (freeze) {
          freeze(cfg);
        }
        CONFIG = cfg;
      };
      /* Keep track of all possible SVG and MathML tags
       * so that we can perform the namespace checks
       * correctly. */
      const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
      const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
      /**
       * @param element a DOM element whose namespace is being checked
       * @returns Return false if the element has a
       *  namespace that a spec-compliant parser would never
       *  return. Return true otherwise.
       */
      const _checkValidNamespace = function _checkValidNamespace(element) {
        let parent = getParentNode(element);
        // In JSDOM, if we're inside shadow DOM, then parentNode
        // can be null. We just simulate parent in this case.
        if (!parent || !parent.tagName) {
          parent = {
            namespaceURI: NAMESPACE,
            tagName: 'template'
          };
        }
        const tagName = stringToLowerCase(element.tagName);
        const parentTagName = stringToLowerCase(parent.tagName);
        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
          return false;
        }
        if (element.namespaceURI === SVG_NAMESPACE) {
          // The only way to switch from HTML namespace to SVG
          // is via <svg>. If it happens via any other tag, then
          // it should be killed.
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'svg';
          }
          // The only way to switch from MathML to SVG is via`
          // svg if parent is either <annotation-xml> or MathML
          // text integration points.
          if (parent.namespaceURI === MATHML_NAMESPACE) {
            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
          }
          // We only allow elements that are defined in SVG
          // spec. All others are disallowed in SVG namespace.
          return Boolean(ALL_SVG_TAGS[tagName]);
        }
        if (element.namespaceURI === MATHML_NAMESPACE) {
          // The only way to switch from HTML namespace to MathML
          // is via <math>. If it happens via any other tag, then
          // it should be killed.
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'math';
          }
          // The only way to switch from SVG to MathML is via
          // <math> and HTML integration points
          if (parent.namespaceURI === SVG_NAMESPACE) {
            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
          }
          // We only allow elements that are defined in MathML
          // spec. All others are disallowed in MathML namespace.
          return Boolean(ALL_MATHML_TAGS[tagName]);
        }
        if (element.namespaceURI === HTML_NAMESPACE) {
          // The only way to switch from SVG to HTML is via
          // HTML integration points, and from MathML to HTML
          // is via MathML text integration points
          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          // We disallow tags that are specific for MathML
          // or SVG and should never appear in HTML namespace
          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
        }
        // For XHTML and XML documents that support custom namespaces
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
          return true;
        }
        // The code should never reach this place (this means
        // that the element somehow got namespace that is not
        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
        // Return false just in case.
        return false;
      };
      /**
       * _forceRemove
       *
       * @param node a DOM node
       */
      const _forceRemove = function _forceRemove(node) {
        arrayPush(DOMPurify.removed, {
          element: node
        });
        try {
          // eslint-disable-next-line unicorn/prefer-dom-node-remove
          getParentNode(node).removeChild(node);
        } catch (_) {
          remove(node);
        }
      };
      /**
       * _removeAttribute
       *
       * @param name an Attribute name
       * @param element a DOM node
       */
      const _removeAttribute = function _removeAttribute(name, element) {
        try {
          arrayPush(DOMPurify.removed, {
            attribute: element.getAttributeNode(name),
            from: element
          });
        } catch (_) {
          arrayPush(DOMPurify.removed, {
            attribute: null,
            from: element
          });
        }
        element.removeAttribute(name);
        // We void attribute values for unremovable "is" attributes
        if (name === 'is') {
          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
            try {
              _forceRemove(element);
            } catch (_) {}
          } else {
            try {
              element.setAttribute(name, '');
            } catch (_) {}
          }
        }
      };
      /**
       * _initDocument
       *
       * @param dirty - a string of dirty markup
       * @return a DOM, filled with the dirty markup
       */
      const _initDocument = function _initDocument(dirty) {
        /* Create a HTML document */
        let doc = null;
        let leadingWhitespace = null;
        if (FORCE_BODY) {
          dirty = '<remove></remove>' + dirty;
        } else {
          /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
          const matches = stringMatch(dirty, /^[\r\n\t ]+/);
          leadingWhitespace = matches && matches[0];
        }
        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
          // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
          dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
        }
        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        /*
         * Use the DOMParser API by default, fallback later if needs be
         * DOMParser not work for svg when has multiple root element.
         */
        if (NAMESPACE === HTML_NAMESPACE) {
          try {
            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
          } catch (_) {}
        }
        /* Use createHTMLDocument in case DOMParser is not available */
        if (!doc || !doc.documentElement) {
          doc = implementation.createDocument(NAMESPACE, 'template', null);
          try {
            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
          } catch (_) {
            // Syntax error if dirtyPayload is invalid xml
          }
        }
        const body = doc.body || doc.documentElement;
        if (dirty && leadingWhitespace) {
          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        /* Work on whole document or just its body */
        if (NAMESPACE === HTML_NAMESPACE) {
          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
        }
        return WHOLE_DOCUMENT ? doc.documentElement : body;
      };
      /**
       * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
       *
       * @param root The root element or node to start traversing on.
       * @return The created NodeIterator
       */
      const _createNodeIterator = function _createNodeIterator(root) {
        return createNodeIterator.call(root.ownerDocument || root, root,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
      };
      /**
       * _isClobbered
       *
       * @param element element to check for clobbering attacks
       * @return true if clobbered, false if safe
       */
      const _isClobbered = function _isClobbered(element) {
        return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
      };
      /**
       * Checks whether the given object is a DOM node.
       *
       * @param value object to check whether it's a DOM node
       * @return true is object is a DOM node
       */
      const _isNode = function _isNode(value) {
        return typeof Node === 'function' && value instanceof Node;
      };
      function _executeHooks(hooks, currentNode, data) {
        arrayForEach(hooks, hook => {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      }
      /**
       * _sanitizeElements
       *
       * @protect nodeName
       * @protect textContent
       * @protect removeChild
       * @param currentNode to check for permission to exist
       * @return true if node was killed, false if left alive
       */
      const _sanitizeElements = function _sanitizeElements(currentNode) {
        let content = null;
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
        /* Check if element is clobbered or can clobber */
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Now let's check the element's type and name */
        const tagName = transformCaseFunc(currentNode.nodeName);
        /* Execute a hook if present */
        _executeHooks(hooks.uponSanitizeElement, currentNode, {
          tagName,
          allowedTags: ALLOWED_TAGS
        });
        /* Detect mXSS attempts abusing namespace confusion */
        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove any occurrence of processing instructions */
        if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove any kind of possibly harmful comments */
        if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Remove element if anything forbids its presence */
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          /* Check if we have a custom element to handle */
          if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
              return false;
            }
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
              return false;
            }
          }
          /* Keep content except for bad-listed elements */
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
            const parentNode = getParentNode(currentNode) || currentNode.parentNode;
            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
            if (childNodes && parentNode) {
              const childCount = childNodes.length;
              for (let i = childCount - 1; i >= 0; --i) {
                const childClone = cloneNode(childNodes[i], true);
                childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                parentNode.insertBefore(childClone, getNextSibling(currentNode));
              }
            }
          }
          _forceRemove(currentNode);
          return true;
        }
        /* Check whether element has a valid namespace */
        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Make sure that older browsers don't get fallback-tag mXSS */
        if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        /* Sanitize element content to be template-safe */
        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
          /* Get the element's text content */
          content = currentNode.textContent;
          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
            content = stringReplace(content, expr, ' ');
          });
          if (currentNode.textContent !== content) {
            arrayPush(DOMPurify.removed, {
              element: currentNode.cloneNode()
            });
            currentNode.textContent = content;
          }
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeElements, currentNode, null);
        return false;
      };
      /**
       * _isValidAttribute
       *
       * @param lcTag Lowercase tag name of containing element.
       * @param lcName Lowercase attribute name.
       * @param value Attribute value.
       * @return Returns true if `value` is valid, otherwise false.
       */
      // eslint-disable-next-line complexity
      const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
        /* Make sure attribute cannot clobber */
        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
          return false;
        }
        /* Allow valid data-* attributes: At least one character after "-"
            (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
            XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
            We don't need to check the value; it's always URI safe. */
        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
          // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
            return false;
          }
          /* Check value is safe. First, is attr inert? If so, is safe */
        } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf$1(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
          return false;
        } else ;
        return true;
      };
      /**
       * _isBasicCustomElement
       * checks if at least one dash is included in tagName, and it's not the first char
       * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
       *
       * @param tagName name of the tag of the node to sanitize
       * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
       */
      const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
        return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
      };
      /**
       * _sanitizeAttributes
       *
       * @protect attributes
       * @protect nodeName
       * @protect removeAttribute
       * @protect setAttribute
       *
       * @param currentNode to sanitize
       */
      const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
        const {
          attributes
        } = currentNode;
        /* Check if we have attributes; if not we might have a text node */
        if (!attributes || _isClobbered(currentNode)) {
          return;
        }
        const hookEvent = {
          attrName: '',
          attrValue: '',
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR,
          forceKeepAttr: undefined
        };
        let l = attributes.length;
        /* Go backwards over all attributes; safely remove bad ones */
        while (l--) {
          const attr = attributes[l];
          const {
            name,
            namespaceURI,
            value: attrValue
          } = attr;
          const lcName = transformCaseFunc(name);
          let value = name === 'value' ? attrValue : stringTrim$1(attrValue);
          /* Execute a hook if present */
          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;
          hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
          _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
          value = hookEvent.attrValue;
          /* Full DOM Clobbering protection via namespace isolation,
           * Prefix id and name attributes with `user-content-`
           */
          if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
            // Remove the attribute with this value
            _removeAttribute(name, currentNode);
            // Prefix the value and later re-create the attribute with the sanitized value
            value = SANITIZE_NAMED_PROPS_PREFIX + value;
          }
          /* Work around a security issue with comments inside attributes */
          if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Did the hooks approve of the attribute? */
          if (hookEvent.forceKeepAttr) {
            continue;
          }
          /* Remove attribute */
          _removeAttribute(name, currentNode);
          /* Did the hooks approve of the attribute? */
          if (!hookEvent.keepAttr) {
            continue;
          }
          /* Work around a security issue in jQuery 3.0 */
          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
            _removeAttribute(name, currentNode);
            continue;
          }
          /* Sanitize attribute content to be template-safe */
          if (SAFE_FOR_TEMPLATES) {
            arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
              value = stringReplace(value, expr, ' ');
            });
          }
          /* Is `value` valid for this attribute? */
          const lcTag = transformCaseFunc(currentNode.nodeName);
          if (!_isValidAttribute(lcTag, lcName, value)) {
            continue;
          }
          /* Handle attributes that require Trusted Types */
          if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
            if (namespaceURI) ; else {
              switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                case 'TrustedHTML':
                  {
                    value = trustedTypesPolicy.createHTML(value);
                    break;
                  }
                case 'TrustedScriptURL':
                  {
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                  }
              }
            }
          }
          /* Handle invalid data-* attribute set by try-catching it */
          try {
            if (namespaceURI) {
              currentNode.setAttributeNS(namespaceURI, name, value);
            } else {
              /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
              currentNode.setAttribute(name, value);
            }
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
            } else {
              arrayPop(DOMPurify.removed);
            }
          } catch (_) {}
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
      };
      /**
       * _sanitizeShadowDOM
       *
       * @param fragment to iterate over recursively
       */
      const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
        let shadowNode = null;
        const shadowIterator = _createNodeIterator(fragment);
        /* Execute a hook if present */
        _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
        while (shadowNode = shadowIterator.nextNode()) {
          /* Execute a hook if present */
          _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
          /* Sanitize tags and elements */
          _sanitizeElements(shadowNode);
          /* Check attributes next */
          _sanitizeAttributes(shadowNode);
          /* Deep shadow DOM detected */
          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(shadowNode.content);
          }
        }
        /* Execute a hook if present */
        _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
      };
      // eslint-disable-next-line complexity
      DOMPurify.sanitize = function (dirty) {
        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        let body = null;
        let importedNode = null;
        let currentNode = null;
        let returnNode = null;
        /* Make sure we have a string to sanitize.
          DO NOT return early, as this will return the wrong type if
          the user has requested a DOM object rather than a string */
        IS_EMPTY_INPUT = !dirty;
        if (IS_EMPTY_INPUT) {
          dirty = '<!-->';
        }
        /* Stringify, in case dirty is an object */
        if (typeof dirty !== 'string' && !_isNode(dirty)) {
          if (typeof dirty.toString === 'function') {
            dirty = dirty.toString();
            if (typeof dirty !== 'string') {
              throw typeErrorCreate('dirty is not a string, aborting');
            }
          } else {
            throw typeErrorCreate('toString is not a function');
          }
        }
        /* Return dirty HTML if DOMPurify cannot run */
        if (!DOMPurify.isSupported) {
          return dirty;
        }
        /* Assign config vars */
        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        /* Clean up removed elements */
        DOMPurify.removed = [];
        /* Check if dirty is correctly typed for IN_PLACE */
        if (typeof dirty === 'string') {
          IN_PLACE = false;
        }
        if (IN_PLACE) {
          /* Do some early pre-sanitization to avoid unsafe root nodes */
          if (dirty.nodeName) {
            const tagName = transformCaseFunc(dirty.nodeName);
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
            }
          }
        } else if (dirty instanceof Node) {
          /* If dirty is a DOM element, append to an empty document to avoid
             elements being stripped by the parser */
          body = _initDocument('<!---->');
          importedNode = body.ownerDocument.importNode(dirty, true);
          if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
            /* Node is already a body, use as is */
            body = importedNode;
          } else if (importedNode.nodeName === 'HTML') {
            body = importedNode;
          } else {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            body.appendChild(importedNode);
          }
        } else {
          /* Exit directly if we have nothing to do */
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
          // eslint-disable-next-line unicorn/prefer-includes
          dirty.indexOf('<') === -1) {
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          /* Initialize the document to work on */
          body = _initDocument(dirty);
          /* Check we have a DOM node from the data */
          if (!body) {
            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
          }
        }
        /* Remove first element node (ours) if FORCE_BODY is set */
        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        /* Get node iterator */
        const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
        /* Now start iterating over the created document */
        while (currentNode = nodeIterator.nextNode()) {
          /* Sanitize tags and elements */
          _sanitizeElements(currentNode);
          /* Check attributes next */
          _sanitizeAttributes(currentNode);
          /* Shadow DOM detected, sanitize it */
          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
        }
        /* If we sanitized `dirty` in-place, return it. */
        if (IN_PLACE) {
          return dirty;
        }
        /* Return sanitized string or DOM */
        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);
            while (body.firstChild) {
              // eslint-disable-next-line unicorn/prefer-dom-node-append
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }
          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
            /*
              AdoptNode() is not used because internal state is not reset
              (e.g. the past names map of a HTMLFormElement), this is safe
              in theory but we would rather not risk another attack vector.
              The state that is cloned by importNode() is explicitly defined
              by the specs.
            */
            returnNode = importNode.call(originalDocument, returnNode, true);
          }
          return returnNode;
        }
        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        /* Serialize doctype if allowed */
        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
        }
        /* Sanitize final string template-safe */
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
            serializedHTML = stringReplace(serializedHTML, expr, ' ');
          });
        }
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      DOMPurify.setConfig = function () {
        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _parseConfig(cfg);
        SET_CONFIG = true;
      };
      DOMPurify.clearConfig = function () {
        CONFIG = null;
        SET_CONFIG = false;
      };
      DOMPurify.isValidAttribute = function (tag, attr, value) {
        /* Initialize shared config vars if necessary. */
        if (!CONFIG) {
          _parseConfig({});
        }
        const lcTag = transformCaseFunc(tag);
        const lcName = transformCaseFunc(attr);
        return _isValidAttribute(lcTag, lcName, value);
      };
      DOMPurify.addHook = function (entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') {
          return;
        }
        arrayPush(hooks[entryPoint], hookFunction);
      };
      DOMPurify.removeHook = function (entryPoint, hookFunction) {
        if (hookFunction !== undefined) {
          const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
          return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];
        }
        return arrayPop(hooks[entryPoint]);
      };
      DOMPurify.removeHooks = function (entryPoint) {
        hooks[entryPoint] = [];
      };
      DOMPurify.removeAllHooks = function () {
        hooks = _createHooksMap();
      };
      return DOMPurify;
    }
    var purify = createDOMPurify();

    /**
     * Module variables.
     * @private
     */
    var matchHtmlRegExp = /["'&<>]/;

    /**
     * Module exports.
     * @public
     */

    var escapeHtml_1 = escapeHtml;

    /**
     * Escape special characters in the given string of html.
     *
     * @param  {string} string The string to escape for inserting into HTML
     * @return {string}
     * @public
     */

    function escapeHtml(string) {
      var str = '' + string;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape;
      var html = '';
      var index = 0;
      var lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            // "
            escape = '&quot;';
            break;
          case 38:
            // &
            escape = '&amp;';
            break;
          case 39:
            // '
            escape = '&#39;';
            break;
          case 60:
            // <
            escape = '&lt;';
            break;
          case 62:
            // >
            escape = '&gt;';
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape;
      }
      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }

    /*!
     * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
     * SPDX-License-Identifier: GPL-3.0-or-later
     */
    function getLocale() {
      return document.documentElement.dataset.locale || "en";
    }
    function getCanonicalLocale() {
      return getLocale().replace(/_/g, "-");
    }
    function getAppTranslations(appId) {
      return {
        translations: window._oc_l10n_registry_translations?.[appId] ?? {},
        pluralFunction: window._oc_l10n_registry_plural_functions?.[appId] ?? ((number) => number)
      };
    }
    /*!
     * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
     * SPDX-License-Identifier: GPL-3.0-or-later
     */
    function translate(app, text, placeholdersOrNumber, optionsOrNumber, options) {
      const vars = typeof placeholdersOrNumber === "object" ? placeholdersOrNumber : void 0;
      const number = typeof placeholdersOrNumber === "number" ? placeholdersOrNumber : void 0;
      const allOptions = {
        // defaults
        escape: true,
        sanitize: true,
        // overwrite with user config
        ...{}
      };
      const identity = (value) => value;
      const optSanitize = allOptions.sanitize ? purify.sanitize : identity;
      const optEscape = allOptions.escape ? escapeHtml_1 : identity;
      const isValidReplacement = (value) => typeof value === "string" || typeof value === "number";
      const _build = (text2, vars2, number2) => {
        return text2.replace(/%n/g, "" + number2).replace(/{([^{}]*)}/g, (match, key) => {
          if (vars2 === void 0 || !(key in vars2)) {
            return optEscape(match);
          }
          const replacement = vars2[key];
          if (isValidReplacement(replacement)) {
            return optEscape(`${replacement}`);
          } else if (typeof replacement === "object" && isValidReplacement(replacement.value)) {
            const escape = replacement.escape !== false ? escapeHtml_1 : identity;
            return escape(`${replacement.value}`);
          } else {
            return optEscape(match);
          }
        });
      };
      const bundle = getAppTranslations(app);
      let translation = bundle.translations[text] || text;
      translation = Array.isArray(translation) ? translation[0] : translation;
      if (typeof vars === "object" || number !== void 0) {
        return optSanitize(_build(
          translation,
          vars,
          number
        ));
      } else {
        return optSanitize(translation);
      }
    }

    /*!
     * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors
     * SPDX-License-Identifier: GPL-3.0-or-later
     */
    function getFirstDay() {
      if (typeof window.firstDay !== "undefined") {
        return window.firstDay;
      }
      const intl = new Intl.Locale(getCanonicalLocale());
      const weekInfo = intl.getWeekInfo?.() ?? intl.weekInfo;
      if (weekInfo) {
        return weekInfo.firstDay % 7;
      }
      return 1;
    }

    var nativeJoin = functionUncurryThis([].join);
    var ES3_STRINGS = indexedObject != Object;
    var FORCED$2 = ES3_STRINGS || !arrayMethodIsStrict('join', ',');

    // `Array.prototype.join` method
    // https://tc39.es/ecma262/#sec-array.prototype.join
    _export({
      target: 'Array',
      proto: true,
      forced: FORCED$2
    }, {
      join: function join(separator) {
        return nativeJoin(toIndexedObject(this), separator === undefined ? ',' : separator);
      }
    });

    // `RegExp.prototype.flags` getter implementation
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
    var regexpFlags = function () {
      var that = anObject(this);
      var result = '';
      if (that.hasIndices) result += 'd';
      if (that.global) result += 'g';
      if (that.ignoreCase) result += 'i';
      if (that.multiline) result += 'm';
      if (that.dotAll) result += 's';
      if (that.unicode) result += 'u';
      if (that.unicodeSets) result += 'v';
      if (that.sticky) result += 'y';
      return result;
    };

    // babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
    var $RegExp$2 = global_1.RegExp;
    var UNSUPPORTED_Y$1 = fails(function () {
      var re = $RegExp$2('a', 'y');
      re.lastIndex = 2;
      return re.exec('abcd') != null;
    });

    // UC Browser bug
    // https://github.com/zloirock/core-js/issues/1008
    var MISSED_STICKY = UNSUPPORTED_Y$1 || fails(function () {
      return !$RegExp$2('a', 'y').sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y$1 || fails(function () {
      // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
      var re = $RegExp$2('^r', 'gy');
      re.lastIndex = 2;
      return re.exec('str') != null;
    });
    var regexpStickyHelpers = {
      BROKEN_CARET: BROKEN_CARET,
      MISSED_STICKY: MISSED_STICKY,
      UNSUPPORTED_Y: UNSUPPORTED_Y$1
    };

    // babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
    var $RegExp$1 = global_1.RegExp;
    var regexpUnsupportedDotAll = fails(function () {
      var re = $RegExp$1('.', 's');
      return !(re.dotAll && re.exec('\n') && re.flags === 's');
    });

    // babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
    var $RegExp = global_1.RegExp;
    var regexpUnsupportedNcg = fails(function () {
      var re = $RegExp('(?<a>b)', 'g');
      return re.exec('b').groups.a !== 'b' || 'b'.replace(re, '$<a>c') !== 'bc';
    });

    /* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
    /* eslint-disable regexp/no-useless-quantifier -- testing */







    var getInternalState = internalState.get;


    var nativeReplace = shared('native-string-replace', String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt$3 = functionUncurryThis(''.charAt);
    var indexOf$1 = functionUncurryThis(''.indexOf);
    var replace$2 = functionUncurryThis(''.replace);
    var stringSlice$2 = functionUncurryThis(''.slice);
    var UPDATES_LAST_INDEX_WRONG = function () {
      var re1 = /a/;
      var re2 = /b*/g;
      functionCall(nativeExec, re1, 'a');
      functionCall(nativeExec, re2, 'a');
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    var UNSUPPORTED_Y = regexpStickyHelpers.BROKEN_CARET;

    // nonparticipating capturing group, copied from es5-shim's String#split patch.
    var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || regexpUnsupportedDotAll || regexpUnsupportedNcg;
    if (PATCH) {
      patchedExec = function exec(string) {
        var re = this;
        var state = getInternalState(re);
        var str = toString_1(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match, i, object, group;
        if (raw) {
          raw.lastIndex = re.lastIndex;
          result = functionCall(patchedExec, raw, str);
          re.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re.sticky;
        var flags = functionCall(regexpFlags, re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace$2(flags, 'y', '');
          if (indexOf$1(flags, 'g') === -1) {
            flags += 'g';
          }
          strCopy = stringSlice$2(str, re.lastIndex);
          // Support anchored sticky behavior.
          if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$3(str, re.lastIndex - 1) !== '\n')) {
            source = '(?: ' + source + ')';
            strCopy = ' ' + strCopy;
            charsAdded++;
          }
          // ^(? + rx + ) is needed, in combination with some str slicing, to
          // simulate the 'y' flag.
          reCopy = new RegExp('^(?:' + source + ')', flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
        }
        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
        match = functionCall(nativeExec, sticky ? reCopy : re, strCopy);
        if (sticky) {
          if (match) {
            match.input = stringSlice$2(match.input, charsAdded);
            match[0] = stringSlice$2(match[0], charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
          } else re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          // Fix browsers whose `exec` methods don't consistently return `undefined`
          // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
          functionCall(nativeReplace, match[0], reCopy, function () {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undefined) match[i] = undefined;
            }
          });
        }
        if (match && groups) {
          match.groups = object = objectCreate(null);
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            object[group[0]] = match[group[1]];
          }
        }
        return match;
      };
    }
    var regexpExec = patchedExec;

    // `RegExp.prototype.exec` method
    // https://tc39.es/ecma262/#sec-regexp.prototype.exec
    _export({
      target: 'RegExp',
      proto: true,
      forced: /./.exec !== regexpExec
    }, {
      exec: regexpExec
    });

    // TODO: Remove from `core-js@4` since it's moved to entry points







    var SPECIES = wellKnownSymbol('species');
    var RegExpPrototype = RegExp.prototype;
    var fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function () {
        // String methods call symbol-named RegEp methods
        var O = {};
        O[SYMBOL] = function () {
          return 7;
        };
        return ''[KEY](O) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
        // Symbol-named RegExp methods call .exec
        var execCalled = false;
        var re = /a/;
        if (KEY === 'split') {
          // We can't use real regex here since it causes deoptimization
          // and serious performance degradation in V8
          // https://github.com/zloirock/core-js/issues/306
          re = {};
          // RegExp[@@split] doesn't call the regex's exec method, but first creates
          // a new one. We need to return the patched regex when creating the new one.
          re.constructor = {};
          re.constructor[SPECIES] = function () {
            return re;
          };
          re.flags = '';
          re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function () {
          execCalled = true;
          return null;
        };
        re[SYMBOL]('');
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var uncurriedNativeRegExpMethod = functionUncurryThisClause(/./[SYMBOL]);
        var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
          var uncurriedNativeMethod = functionUncurryThisClause(nativeMethod);
          var $exec = regexp.exec;
          if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              // The native String method already delegates to @@method (this
              // polyfilled function), leasing to infinite recursion.
              // We avoid it by directly calling the native @@method method.
              return {
                done: true,
                value: uncurriedNativeRegExpMethod(regexp, str, arg2)
              };
            }
            return {
              done: true,
              value: uncurriedNativeMethod(str, regexp, arg2)
            };
          }
          return {
            done: false
          };
        });
        defineBuiltIn(String.prototype, KEY, methods[0]);
        defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
      }
    };

    var charAt$2 = stringMultibyte.charAt;

    // `AdvanceStringIndex` abstract operation
    // https://tc39.es/ecma262/#sec-advancestringindex
    var advanceStringIndex = function (S, index, unicode) {
      return index + (unicode ? charAt$2(S, index).length : 1);
    };

    var floor$1 = Math.floor;
    var charAt$1 = functionUncurryThis(''.charAt);
    var replace$1 = functionUncurryThis(''.replace);
    var stringSlice$1 = functionUncurryThis(''.slice);
    // eslint-disable-next-line redos/no-vulnerable -- safe
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

    // `GetSubstitution` abstract operation
    // https://tc39.es/ecma262/#sec-getsubstitution
    var getSubstitution = function (matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== undefined) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return replace$1(replacement, symbols, function (match, ch) {
        var capture;
        switch (charAt$1(ch, 0)) {
          case '$':
            return '$';
          case '&':
            return matched;
          case '`':
            return stringSlice$1(str, 0, position);
          case "'":
            return stringSlice$1(str, tailPos);
          case '<':
            capture = namedCaptures[stringSlice$1(ch, 1, -1)];
            break;
          default:
            // \d\d?
            var n = +ch;
            if (n === 0) return match;
            if (n > m) {
              var f = floor$1(n / 10);
              if (f === 0) return match;
              if (f <= m) return captures[f - 1] === undefined ? charAt$1(ch, 1) : captures[f - 1] + charAt$1(ch, 1);
              return match;
            }
            capture = captures[n - 1];
        }
        return capture === undefined ? '' : capture;
      });
    };

    var $TypeError$1 = TypeError;

    // `RegExpExec` abstract operation
    // https://tc39.es/ecma262/#sec-regexpexec
    var regexpExecAbstract = function (R, S) {
      var exec = R.exec;
      if (isCallable(exec)) {
        var result = functionCall(exec, R, S);
        if (result !== null) anObject(result);
        return result;
      }
      if (classofRaw(R) === 'RegExp') return functionCall(regexpExec, R, S);
      throw $TypeError$1('RegExp#exec called on incompatible receiver');
    };

    var REPLACE = wellKnownSymbol('replace');
    var max$2 = Math.max;
    var min$2 = Math.min;
    var concat = functionUncurryThis([].concat);
    var push$2 = functionUncurryThis([].push);
    var stringIndexOf = functionUncurryThis(''.indexOf);
    var stringSlice = functionUncurryThis(''.slice);
    var maybeToString = function (it) {
      return it === undefined ? it : String(it);
    };

    // IE <= 11 replaces $0 with the whole match, as if it was $&
    // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
    var REPLACE_KEEPS_$0 = function () {
      // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
      return 'a'.replace(/./, '$0') === '$0';
    }();

    // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
      if (/./[REPLACE]) {
        return /./[REPLACE]('a', '$0') === '';
      }
      return false;
    }();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
      var re = /./;
      re.exec = function () {
        var result = [];
        result.groups = {
          a: '7'
        };
        return result;
      };
      // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
      return ''.replace(re, '$<a>') !== '7';
    });

    // @@replace logic
    fixRegexpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
      return [
      // `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var replacer = isNullOrUndefined(searchValue) ? undefined : getMethod(searchValue, REPLACE);
        return replacer ? functionCall(replacer, searchValue, O, replaceValue) : functionCall(nativeReplace, toString_1(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function (string, replaceValue) {
        var rx = anObject(this);
        var S = toString_1(string);
        if (typeof replaceValue == 'string' && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, '$<') === -1) {
          var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
          if (res.done) return res.value;
        }
        var functionalReplace = isCallable(replaceValue);
        if (!functionalReplace) replaceValue = toString_1(replaceValue);
        var global = rx.global;
        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }
        var results = [];
        while (true) {
          var result = regexpExecAbstract(rx, S);
          if (result === null) break;
          push$2(results, result);
          if (!global) break;
          var matchStr = toString_1(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        }
        var accumulatedResult = '';
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];
          var matched = toString_1(result[0]);
          var position = max$2(min$2(toIntegerOrInfinity(result.index), S.length), 0);
          var captures = [];
          // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
          for (var j = 1; j < result.length; j++) push$2(captures, maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = concat([matched], captures, position, S);
            if (namedCaptures !== undefined) push$2(replacerArgs, namedCaptures);
            var replacement = toString_1(functionApply(replaceValue, undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + stringSlice(S, nextSourcePosition);
      }];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;







    // eslint-disable-next-line es/no-string-prototype-endswith -- safe
    var nativeEndsWith = functionUncurryThisClause(''.endsWith);
    var slice = functionUncurryThisClause(''.slice);
    var min$1 = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('endsWith');
    // https://github.com/zloirock/core-js/pull/702
    var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function () {
      var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
      return descriptor && !descriptor.writable;
    }();

    // `String.prototype.endsWith` method
    // https://tc39.es/ecma262/#sec-string.prototype.endswith
    _export({
      target: 'String',
      proto: true,
      forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
    }, {
      endsWith: function endsWith(searchString /* , endPosition = @length */) {
        var that = toString_1(requireObjectCoercible(this));
        notARegexp(searchString);
        var endPosition = arguments.length > 1 ? arguments[1] : undefined;
        var len = that.length;
        var end = endPosition === undefined ? len : min$1(toLength(endPosition), len);
        var search = toString_1(searchString);
        return nativeEndsWith ? nativeEndsWith(that, search, end) : slice(that, end - search.length, end) === search;
      }
    });

    var formatDistanceLocale$2 = {
      lessThanXSeconds: {
        standalone: {
          one: 'weniger als 1 Sekunde',
          other: 'weniger als {{count}} Sekunden'
        },
        withPreposition: {
          one: 'weniger als 1 Sekunde',
          other: 'weniger als {{count}} Sekunden'
        }
      },
      xSeconds: {
        standalone: {
          one: '1 Sekunde',
          other: '{{count}} Sekunden'
        },
        withPreposition: {
          one: '1 Sekunde',
          other: '{{count}} Sekunden'
        }
      },
      halfAMinute: {
        standalone: 'halbe Minute',
        withPreposition: 'halben Minute'
      },
      lessThanXMinutes: {
        standalone: {
          one: 'weniger als 1 Minute',
          other: 'weniger als {{count}} Minuten'
        },
        withPreposition: {
          one: 'weniger als 1 Minute',
          other: 'weniger als {{count}} Minuten'
        }
      },
      xMinutes: {
        standalone: {
          one: '1 Minute',
          other: '{{count}} Minuten'
        },
        withPreposition: {
          one: '1 Minute',
          other: '{{count}} Minuten'
        }
      },
      aboutXHours: {
        standalone: {
          one: 'etwa 1 Stunde',
          other: 'etwa {{count}} Stunden'
        },
        withPreposition: {
          one: 'etwa 1 Stunde',
          other: 'etwa {{count}} Stunden'
        }
      },
      xHours: {
        standalone: {
          one: '1 Stunde',
          other: '{{count}} Stunden'
        },
        withPreposition: {
          one: '1 Stunde',
          other: '{{count}} Stunden'
        }
      },
      xDays: {
        standalone: {
          one: '1 Tag',
          other: '{{count}} Tage'
        },
        withPreposition: {
          one: '1 Tag',
          other: '{{count}} Tagen'
        }
      },
      aboutXWeeks: {
        standalone: {
          one: 'etwa 1 Woche',
          other: 'etwa {{count}} Wochen'
        },
        withPreposition: {
          one: 'etwa 1 Woche',
          other: 'etwa {{count}} Wochen'
        }
      },
      xWeeks: {
        standalone: {
          one: '1 Woche',
          other: '{{count}} Wochen'
        },
        withPreposition: {
          one: '1 Woche',
          other: '{{count}} Wochen'
        }
      },
      aboutXMonths: {
        standalone: {
          one: 'etwa 1 Monat',
          other: 'etwa {{count}} Monate'
        },
        withPreposition: {
          one: 'etwa 1 Monat',
          other: 'etwa {{count}} Monaten'
        }
      },
      xMonths: {
        standalone: {
          one: '1 Monat',
          other: '{{count}} Monate'
        },
        withPreposition: {
          one: '1 Monat',
          other: '{{count}} Monaten'
        }
      },
      aboutXYears: {
        standalone: {
          one: 'etwa 1 Jahr',
          other: 'etwa {{count}} Jahre'
        },
        withPreposition: {
          one: 'etwa 1 Jahr',
          other: 'etwa {{count}} Jahren'
        }
      },
      xYears: {
        standalone: {
          one: '1 Jahr',
          other: '{{count}} Jahre'
        },
        withPreposition: {
          one: '1 Jahr',
          other: '{{count}} Jahren'
        }
      },
      overXYears: {
        standalone: {
          one: 'mehr als 1 Jahr',
          other: 'mehr als {{count}} Jahre'
        },
        withPreposition: {
          one: 'mehr als 1 Jahr',
          other: 'mehr als {{count}} Jahren'
        }
      },
      almostXYears: {
        standalone: {
          one: 'fast 1 Jahr',
          other: 'fast {{count}} Jahre'
        },
        withPreposition: {
          one: 'fast 1 Jahr',
          other: 'fast {{count}} Jahren'
        }
      }
    };
    var formatDistance$2 = function formatDistance(token, count, options) {
      var result;
      var tokenValue = options !== null && options !== void 0 && options.addSuffix ? formatDistanceLocale$2[token].withPreposition : formatDistanceLocale$2[token].standalone;
      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }
      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'in ' + result;
        } else {
          return 'vor ' + result;
        }
      }
      return result;
    };

    // DIN 5008: https://de.wikipedia.org/wiki/Datumsformat#DIN_5008
    var dateFormats$2 = {
      full: 'EEEE, do MMMM y',
      // Montag, 7. Januar 2018
      long: 'do MMMM y',
      // 7. Januar 2018
      medium: 'do MMM y',
      // 7. Jan. 2018
      short: 'dd.MM.y' // 07.01.2018
    };

    var timeFormats$2 = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$2 = {
      full: "{{date}} 'um' {{time}}",
      long: "{{date}} 'um' {{time}}",
      medium: '{{date}} {{time}}',
      short: '{{date}} {{time}}'
    };
    var formatLong$2 = {
      date: buildFormatLongFn({
        formats: dateFormats$2,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats$2,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$2,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$2 = {
      lastWeek: "'letzten' eeee 'um' p",
      yesterday: "'gestern um' p",
      today: "'heute um' p",
      tomorrow: "'morgen um' p",
      nextWeek: "eeee 'um' p",
      other: 'P'
    };
    var formatRelative$2 = function formatRelative(token, _date, _baseDate, _options) {
      return formatRelativeLocale$2[token];
    };

    var eraValues$2 = {
      narrow: ['v.Chr.', 'n.Chr.'],
      abbreviated: ['v.Chr.', 'n.Chr.'],
      wide: ['vor Christus', 'nach Christus']
    };
    var quarterValues$2 = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1. Quartal', '2. Quartal', '3. Quartal', '4. Quartal']
    };

    // Note: in German, the names of days of the week and months are capitalized.
    // If you are making a new locale based on this one, check if the same is true for the language you're working on.
    // Generally, formatted dates should look like they are in the middle of a sentence,
    // e.g. in Spanish language the weekdays and months should be in the lowercase.
    var monthValues$2 = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
      wide: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']
    };

    // https://st.unicode.org/cldr-apps/v#/de/Gregorian/
    var formattingMonthValues = {
      narrow: monthValues$2.narrow,
      abbreviated: ['Jan.', 'Feb.', 'März', 'Apr.', 'Mai', 'Juni', 'Juli', 'Aug.', 'Sep.', 'Okt.', 'Nov.', 'Dez.'],
      wide: monthValues$2.wide
    };
    var dayValues$2 = {
      narrow: ['S', 'M', 'D', 'M', 'D', 'F', 'S'],
      short: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
      abbreviated: ['So.', 'Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.'],
      wide: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag']
    };

    // https://www.unicode.org/cldr/charts/32/summary/de.html#1881
    var dayPeriodValues$2 = {
      narrow: {
        am: 'vm.',
        pm: 'nm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachm.',
        evening: 'Abend',
        night: 'Nacht'
      },
      abbreviated: {
        am: 'vorm.',
        pm: 'nachm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachmittag',
        evening: 'Abend',
        night: 'Nacht'
      },
      wide: {
        am: 'vormittags',
        pm: 'nachmittags',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'Morgen',
        afternoon: 'Nachmittag',
        evening: 'Abend',
        night: 'Nacht'
      }
    };
    var formattingDayPeriodValues$1 = {
      narrow: {
        am: 'vm.',
        pm: 'nm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachm.',
        evening: 'abends',
        night: 'nachts'
      },
      abbreviated: {
        am: 'vorm.',
        pm: 'nachm.',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachmittags',
        evening: 'abends',
        night: 'nachts'
      },
      wide: {
        am: 'vormittags',
        pm: 'nachmittags',
        midnight: 'Mitternacht',
        noon: 'Mittag',
        morning: 'morgens',
        afternoon: 'nachmittags',
        evening: 'abends',
        night: 'nachts'
      }
    };
    var ordinalNumber$2 = function ordinalNumber(dirtyNumber) {
      var number = Number(dirtyNumber);
      return number + '.';
    };
    var localize$2 = {
      ordinalNumber: ordinalNumber$2,
      era: buildLocalizeFn({
        values: eraValues$2,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$2,
        defaultWidth: 'wide',
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues$2,
        formattingValues: formattingMonthValues,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues$2,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$2,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues$1,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$2 = /^(\d+)(\.)?/i;
    var parseOrdinalNumberPattern$2 = /\d+/i;
    var matchEraPatterns$2 = {
      narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
      abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
      wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
    };
    var parseEraPatterns$2 = {
      any: [/^v/i, /^n/i]
    };
    var matchQuarterPatterns$2 = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](\.)? Quartal/i
    };
    var parseQuarterPatterns$2 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$2 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(j[aä]n|feb|mär[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
      wide: /^(januar|februar|märz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
    };
    var parseMonthPatterns$2 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^j[aä]/i, /^f/i, /^mär/i, /^ap/i, /^mai/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$2 = {
      narrow: /^[smdmf]/i,
      short: /^(so|mo|di|mi|do|fr|sa)/i,
      abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
      wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
    };
    var parseDayPatterns$2 = {
      any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns$2 = {
      narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
      abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
      wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
    };
    var parseDayPeriodPatterns$2 = {
      any: {
        am: /^v/i,
        pm: /^n/i,
        midnight: /^Mitte/i,
        noon: /^Mitta/i,
        morning: /morgens/i,
        afternoon: /nachmittags/i,
        // will never be matched. Afternoon is matched by `pm`
        evening: /abends/i,
        night: /nachts/i // will never be matched. Night is matched by `pm`
      }
    };

    var match$2 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$2,
        parsePattern: parseOrdinalNumberPattern$2,
        valueCallback: function valueCallback(value) {
          return parseInt(value);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$2,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$2,
        defaultParseWidth: 'any',
        valueCallback: function valueCallback(index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$2,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$2,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$2,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPeriodPatterns$2,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary German locale.
     * @language German
     * @iso-639-2 deu
     * @author Thomas Eilmsteiner [@DeMuu]{@link https://github.com/DeMuu}
     * @author Asia [@asia-t]{@link https://github.com/asia-t}
     * @author Van Vuong Ngo [@vanvuongngo]{@link https://github.com/vanvuongngo}
     * @author RomanErnst [@pex]{@link https://github.com/pex}
     * @author Philipp Keck [@Philipp91]{@link https://github.com/Philipp91}
     */
    var locale$2 = {
      code: 'de',
      formatDistance: formatDistance$2,
      formatLong: formatLong$2,
      formatRelative: formatRelative$2,
      localize: localize$2,
      match: match$2,
      options: {
        weekStartsOn: 1 /* Monday */,
        firstWeekContainsDate: 4
      }
    };

    var formatDistanceLocale$1 = {
      lessThanXSeconds: {
        one: 'moins d’une seconde',
        other: 'moins de {{count}} secondes'
      },
      xSeconds: {
        one: '1 seconde',
        other: '{{count}} secondes'
      },
      halfAMinute: '30 secondes',
      lessThanXMinutes: {
        one: 'moins d’une minute',
        other: 'moins de {{count}} minutes'
      },
      xMinutes: {
        one: '1 minute',
        other: '{{count}} minutes'
      },
      aboutXHours: {
        one: 'environ 1 heure',
        other: 'environ {{count}} heures'
      },
      xHours: {
        one: '1 heure',
        other: '{{count}} heures'
      },
      xDays: {
        one: '1 jour',
        other: '{{count}} jours'
      },
      aboutXWeeks: {
        one: 'environ 1 semaine',
        other: 'environ {{count}} semaines'
      },
      xWeeks: {
        one: '1 semaine',
        other: '{{count}} semaines'
      },
      aboutXMonths: {
        one: 'environ 1 mois',
        other: 'environ {{count}} mois'
      },
      xMonths: {
        one: '1 mois',
        other: '{{count}} mois'
      },
      aboutXYears: {
        one: 'environ 1 an',
        other: 'environ {{count}} ans'
      },
      xYears: {
        one: '1 an',
        other: '{{count}} ans'
      },
      overXYears: {
        one: 'plus d’un an',
        other: 'plus de {{count}} ans'
      },
      almostXYears: {
        one: 'presqu’un an',
        other: 'presque {{count}} ans'
      }
    };
    var formatDistance$1 = function formatDistance(token, count, options) {
      var result;
      var form = formatDistanceLocale$1[token];
      if (typeof form === 'string') {
        result = form;
      } else if (count === 1) {
        result = form.one;
      } else {
        result = form.other.replace('{{count}}', String(count));
      }
      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'dans ' + result;
        } else {
          return 'il y a ' + result;
        }
      }
      return result;
    };

    var dateFormats$1 = {
      full: 'EEEE d MMMM y',
      long: 'd MMMM y',
      medium: 'd MMM y',
      short: 'dd/MM/y'
    };
    var timeFormats$1 = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats$1 = {
      full: "{{date}} 'à' {{time}}",
      long: "{{date}} 'à' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong$1 = {
      date: buildFormatLongFn({
        formats: dateFormats$1,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats$1,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale$1 = {
      lastWeek: "eeee 'dernier à' p",
      yesterday: "'hier à' p",
      today: "'aujourd’hui à' p",
      tomorrow: "'demain à' p'",
      nextWeek: "eeee 'prochain à' p",
      other: 'P'
    };
    var formatRelative$1 = function formatRelative(token, _date, _baseDate, _options) {
      return formatRelativeLocale$1[token];
    };

    var eraValues$1 = {
      narrow: ['av. J.-C', 'ap. J.-C'],
      abbreviated: ['av. J.-C', 'ap. J.-C'],
      wide: ['avant Jésus-Christ', 'après Jésus-Christ']
    };
    var quarterValues$1 = {
      narrow: ['T1', 'T2', 'T3', 'T4'],
      abbreviated: ['1er trim.', '2ème trim.', '3ème trim.', '4ème trim.'],
      wide: ['1er trimestre', '2ème trimestre', '3ème trimestre', '4ème trimestre']
    };
    var monthValues$1 = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['janv.', 'févr.', 'mars', 'avr.', 'mai', 'juin', 'juil.', 'août', 'sept.', 'oct.', 'nov.', 'déc.'],
      wide: ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre']
    };
    var dayValues$1 = {
      narrow: ['D', 'L', 'M', 'M', 'J', 'V', 'S'],
      short: ['di', 'lu', 'ma', 'me', 'je', 've', 'sa'],
      abbreviated: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
      wide: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi']
    };
    var dayPeriodValues$1 = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'minuit',
        noon: 'midi',
        morning: 'mat.',
        afternoon: 'ap.m.',
        evening: 'soir',
        night: 'mat.'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'minuit',
        noon: 'midi',
        morning: 'matin',
        afternoon: 'après-midi',
        evening: 'soir',
        night: 'matin'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'minuit',
        noon: 'midi',
        morning: 'du matin',
        afternoon: 'de l’après-midi',
        evening: 'du soir',
        night: 'du matin'
      }
    };
    var ordinalNumber$1 = function ordinalNumber(dirtyNumber, options) {
      var number = Number(dirtyNumber);
      var unit = options === null || options === void 0 ? void 0 : options.unit;
      if (number === 0) return '0';
      var feminineUnits = ['year', 'week', 'hour', 'minute', 'second'];
      var suffix;
      if (number === 1) {
        suffix = unit && feminineUnits.includes(unit) ? 'ère' : 'er';
      } else {
        suffix = 'ème';
      }
      return number + suffix;
    };
    var localize$1 = {
      ordinalNumber: ordinalNumber$1,
      era: buildLocalizeFn({
        values: eraValues$1,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$1,
        defaultWidth: 'wide',
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues$1,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues$1,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1,
        defaultWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern$1 = /^(\d+)(ième|ère|ème|er|e)?/i;
    var parseOrdinalNumberPattern$1 = /\d+/i;
    var matchEraPatterns$1 = {
      narrow: /^(av\.J\.C|ap\.J\.C|ap\.J\.-C)/i,
      abbreviated: /^(av\.J\.-C|av\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
      wide: /^(avant Jésus-Christ|après Jésus-Christ)/i
    };
    var parseEraPatterns$1 = {
      any: [/^av/i, /^ap/i]
    };
    var matchQuarterPatterns$1 = {
      narrow: /^T?[1234]/i,
      abbreviated: /^[1234](er|ème|e)? trim\.?/i,
      wide: /^[1234](er|ème|e)? trimestre/i
    };
    var parseQuarterPatterns$1 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns$1 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(janv|févr|mars|avr|mai|juin|juill|juil|août|sept|oct|nov|déc)\.?/i,
      wide: /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i
    };
    var parseMonthPatterns$1 = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^av/i, /^ma/i, /^juin/i, /^juil/i, /^ao/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns$1 = {
      narrow: /^[lmjvsd]/i,
      short: /^(di|lu|ma|me|je|ve|sa)/i,
      abbreviated: /^(dim|lun|mar|mer|jeu|ven|sam)\.?/i,
      wide: /^(dimanche|lundi|mardi|mercredi|jeudi|vendredi|samedi)/i
    };
    var parseDayPatterns$1 = {
      narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
      any: [/^di/i, /^lu/i, /^ma/i, /^me/i, /^je/i, /^ve/i, /^sa/i]
    };
    var matchDayPeriodPatterns$1 = {
      narrow: /^(a|p|minuit|midi|mat\.?|ap\.?m\.?|soir|nuit)/i,
      any: /^([ap]\.?\s?m\.?|du matin|de l'après[-\s]midi|du soir|de la nuit)/i
    };
    var parseDayPeriodPatterns$1 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^min/i,
        noon: /^mid/i,
        morning: /mat/i,
        afternoon: /ap/i,
        evening: /soir/i,
        night: /nuit/i
      }
    };
    var match$1 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1,
        parsePattern: parseOrdinalNumberPattern$1,
        valueCallback: function valueCallback(value) {
          return parseInt(value);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns$1,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns$1,
        defaultParseWidth: 'any',
        valueCallback: function valueCallback(index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns$1,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$1,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns$1,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns$1,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary French locale.
     * @language French
     * @iso-639-2 fra
     * @author Jean Dupouy [@izeau]{@link https://github.com/izeau}
     * @author François B [@fbonzon]{@link https://github.com/fbonzon}
     */
    var locale$1 = {
      code: 'fr',
      formatDistance: formatDistance$1,
      formatLong: formatLong$1,
      formatRelative: formatRelative$1,
      localize: localize$1,
      match: match$1,
      options: {
        weekStartsOn: 1 /* Monday */,
        firstWeekContainsDate: 4
      }
    };

    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: 'menos de um segundo',
        other: 'menos de {{count}} segundos'
      },
      xSeconds: {
        one: '1 segundo',
        other: '{{count}} segundos'
      },
      halfAMinute: 'meio minuto',
      lessThanXMinutes: {
        one: 'menos de um minuto',
        other: 'menos de {{count}} minutos'
      },
      xMinutes: {
        one: '1 minuto',
        other: '{{count}} minutos'
      },
      aboutXHours: {
        one: 'aproximadamente 1 hora',
        other: 'aproximadamente {{count}} horas'
      },
      xHours: {
        one: '1 hora',
        other: '{{count}} horas'
      },
      xDays: {
        one: '1 dia',
        other: '{{count}} dias'
      },
      aboutXWeeks: {
        one: 'aproximadamente 1 semana',
        other: 'aproximadamente {{count}} semanas'
      },
      xWeeks: {
        one: '1 semana',
        other: '{{count}} semanas'
      },
      aboutXMonths: {
        one: 'aproximadamente 1 mês',
        other: 'aproximadamente {{count}} meses'
      },
      xMonths: {
        one: '1 mês',
        other: '{{count}} meses'
      },
      aboutXYears: {
        one: 'aproximadamente 1 ano',
        other: 'aproximadamente {{count}} anos'
      },
      xYears: {
        one: '1 ano',
        other: '{{count}} anos'
      },
      overXYears: {
        one: 'mais de 1 ano',
        other: 'mais de {{count}} anos'
      },
      almostXYears: {
        one: 'quase 1 ano',
        other: 'quase {{count}} anos'
      }
    };
    var formatDistance = function formatDistance(token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale[token];
      if (typeof tokenValue === 'string') {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace('{{count}}', String(count));
      }
      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return 'daqui a ' + result;
        } else {
          return 'há ' + result;
        }
      }
      return result;
    };

    var dateFormats = {
      full: "EEEE, d 'de' MMMM 'de' y",
      long: "d 'de' MMMM 'de' y",
      medium: "d 'de' MMM 'de' y",
      short: 'dd/MM/y'
    };
    var timeFormats = {
      full: 'HH:mm:ss zzzz',
      long: 'HH:mm:ss z',
      medium: 'HH:mm:ss',
      short: 'HH:mm'
    };
    var dateTimeFormats = {
      full: "{{date}} 'às' {{time}}",
      long: "{{date}} 'às' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale = {
      lastWeek: function lastWeek(date) {
        var weekday = date.getUTCDay();
        var last = weekday === 0 || weekday === 6 ? 'último' : 'última';
        return "'" + last + "' eeee 'às' p";
      },
      yesterday: "'ontem às' p",
      today: "'hoje às' p",
      tomorrow: "'amanhã às' p",
      nextWeek: "eeee 'às' p",
      other: 'P'
    };
    var formatRelative = function formatRelative(token, date, _baseDate, _options) {
      var format = formatRelativeLocale[token];
      if (typeof format === 'function') {
        return format(date);
      }
      return format;
    };

    var eraValues = {
      narrow: ['aC', 'dC'],
      abbreviated: ['a.C.', 'd.C.'],
      wide: ['antes de Cristo', 'depois de Cristo']
    };
    var quarterValues = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['T1', 'T2', 'T3', 'T4'],
      wide: ['1º trimestre', '2º trimestre', '3º trimestre', '4º trimestre']
    };
    var monthValues = {
      narrow: ['j', 'f', 'm', 'a', 'm', 'j', 'j', 'a', 's', 'o', 'n', 'd'],
      abbreviated: ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez'],
      wide: ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro']
    };
    var dayValues = {
      narrow: ['d', 's', 't', 'q', 'q', 's', 's'],
      short: ['dom', 'seg', 'ter', 'qua', 'qui', 'sex', 'sáb'],
      abbreviated: ['dom', 'seg', 'ter', 'qua', 'qui', 'sex', 'sáb'],
      wide: ['domingo', 'segunda-feira', 'terça-feira', 'quarta-feira', 'quinta-feira', 'sexta-feira', 'sábado']
    };
    var dayPeriodValues = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'manhã',
        afternoon: 'tarde',
        evening: 'noite',
        night: 'madrugada'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'manhã',
        afternoon: 'tarde',
        evening: 'noite',
        night: 'madrugada'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'manhã',
        afternoon: 'tarde',
        evening: 'noite',
        night: 'madrugada'
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'da manhã',
        afternoon: 'da tarde',
        evening: 'da noite',
        night: 'da madrugada'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'da manhã',
        afternoon: 'da tarde',
        evening: 'da noite',
        night: 'da madrugada'
      },
      wide: {
        am: 'AM',
        pm: 'PM',
        midnight: 'meia-noite',
        noon: 'meio-dia',
        morning: 'da manhã',
        afternoon: 'da tarde',
        evening: 'da noite',
        night: 'da madrugada'
      }
    };
    var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
      var number = Number(dirtyNumber);
      return number + 'º';
    };
    var localize = {
      ordinalNumber: ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: 'wide',
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: 'wide'
      })
    };

    var matchOrdinalNumberPattern = /^(\d+)(º|ª)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(ac|dc|a|d)/i,
      abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
      wide: /^(antes de cristo|antes da era comum|depois de cristo|era comum)/i
    };
    var parseEraPatterns = {
      any: [/^ac/i, /^dc/i],
      wide: [/^(antes de cristo|antes da era comum)/i, /^(depois de cristo|era comum)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^T[1234]/i,
      wide: /^[1234](º|ª)? trimestre/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
      wide: /^(janeiro|fevereiro|março|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
    };
    var parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ab/i, /^mai/i, /^jun/i, /^jul/i, /^ag/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns = {
      narrow: /^[dstq]/i,
      short: /^(dom|seg|ter|qua|qui|sex|s[áa]b)/i,
      abbreviated: /^(dom|seg|ter|qua|qui|sex|s[áa]b)/i,
      wide: /^(domingo|segunda-?\s?feira|terça-?\s?feira|quarta-?\s?feira|quinta-?\s?feira|sexta-?\s?feira|s[áa]bado)/i
    };
    var parseDayPatterns = {
      narrow: [/^d/i, /^s/i, /^t/i, /^q/i, /^q/i, /^s/i, /^s/i],
      any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[áa]/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|meia-?\s?noite|meio-?\s?dia|(da) (manh[ãa]|tarde|noite|madrugada))/i,
      any: /^([ap]\.?\s?m\.?|meia-?\s?noite|meio-?\s?dia|(da) (manh[ãa]|tarde|noite|madrugada))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^meia/i,
        noon: /^meio/i,
        morning: /manh[ãa]/i,
        afternoon: /tarde/i,
        evening: /noite/i,
        night: /madrugada/i
      }
    };
    var match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function valueCallback(value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: 'any',
        valueCallback: function valueCallback(index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary Portuguese locale.
     * @language Portuguese
     * @iso-639-2 por
     * @author Dário Freire [@dfreire]{@link https://github.com/dfreire}
     * @author Adrián de la Rosa [@adrm]{@link https://github.com/adrm}
     */
    var locale = {
      code: 'pt',
      formatDistance: formatDistance,
      formatLong: formatLong,
      formatRelative: formatRelative,
      localize: localize,
      match: match,
      options: {
        weekStartsOn: 1 /* Monday */,
        firstWeekContainsDate: 4
      }
    };

    var Helpers = /*#__PURE__*/function () {
      function Helpers() {
        _classCallCheck$1(this, Helpers);
      }
      _createClass$1(Helpers, null, [{
        key: "replaceNode",
        value:
        // Helps replacing a SSR node with a Svelte component
        function replaceNode(node) {
          if (node) {
            node.innerHTML = "";
          }
          return node;
        }
      }, {
        key: "hideFallbacks",
        value: function hideFallbacks(fileName) {
          var nodes = document.querySelectorAll("[data-svelte-hide=\"".concat(fileName, "\"]"));
          if (nodes && nodes.length) {
            nodes.forEach(function (node) {
              return node.remove();
            });
          }
        }

        // Returns a new url with updated fields
      }, {
        key: "getUpdatedFilterUrl",
        value: function getUpdatedFilterUrl(field, value, baseUrl) {
          var urlParts = baseUrl.split("?");
          if (urlParts.length > 1) {
            var queryString = urlParts[1];
            var queryStringParts = queryString.split("&");
            var queryStringVariables = {};
            queryStringParts.forEach(function (part) {
              var partParts = part.split("=");
              if (partParts && partParts.length > 1 && typeof partParts[1] !== "undefined") {
                queryStringVariables = _objectSpread2(_objectSpread2({}, queryStringVariables), {}, {
                  [partParts[0]]: partParts[1]
                });
              }
            });
            queryStringVariables[field] = value;
            queryStringVariables.timezone = Helpers.getTimezone();
            return "".concat(urlParts[0], "?").concat(Object.keys(queryStringVariables).map(function (key) {
              return "".concat(key, "=").concat(queryStringVariables[key]);
            }).join("&"));
          } else {
            if (field === "timezone") {
              return "".concat(baseUrl, "?").concat(field, "=").concat(value);
            } else {
              return "".concat(baseUrl, "?").concat(field, "=").concat(value, "&timezone=").concat(Helpers.getTimezone());
            }
          }
        }
      }, {
        key: "getLinkEl",
        value: function getLinkEl() {
          return document.querySelector(".hidden-filter-link");
        }
      }, {
        key: "getDateLocaleOptions",
        value: function getDateLocaleOptions() {
          var shortLocale = getLocale().split("_")[0];
          var locales = {
            de: locale$2,
            fr: locale$1,
            pt: locale
          };
          return {
            weekStartsOn: getFirstDay(),
            locale: locales[shortLocale]
          };
        }
      }, {
        key: "calculateDuration",
        value: function calculateDuration(startTime, endTime) {
          var start = parse$3(startTime, "HH:mm", new Date(), this.getDateLocaleOptions());
          var end = parse$3(endTime, "HH:mm", new Date(), this.getDateLocaleOptions());
          var duration = Math.max(0, this.simpleRounding(differenceInMinutes(end, start) / 60));
          if (isNaN(duration)) {
            return 0;
          }
          return duration;
        }
      }, {
        key: "normalizeDuration",
        value: function normalizeDuration(duration) {
          if (!duration) {
            return duration;
          }
          var value = "".concat(duration);
          var normalizedValue = value.replace(/[^0-9.,]*/g, "");

          // Replace decimal comma with dot
          normalizedValue = normalizedValue.replace(/,/g, ".");
          // Remove duplicate decimal dots
          if (normalizedValue.includes(".")) {
            var partsArray = normalizedValue.split(".");
            var _partsArray = _slicedToArray(partsArray, 1),
              wholeNumber = _partsArray[0];
            partsArray.shift();
            normalizedValue = "".concat(wholeNumber, ".").concat(partsArray.join(""));
            if (value.endsWith(".") && partsArray.length <= 1) {
              return duration;
            }
          }
          return normalizedValue;
        }

        // NOTE: As this methods returns the 'HH:mm' value only, durations >= 24h will be ignored
      }, {
        key: "calculateEndTime",
        value: function calculateEndTime(startTime, duration) {
          if (!startTime || !duration) {
            return undefined;
          }
          var start = parse$3(startTime, "HH:mm", new Date(), this.getDateLocaleOptions()).getTime();
          return addMinutes(start, Math.round(duration * 60)).toTimeString().substring(0, 5);
        }
      }, {
        key: "toUTC",
        value: function toUTC(date) {
          date.setTime(date.getTime() + date.getTimezoneOffset() * 60000);
          return date;
        }
      }, {
        key: "simpleRounding",
        value: function simpleRounding(number) {
          return Math.round(number * 100) / 100;
        }
      }, {
        key: "getTimezone",
        value: function getTimezone() {
          return Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
      }]);
      return Helpers;
    }();

    function get_each_context$8(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[25] = list[i];
      child_ctx[27] = i;
      return child_ctx;
    }

    // (228:0) {#if controls}
    function create_if_block_7$2(ctx) {
      var h2;
      return {
        c() {
          h2 = element("h2");
          h2.textContent = "".concat(translate("timemanager", "Statistics"));
        },
        m(target, anchor) {
          insert(target, h2, anchor);
        },
        d(detaching) {
          if (detaching) {
            detach(h2);
          }
        }
      };
    }

    // (232:1) {#if controls}
    function create_if_block_6$3(ctx) {
      var div;
      var figure0;
      var figcaption0;
      var t1;
      var t2_value = /*simpleRounding*/ctx[8]( /*todayTotal*/ctx[4]) + "";
      var t2;
      var t3;
      var t4_value = translate("timemanager", "hrs.") + "";
      var t4;
      var t5;
      var figure1;
      var figcaption1;
      var t7;
      var t8_value = /*simpleRounding*/ctx[8]( /*weekTotal*/ctx[5]) + "";
      var t8;
      var t9;
      var t10_value = translate("timemanager", "hrs.") + "";
      var t10;
      return {
        c() {
          div = element("div");
          figure0 = element("figure");
          figcaption0 = element("figcaption");
          figcaption0.textContent = "".concat(translate("timemanager", "Today"));
          t1 = space$1();
          t2 = text$1(t2_value);
          t3 = space$1();
          t4 = text$1(t4_value);
          t5 = space$1();
          figure1 = element("figure");
          figcaption1 = element("figcaption");
          figcaption1.textContent = "".concat(translate("timemanager", "Week"));
          t7 = space$1();
          t8 = text$1(t8_value);
          t9 = space$1();
          t10 = text$1(t10_value);
          attr(figcaption0, "class", "tm_label");
          attr(figcaption1, "class", "tm_label");
          attr(div, "class", "top-stats");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          append(div, figure0);
          append(figure0, figcaption0);
          append(figure0, t1);
          append(figure0, t2);
          append(figure0, t3);
          append(figure0, t4);
          append(div, t5);
          append(div, figure1);
          append(figure1, figcaption1);
          append(figure1, t7);
          append(figure1, t8);
          append(figure1, t9);
          append(figure1, t10);
        },
        p(ctx, dirty) {
          if (dirty & /*todayTotal*/16 && t2_value !== (t2_value = /*simpleRounding*/ctx[8]( /*todayTotal*/ctx[4]) + "")) set_data(t2, t2_value);
          if (dirty & /*weekTotal*/32 && t8_value !== (t8_value = /*simpleRounding*/ctx[8]( /*weekTotal*/ctx[5]) + "")) set_data(t8, t8_value);
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
        }
      };
    }

    // (248:3) {#if !loading && weekTotal > 0}
    function create_if_block_3$3(ctx) {
      var each_1_anchor;
      var each_value = ensure_array_like( /*points*/ctx[3]);
      var each_blocks = [];
      for (var i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
      }
      return {
        c() {
          for (var _i = 0; _i < each_blocks.length; _i += 1) {
            each_blocks[_i].c();
          }
          each_1_anchor = empty();
        },
        m(target, anchor) {
          for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
            if (each_blocks[_i2]) {
              each_blocks[_i2].m(target, anchor);
            }
          }
          insert(target, each_1_anchor, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*formatDateForScale, points, highest*/2120) {
            each_value = ensure_array_like( /*points*/ctx[3]);
            var _i3;
            for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
              var child_ctx = get_each_context$8(ctx, each_value, _i3);
              if (each_blocks[_i3]) {
                each_blocks[_i3].p(child_ctx, dirty);
              } else {
                each_blocks[_i3] = create_each_block$8(child_ctx);
                each_blocks[_i3].c();
                each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            for (; _i3 < each_blocks.length; _i3 += 1) {
              each_blocks[_i3].d(1);
            }
            each_blocks.length = each_value.length;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(each_1_anchor);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }

    // (251:6) {#if point && point.stats}
    function create_if_block_4$3(ctx) {
      var t0;
      var div;
      var span0;
      var t1_value = /*formatDateForScale*/ctx[11]( /*point*/ctx[25].date, "primary") + "";
      var t1;
      var t2;
      var span1;
      var t3_value = /*formatDateForScale*/ctx[11]( /*point*/ctx[25].date, "secondary") + "";
      var t3;
      var if_block = /*point*/ctx[25].stats.total > 0 && create_if_block_5$3(ctx);
      return {
        c() {
          if (if_block) if_block.c();
          t0 = space$1();
          div = element("div");
          span0 = element("span");
          t1 = text$1(t1_value);
          t2 = space$1();
          span1 = element("span");
          t3 = text$1(t3_value);
          attr(span0, "class", "day");
          attr(span1, "class", "date");
          attr(div, "class", "date-label");
        },
        m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, t0, anchor);
          insert(target, div, anchor);
          append(div, span0);
          append(span0, t1);
          append(div, t2);
          append(div, span1);
          append(span1, t3);
        },
        p(ctx, dirty) {
          if ( /*point*/ctx[25].stats.total > 0) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_5$3(ctx);
              if_block.c();
              if_block.m(t0.parentNode, t0);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
          if (dirty & /*points*/8 && t1_value !== (t1_value = /*formatDateForScale*/ctx[11]( /*point*/ctx[25].date, "primary") + "")) set_data(t1, t1_value);
          if (dirty & /*points*/8 && t3_value !== (t3_value = /*formatDateForScale*/ctx[11]( /*point*/ctx[25].date, "secondary") + "")) set_data(t3, t3_value);
        },
        d(detaching) {
          if (detaching) {
            detach(t0);
            detach(div);
          }
          if (if_block) if_block.d(detaching);
        }
      };
    }

    // (252:7) {#if point.stats.total > 0}
    function create_if_block_5$3(ctx) {
      var span;
      var t0_value = /*point*/ctx[25].stats.total + "";
      var t0;
      var t1;
      var t2_value = translate("timemanager", "hrs.") + "";
      var t2;
      var t3;
      var div;
      var div_style_value;
      return {
        c() {
          span = element("span");
          t0 = text$1(t0_value);
          t1 = space$1();
          t2 = text$1(t2_value);
          t3 = space$1();
          div = element("div");
          attr(span, "class", "hours-label");
          attr(div, "class", "column-inner");
          attr(div, "style", div_style_value = "height: ".concat( /*point*/ctx[25].stats.total / /*highest*/ctx[6] * 100, "%"));
        },
        m(target, anchor) {
          insert(target, span, anchor);
          append(span, t0);
          append(span, t1);
          append(span, t2);
          insert(target, t3, anchor);
          insert(target, div, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*points*/8 && t0_value !== (t0_value = /*point*/ctx[25].stats.total + "")) set_data(t0, t0_value);
          if (dirty & /*points, highest*/72 && div_style_value !== (div_style_value = "height: ".concat( /*point*/ctx[25].stats.total / /*highest*/ctx[6] * 100, "%"))) {
            attr(div, "style", div_style_value);
          }
        },
        d(detaching) {
          if (detaching) {
            detach(span);
            detach(t3);
            detach(div);
          }
        }
      };
    }

    // (249:4) {#each points as point, index}
    function create_each_block$8(ctx) {
      var div;
      var t;
      var if_block = /*point*/ctx[25] && /*point*/ctx[25].stats && create_if_block_4$3(ctx);
      return {
        c() {
          div = element("div");
          if (if_block) if_block.c();
          t = space$1();
          attr(div, "class", "column");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          if (if_block) if_block.m(div, null);
          append(div, t);
        },
        p(ctx, dirty) {
          if ( /*point*/ctx[25] && /*point*/ctx[25].stats) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_4$3(ctx);
              if_block.c();
              if_block.m(div, t);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          if (if_block) if_block.d();
        }
      };
    }

    // (264:3) {#if controls && !loading && weekTotal === 0}
    function create_if_block_2$6(ctx) {
      var p;
      return {
        c() {
          p = element("p");
          p.textContent = "".concat(translate("timemanager", "When you add entries for this week graphs will appear here."));
          attr(p, "class", "empty");
        },
        m(target, anchor) {
          insert(target, p, anchor);
        },
        d(detaching) {
          if (detaching) {
            detach(p);
          }
        }
      };
    }

    // (268:2) {#if controls}
    function create_if_block$j(ctx) {
      var nav;
      var button0;
      var t1;
      var span1;
      var t2_value = translate("timemanager", "Week") + "";
      var t2;
      var t3;
      var t4;
      var t5;
      var span0;
      var t6;
      var t7_value = format$2(startOfWeek( /*startCursor*/ctx[1], /*localeOptions*/ctx[9]), "iiiiii d.MM.Y", /*localeOptions*/ctx[9]) + "";
      var t7;
      var t8;
      var t9_value = format$2(endOfWeek( /*startCursor*/ctx[1], /*localeOptions*/ctx[9]), "iiiiii d.MM.Y", /*localeOptions*/ctx[9]) + "";
      var t9;
      var t10;
      var t11;
      var span2;
      var show_if = !isSameDay(startOfWeek(startOfToday(), /*localeOptions*/ctx[9]), /*startCursor*/ctx[1]);
      var t12;
      var button1;
      var mounted;
      var dispose;
      var if_block = show_if && create_if_block_1$7(ctx);
      return {
        c() {
          nav = element("nav");
          button0 = element("button");
          button0.textContent = "".concat(translate("timemanager", "Previous week"));
          t1 = space$1();
          span1 = element("span");
          t2 = text$1(t2_value);
          t3 = space$1();
          t4 = text$1( /*currentWeek*/ctx[7]);
          t5 = space$1();
          span0 = element("span");
          t6 = text$1("(");
          t7 = text$1(t7_value);
          t8 = text$1(" – ");
          t9 = text$1(t9_value);
          t10 = text$1(")");
          t11 = space$1();
          span2 = element("span");
          if (if_block) if_block.c();
          t12 = space$1();
          button1 = element("button");
          button1.textContent = "".concat(translate("timemanager", "Next week"));
          attr(button0, "class", "previous");
          attr(span0, "class", "dates");
          attr(button1, "class", "next");
          attr(nav, "class", "week-navigation");
        },
        m(target, anchor) {
          insert(target, nav, anchor);
          append(nav, button0);
          append(nav, t1);
          append(nav, span1);
          append(span1, t2);
          append(span1, t3);
          append(span1, t4);
          append(span1, t5);
          append(span1, span0);
          append(span0, t6);
          append(span0, t7);
          append(span0, t8);
          append(span0, t9);
          append(span0, t10);
          append(nav, t11);
          append(nav, span2);
          if (if_block) if_block.m(span2, null);
          append(span2, t12);
          append(span2, button1);
          if (!mounted) {
            dispose = [listen(button0, "click", prevent_default( /*click_handler*/ctx[17])), listen(button1, "click", prevent_default( /*click_handler_2*/ctx[19]))];
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty & /*currentWeek*/128) set_data(t4, /*currentWeek*/ctx[7]);
          if (dirty & /*startCursor*/2 && t7_value !== (t7_value = format$2(startOfWeek( /*startCursor*/ctx[1], /*localeOptions*/ctx[9]), "iiiiii d.MM.Y", /*localeOptions*/ctx[9]) + "")) set_data(t7, t7_value);
          if (dirty & /*startCursor*/2 && t9_value !== (t9_value = format$2(endOfWeek( /*startCursor*/ctx[1], /*localeOptions*/ctx[9]), "iiiiii d.MM.Y", /*localeOptions*/ctx[9]) + "")) set_data(t9, t9_value);
          if (dirty & /*startCursor*/2) show_if = !isSameDay(startOfWeek(startOfToday(), /*localeOptions*/ctx[9]), /*startCursor*/ctx[1]);
          if (show_if) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_1$7(ctx);
              if_block.c();
              if_block.m(span2, t12);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(nav);
          }
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }

    // (285:5) {#if !isSameDay(startOfWeek(startOfToday(), localeOptions), startCursor)}
    function create_if_block_1$7(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c() {
          button = element("button");
          button.textContent = "".concat(translate("timemanager", "Current week"));
          attr(button, "class", "current");
        },
        m(target, anchor) {
          insert(target, button, anchor);
          if (!mounted) {
            dispose = listen(button, "click", prevent_default( /*click_handler_1*/ctx[18]));
            mounted = true;
          }
        },
        p: noop$1,
        d(detaching) {
          if (detaching) {
            detach(button);
          }
          mounted = false;
          dispose();
        }
      };
    }
    function create_fragment$s(ctx) {
      var t0;
      var div2;
      var t1;
      var div1;
      var div0;
      var t2;
      var div0_class_value;
      var t3;
      var div2_class_value;
      var if_block0 = /*controls*/ctx[0] && create_if_block_7$2();
      var if_block1 = /*controls*/ctx[0] && create_if_block_6$3(ctx);
      var if_block2 = ! /*loading*/ctx[2] && /*weekTotal*/ctx[5] > 0 && create_if_block_3$3(ctx);
      var if_block3 = /*controls*/ctx[0] && ! /*loading*/ctx[2] && /*weekTotal*/ctx[5] === 0 && create_if_block_2$6();
      var if_block4 = /*controls*/ctx[0] && create_if_block$j(ctx);
      return {
        c() {
          if (if_block0) if_block0.c();
          t0 = space$1();
          div2 = element("div");
          if (if_block1) if_block1.c();
          t1 = space$1();
          div1 = element("div");
          div0 = element("div");
          if (if_block2) if_block2.c();
          t2 = space$1();
          if (if_block3) if_block3.c();
          t3 = space$1();
          if (if_block4) if_block4.c();
          attr(div0, "class", div0_class_value = "hours-per-week ".concat( /*points*/ctx[3].length > 12 || window.clientWidth < 768 ? "many" : "few"));
          attr(div1, "class", "graphs");
          attr(div2, "class", div2_class_value = "".concat( /*loading*/ctx[2] ? "icon-loading" : ""));
        },
        m(target, anchor) {
          if (if_block0) if_block0.m(target, anchor);
          insert(target, t0, anchor);
          insert(target, div2, anchor);
          if (if_block1) if_block1.m(div2, null);
          append(div2, t1);
          append(div2, div1);
          append(div1, div0);
          if (if_block2) if_block2.m(div0, null);
          append(div0, t2);
          if (if_block3) if_block3.m(div0, null);
          append(div1, t3);
          if (if_block4) if_block4.m(div1, null);
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if ( /*controls*/ctx[0]) {
            if (if_block0) ; else {
              if_block0 = create_if_block_7$2();
              if_block0.c();
              if_block0.m(t0.parentNode, t0);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          if ( /*controls*/ctx[0]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block_6$3(ctx);
              if_block1.c();
              if_block1.m(div2, t1);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
          if (! /*loading*/ctx[2] && /*weekTotal*/ctx[5] > 0) {
            if (if_block2) {
              if_block2.p(ctx, dirty);
            } else {
              if_block2 = create_if_block_3$3(ctx);
              if_block2.c();
              if_block2.m(div0, t2);
            }
          } else if (if_block2) {
            if_block2.d(1);
            if_block2 = null;
          }
          if ( /*controls*/ctx[0] && ! /*loading*/ctx[2] && /*weekTotal*/ctx[5] === 0) {
            if (if_block3) ; else {
              if_block3 = create_if_block_2$6();
              if_block3.c();
              if_block3.m(div0, null);
            }
          } else if (if_block3) {
            if_block3.d(1);
            if_block3 = null;
          }
          if (dirty & /*points*/8 && div0_class_value !== (div0_class_value = "hours-per-week ".concat( /*points*/ctx[3].length > 12 || window.clientWidth < 768 ? "many" : "few"))) {
            attr(div0, "class", div0_class_value);
          }
          if ( /*controls*/ctx[0]) {
            if (if_block4) {
              if_block4.p(ctx, dirty);
            } else {
              if_block4 = create_if_block$j(ctx);
              if_block4.c();
              if_block4.m(div1, null);
            }
          } else if (if_block4) {
            if_block4.d(1);
            if_block4 = null;
          }
          if (dirty & /*loading*/4 && div2_class_value !== (div2_class_value = "".concat( /*loading*/ctx[2] ? "icon-loading" : ""))) {
            attr(div2, "class", div2_class_value);
          }
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(t0);
            detach(div2);
          }
          if (if_block0) if_block0.d(detaching);
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          if (if_block3) if_block3.d();
          if (if_block4) if_block4.d();
        }
      };
    }
    var dateFormat$4 = "yyyy-MM-dd";
    var apiDateFormat = "yyyy-MM-dd HH:mm:ss";
    function instance$r($$self, $$props, $$invalidate) {
      var loading;
      var scale;
      var points;
      var weekTotal;
      var todayTotal;
      var highest;
      var startCursor;
      var endCursor;
      var currentWeek;
      var statsApiUrl = $$props.statsApiUrl;
      var requestToken = $$props.requestToken;
      var _$$props$controls = $$props.controls,
        controls = _$$props$controls === void 0 ? true : _$$props$controls;
      var _$$props$includeShare = $$props.includeShared,
        includeShared = _$$props$includeShare === void 0 ? false : _$$props$includeShare;
      var simpleRounding = Helpers.simpleRounding;
      var localeOptions = Helpers.getDateLocaleOptions();
      var _$$props$start = $$props.start,
        start = _$$props$start === void 0 ? format$2(startOfWeek(new Date(), localeOptions), dateFormat$4, new Date()) : _$$props$start;
      var _$$props$end = $$props.end,
        end = _$$props$end === void 0 ? format$2(endOfWeek(new Date(), localeOptions), dateFormat$4, new Date()) : _$$props$end;
      var updateWeek = function updateWeek() {
        $$invalidate(5, weekTotal = 0);
        $$invalidate(4, todayTotal = 0);
        $$invalidate(6, highest = 0);
        $$invalidate(7, currentWeek = getWeek(startCursor, localeOptions));
      };
      onMount( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              updateWeek();
              loadData();
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      })));
      var loadData = /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var durationDays, durationMonths, durationWeeks, durationYears, _yield$loadStats, grouped, js_date_format;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                $$invalidate(2, loading = true);

                // Reset points
                $$invalidate(3, points = []);

                // Determine duration between cursors
                durationDays = differenceInDays(endCursor, startCursor);
                durationMonths = differenceInMonths(endCursor, startCursor);
                durationWeeks = differenceInWeeks(endCursor, startCursor);
                durationYears = differenceInYears(endCursor, startCursor); // Determine scale
                if (durationDays > 31 && durationDays <= 180) {
                  scale = "week";
                  Array.from(Array(durationWeeks + 1).keys()).forEach(function (week) {
                    points.push({
                      date: addWeeks(startCursor, week)
                    });
                  });
                } else if (durationDays > 180 && durationMonths <= 24) {
                  scale = "month";
                  Array.from(Array(durationMonths + 1).keys()).forEach(function (month) {
                    points.push({
                      date: addMonths(startCursor, month)
                    });
                  });
                } else if (durationMonths > 24) {
                  scale = "year";
                  Array.from(Array(durationYears + 1).keys()).forEach(function (year) {
                    points.push({
                      date: addYears(startCursor, year)
                    });
                  });
                } else {
                  scale = "day";
                  Array.from(Array(durationDays + 1).keys()).forEach(function (day) {
                    points.push({
                      date: addDays(startCursor, day)
                    });
                  });
                }

                // Load data from API
                _context2.next = 9;
                return loadStats();
              case 9:
                _yield$loadStats = _context2.sent;
                grouped = _yield$loadStats.grouped;
                js_date_format = _yield$loadStats.js_date_format;
                // Extract points from grouped array
                $$invalidate(3, points = points.map(function (point) {
                  // Get total from API response
                  var total = grouped[format$2(point.date, js_date_format)];
                  point.stats = {
                    total: total ? simpleRounding(total) : 0
                  };

                  // Find highest value
                  if (total > highest) {
                    $$invalidate(6, highest = total);
                  }

                  // Sum up total
                  $$invalidate(5, weekTotal += point.stats.total);

                  // Day total
                  if (isSameDay(point.date, startOfToday())) {
                    $$invalidate(4, todayTotal += point.stats.total);
                  }
                  return point;
                }));

                // Set columns
                document.documentElement.style.setProperty("--tm-stats-columns", points.length);
                $$invalidate(2, loading = false);
              case 15:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        return function loadData() {
          return _ref4.apply(this, arguments);
        };
      }();
      var loadStats = /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
          var start, end, statUrl, urlParts, queryString, queryStringParts, stats;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                start = format$2(startOfDay(startCursor), apiDateFormat);
                end = format$2(endOfDay(endCursor), apiDateFormat);
                statUrl = "".concat(statsApiUrl, "?start=").concat(start, "&end=").concat(end, "&group_by=").concat(scale, "&shared=").concat(includeShared ? 1 : 0);
                statUrl += "&timezone=".concat(Helpers.getTimezone());

                // Parse current URL for filters
                urlParts = document.location.href.split("?");
                if (urlParts.length > 1) {
                  queryString = urlParts[1];
                  queryStringParts = queryString.split("&"); // Map over all query params
                  queryStringParts.forEach(function (part) {
                    // Split query params
                    var partParts = part.split("=");
                    var _partParts = _slicedToArray(partParts, 2),
                      name = _partParts[0],
                      value = _partParts[1];

                    // Apply filters from query params
                    if (name === "status" && value) {
                      statUrl += "&status=".concat(value);
                    }
                    if (name === "tasks" && value && value.length) {
                      statUrl += "&tasks=".concat(value);
                    }
                    if (name === "projects" && value && value.length) {
                      statUrl += "&projects=".concat(value);
                    }
                    if (name === "clients" && value && value.length) {
                      statUrl += "&clients=".concat(value);
                    }
                    if (name === "userFilter" && value && value.length) {
                      statUrl += "&userFilter=".concat(value);
                    }
                  });
                }
                _context3.next = 8;
                return fetch(statUrl, {
                  method: "GET",
                  headers: {
                    requesttoken: requestToken,
                    "content-type": "application/json"
                  }
                });
              case 8:
                stats = _context3.sent;
                _context3.next = 11;
                return stats.json();
              case 11:
                return _context3.abrupt("return", _context3.sent);
              case 12:
              case "end":
                return _context3.stop();
            }
          }, _callee3);
        }));
        return function loadStats() {
          return _ref5.apply(this, arguments);
        };
      }();
      var weekNavigation = function weekNavigation(mode) {
        if (mode === "reset") {
          $$invalidate(1, startCursor = startOfWeek(startOfToday(), localeOptions));
          endCursor = endOfWeek(startCursor, localeOptions);
        } else if (mode === "next") {
          $$invalidate(1, startCursor = addWeeks(startCursor, 1));
          endCursor = addWeeks(endCursor, 1);
        } else {
          $$invalidate(1, startCursor = subWeeks(startCursor, 1));
          endCursor = subWeeks(endCursor, 1);
        }
        updateWeek();
        loadData();
      };
      var formatDateForScale = function formatDateForScale(date, type) {
        if (type === "primary") {
          if (scale === "year") {
            return format$2(date, "yyyy", localeOptions);
          }
          if (scale === "month") {
            return format$2(date, "LLL", localeOptions);
          }
          if (scale === "week") {
            return "".concat(translate("timemanager", "Week"), " ").concat(format$2(date, "w", localeOptions));
          }
          return format$2(date, "iii", localeOptions);
        }
        if (type === "secondary") {
          if (scale === "year") {
            return "";
          }
          if (scale === "month") {
            return format$2(date, "yyyy", localeOptions);
          }
          if (scale === "week") {
            return "".concat(format$2(startOfWeek(date, localeOptions), "d.M.", localeOptions), " - ").concat(format$2(endOfWeek(date, localeOptions), "d.M.", localeOptions));
          }
          return format$2(date, "d.M.", localeOptions);
        }
      };
      var click_handler = function click_handler() {
        return weekNavigation("previous");
      };
      var click_handler_1 = function click_handler_1() {
        return weekNavigation("reset");
      };
      var click_handler_2 = function click_handler_2() {
        return weekNavigation("next");
      };
      $$self.$$set = function ($$props) {
        if ('statsApiUrl' in $$props) $$invalidate(12, statsApiUrl = $$props.statsApiUrl);
        if ('requestToken' in $$props) $$invalidate(13, requestToken = $$props.requestToken);
        if ('controls' in $$props) $$invalidate(0, controls = $$props.controls);
        if ('includeShared' in $$props) $$invalidate(14, includeShared = $$props.includeShared);
        if ('start' in $$props) $$invalidate(15, start = $$props.start);
        if ('end' in $$props) $$invalidate(16, end = $$props.end);
      };
      $$self.$$.update = function () {
        if ($$self.$$.dirty & /*start*/32768) {
          $$invalidate(1, startCursor = isDate$1(parse$3(start, dateFormat$4, new Date())) ? parse$3(start, dateFormat$4, new Date()) : startOfWeek(new Date(), localeOptions));
        }
        if ($$self.$$.dirty & /*end*/65536) {
          endCursor = isDate$1(parse$3(end, dateFormat$4, new Date())) ? parse$3(end, dateFormat$4, new Date()) : endOfWeek(new Date(), localeOptions);
        }
      };
      $$invalidate(2, loading = false);
      scale = "day";
      $$invalidate(3, points = []);
      $$invalidate(5, weekTotal = 0);
      $$invalidate(4, todayTotal = 0);
      $$invalidate(6, highest = 0);
      $$invalidate(7, currentWeek = null);
      return [controls, startCursor, loading, points, todayTotal, weekTotal, highest, currentWeek, simpleRounding, localeOptions, weekNavigation, formatDateForScale, statsApiUrl, requestToken, includeShared, start, end, click_handler, click_handler_1, click_handler_2];
    }
    var Statistics = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(Statistics, _SvelteComponent);
      var _super = _createSuper$1(Statistics);
      function Statistics(options) {
        var _this;
        _classCallCheck$1(this, Statistics);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$r, create_fragment$s, safe_not_equal, {
          statsApiUrl: 12,
          requestToken: 13,
          controls: 0,
          includeShared: 14,
          start: 15,
          end: 16
        });
        return _this;
      }
      return _createClass$1(Statistics);
    }(SvelteComponent);

    function create_fragment$r(ctx) {
      var div0;
      var t;
      var div1;
      var div1_class_value;
      var current;
      var default_slot_template = /*#slots*/ctx[2].default;
      var default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[1], null);
      return {
        c() {
          div0 = element("div");
          t = space$1();
          div1 = element("div");
          if (default_slot) default_slot.c();
          attr(div0, "class", "oc-dialog-dim");
          attr(div1, "class", div1_class_value = "oc-dialog ".concat( /*loading*/ctx[0] ? 'icon-loading' : ''));
          set_style(div1, "position", "fixed");
        },
        m(target, anchor) {
          insert(target, div0, anchor);
          insert(target, t, anchor);
          insert(target, div1, anchor);
          if (default_slot) {
            default_slot.m(div1, null);
          }
          current = true;
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if (default_slot) {
            if (default_slot.p && (!current || dirty & /*$$scope*/2)) {
              update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[1], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[1]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[1], dirty, null), null);
            }
          }
          if (!current || dirty & /*loading*/1 && div1_class_value !== (div1_class_value = "oc-dialog ".concat( /*loading*/ctx[0] ? 'icon-loading' : ''))) {
            attr(div1, "class", div1_class_value);
          }
        },
        i(local) {
          if (current) return;
          transition_in(default_slot, local);
          current = true;
        },
        o(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div0);
            detach(t);
            detach(div1);
          }
          if (default_slot) default_slot.d(detaching);
        }
      };
    }
    function instance$q($$self, $$props, $$invalidate) {
      var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
        $$scope = $$props.$$scope;
      var _$$props$loading = $$props.loading,
        loading = _$$props$loading === void 0 ? false : _$$props$loading;
      $$self.$$set = function ($$props) {
        if ('loading' in $$props) $$invalidate(0, loading = $$props.loading);
        if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
      };
      return [loading, $$scope, slots];
    }
    var Overlay = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(Overlay, _SvelteComponent);
      var _super = _createSuper$1(Overlay);
      function Overlay(options) {
        var _this;
        _classCallCheck$1(this, Overlay);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$q, create_fragment$r, safe_not_equal, {
          loading: 0
        });
        return _this;
      }
      return _createClass$1(Overlay);
    }(SvelteComponent);

    function create_if_block$i(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c() {
          button = element("button");
          button.textContent = "".concat(translate('timemanager', 'Cancel'));
          attr(button, "type", "reset");
          attr(button, "class", "button");
        },
        m(target, anchor) {
          insert(target, button, anchor);
          if (!mounted) {
            dispose = listen(button, "click", prevent_default(function () {
              if (is_function( /*onCancel*/ctx[3])) /*onCancel*/ctx[3].apply(this, arguments);
            }));
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
        },
        d(detaching) {
          if (detaching) {
            detach(button);
          }
          mounted = false;
          dispose();
        }
      };
    }
    function create_fragment$q(ctx) {
      var div1;
      var h3;
      var t0;
      var t1;
      var form;
      var label0;
      var t2_value = translate('timemanager', 'Client name') + "";
      var t2;
      var t3;
      var br0;
      var t4;
      var input0;
      var t5;
      var label1;
      var t6_value = translate('timemanager', 'Note') + "";
      var t6;
      var t7;
      var br1;
      var t8;
      var textarea;
      var t9;
      var input1;
      var t10;
      var div0;
      var button;
      var t11;
      var t12;
      var mounted;
      var dispose;
      var if_block = ! /*isServer*/ctx[2] && create_if_block$i(ctx);
      return {
        c() {
          div1 = element("div");
          h3 = element("h3");
          t0 = text$1( /*clientEditorCaption*/ctx[5]);
          t1 = space$1();
          form = element("form");
          label0 = element("label");
          t2 = text$1(t2_value);
          t3 = space$1();
          br0 = element("br");
          t4 = space$1();
          input0 = element("input");
          t5 = space$1();
          label1 = element("label");
          t6 = text$1(t6_value);
          t7 = space$1();
          br1 = element("br");
          t8 = space$1();
          textarea = element("textarea");
          t9 = space$1();
          input1 = element("input");
          t10 = space$1();
          div0 = element("div");
          button = element("button");
          t11 = text$1( /*clientEditorButtonCaption*/ctx[4]);
          t12 = space$1();
          if (if_block) if_block.c();
          input0.autofocus = true;
          attr(input0, "type", "text");
          set_style(input0, "width", "100%");
          attr(input0, "class", "input-wide");
          attr(input0, "name", "name");
          attr(input0, "placeholder", translate('timemanager', 'Example Corp.'));
          input0.required = true;
          attr(label0, "class", "space-top");
          set_style(textarea, "width", "100%");
          attr(textarea, "class", "input-wide");
          attr(textarea, "name", "note");
          attr(textarea, "placeholder", "");
          textarea.value = /*note*/ctx[7];
          attr(label1, "class", "space-top");
          attr(input1, "type", "hidden");
          attr(input1, "name", "requesttoken");
          input1.value = /*requestToken*/ctx[1];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(form, "action", /*action*/ctx[0]);
          attr(form, "method", "post");
          attr(div1, "class", "inner tm_new-item");
        },
        m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, h3);
          append(h3, t0);
          append(div1, t1);
          append(div1, form);
          append(form, label0);
          append(label0, t2);
          append(label0, t3);
          append(label0, br0);
          append(label0, t4);
          append(label0, input0);
          set_input_value(input0, /*name*/ctx[6]);
          append(form, t5);
          append(form, label1);
          append(label1, t6);
          append(label1, t7);
          append(label1, br1);
          append(label1, t8);
          append(label1, textarea);
          append(form, t9);
          append(form, input1);
          append(form, t10);
          append(form, div0);
          append(div0, button);
          append(button, t11);
          append(div0, t12);
          if (if_block) if_block.m(div0, null);
          input0.focus();
          if (!mounted) {
            dispose = [listen(input0, "input", /*input0_input_handler*/ctx[11]), listen(textarea, "input", /*input_handler*/ctx[12]), listen(form, "submit", prevent_default( /*submit*/ctx[8]))];
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if (dirty & /*clientEditorCaption*/32) set_data(t0, /*clientEditorCaption*/ctx[5]);
          if (dirty & /*name*/64 && input0.value !== /*name*/ctx[6]) {
            set_input_value(input0, /*name*/ctx[6]);
          }
          if (dirty & /*note*/128) {
            textarea.value = /*note*/ctx[7];
          }
          if (dirty & /*requestToken*/2) {
            input1.value = /*requestToken*/ctx[1];
          }
          if (dirty & /*clientEditorButtonCaption*/16) set_data(t11, /*clientEditorButtonCaption*/ctx[4]);
          if (! /*isServer*/ctx[2]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$i(ctx);
              if_block.c();
              if_block.m(div0, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
          if (dirty & /*action*/1) {
            attr(form, "action", /*action*/ctx[0]);
          }
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(div1);
          }
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function instance$p($$self, $$props, $$invalidate) {
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var isServer = $$props.isServer;
      var onCancel = $$props.onCancel;
      var onSubmit = $$props.onSubmit;
      var clientEditorButtonCaption = $$props.clientEditorButtonCaption;
      var clientEditorCaption = $$props.clientEditorCaption;
      var editClientData = $$props.editClientData;
      var name = editClientData ? editClientData.name : "";
      var note = editClientData ? editClientData.note : "";
      var submit = function submit() {
        onSubmit({
          name,
          note
        });
      };
      function input0_input_handler() {
        name = this.value;
        $$invalidate(6, name);
      }
      var input_handler = function input_handler(e) {
        return $$invalidate(7, note = e.target.value);
      };
      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('isServer' in $$props) $$invalidate(2, isServer = $$props.isServer);
        if ('onCancel' in $$props) $$invalidate(3, onCancel = $$props.onCancel);
        if ('onSubmit' in $$props) $$invalidate(9, onSubmit = $$props.onSubmit);
        if ('clientEditorButtonCaption' in $$props) $$invalidate(4, clientEditorButtonCaption = $$props.clientEditorButtonCaption);
        if ('clientEditorCaption' in $$props) $$invalidate(5, clientEditorCaption = $$props.clientEditorCaption);
        if ('editClientData' in $$props) $$invalidate(10, editClientData = $$props.editClientData);
      };
      return [action, requestToken, isServer, onCancel, clientEditorButtonCaption, clientEditorCaption, name, note, submit, onSubmit, editClientData, input0_input_handler, input_handler];
    }
    var ClientEditor = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(ClientEditor, _SvelteComponent);
      var _super = _createSuper$1(ClientEditor);
      function ClientEditor(options) {
        var _this;
        _classCallCheck$1(this, ClientEditor);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$p, create_fragment$q, safe_not_equal, {
          action: 0,
          requestToken: 1,
          isServer: 2,
          onCancel: 3,
          onSubmit: 9,
          clientEditorButtonCaption: 4,
          clientEditorCaption: 5,
          editClientData: 10
        });
        return _this;
      }
      return _createClass$1(ClientEditor);
    }(SvelteComponent);

    function create_if_block$h(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          loading: /*loading*/ctx[5],
          $$slots: {
            default: [create_default_slot$8]
          },
          $$scope: {
            ctx
          }
        }
      });
      return {
        c() {
          create_component(overlay.$$.fragment);
        },
        m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty & /*loading*/32) overlay_changes.loading = /*loading*/ctx[5];
          if (dirty & /*$$scope, action, requestToken, show, clientEditorButtonCaption, clientEditorCaption, editClientData*/4191) {
            overlay_changes.$$scope = {
              dirty,
              ctx
            };
          }
          overlay.$set(overlay_changes);
        },
        i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    }

    // (56:1) <Overlay {loading}>
    function create_default_slot$8(ctx) {
      var clienteditor;
      var current;
      clienteditor = new ClientEditor({
        props: {
          action: /*action*/ctx[0],
          requestToken: /*requestToken*/ctx[1],
          onCancel: /*func*/ctx[11],
          onSubmit: /*save*/ctx[7],
          clientEditorButtonCaption: /*clientEditorButtonCaption*/ctx[2],
          clientEditorCaption: /*clientEditorCaption*/ctx[3],
          editClientData: /*editClientData*/ctx[4]
        }
      });
      return {
        c() {
          create_component(clienteditor.$$.fragment);
        },
        m(target, anchor) {
          mount_component(clienteditor, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var clienteditor_changes = {};
          if (dirty & /*action*/1) clienteditor_changes.action = /*action*/ctx[0];
          if (dirty & /*requestToken*/2) clienteditor_changes.requestToken = /*requestToken*/ctx[1];
          if (dirty & /*show*/64) clienteditor_changes.onCancel = /*func*/ctx[11];
          if (dirty & /*clientEditorButtonCaption*/4) clienteditor_changes.clientEditorButtonCaption = /*clientEditorButtonCaption*/ctx[2];
          if (dirty & /*clientEditorCaption*/8) clienteditor_changes.clientEditorCaption = /*clientEditorCaption*/ctx[3];
          if (dirty & /*editClientData*/16) clienteditor_changes.editClientData = /*editClientData*/ctx[4];
          clienteditor.$set(clienteditor_changes);
        },
        i(local) {
          if (current) return;
          transition_in(clienteditor.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(clienteditor.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(clienteditor, detaching);
        }
      };
    }
    function create_fragment$p(ctx) {
      var a;
      var span;
      var t0;
      var t1;
      var if_block_anchor;
      var current;
      var mounted;
      var dispose;
      var if_block = /*show*/ctx[6] && create_if_block$h(ctx);
      return {
        c() {
          a = element("a");
          span = element("span");
          t0 = text$1( /*clientEditorButtonCaption*/ctx[2]);
          t1 = space$1();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr(a, "href", "#/");
          attr(a, "class", "button primary new");
        },
        m(target, anchor) {
          insert(target, a, anchor);
          append(a, span);
          append(span, t0);
          insert(target, t1, anchor);
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
          if (!mounted) {
            dispose = listen(a, "click", prevent_default( /*click_handler*/ctx[10]));
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if (!current || dirty & /*clientEditorButtonCaption*/4) set_data(t0, /*clientEditorButtonCaption*/ctx[2]);
          if ( /*show*/ctx[6]) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty & /*show*/64) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$h(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(a);
            detach(t1);
            detach(if_block_anchor);
          }
          if (if_block) if_block.d(detaching);
          mounted = false;
          dispose();
        }
      };
    }
    function instance$o($$self, $$props, $$invalidate) {
      var show;
      var loading;
      var action = $$props.action;
      var editAction = $$props.editAction;
      var requestToken = $$props.requestToken;
      var clientEditorButtonCaption = $$props.clientEditorButtonCaption;
      var clientEditorCaption = $$props.clientEditorCaption;
      var clientUuid = $$props.clientUuid;
      var editClientData = $$props.editClientData;
      onMount(function () {
        Helpers.hideFallbacks("ClientEditor.svelte");
      });
      var save = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator(function (_ref4) {
          var name = _ref4.name,
            note = _ref4.note;
          return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var client, response;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  $$invalidate(5, loading = true);
                  _context.prev = 1;
                  client = {
                    name,
                    note
                  };
                  if (clientUuid) {
                    client = _objectSpread2(_objectSpread2({}, client), {}, {
                      uuid: clientUuid
                    });
                  }
                  _context.next = 6;
                  return fetch(clientUuid ? editAction : action, {
                    method: clientUuid ? "PATCH" : "POST",
                    body: JSON.stringify(client),
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });
                case 6:
                  response = _context.sent;
                  if (response && response.ok) {
                    $$invalidate(6, show = false);
                    if (clientUuid) {
                      document.querySelector(".app-timemanager [data-current-link]").click();
                    } else {
                      document.querySelector("#app-navigation a.active").click();
                    }
                  }
                  _context.next = 13;
                  break;
                case 10:
                  _context.prev = 10;
                  _context.t0 = _context["catch"](1);
                  console.error(_context.t0);
                case 13:
                  $$invalidate(5, loading = false);
                case 14:
                case "end":
                  return _context.stop();
              }
            }, _callee, null, [[1, 10]]);
          })();
        });
        return function save(_x) {
          return _ref3.apply(this, arguments);
        };
      }();
      var click_handler = function click_handler() {
        return $$invalidate(6, show = !show);
      };
      var func = function func() {
        return $$invalidate(6, show = false);
      };
      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('editAction' in $$props) $$invalidate(8, editAction = $$props.editAction);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientEditorButtonCaption' in $$props) $$invalidate(2, clientEditorButtonCaption = $$props.clientEditorButtonCaption);
        if ('clientEditorCaption' in $$props) $$invalidate(3, clientEditorCaption = $$props.clientEditorCaption);
        if ('clientUuid' in $$props) $$invalidate(9, clientUuid = $$props.clientUuid);
        if ('editClientData' in $$props) $$invalidate(4, editClientData = $$props.editClientData);
      };
      $$invalidate(6, show = false);
      $$invalidate(5, loading = false);
      return [action, requestToken, clientEditorButtonCaption, clientEditorCaption, editClientData, loading, show, save, editAction, clientUuid, click_handler, func];
    }
    var ClientEditorDialog = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(ClientEditorDialog, _SvelteComponent);
      var _super = _createSuper$1(ClientEditorDialog);
      function ClientEditorDialog(options) {
        var _this;
        _classCallCheck$1(this, ClientEditorDialog);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$o, create_fragment$p, safe_not_equal, {
          action: 0,
          editAction: 8,
          requestToken: 1,
          clientEditorButtonCaption: 2,
          clientEditorCaption: 3,
          clientUuid: 9,
          editClientData: 4
        });
        return _this;
      }
      return _createClass$1(ClientEditorDialog);
    }(SvelteComponent);

    function create_if_block$g(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c() {
          button = element("button");
          button.textContent = "".concat(translate('timemanager', 'Cancel'));
          attr(button, "type", "reset");
          attr(button, "class", "button");
        },
        m(target, anchor) {
          insert(target, button, anchor);
          if (!mounted) {
            dispose = listen(button, "click", prevent_default(function () {
              if (is_function( /*onCancel*/ctx[4])) /*onCancel*/ctx[4].apply(this, arguments);
            }));
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
        },
        d(detaching) {
          if (detaching) {
            detach(button);
          }
          mounted = false;
          dispose();
        }
      };
    }
    function create_fragment$o(ctx) {
      var div1;
      var h3;
      var t0;
      var t1;
      var form;
      var label0;
      var t2_value = translate('timemanager', 'Project name') + "";
      var t2;
      var t3;
      var br0;
      var t4;
      var input0;
      var t5;
      var label1;
      var t6_value = translate('timemanager', 'For client') + "";
      var t6;
      var t7;
      var br1;
      var t8;
      var strong;
      var t9;
      var t10;
      var br2;
      var t11;
      var input1;
      var t12;
      var div0;
      var button;
      var t13;
      var t14;
      var mounted;
      var dispose;
      var if_block = ! /*isServer*/ctx[3] && create_if_block$g(ctx);
      return {
        c() {
          div1 = element("div");
          h3 = element("h3");
          t0 = text$1( /*projectEditorCaption*/ctx[6]);
          t1 = space$1();
          form = element("form");
          label0 = element("label");
          t2 = text$1(t2_value);
          t3 = space$1();
          br0 = element("br");
          t4 = space$1();
          input0 = element("input");
          t5 = space$1();
          label1 = element("label");
          t6 = text$1(t6_value);
          t7 = space$1();
          br1 = element("br");
          t8 = space$1();
          strong = element("strong");
          t9 = text$1( /*clientName*/ctx[2]);
          t10 = space$1();
          br2 = element("br");
          t11 = space$1();
          input1 = element("input");
          t12 = space$1();
          div0 = element("div");
          button = element("button");
          t13 = text$1( /*projectEditorButtonCaption*/ctx[5]);
          t14 = space$1();
          if (if_block) if_block.c();
          input0.autofocus = true;
          attr(input0, "type", "text");
          set_style(input0, "width", "100%");
          attr(input0, "class", "input-wide");
          attr(input0, "name", "name");
          attr(input0, "placeholder", translate('timemanager', 'A project name'));
          input0.required = true;
          attr(label0, "class", "space-top");
          attr(label1, "class", "space-top");
          attr(input1, "type", "hidden");
          attr(input1, "name", "requesttoken");
          input1.value = /*requestToken*/ctx[1];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(form, "action", /*action*/ctx[0]);
          attr(form, "method", "post");
          attr(div1, "class", "inner tm_new-item");
        },
        m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, h3);
          append(h3, t0);
          append(div1, t1);
          append(div1, form);
          append(form, label0);
          append(label0, t2);
          append(label0, t3);
          append(label0, br0);
          append(label0, t4);
          append(label0, input0);
          set_input_value(input0, /*name*/ctx[7]);
          append(form, t5);
          append(form, label1);
          append(label1, t6);
          append(label1, t7);
          append(label1, br1);
          append(label1, t8);
          append(label1, strong);
          append(strong, t9);
          append(form, t10);
          append(form, br2);
          append(form, t11);
          append(form, input1);
          append(form, t12);
          append(form, div0);
          append(div0, button);
          append(button, t13);
          append(div0, t14);
          if (if_block) if_block.m(div0, null);
          input0.focus();
          if (!mounted) {
            dispose = [listen(input0, "input", /*input0_input_handler*/ctx[11]), listen(form, "submit", prevent_default( /*submit*/ctx[8]))];
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if (dirty & /*projectEditorCaption*/64) set_data(t0, /*projectEditorCaption*/ctx[6]);
          if (dirty & /*name*/128 && input0.value !== /*name*/ctx[7]) {
            set_input_value(input0, /*name*/ctx[7]);
          }
          if (dirty & /*clientName*/4) set_data(t9, /*clientName*/ctx[2]);
          if (dirty & /*requestToken*/2) {
            input1.value = /*requestToken*/ctx[1];
          }
          if (dirty & /*projectEditorButtonCaption*/32) set_data(t13, /*projectEditorButtonCaption*/ctx[5]);
          if (! /*isServer*/ctx[3]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$g(ctx);
              if_block.c();
              if_block.m(div0, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
          if (dirty & /*action*/1) {
            attr(form, "action", /*action*/ctx[0]);
          }
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(div1);
          }
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function instance$n($$self, $$props, $$invalidate) {
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var isServer = $$props.isServer;
      var onCancel = $$props.onCancel;
      var onSubmit = $$props.onSubmit;
      var projectEditorButtonCaption = $$props.projectEditorButtonCaption;
      var projectEditorCaption = $$props.projectEditorCaption;
      var editProjectData = $$props.editProjectData;
      var name = editProjectData ? editProjectData.name : "";
      var submit = function submit() {
        onSubmit({
          name
        });
      };
      function input0_input_handler() {
        name = this.value;
        $$invalidate(7, name);
      }
      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(2, clientName = $$props.clientName);
        if ('isServer' in $$props) $$invalidate(3, isServer = $$props.isServer);
        if ('onCancel' in $$props) $$invalidate(4, onCancel = $$props.onCancel);
        if ('onSubmit' in $$props) $$invalidate(9, onSubmit = $$props.onSubmit);
        if ('projectEditorButtonCaption' in $$props) $$invalidate(5, projectEditorButtonCaption = $$props.projectEditorButtonCaption);
        if ('projectEditorCaption' in $$props) $$invalidate(6, projectEditorCaption = $$props.projectEditorCaption);
        if ('editProjectData' in $$props) $$invalidate(10, editProjectData = $$props.editProjectData);
      };
      return [action, requestToken, clientName, isServer, onCancel, projectEditorButtonCaption, projectEditorCaption, name, submit, onSubmit, editProjectData, input0_input_handler];
    }
    var ProjectEditor = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(ProjectEditor, _SvelteComponent);
      var _super = _createSuper$1(ProjectEditor);
      function ProjectEditor(options) {
        var _this;
        _classCallCheck$1(this, ProjectEditor);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$n, create_fragment$o, safe_not_equal, {
          action: 0,
          requestToken: 1,
          clientName: 2,
          isServer: 3,
          onCancel: 4,
          onSubmit: 9,
          projectEditorButtonCaption: 5,
          projectEditorCaption: 6,
          editProjectData: 10
        });
        return _this;
      }
      return _createClass$1(ProjectEditor);
    }(SvelteComponent);

    function create_if_block$f(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          loading: /*loading*/ctx[7],
          $$slots: {
            default: [create_default_slot$7]
          },
          $$scope: {
            ctx
          }
        }
      });
      return {
        c() {
          create_component(overlay.$$.fragment);
        },
        m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty & /*loading*/128) overlay_changes.loading = /*loading*/ctx[7];
          if (dirty & /*$$scope, action, requestToken, show, clientName, isServer, projectEditorButtonCaption, projectEditorCaption, editProjectData*/16767) {
            overlay_changes.$$scope = {
              dirty,
              ctx
            };
          }
          overlay.$set(overlay_changes);
        },
        i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    }

    // (54:1) <Overlay {loading}>
    function create_default_slot$7(ctx) {
      var projecteditor;
      var current;
      projecteditor = new ProjectEditor({
        props: {
          action: /*action*/ctx[0],
          requestToken: /*requestToken*/ctx[1],
          onCancel: /*func*/ctx[13],
          onSubmit: /*save*/ctx[9],
          clientName: /*clientName*/ctx[2],
          isServer: /*isServer*/ctx[3],
          projectEditorButtonCaption: /*projectEditorButtonCaption*/ctx[4],
          projectEditorCaption: /*projectEditorCaption*/ctx[5],
          editProjectData: /*editProjectData*/ctx[6]
        }
      });
      return {
        c() {
          create_component(projecteditor.$$.fragment);
        },
        m(target, anchor) {
          mount_component(projecteditor, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var projecteditor_changes = {};
          if (dirty & /*action*/1) projecteditor_changes.action = /*action*/ctx[0];
          if (dirty & /*requestToken*/2) projecteditor_changes.requestToken = /*requestToken*/ctx[1];
          if (dirty & /*show*/256) projecteditor_changes.onCancel = /*func*/ctx[13];
          if (dirty & /*clientName*/4) projecteditor_changes.clientName = /*clientName*/ctx[2];
          if (dirty & /*isServer*/8) projecteditor_changes.isServer = /*isServer*/ctx[3];
          if (dirty & /*projectEditorButtonCaption*/16) projecteditor_changes.projectEditorButtonCaption = /*projectEditorButtonCaption*/ctx[4];
          if (dirty & /*projectEditorCaption*/32) projecteditor_changes.projectEditorCaption = /*projectEditorCaption*/ctx[5];
          if (dirty & /*editProjectData*/64) projecteditor_changes.editProjectData = /*editProjectData*/ctx[6];
          projecteditor.$set(projecteditor_changes);
        },
        i(local) {
          if (current) return;
          transition_in(projecteditor.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(projecteditor.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(projecteditor, detaching);
        }
      };
    }
    function create_fragment$n(ctx) {
      var a;
      var span;
      var t0;
      var t1;
      var if_block_anchor;
      var current;
      var mounted;
      var dispose;
      var if_block = /*show*/ctx[8] && create_if_block$f(ctx);
      return {
        c() {
          a = element("a");
          span = element("span");
          t0 = text$1( /*projectEditorButtonCaption*/ctx[4]);
          t1 = space$1();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr(a, "href", "#/");
          attr(a, "class", "button primary new");
        },
        m(target, anchor) {
          insert(target, a, anchor);
          append(a, span);
          append(span, t0);
          insert(target, t1, anchor);
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
          if (!mounted) {
            dispose = listen(a, "click", prevent_default( /*click_handler*/ctx[12]));
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if (!current || dirty & /*projectEditorButtonCaption*/16) set_data(t0, /*projectEditorButtonCaption*/ctx[4]);
          if ( /*show*/ctx[8]) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty & /*show*/256) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$f(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(a);
            detach(t1);
            detach(if_block_anchor);
          }
          if (if_block) if_block.d(detaching);
          mounted = false;
          dispose();
        }
      };
    }
    function instance$m($$self, $$props, $$invalidate) {
      var show;
      var loading;
      var action = $$props.action;
      var editAction = $$props.editAction;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var isServer = $$props.isServer;
      var projectEditorButtonCaption = $$props.projectEditorButtonCaption;
      var projectEditorCaption = $$props.projectEditorCaption;
      var projectUuid = $$props.projectUuid;
      var editProjectData = $$props.editProjectData;
      onMount(function () {
        Helpers.hideFallbacks("ProjectEditor.svelte");
      });
      var save = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator(function (_ref4) {
          var name = _ref4.name;
          return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var project, response;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  $$invalidate(7, loading = true);
                  _context.prev = 1;
                  project = {
                    name
                  };
                  if (projectUuid) {
                    project = _objectSpread2(_objectSpread2({}, project), {}, {
                      uuid: projectUuid
                    });
                  }
                  _context.next = 6;
                  return fetch(projectUuid ? editAction : action, {
                    method: projectUuid ? "PATCH" : "POST",
                    body: JSON.stringify(project),
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });
                case 6:
                  response = _context.sent;
                  if (response && response.ok) {
                    $$invalidate(8, show = false);
                    document.querySelector(".app-timemanager [data-current-link]").click();
                  }
                  _context.next = 13;
                  break;
                case 10:
                  _context.prev = 10;
                  _context.t0 = _context["catch"](1);
                  console.error(_context.t0);
                case 13:
                  $$invalidate(7, loading = false);
                case 14:
                case "end":
                  return _context.stop();
              }
            }, _callee, null, [[1, 10]]);
          })();
        });
        return function save(_x) {
          return _ref3.apply(this, arguments);
        };
      }();
      var click_handler = function click_handler() {
        return $$invalidate(8, show = !show);
      };
      var func = function func() {
        return $$invalidate(8, show = false);
      };
      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('editAction' in $$props) $$invalidate(10, editAction = $$props.editAction);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(2, clientName = $$props.clientName);
        if ('isServer' in $$props) $$invalidate(3, isServer = $$props.isServer);
        if ('projectEditorButtonCaption' in $$props) $$invalidate(4, projectEditorButtonCaption = $$props.projectEditorButtonCaption);
        if ('projectEditorCaption' in $$props) $$invalidate(5, projectEditorCaption = $$props.projectEditorCaption);
        if ('projectUuid' in $$props) $$invalidate(11, projectUuid = $$props.projectUuid);
        if ('editProjectData' in $$props) $$invalidate(6, editProjectData = $$props.editProjectData);
      };
      $$invalidate(8, show = false);
      $$invalidate(7, loading = false);
      return [action, requestToken, clientName, isServer, projectEditorButtonCaption, projectEditorCaption, editProjectData, loading, show, save, editAction, projectUuid, click_handler, func];
    }
    var ProjectEditorDialog = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(ProjectEditorDialog, _SvelteComponent);
      var _super = _createSuper$1(ProjectEditorDialog);
      function ProjectEditorDialog(options) {
        var _this;
        _classCallCheck$1(this, ProjectEditorDialog);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$m, create_fragment$n, safe_not_equal, {
          action: 0,
          editAction: 10,
          requestToken: 1,
          clientName: 2,
          isServer: 3,
          projectEditorButtonCaption: 4,
          projectEditorCaption: 5,
          projectUuid: 11,
          editProjectData: 6
        });
        return _this;
      }
      return _createClass$1(ProjectEditorDialog);
    }(SvelteComponent);

    function create_if_block$e(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c() {
          button = element("button");
          button.textContent = "".concat(translate('timemanager', 'Cancel'));
          attr(button, "type", "reset");
          attr(button, "class", "button");
        },
        m(target, anchor) {
          insert(target, button, anchor);
          if (!mounted) {
            dispose = listen(button, "click", prevent_default(function () {
              if (is_function( /*onCancel*/ctx[5])) /*onCancel*/ctx[5].apply(this, arguments);
            }));
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
        },
        d(detaching) {
          if (detaching) {
            detach(button);
          }
          mounted = false;
          dispose();
        }
      };
    }
    function create_fragment$m(ctx) {
      var div1;
      var h3;
      var t0;
      var t1;
      var form;
      var label0;
      var t2_value = translate('timemanager', 'Task name') + "";
      var t2;
      var t3;
      var br0;
      var t4;
      var input0;
      var t5;
      var label1;
      var t6_value = translate('timemanager', 'For project') + "";
      var t6;
      var t7;
      var br1;
      var t8;
      var strong0;
      var t9;
      var t10;
      var label2;
      var t11_value = translate('timemanager', 'For client') + "";
      var t11;
      var t12;
      var br2;
      var t13;
      var strong1;
      var t14;
      var t15;
      var br3;
      var t16;
      var input1;
      var t17;
      var div0;
      var button;
      var t18;
      var t19;
      var mounted;
      var dispose;
      var if_block = ! /*isServer*/ctx[4] && create_if_block$e(ctx);
      return {
        c() {
          div1 = element("div");
          h3 = element("h3");
          t0 = text$1( /*taskEditorCaption*/ctx[7]);
          t1 = space$1();
          form = element("form");
          label0 = element("label");
          t2 = text$1(t2_value);
          t3 = space$1();
          br0 = element("br");
          t4 = space$1();
          input0 = element("input");
          t5 = space$1();
          label1 = element("label");
          t6 = text$1(t6_value);
          t7 = space$1();
          br1 = element("br");
          t8 = space$1();
          strong0 = element("strong");
          t9 = text$1( /*projectName*/ctx[3]);
          t10 = space$1();
          label2 = element("label");
          t11 = text$1(t11_value);
          t12 = space$1();
          br2 = element("br");
          t13 = space$1();
          strong1 = element("strong");
          t14 = text$1( /*clientName*/ctx[2]);
          t15 = space$1();
          br3 = element("br");
          t16 = space$1();
          input1 = element("input");
          t17 = space$1();
          div0 = element("div");
          button = element("button");
          t18 = text$1( /*taskEditorButtonCaption*/ctx[6]);
          t19 = space$1();
          if (if_block) if_block.c();
          input0.autofocus = true;
          attr(input0, "type", "text");
          set_style(input0, "width", "100%");
          attr(input0, "class", "input-wide");
          attr(input0, "name", "name");
          attr(input0, "placeholder", translate('timemanager', 'A task name'));
          input0.required = true;
          attr(label0, "class", "space-top");
          attr(label1, "class", "space-top");
          attr(label2, "class", "space-top");
          attr(input1, "type", "hidden");
          attr(input1, "name", "requesttoken");
          input1.value = /*requestToken*/ctx[1];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(form, "action", /*action*/ctx[0]);
          attr(form, "method", "post");
          attr(div1, "class", "inner tm_new-item");
        },
        m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, h3);
          append(h3, t0);
          append(div1, t1);
          append(div1, form);
          append(form, label0);
          append(label0, t2);
          append(label0, t3);
          append(label0, br0);
          append(label0, t4);
          append(label0, input0);
          set_input_value(input0, /*name*/ctx[8]);
          append(form, t5);
          append(form, label1);
          append(label1, t6);
          append(label1, t7);
          append(label1, br1);
          append(label1, t8);
          append(label1, strong0);
          append(strong0, t9);
          append(form, t10);
          append(form, label2);
          append(label2, t11);
          append(label2, t12);
          append(label2, br2);
          append(label2, t13);
          append(label2, strong1);
          append(strong1, t14);
          append(form, t15);
          append(form, br3);
          append(form, t16);
          append(form, input1);
          append(form, t17);
          append(form, div0);
          append(div0, button);
          append(button, t18);
          append(div0, t19);
          if (if_block) if_block.m(div0, null);
          input0.focus();
          if (!mounted) {
            dispose = [listen(input0, "input", /*input0_input_handler*/ctx[12]), listen(form, "submit", prevent_default( /*submit*/ctx[9]))];
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if (dirty & /*taskEditorCaption*/128) set_data(t0, /*taskEditorCaption*/ctx[7]);
          if (dirty & /*name*/256 && input0.value !== /*name*/ctx[8]) {
            set_input_value(input0, /*name*/ctx[8]);
          }
          if (dirty & /*projectName*/8) set_data(t9, /*projectName*/ctx[3]);
          if (dirty & /*clientName*/4) set_data(t14, /*clientName*/ctx[2]);
          if (dirty & /*requestToken*/2) {
            input1.value = /*requestToken*/ctx[1];
          }
          if (dirty & /*taskEditorButtonCaption*/64) set_data(t18, /*taskEditorButtonCaption*/ctx[6]);
          if (! /*isServer*/ctx[4]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$e(ctx);
              if_block.c();
              if_block.m(div0, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
          if (dirty & /*action*/1) {
            attr(form, "action", /*action*/ctx[0]);
          }
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(div1);
          }
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function instance$l($$self, $$props, $$invalidate) {
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var projectName = $$props.projectName;
      var isServer = $$props.isServer;
      var onCancel = $$props.onCancel;
      var onSubmit = $$props.onSubmit;
      var taskEditorButtonCaption = $$props.taskEditorButtonCaption;
      var taskEditorCaption = $$props.taskEditorCaption;
      var editTaskData = $$props.editTaskData;
      var name = editTaskData ? editTaskData.name : "";
      var submit = function submit() {
        onSubmit({
          name
        });
      };
      function input0_input_handler() {
        name = this.value;
        $$invalidate(8, name);
      }
      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(2, clientName = $$props.clientName);
        if ('projectName' in $$props) $$invalidate(3, projectName = $$props.projectName);
        if ('isServer' in $$props) $$invalidate(4, isServer = $$props.isServer);
        if ('onCancel' in $$props) $$invalidate(5, onCancel = $$props.onCancel);
        if ('onSubmit' in $$props) $$invalidate(10, onSubmit = $$props.onSubmit);
        if ('taskEditorButtonCaption' in $$props) $$invalidate(6, taskEditorButtonCaption = $$props.taskEditorButtonCaption);
        if ('taskEditorCaption' in $$props) $$invalidate(7, taskEditorCaption = $$props.taskEditorCaption);
        if ('editTaskData' in $$props) $$invalidate(11, editTaskData = $$props.editTaskData);
      };
      return [action, requestToken, clientName, projectName, isServer, onCancel, taskEditorButtonCaption, taskEditorCaption, name, submit, onSubmit, editTaskData, input0_input_handler];
    }
    var TaskEditor = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(TaskEditor, _SvelteComponent);
      var _super = _createSuper$1(TaskEditor);
      function TaskEditor(options) {
        var _this;
        _classCallCheck$1(this, TaskEditor);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$l, create_fragment$m, safe_not_equal, {
          action: 0,
          requestToken: 1,
          clientName: 2,
          projectName: 3,
          isServer: 4,
          onCancel: 5,
          onSubmit: 10,
          taskEditorButtonCaption: 6,
          taskEditorCaption: 7,
          editTaskData: 11
        });
        return _this;
      }
      return _createClass$1(TaskEditor);
    }(SvelteComponent);

    function create_if_block$d(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          loading: /*loading*/ctx[8],
          $$slots: {
            default: [create_default_slot$6]
          },
          $$scope: {
            ctx
          }
        }
      });
      return {
        c() {
          create_component(overlay.$$.fragment);
        },
        m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty & /*loading*/256) overlay_changes.loading = /*loading*/ctx[8];
          if (dirty & /*$$scope, action, requestToken, show, clientName, projectName, isServer, taskEditorButtonCaption, taskEditorCaption, editTaskData*/33535) {
            overlay_changes.$$scope = {
              dirty,
              ctx
            };
          }
          overlay.$set(overlay_changes);
        },
        i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    }

    // (55:1) <Overlay {loading}>
    function create_default_slot$6(ctx) {
      var taskeditor;
      var current;
      taskeditor = new TaskEditor({
        props: {
          action: /*action*/ctx[0],
          requestToken: /*requestToken*/ctx[1],
          onCancel: /*func*/ctx[14],
          onSubmit: /*save*/ctx[10],
          clientName: /*clientName*/ctx[2],
          projectName: /*projectName*/ctx[3],
          isServer: /*isServer*/ctx[4],
          taskEditorButtonCaption: /*taskEditorButtonCaption*/ctx[5],
          taskEditorCaption: /*taskEditorCaption*/ctx[6],
          editTaskData: /*editTaskData*/ctx[7]
        }
      });
      return {
        c() {
          create_component(taskeditor.$$.fragment);
        },
        m(target, anchor) {
          mount_component(taskeditor, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var taskeditor_changes = {};
          if (dirty & /*action*/1) taskeditor_changes.action = /*action*/ctx[0];
          if (dirty & /*requestToken*/2) taskeditor_changes.requestToken = /*requestToken*/ctx[1];
          if (dirty & /*show*/512) taskeditor_changes.onCancel = /*func*/ctx[14];
          if (dirty & /*clientName*/4) taskeditor_changes.clientName = /*clientName*/ctx[2];
          if (dirty & /*projectName*/8) taskeditor_changes.projectName = /*projectName*/ctx[3];
          if (dirty & /*isServer*/16) taskeditor_changes.isServer = /*isServer*/ctx[4];
          if (dirty & /*taskEditorButtonCaption*/32) taskeditor_changes.taskEditorButtonCaption = /*taskEditorButtonCaption*/ctx[5];
          if (dirty & /*taskEditorCaption*/64) taskeditor_changes.taskEditorCaption = /*taskEditorCaption*/ctx[6];
          if (dirty & /*editTaskData*/128) taskeditor_changes.editTaskData = /*editTaskData*/ctx[7];
          taskeditor.$set(taskeditor_changes);
        },
        i(local) {
          if (current) return;
          transition_in(taskeditor.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(taskeditor.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(taskeditor, detaching);
        }
      };
    }
    function create_fragment$l(ctx) {
      var a;
      var span;
      var t0;
      var t1;
      var if_block_anchor;
      var current;
      var mounted;
      var dispose;
      var if_block = /*show*/ctx[9] && create_if_block$d(ctx);
      return {
        c() {
          a = element("a");
          span = element("span");
          t0 = text$1( /*taskEditorButtonCaption*/ctx[5]);
          t1 = space$1();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr(a, "href", "#/");
          attr(a, "class", "button primary new");
        },
        m(target, anchor) {
          insert(target, a, anchor);
          append(a, span);
          append(span, t0);
          insert(target, t1, anchor);
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
          if (!mounted) {
            dispose = listen(a, "click", prevent_default( /*click_handler*/ctx[13]));
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if (!current || dirty & /*taskEditorButtonCaption*/32) set_data(t0, /*taskEditorButtonCaption*/ctx[5]);
          if ( /*show*/ctx[9]) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty & /*show*/512) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$d(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(a);
            detach(t1);
            detach(if_block_anchor);
          }
          if (if_block) if_block.d(detaching);
          mounted = false;
          dispose();
        }
      };
    }
    function instance$k($$self, $$props, $$invalidate) {
      var show;
      var loading;
      var action = $$props.action;
      var editAction = $$props.editAction;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var projectName = $$props.projectName;
      var isServer = $$props.isServer;
      var taskEditorButtonCaption = $$props.taskEditorButtonCaption;
      var taskEditorCaption = $$props.taskEditorCaption;
      var taskUuid = $$props.taskUuid;
      var editTaskData = $$props.editTaskData;
      onMount(function () {
        Helpers.hideFallbacks("TaskEditor.svelte");
      });
      var save = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator(function (_ref4) {
          var name = _ref4.name;
          return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var task, response;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  $$invalidate(8, loading = true);
                  _context.prev = 1;
                  task = {
                    name
                  };
                  if (taskUuid) {
                    task = _objectSpread2(_objectSpread2({}, task), {}, {
                      uuid: taskUuid
                    });
                  }
                  _context.next = 6;
                  return fetch(taskUuid ? editAction : action, {
                    method: taskUuid ? "PATCH" : "POST",
                    body: JSON.stringify(task),
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });
                case 6:
                  response = _context.sent;
                  if (response && response.ok) {
                    $$invalidate(9, show = false);
                    document.querySelector(".app-timemanager [data-current-link]").click();
                  }
                  _context.next = 13;
                  break;
                case 10:
                  _context.prev = 10;
                  _context.t0 = _context["catch"](1);
                  console.error(_context.t0);
                case 13:
                  $$invalidate(8, loading = false);
                case 14:
                case "end":
                  return _context.stop();
              }
            }, _callee, null, [[1, 10]]);
          })();
        });
        return function save(_x) {
          return _ref3.apply(this, arguments);
        };
      }();
      var click_handler = function click_handler() {
        return $$invalidate(9, show = !show);
      };
      var func = function func() {
        return $$invalidate(9, show = false);
      };
      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('editAction' in $$props) $$invalidate(11, editAction = $$props.editAction);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(2, clientName = $$props.clientName);
        if ('projectName' in $$props) $$invalidate(3, projectName = $$props.projectName);
        if ('isServer' in $$props) $$invalidate(4, isServer = $$props.isServer);
        if ('taskEditorButtonCaption' in $$props) $$invalidate(5, taskEditorButtonCaption = $$props.taskEditorButtonCaption);
        if ('taskEditorCaption' in $$props) $$invalidate(6, taskEditorCaption = $$props.taskEditorCaption);
        if ('taskUuid' in $$props) $$invalidate(12, taskUuid = $$props.taskUuid);
        if ('editTaskData' in $$props) $$invalidate(7, editTaskData = $$props.editTaskData);
      };
      $$invalidate(9, show = false);
      $$invalidate(8, loading = false);
      return [action, requestToken, clientName, projectName, isServer, taskEditorButtonCaption, taskEditorCaption, editTaskData, loading, show, save, editAction, taskUuid, click_handler, func];
    }
    var TaskEditorDialog = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(TaskEditorDialog, _SvelteComponent);
      var _super = _createSuper$1(TaskEditorDialog);
      function TaskEditorDialog(options) {
        var _this;
        _classCallCheck$1(this, TaskEditorDialog);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$k, create_fragment$l, safe_not_equal, {
          action: 0,
          editAction: 11,
          requestToken: 1,
          clientName: 2,
          projectName: 3,
          isServer: 4,
          taskEditorButtonCaption: 5,
          taskEditorCaption: 6,
          taskUuid: 12,
          editTaskData: 7
        });
        return _this;
      }
      return _createClass$1(TaskEditorDialog);
    }(SvelteComponent);

    // a string of all valid unicode whitespaces
    var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' + '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

    var replace = functionUncurryThis(''.replace);
    var ltrim = RegExp('^[' + whitespaces + ']+');
    var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');

    // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
    var createMethod$1 = function (TYPE) {
      return function ($this) {
        var string = toString_1(requireObjectCoercible($this));
        if (TYPE & 1) string = replace(string, ltrim, '');
        if (TYPE & 2) string = replace(string, rtrim, '$1');
        return string;
      };
    };
    var stringTrim = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod$1(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod$1(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod$1(3)
    };

    var trim = stringTrim.trim;

    var charAt = functionUncurryThis(''.charAt);
    var $parseFloat = global_1.parseFloat;
    var Symbol$1 = global_1.Symbol;
    var ITERATOR = Symbol$1 && Symbol$1.iterator;
    var FORCED$1 = 1 / $parseFloat(whitespaces + '-0') !== -Infinity
    // MS Edge 18- broken with boxed symbols
    || ITERATOR && !fails(function () {
      $parseFloat(Object(ITERATOR));
    });

    // `parseFloat` method
    // https://tc39.es/ecma262/#sec-parsefloat-string
    var numberParseFloat = FORCED$1 ? function parseFloat(string) {
      var trimmedString = trim(toString_1(string));
      var result = $parseFloat(trimmedString);
      return result === 0 && charAt(trimmedString, 0) == '-' ? -0 : result;
    } : $parseFloat;

    // `parseFloat` method
    // https://tc39.es/ecma262/#sec-parsefloat-string
    _export({
      global: true,
      forced: parseFloat != numberParseFloat
    }, {
      parseFloat: numberParseFloat
    });

    function create_if_block$c(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c() {
          button = element("button");
          button.textContent = "".concat(translate("timemanager", "Cancel"));
          attr(button, "type", "reset");
          attr(button, "class", "button");
        },
        m(target, anchor) {
          insert(target, button, anchor);
          if (!mounted) {
            dispose = listen(button, "click", prevent_default(function () {
              if (is_function( /*onCancel*/ctx[6])) /*onCancel*/ctx[6].apply(this, arguments);
            }));
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
        },
        d(detaching) {
          if (detaching) {
            detach(button);
          }
          mounted = false;
          dispose();
        }
      };
    }
    function create_fragment$k(ctx) {
      var div1;
      var h3;
      var t0;
      var t1;
      var form;
      var span1;
      var label0;
      var t2_value = translate("timemanager", "Duration (in hrs.)") + "";
      var t2;
      var t3;
      var br0;
      var t4;
      var input0;
      var t5;
      var span0;
      var label1;
      var t6_value = translate("timemanager", "Start time") + "";
      var t6;
      var t7;
      var br1;
      var t8;
      var input1;
      var t9;
      var label2;
      var t10_value = translate("timemanager", "End time") + "";
      var t10;
      var t11;
      var br2;
      var t12;
      var input2;
      var t13;
      var br3;
      var t14;
      var label3;
      var t15_value = translate("timemanager", "Date") + "";
      var t15;
      var t16;
      var br4;
      var t17;
      var input3;
      var t18;
      var br5;
      var t19;
      var label4;
      var t20_value = translate("timemanager", "Note") + "";
      var t20;
      var t21;
      var br6;
      var t22;
      var textarea;
      var t23;
      var br7;
      var t24;
      var label5;
      var t25_value = translate("timemanager", "For task") + "";
      var t25;
      var t26;
      var br8;
      var t27;
      var strong0;
      var t28;
      var t29;
      var label6;
      var t30_value = translate("timemanager", "For project") + "";
      var t30;
      var t31;
      var br9;
      var t32;
      var strong1;
      var t33;
      var t34;
      var label7;
      var t35_value = translate("timemanager", "For client") + "";
      var t35;
      var t36;
      var br10;
      var t37;
      var strong2;
      var t38;
      var t39;
      var br11;
      var t40;
      var input4;
      var t41;
      var div0;
      var button;
      var t42;
      var t43;
      var mounted;
      var dispose;
      var if_block = ! /*isServer*/ctx[5] && create_if_block$c(ctx);
      return {
        c() {
          div1 = element("div");
          h3 = element("h3");
          t0 = text$1( /*timeEditorCaption*/ctx[7]);
          t1 = space$1();
          form = element("form");
          span1 = element("span");
          label0 = element("label");
          t2 = text$1(t2_value);
          t3 = space$1();
          br0 = element("br");
          t4 = space$1();
          input0 = element("input");
          t5 = space$1();
          span0 = element("span");
          label1 = element("label");
          t6 = text$1(t6_value);
          t7 = space$1();
          br1 = element("br");
          t8 = space$1();
          input1 = element("input");
          t9 = space$1();
          label2 = element("label");
          t10 = text$1(t10_value);
          t11 = space$1();
          br2 = element("br");
          t12 = space$1();
          input2 = element("input");
          t13 = space$1();
          br3 = element("br");
          t14 = space$1();
          label3 = element("label");
          t15 = text$1(t15_value);
          t16 = space$1();
          br4 = element("br");
          t17 = space$1();
          input3 = element("input");
          t18 = space$1();
          br5 = element("br");
          t19 = space$1();
          label4 = element("label");
          t20 = text$1(t20_value);
          t21 = space$1();
          br6 = element("br");
          t22 = space$1();
          textarea = element("textarea");
          t23 = space$1();
          br7 = element("br");
          t24 = space$1();
          label5 = element("label");
          t25 = text$1(t25_value);
          t26 = space$1();
          br8 = element("br");
          t27 = space$1();
          strong0 = element("strong");
          t28 = text$1( /*taskName*/ctx[4]);
          t29 = space$1();
          label6 = element("label");
          t30 = text$1(t30_value);
          t31 = space$1();
          br9 = element("br");
          t32 = space$1();
          strong1 = element("strong");
          t33 = text$1( /*projectName*/ctx[3]);
          t34 = space$1();
          label7 = element("label");
          t35 = text$1(t35_value);
          t36 = space$1();
          br10 = element("br");
          t37 = space$1();
          strong2 = element("strong");
          t38 = text$1( /*clientName*/ctx[2]);
          t39 = space$1();
          br11 = element("br");
          t40 = space$1();
          input4 = element("input");
          t41 = space$1();
          div0 = element("div");
          button = element("button");
          t42 = text$1( /*timeEditorButtonCaption*/ctx[8]);
          t43 = space$1();
          if (if_block) if_block.c();
          input0.autofocus = true;
          attr(input0, "type", "text");
          attr(input0, "name", "duration");
          attr(input0, "placeholder", "");
          attr(input0, "class", "duration-input");
          input0.required = true;
          attr(input1, "type", "time");
          attr(input1, "name", "startTime");
          attr(input1, "placeholder", "--:--");
          attr(input1, "class", "time-input");
          attr(input1, "pattern", "[0-9]" + 2 + ":[0-9]" + 2);
          input1.required = true;
          attr(input2, "type", "time");
          attr(input2, "name", "endTime");
          attr(input2, "placeholder", "--:--");
          attr(input2, "class", "time-input");
          attr(input2, "pattern", "[0-9]" + 2 + ":[0-9]" + 2);
          input2.required = true;
          attr(span0, "class", "flex-fields");
          attr(span1, "class", "flex-fields");
          attr(input3, "type", "date");
          attr(input3, "name", "date");
          set_style(input3, "width", "100%");
          attr(input3, "class", "input-wide");
          set_style(textarea, "width", "100%");
          attr(textarea, "class", "input-wide");
          attr(textarea, "name", "note");
          attr(textarea, "placeholder", translate('timemanager', 'Describe what you did...'));
          textarea.value = /*note*/ctx[13];
          attr(label5, "class", "space-top");
          attr(label6, "class", "space-top");
          attr(label7, "class", "space-top");
          attr(input4, "type", "hidden");
          attr(input4, "name", "requesttoken");
          input4.value = /*requestToken*/ctx[1];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(form, "action", /*action*/ctx[0]);
          attr(form, "method", "post");
          attr(div1, "class", "inner tm_new-item");
        },
        m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, h3);
          append(h3, t0);
          append(div1, t1);
          append(div1, form);
          append(form, span1);
          append(span1, label0);
          append(label0, t2);
          append(label0, t3);
          append(label0, br0);
          append(label0, t4);
          append(label0, input0);
          set_input_value(input0, /*duration*/ctx[10]);
          append(span1, t5);
          append(span1, span0);
          append(span0, label1);
          append(label1, t6);
          append(label1, t7);
          append(label1, br1);
          append(label1, t8);
          append(label1, input1);
          set_input_value(input1, /*startTime*/ctx[11]);
          append(span0, t9);
          append(span0, label2);
          append(label2, t10);
          append(label2, t11);
          append(label2, br2);
          append(label2, t12);
          append(label2, input2);
          set_input_value(input2, /*endTime*/ctx[12]);
          append(form, t13);
          append(form, br3);
          append(form, t14);
          append(form, label3);
          append(label3, t15);
          append(label3, t16);
          append(label3, br4);
          append(label3, t17);
          append(label3, input3);
          set_input_value(input3, /*date*/ctx[9]);
          append(form, t18);
          append(form, br5);
          append(form, t19);
          append(form, label4);
          append(label4, t20);
          append(label4, t21);
          append(label4, br6);
          append(label4, t22);
          append(label4, textarea);
          append(form, t23);
          append(form, br7);
          append(form, t24);
          append(form, label5);
          append(label5, t25);
          append(label5, t26);
          append(label5, br8);
          append(label5, t27);
          append(label5, strong0);
          append(strong0, t28);
          append(form, t29);
          append(form, label6);
          append(label6, t30);
          append(label6, t31);
          append(label6, br9);
          append(label6, t32);
          append(label6, strong1);
          append(strong1, t33);
          append(form, t34);
          append(form, label7);
          append(label7, t35);
          append(label7, t36);
          append(label7, br10);
          append(label7, t37);
          append(label7, strong2);
          append(strong2, t38);
          append(form, t39);
          append(form, br11);
          append(form, t40);
          append(form, input4);
          append(form, t41);
          append(form, div0);
          append(div0, button);
          append(button, t42);
          append(div0, t43);
          if (if_block) if_block.m(div0, null);
          input0.focus();
          if (!mounted) {
            dispose = [listen(input0, "input", /*input0_input_handler*/ctx[17]), listen(input0, "input", /*input_handler*/ctx[18]), listen(input1, "input", /*input1_input_handler*/ctx[19]), listen(input1, "input", /*input_handler_1*/ctx[20]), listen(input2, "input", /*input2_input_handler*/ctx[21]), listen(input2, "input", /*input_handler_2*/ctx[22]), listen(input3, "input", /*input3_input_handler*/ctx[23]), listen(textarea, "input", /*input_handler_3*/ctx[24]), listen(form, "submit", prevent_default( /*submit*/ctx[14]))];
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if (dirty & /*timeEditorCaption*/128) set_data(t0, /*timeEditorCaption*/ctx[7]);
          if (dirty & /*duration*/1024 && input0.value !== /*duration*/ctx[10]) {
            set_input_value(input0, /*duration*/ctx[10]);
          }
          if (dirty & /*startTime*/2048) {
            set_input_value(input1, /*startTime*/ctx[11]);
          }
          if (dirty & /*endTime*/4096) {
            set_input_value(input2, /*endTime*/ctx[12]);
          }
          if (dirty & /*date*/512) {
            set_input_value(input3, /*date*/ctx[9]);
          }
          if (dirty & /*note*/8192) {
            textarea.value = /*note*/ctx[13];
          }
          if (dirty & /*taskName*/16) set_data(t28, /*taskName*/ctx[4]);
          if (dirty & /*projectName*/8) set_data(t33, /*projectName*/ctx[3]);
          if (dirty & /*clientName*/4) set_data(t38, /*clientName*/ctx[2]);
          if (dirty & /*requestToken*/2) {
            input4.value = /*requestToken*/ctx[1];
          }
          if (dirty & /*timeEditorButtonCaption*/256) set_data(t42, /*timeEditorButtonCaption*/ctx[8]);
          if (! /*isServer*/ctx[5]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$c(ctx);
              if_block.c();
              if_block.m(div0, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
          if (dirty & /*action*/1) {
            attr(form, "action", /*action*/ctx[0]);
          }
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(div1);
          }
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }
    var timeFormat = "HH:mm";
    var dateFormat$3 = "yyyy-MM-dd";
    function instance$j($$self, $$props, $$invalidate) {
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var projectName = $$props.projectName;
      var taskName = $$props.taskName;
      var isServer = $$props.isServer;
      var onCancel = $$props.onCancel;
      var onSubmit = $$props.onSubmit;
      var _$$props$editTimeEntr = $$props.editTimeEntryData,
        editTimeEntryData = _$$props$editTimeEntr === void 0 ? {} : _$$props$editTimeEntr;
      var timeEditorCaption = $$props.timeEditorCaption;
      var timeEditorButtonCaption = $$props.timeEditorButtonCaption;
      var localeOptions = Helpers.getDateLocaleOptions();
      var hasDate = Boolean(editTimeEntryData.date);
      var startDate = hasDate ? parseISO(editTimeEntryData.date) : new Date();
      var date = format$2(startDate, dateFormat$3, localeOptions);
      var duration = editTimeEntryData.duration;
      var startTime = format$2(startDate, timeFormat, localeOptions);
      var endTime = Helpers.calculateEndTime(startTime, parseFloat(duration));
      var note = editTimeEntryData.note || "";
      var submit = function submit() {
        onSubmit({
          duration,
          date: "".concat(date, "T").concat(startTime, ":00"),
          note
        });
      };
      function input0_input_handler() {
        duration = this.value;
        $$invalidate(10, duration);
      }
      var input_handler = function input_handler() {
        $$invalidate(10, duration = Helpers.normalizeDuration(duration));
        $$invalidate(12, endTime = Helpers.calculateEndTime(startTime, parseFloat(duration)));
      };
      function input1_input_handler() {
        startTime = this.value;
        $$invalidate(11, startTime);
      }
      var input_handler_1 = function input_handler_1() {
        return $$invalidate(10, duration = Helpers.calculateDuration(startTime, endTime));
      };
      function input2_input_handler() {
        endTime = this.value;
        $$invalidate(12, endTime);
      }
      var input_handler_2 = function input_handler_2() {
        return $$invalidate(10, duration = Helpers.calculateDuration(startTime, endTime));
      };
      function input3_input_handler() {
        date = this.value;
        $$invalidate(9, date);
      }
      var input_handler_3 = function input_handler_3(e) {
        return $$invalidate(13, note = e.target.value);
      };
      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(2, clientName = $$props.clientName);
        if ('projectName' in $$props) $$invalidate(3, projectName = $$props.projectName);
        if ('taskName' in $$props) $$invalidate(4, taskName = $$props.taskName);
        if ('isServer' in $$props) $$invalidate(5, isServer = $$props.isServer);
        if ('onCancel' in $$props) $$invalidate(6, onCancel = $$props.onCancel);
        if ('onSubmit' in $$props) $$invalidate(15, onSubmit = $$props.onSubmit);
        if ('editTimeEntryData' in $$props) $$invalidate(16, editTimeEntryData = $$props.editTimeEntryData);
        if ('timeEditorCaption' in $$props) $$invalidate(7, timeEditorCaption = $$props.timeEditorCaption);
        if ('timeEditorButtonCaption' in $$props) $$invalidate(8, timeEditorButtonCaption = $$props.timeEditorButtonCaption);
      };
      return [action, requestToken, clientName, projectName, taskName, isServer, onCancel, timeEditorCaption, timeEditorButtonCaption, date, duration, startTime, endTime, note, submit, onSubmit, editTimeEntryData, input0_input_handler, input_handler, input1_input_handler, input_handler_1, input2_input_handler, input_handler_2, input3_input_handler, input_handler_3];
    }
    var TimeEditor = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(TimeEditor, _SvelteComponent);
      var _super = _createSuper$1(TimeEditor);
      function TimeEditor(options) {
        var _this;
        _classCallCheck$1(this, TimeEditor);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$j, create_fragment$k, safe_not_equal, {
          action: 0,
          requestToken: 1,
          clientName: 2,
          projectName: 3,
          taskName: 4,
          isServer: 5,
          onCancel: 6,
          onSubmit: 15,
          editTimeEntryData: 16,
          timeEditorCaption: 7,
          timeEditorButtonCaption: 8
        });
        return _this;
      }
      return _createClass$1(TimeEditor);
    }(SvelteComponent);

    function create_else_block$5(ctx) {
      var div;
      var button;
      var t;
      var mounted;
      var dispose;
      return {
        c() {
          div = element("div");
          button = element("button");
          t = text$1( /*timeEditorButtonCaption*/ctx[6]);
          attr(button, "type", "button");
          attr(button, "class", "btn");
          attr(div, "class", "tm_inline-hover-form");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          append(div, button);
          append(button, t);
          if (!mounted) {
            dispose = listen(button, "click", prevent_default( /*click_handler_1*/ctx[15]));
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty & /*timeEditorButtonCaption*/64) set_data(t, /*timeEditorButtonCaption*/ctx[6]);
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          mounted = false;
          dispose();
        }
      };
    }

    // (60:0) {#if !timeUuid}
    function create_if_block_1$6(ctx) {
      var a;
      var span;
      var t;
      var mounted;
      var dispose;
      return {
        c() {
          a = element("a");
          span = element("span");
          t = text$1( /*timeEditorButtonCaption*/ctx[6]);
          attr(a, "href", "#/");
          attr(a, "class", "button primary new");
        },
        m(target, anchor) {
          insert(target, a, anchor);
          append(a, span);
          append(span, t);
          if (!mounted) {
            dispose = listen(a, "click", prevent_default( /*click_handler*/ctx[14]));
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty & /*timeEditorButtonCaption*/64) set_data(t, /*timeEditorButtonCaption*/ctx[6]);
        },
        d(detaching) {
          if (detaching) {
            detach(a);
          }
          mounted = false;
          dispose();
        }
      };
    }

    // (69:0) {#if show}
    function create_if_block$b(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          loading: /*loading*/ctx[10],
          $$slots: {
            default: [create_default_slot$5]
          },
          $$scope: {
            ctx
          }
        }
      });
      return {
        c() {
          create_component(overlay.$$.fragment);
        },
        m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty & /*loading*/1024) overlay_changes.loading = /*loading*/ctx[10];
          if (dirty & /*$$scope, action, requestToken, show, clientName, projectName, taskName, timeEditorButtonCaption, timeEditorCaption, editTimeEntryData, isServer*/265213) {
            overlay_changes.$$scope = {
              dirty,
              ctx
            };
          }
          overlay.$set(overlay_changes);
        },
        i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    }

    // (70:1) <Overlay {loading}>
    function create_default_slot$5(ctx) {
      var timeeditor;
      var current;
      timeeditor = new TimeEditor({
        props: {
          action: /*action*/ctx[0],
          requestToken: /*requestToken*/ctx[2],
          onCancel: /*func*/ctx[16],
          onSubmit: /*save*/ctx[12],
          clientName: /*clientName*/ctx[3],
          projectName: /*projectName*/ctx[4],
          taskName: /*taskName*/ctx[5],
          timeEditorButtonCaption: /*timeEditorButtonCaption*/ctx[6],
          timeEditorCaption: /*timeEditorCaption*/ctx[7],
          editTimeEntryData: /*editTimeEntryData*/ctx[8],
          isServer: /*isServer*/ctx[9]
        }
      });
      return {
        c() {
          create_component(timeeditor.$$.fragment);
        },
        m(target, anchor) {
          mount_component(timeeditor, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var timeeditor_changes = {};
          if (dirty & /*action*/1) timeeditor_changes.action = /*action*/ctx[0];
          if (dirty & /*requestToken*/4) timeeditor_changes.requestToken = /*requestToken*/ctx[2];
          if (dirty & /*show*/2048) timeeditor_changes.onCancel = /*func*/ctx[16];
          if (dirty & /*clientName*/8) timeeditor_changes.clientName = /*clientName*/ctx[3];
          if (dirty & /*projectName*/16) timeeditor_changes.projectName = /*projectName*/ctx[4];
          if (dirty & /*taskName*/32) timeeditor_changes.taskName = /*taskName*/ctx[5];
          if (dirty & /*timeEditorButtonCaption*/64) timeeditor_changes.timeEditorButtonCaption = /*timeEditorButtonCaption*/ctx[6];
          if (dirty & /*timeEditorCaption*/128) timeeditor_changes.timeEditorCaption = /*timeEditorCaption*/ctx[7];
          if (dirty & /*editTimeEntryData*/256) timeeditor_changes.editTimeEntryData = /*editTimeEntryData*/ctx[8];
          if (dirty & /*isServer*/512) timeeditor_changes.isServer = /*isServer*/ctx[9];
          timeeditor.$set(timeeditor_changes);
        },
        i(local) {
          if (current) return;
          transition_in(timeeditor.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(timeeditor.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(timeeditor, detaching);
        }
      };
    }
    function create_fragment$j(ctx) {
      var t;
      var if_block1_anchor;
      var current;
      function select_block_type(ctx, dirty) {
        if (! /*timeUuid*/ctx[1]) return create_if_block_1$6;
        return create_else_block$5;
      }
      var current_block_type = select_block_type(ctx);
      var if_block0 = current_block_type(ctx);
      var if_block1 = /*show*/ctx[11] && create_if_block$b(ctx);
      return {
        c() {
          if_block0.c();
          t = space$1();
          if (if_block1) if_block1.c();
          if_block1_anchor = empty();
        },
        m(target, anchor) {
          if_block0.m(target, anchor);
          insert(target, t, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert(target, if_block1_anchor, anchor);
          current = true;
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0.d(1);
            if_block0 = current_block_type(ctx);
            if (if_block0) {
              if_block0.c();
              if_block0.m(t.parentNode, t);
            }
          }
          if ( /*show*/ctx[11]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
              if (dirty & /*show*/2048) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block$b(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, function () {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block1);
          current = true;
        },
        o(local) {
          transition_out(if_block1);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(t);
            detach(if_block1_anchor);
          }
          if_block0.d(detaching);
          if (if_block1) if_block1.d(detaching);
        }
      };
    }
    var dateFormat$2 = "yyyy-MM-dd HH:mm:ss";
    function instance$i($$self, $$props, $$invalidate) {
      var show;
      var loading;
      var action = $$props.action;
      var editTimeEntryAction = $$props.editTimeEntryAction;
      var timeUuid = $$props.timeUuid;
      var requestToken = $$props.requestToken;
      var clientName = $$props.clientName;
      var projectName = $$props.projectName;
      var taskName = $$props.taskName;
      var timeEditorButtonCaption = $$props.timeEditorButtonCaption;
      var timeEditorCaption = $$props.timeEditorCaption;
      var editTimeEntryData = $$props.editTimeEntryData;
      var isServer = $$props.isServer;
      var localeOptions = Helpers.getDateLocaleOptions();
      onMount(function () {
        Helpers.hideFallbacks("TimeEditor.svelte");
      });
      var save = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator(function (_ref4) {
          var duration = _ref4.duration,
            date = _ref4.date,
            note = _ref4.note;
          return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var entry, response;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  $$invalidate(10, loading = true);
                  _context.prev = 1;
                  entry = {
                    duration,
                    date: format$2(Helpers.toUTC(parseISO(date)), dateFormat$2, localeOptions),
                    note
                  };
                  if (timeUuid) {
                    entry.uuid = timeUuid;
                  }
                  _context.next = 6;
                  return fetch(timeUuid ? editTimeEntryAction : action, {
                    method: timeUuid ? "PATCH" : "POST",
                    body: JSON.stringify(entry),
                    headers: {
                      requesttoken: requestToken,
                      "content-type": "application/json"
                    }
                  });
                case 6:
                  response = _context.sent;
                  if (response && response.ok) {
                    $$invalidate(11, show = false);
                    document.querySelector(".app-timemanager [data-current-link]").click();
                  }
                  _context.next = 13;
                  break;
                case 10:
                  _context.prev = 10;
                  _context.t0 = _context["catch"](1);
                  console.error(_context.t0);
                case 13:
                  $$invalidate(10, loading = false);
                case 14:
                case "end":
                  return _context.stop();
              }
            }, _callee, null, [[1, 10]]);
          })();
        });
        return function save(_x) {
          return _ref3.apply(this, arguments);
        };
      }();
      var click_handler = function click_handler() {
        return $$invalidate(11, show = !show);
      };
      var click_handler_1 = function click_handler_1() {
        return $$invalidate(11, show = !show);
      };
      var func = function func() {
        return $$invalidate(11, show = false);
      };
      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(0, action = $$props.action);
        if ('editTimeEntryAction' in $$props) $$invalidate(13, editTimeEntryAction = $$props.editTimeEntryAction);
        if ('timeUuid' in $$props) $$invalidate(1, timeUuid = $$props.timeUuid);
        if ('requestToken' in $$props) $$invalidate(2, requestToken = $$props.requestToken);
        if ('clientName' in $$props) $$invalidate(3, clientName = $$props.clientName);
        if ('projectName' in $$props) $$invalidate(4, projectName = $$props.projectName);
        if ('taskName' in $$props) $$invalidate(5, taskName = $$props.taskName);
        if ('timeEditorButtonCaption' in $$props) $$invalidate(6, timeEditorButtonCaption = $$props.timeEditorButtonCaption);
        if ('timeEditorCaption' in $$props) $$invalidate(7, timeEditorCaption = $$props.timeEditorCaption);
        if ('editTimeEntryData' in $$props) $$invalidate(8, editTimeEntryData = $$props.editTimeEntryData);
        if ('isServer' in $$props) $$invalidate(9, isServer = $$props.isServer);
      };
      $$invalidate(11, show = false);
      $$invalidate(10, loading = false);
      return [action, timeUuid, requestToken, clientName, projectName, taskName, timeEditorButtonCaption, timeEditorCaption, editTimeEntryData, isServer, loading, show, save, editTimeEntryAction, click_handler, click_handler_1, func];
    }
    var TimeEditorDialog = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(TimeEditorDialog, _SvelteComponent);
      var _super = _createSuper$1(TimeEditorDialog);
      function TimeEditorDialog(options) {
        var _this;
        _classCallCheck$1(this, TimeEditorDialog);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$i, create_fragment$j, safe_not_equal, {
          action: 0,
          editTimeEntryAction: 13,
          timeUuid: 1,
          requestToken: 2,
          clientName: 3,
          projectName: 4,
          taskName: 5,
          timeEditorButtonCaption: 6,
          timeEditorCaption: 7,
          editTimeEntryData: 8,
          isServer: 9
        });
        return _this;
      }
      return _createClass$1(TimeEditorDialog);
    }(SvelteComponent);

    function create_if_block$a(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot$4]
          },
          $$scope: {
            ctx
          }
        }
      });
      return {
        c() {
          create_component(overlay.$$.fragment);
        },
        m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty & /*$$scope, deleteQuestion*/2056) {
            overlay_changes.$$scope = {
              dirty,
              ctx
            };
          }
          overlay.$set(overlay_changes);
        },
        i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    }

    // (38:1) <Overlay>
    function create_default_slot$4(ctx) {
      var div1;
      var t0;
      var t1;
      var div0;
      var button0;
      var t3;
      var button1;
      var mounted;
      var dispose;
      return {
        c() {
          div1 = element("div");
          t0 = text$1( /*deleteQuestion*/ctx[3]);
          t1 = space$1();
          div0 = element("div");
          button0 = element("button");
          button0.textContent = "".concat(translate('timemanager', 'Delete'));
          t3 = space$1();
          button1 = element("button");
          button1.textContent = "".concat(translate('timemanager', 'Cancel'));
          attr(button0, "class", "button primary");
          attr(button1, "class", "button");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(div1, "class", "inner tm_new-item");
        },
        m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, t0);
          append(div1, t1);
          append(div1, div0);
          append(div0, button0);
          append(div0, t3);
          append(div0, button1);
          if (!mounted) {
            dispose = [listen(button0, "click", prevent_default( /*doDelete*/ctx[7])), listen(button1, "click", prevent_default( /*cancelDelete*/ctx[8]))];
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty & /*deleteQuestion*/8) set_data(t0, /*deleteQuestion*/ctx[3]);
        },
        d(detaching) {
          if (detaching) {
            detach(div1);
          }
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function create_fragment$i(ctx) {
      var t0;
      var form_1;
      var input0;
      var t1;
      var input1;
      var t2;
      var button;
      var t3;
      var current;
      var if_block = /*confirmation*/ctx[6] && create_if_block$a(ctx);
      return {
        c() {
          if (if_block) if_block.c();
          t0 = space$1();
          form_1 = element("form");
          input0 = element("input");
          t1 = space$1();
          input1 = element("input");
          t2 = space$1();
          button = element("button");
          t3 = text$1( /*deleteButtonCaption*/ctx[2]);
          attr(input0, "type", "hidden");
          attr(input0, "name", "uuid");
          input0.value = /*deleteUuid*/ctx[1];
          attr(input1, "type", "hidden");
          attr(input1, "name", "requesttoken");
          input1.value = /*requestToken*/ctx[4];
          attr(button, "type", "submit");
          attr(button, "name", "action");
          button.value = "delete";
          attr(button, "class", "btn");
          attr(form_1, "action", /*deleteAction*/ctx[0]);
          attr(form_1, "method", "post");
        },
        m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, t0, anchor);
          insert(target, form_1, anchor);
          append(form_1, input0);
          append(form_1, t1);
          append(form_1, input1);
          append(form_1, t2);
          append(form_1, button);
          append(button, t3);
          /*form_1_binding*/
          ctx[9](form_1);
          current = true;
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if ( /*confirmation*/ctx[6]) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty & /*confirmation*/64) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$a(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(t0.parentNode, t0);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
          if (!current || dirty & /*deleteUuid*/2) {
            input0.value = /*deleteUuid*/ctx[1];
          }
          if (!current || dirty & /*requestToken*/16) {
            input1.value = /*requestToken*/ctx[4];
          }
          if (!current || dirty & /*deleteButtonCaption*/4) set_data(t3, /*deleteButtonCaption*/ctx[2]);
          if (!current || dirty & /*deleteAction*/1) {
            attr(form_1, "action", /*deleteAction*/ctx[0]);
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(t0);
            detach(form_1);
          }
          if (if_block) if_block.d(detaching);
          /*form_1_binding*/
          ctx[9](null);
        }
      };
    }
    function instance$h($$self, $$props, $$invalidate) {
      var confirmation;
      var deleteAction = $$props.deleteAction;
      var deleteUuid = $$props.deleteUuid;
      var deleteButtonCaption = $$props.deleteButtonCaption;
      var deleteQuestion = $$props.deleteQuestion;
      var requestToken = $$props.requestToken;
      var form;
      onMount(function () {
        Helpers.hideFallbacks("DeleteButton.svelte");
        form.addEventListener("submit", submit);
      });
      var submit = function submit(e) {
        e.preventDefault();
        $$invalidate(6, confirmation = true);
      };
      var doDelete = function doDelete() {
        $$invalidate(6, confirmation = false);
        form.removeEventListener("submit", submit);
        form.submit();
      };
      var cancelDelete = function cancelDelete() {
        $$invalidate(6, confirmation = false);
      };
      function form_1_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          form = $$value;
          $$invalidate(5, form);
        });
      }
      $$self.$$set = function ($$props) {
        if ('deleteAction' in $$props) $$invalidate(0, deleteAction = $$props.deleteAction);
        if ('deleteUuid' in $$props) $$invalidate(1, deleteUuid = $$props.deleteUuid);
        if ('deleteButtonCaption' in $$props) $$invalidate(2, deleteButtonCaption = $$props.deleteButtonCaption);
        if ('deleteQuestion' in $$props) $$invalidate(3, deleteQuestion = $$props.deleteQuestion);
        if ('requestToken' in $$props) $$invalidate(4, requestToken = $$props.requestToken);
      };
      $$invalidate(6, confirmation = false);
      return [deleteAction, deleteUuid, deleteButtonCaption, deleteQuestion, requestToken, form, confirmation, doDelete, cancelDelete, form_1_binding];
    }
    var DeleteButton = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(DeleteButton, _SvelteComponent);
      var _super = _createSuper$1(DeleteButton);
      function DeleteButton(options) {
        var _this;
        _classCallCheck$1(this, DeleteButton);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$h, create_fragment$i, safe_not_equal, {
          deleteAction: 0,
          deleteUuid: 1,
          deleteButtonCaption: 2,
          deleteQuestion: 3,
          requestToken: 4
        });
        return _this;
      }
      return _createClass$1(DeleteButton);
    }(SvelteComponent);

    var $filter = arrayIteration.filter;

    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    // with adding support of @@species
    _export({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT
    }, {
      filter: function filter(callbackfn /* , thisArg */) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });

    function isOutOfViewport (parent, container) {
      const parentBounding = parent.getBoundingClientRect();
      const boundingContainer = container.getBoundingClientRect();
      const out = {};
      out.top = parentBounding.top < 0;
      out.left = parentBounding.left < 0;
      out.bottom = parentBounding.bottom + boundingContainer.height > (window.innerHeight || document.documentElement.clientHeight);
      out.right = parentBounding.right > (window.innerWidth || document.documentElement.clientWidth);
      out.any = out.top || out.left || out.bottom || out.right;
      return out;
    }

    function add_css$5(target) {
      append_styles(target, "svelte-3e0qet", ".item.svelte-3e0qet{cursor:default;height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--itemPadding, 0 20px);color:var(--itemColor, inherit);text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.groupHeader.svelte-3e0qet{text-transform:var(--groupTitleTextTransform, uppercase)}.groupItem.svelte-3e0qet{padding-left:var(--groupItemPaddingLeft, 40px)}.item.svelte-3e0qet:active{background:var(--itemActiveBackground, #b9daff)}.item.active.svelte-3e0qet{background:var(--itemIsActiveBG, #007aff);color:var(--itemIsActiveColor, #fff)}.item.notSelectable.svelte-3e0qet{color:var(--itemIsNotSelectableColor, #999)}.item.first.svelte-3e0qet{border-radius:var(--itemFirstBorderRadius, 4px 4px 0 0)}.item.hover.svelte-3e0qet:not(.active){background:var(--itemHoverBG, #e7f2ff);color:var(--itemHoverColor, inherit)}");
    }
    function create_fragment$h(ctx) {
      let div;
      let raw_value = /*getOptionLabel*/ctx[0]( /*item*/ctx[1], /*filterText*/ctx[2]) + "";
      let div_class_value;
      return {
        c() {
          div = element("div");
          attr(div, "class", div_class_value = "item " + /*itemClasses*/ctx[3] + " svelte-3e0qet");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          div.innerHTML = raw_value;
        },
        p(ctx, [dirty]) {
          if (dirty & /*getOptionLabel, item, filterText*/7 && raw_value !== (raw_value = /*getOptionLabel*/ctx[0]( /*item*/ctx[1], /*filterText*/ctx[2]) + "")) div.innerHTML = raw_value;
          if (dirty & /*itemClasses*/8 && div_class_value !== (div_class_value = "item " + /*itemClasses*/ctx[3] + " svelte-3e0qet")) {
            attr(div, "class", div_class_value);
          }
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(div);
          }
        }
      };
    }
    function instance$g($$self, $$props, $$invalidate) {
      let {
        isActive = false
      } = $$props;
      let {
        isFirst = false
      } = $$props;
      let {
        isHover = false
      } = $$props;
      let {
        isSelectable = false
      } = $$props;
      let {
        getOptionLabel = undefined
      } = $$props;
      let {
        item = undefined
      } = $$props;
      let {
        filterText = ''
      } = $$props;
      let itemClasses = '';
      $$self.$$set = $$props => {
        if ('isActive' in $$props) $$invalidate(4, isActive = $$props.isActive);
        if ('isFirst' in $$props) $$invalidate(5, isFirst = $$props.isFirst);
        if ('isHover' in $$props) $$invalidate(6, isHover = $$props.isHover);
        if ('isSelectable' in $$props) $$invalidate(7, isSelectable = $$props.isSelectable);
        if ('getOptionLabel' in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
        if ('item' in $$props) $$invalidate(1, item = $$props.item);
        if ('filterText' in $$props) $$invalidate(2, filterText = $$props.filterText);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*isActive, isFirst, isHover, item, isSelectable*/242) {
          {
            const classes = [];
            if (isActive) {
              classes.push('active');
            }
            if (isFirst) {
              classes.push('first');
            }
            if (isHover) {
              classes.push('hover');
            }
            if (item.isGroupHeader) {
              classes.push('groupHeader');
            }
            if (item.isGroupItem) {
              classes.push('groupItem');
            }
            if (!isSelectable) {
              classes.push('notSelectable');
            }
            $$invalidate(3, itemClasses = classes.join(' '));
          }
        }
      };
      return [getOptionLabel, item, filterText, itemClasses, isActive, isFirst, isHover, isSelectable];
    }
    class Item extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$g, create_fragment$h, safe_not_equal, {
          isActive: 4,
          isFirst: 5,
          isHover: 6,
          isSelectable: 7,
          getOptionLabel: 0,
          item: 1,
          filterText: 2
        }, add_css$5);
      }
    }

    function add_css$4(target) {
      append_styles(target, "svelte-1uyqfml", ".listContainer.svelte-1uyqfml{box-shadow:var(--listShadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));border-radius:var(--listBorderRadius, 4px);max-height:var(--listMaxHeight, 250px);overflow-y:auto;background:var(--listBackground, #fff);border:var(--listBorder, none);position:var(--listPosition, absolute);z-index:var(--listZIndex, 2);width:100%;left:var(--listLeft, 0);right:var(--listRight, 0)}.virtualList.svelte-1uyqfml{height:var(--virtualListHeight, 200px)}.listGroupTitle.svelte-1uyqfml{color:var(--groupTitleColor, #8f8f8f);cursor:default;font-size:var(--groupTitleFontSize, 12px);font-weight:var(--groupTitleFontWeight, 600);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--groupTitlePadding, 0 20px);text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap;text-transform:var(--groupTitleTextTransform, uppercase)}.empty.svelte-1uyqfml{text-align:var(--listEmptyTextAlign, center);padding:var(--listEmptyPadding, 20px 0);color:var(--listEmptyColor, #78848f)}");
    }
    function get_each_context$7(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[41] = list[i];
      child_ctx[42] = i;
      return child_ctx;
    }

    // (309:4) {:else}
    function create_else_block$4(ctx) {
      let each_1_anchor;
      let current;
      let each_value = ensure_array_like( /*items*/ctx[1]);
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
      }
      const out = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });
      let each_1_else = null;
      if (!each_value.length) {
        each_1_else = create_else_block_2(ctx);
      }
      return {
        c() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          each_1_anchor = empty();
          if (each_1_else) {
            each_1_else.c();
          }
        },
        m(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(target, anchor);
            }
          }
          insert(target, each_1_anchor, anchor);
          if (each_1_else) {
            each_1_else.m(target, anchor);
          }
          current = true;
        },
        p(ctx, dirty) {
          if (dirty[0] & /*getGroupHeaderLabel, items, handleHover, handleClick, Item, filterText, getOptionLabel, value, optionIdentifier, hoverItemIndex, noOptionsMessage, hideEmptyState*/114390) {
            each_value = ensure_array_like( /*items*/ctx[1]);
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$7(ctx, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$7(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            group_outros();
            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }
            check_outros();
            if (!each_value.length && each_1_else) {
              each_1_else.p(ctx, dirty);
            } else if (!each_value.length) {
              each_1_else = create_else_block_2(ctx);
              each_1_else.c();
              each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
            } else if (each_1_else) {
              each_1_else.d(1);
              each_1_else = null;
            }
          }
        },
        i(local) {
          if (current) return;
          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }
          current = true;
        },
        o(local) {
          each_blocks = each_blocks.filter(Boolean);
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(each_1_anchor);
          }
          destroy_each(each_blocks, detaching);
          if (each_1_else) each_1_else.d(detaching);
        }
      };
    }

    // (286:4) {#if isVirtualList}
    function create_if_block$9(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      var switch_value = /*VirtualList*/ctx[3];
      function switch_props(ctx, dirty) {
        return {
          props: {
            items: /*items*/ctx[1],
            itemHeight: /*itemHeight*/ctx[8],
            $$slots: {
              default: [create_default_slot$3, ({
                item,
                i
              }) => ({
                41: item,
                42: i
              }), ({
                item,
                i
              }) => [0, (item ? 1024 : 0) | (i ? 2048 : 0)]]
            },
            $$scope: {
              ctx
            }
          }
        };
      }
      if (switch_value) {
        switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
      }
      return {
        c() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        m(target, anchor) {
          if (switch_instance) mount_component(switch_instance, target, anchor);
          insert(target, switch_instance_anchor, anchor);
          current = true;
        },
        p(ctx, dirty) {
          if (dirty[0] & /*VirtualList*/8 && switch_value !== (switch_value = /*VirtualList*/ctx[3])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            const switch_instance_changes = {};
            if (dirty[0] & /*items*/2) switch_instance_changes.items = /*items*/ctx[1];
            if (dirty[0] & /*itemHeight*/256) switch_instance_changes.itemHeight = /*itemHeight*/ctx[8];
            if (dirty[0] & /*Item, filterText, getOptionLabel, value, optionIdentifier, hoverItemIndex, items*/9814 | dirty[1] & /*$$scope, i, item*/11264) {
              switch_instance_changes.$$scope = {
                dirty,
                ctx
              };
            }
            switch_instance.$set(switch_instance_changes);
          }
        },
        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(switch_instance_anchor);
          }
          if (switch_instance) destroy_component(switch_instance, detaching);
        }
      };
    }

    // (331:8) {:else}
    function create_else_block_2(ctx) {
      let if_block_anchor;
      let if_block = ! /*hideEmptyState*/ctx[11] && create_if_block_2$5(ctx);
      return {
        c() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
        },
        p(ctx, dirty) {
          if (! /*hideEmptyState*/ctx[11]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_2$5(ctx);
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(if_block_anchor);
          }
          if (if_block) if_block.d(detaching);
        }
      };
    }

    // (332:12) {#if !hideEmptyState}
    function create_if_block_2$5(ctx) {
      let div;
      let t;
      return {
        c() {
          div = element("div");
          t = text$1( /*noOptionsMessage*/ctx[12]);
          attr(div, "class", "empty svelte-1uyqfml");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          append(div, t);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*noOptionsMessage*/4096) set_data(t, /*noOptionsMessage*/ctx[12]);
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
        }
      };
    }

    // (313:12) {:else}
    function create_else_block_1(ctx) {
      let div;
      let switch_instance;
      let t;
      let current;
      let mounted;
      let dispose;
      var switch_value = /*Item*/ctx[4];
      function switch_props(ctx, dirty) {
        return {
          props: {
            item: /*item*/ctx[41],
            filterText: /*filterText*/ctx[13],
            getOptionLabel: /*getOptionLabel*/ctx[6],
            isFirst: isItemFirst( /*i*/ctx[42]),
            isActive: isItemActive( /*item*/ctx[41], /*value*/ctx[9], /*optionIdentifier*/ctx[10]),
            isHover: isItemHover( /*hoverItemIndex*/ctx[2], /*item*/ctx[41], /*i*/ctx[42], /*items*/ctx[1]),
            isSelectable: isItemSelectable( /*item*/ctx[41])
          }
        };
      }
      if (switch_value) {
        switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
      }
      function mouseover_handler_1() {
        return (/*mouseover_handler_1*/ctx[29]( /*i*/ctx[42])
        );
      }
      function focus_handler_1() {
        return (/*focus_handler_1*/ctx[30]( /*i*/ctx[42])
        );
      }
      function click_handler_1(...args) {
        return (/*click_handler_1*/ctx[31]( /*item*/ctx[41], /*i*/ctx[42], ...args)
        );
      }
      return {
        c() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          t = space$1();
          attr(div, "class", "listItem");
          attr(div, "tabindex", "-1");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          if (switch_instance) mount_component(switch_instance, div, null);
          append(div, t);
          current = true;
          if (!mounted) {
            dispose = [listen(div, "mouseover", mouseover_handler_1), listen(div, "focus", focus_handler_1), listen(div, "click", click_handler_1)];
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] & /*Item*/16 && switch_value !== (switch_value = /*Item*/ctx[4])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, t);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            const switch_instance_changes = {};
            if (dirty[0] & /*items*/2) switch_instance_changes.item = /*item*/ctx[41];
            if (dirty[0] & /*filterText*/8192) switch_instance_changes.filterText = /*filterText*/ctx[13];
            if (dirty[0] & /*getOptionLabel*/64) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ctx[6];
            if (dirty[0] & /*items, value, optionIdentifier*/1538) switch_instance_changes.isActive = isItemActive( /*item*/ctx[41], /*value*/ctx[9], /*optionIdentifier*/ctx[10]);
            if (dirty[0] & /*hoverItemIndex, items*/6) switch_instance_changes.isHover = isItemHover( /*hoverItemIndex*/ctx[2], /*item*/ctx[41], /*i*/ctx[42], /*items*/ctx[1]);
            if (dirty[0] & /*items*/2) switch_instance_changes.isSelectable = isItemSelectable( /*item*/ctx[41]);
            switch_instance.$set(switch_instance_changes);
          }
        },
        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          run_all(dispose);
        }
      };
    }

    // (311:12) {#if item.isGroupHeader && !item.isSelectable}
    function create_if_block_1$5(ctx) {
      let div;
      let t_value = /*getGroupHeaderLabel*/ctx[7]( /*item*/ctx[41]) + "";
      let t;
      return {
        c() {
          div = element("div");
          t = text$1(t_value);
          attr(div, "class", "listGroupTitle svelte-1uyqfml");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          append(div, t);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*getGroupHeaderLabel, items*/130 && t_value !== (t_value = /*getGroupHeaderLabel*/ctx[7]( /*item*/ctx[41]) + "")) set_data(t, t_value);
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(div);
          }
        }
      };
    }

    // (310:8) {#each items as item, i}
    function create_each_block$7(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block_1$5, create_else_block_1];
      const if_blocks = [];
      function select_block_type_1(ctx, dirty) {
        if ( /*item*/ctx[41].isGroupHeader && ! /*item*/ctx[41].isSelectable) return 0;
        return 1;
      }
      current_block_type_index = select_block_type_1(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      return {
        c() {
          if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
        },
        p(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_1(ctx);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(if_block_anchor);
          }
          if_blocks[current_block_type_index].d(detaching);
        }
      };
    }

    // (287:8) <svelte:component             this={VirtualList}             {items}             {itemHeight}             let:item             let:i>
    function create_default_slot$3(ctx) {
      let div;
      let switch_instance;
      let current;
      let mounted;
      let dispose;
      var switch_value = /*Item*/ctx[4];
      function switch_props(ctx, dirty) {
        return {
          props: {
            item: /*item*/ctx[41],
            filterText: /*filterText*/ctx[13],
            getOptionLabel: /*getOptionLabel*/ctx[6],
            isFirst: isItemFirst( /*i*/ctx[42]),
            isActive: isItemActive( /*item*/ctx[41], /*value*/ctx[9], /*optionIdentifier*/ctx[10]),
            isHover: isItemHover( /*hoverItemIndex*/ctx[2], /*item*/ctx[41], /*i*/ctx[42], /*items*/ctx[1]),
            isSelectable: isItemSelectable( /*item*/ctx[41])
          }
        };
      }
      if (switch_value) {
        switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
      }
      function mouseover_handler() {
        return (/*mouseover_handler*/ctx[26]( /*i*/ctx[42])
        );
      }
      function focus_handler() {
        return (/*focus_handler*/ctx[27]( /*i*/ctx[42])
        );
      }
      function click_handler(...args) {
        return (/*click_handler*/ctx[28]( /*item*/ctx[41], /*i*/ctx[42], ...args)
        );
      }
      return {
        c() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr(div, "class", "listItem");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          if (switch_instance) mount_component(switch_instance, div, null);
          current = true;
          if (!mounted) {
            dispose = [listen(div, "mouseover", mouseover_handler), listen(div, "focus", focus_handler), listen(div, "click", click_handler)];
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] & /*Item*/16 && switch_value !== (switch_value = /*Item*/ctx[4])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, null);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            const switch_instance_changes = {};
            if (dirty[1] & /*item*/1024) switch_instance_changes.item = /*item*/ctx[41];
            if (dirty[0] & /*filterText*/8192) switch_instance_changes.filterText = /*filterText*/ctx[13];
            if (dirty[0] & /*getOptionLabel*/64) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ctx[6];
            if (dirty[1] & /*i*/2048) switch_instance_changes.isFirst = isItemFirst( /*i*/ctx[42]);
            if (dirty[0] & /*value, optionIdentifier*/1536 | dirty[1] & /*item*/1024) switch_instance_changes.isActive = isItemActive( /*item*/ctx[41], /*value*/ctx[9], /*optionIdentifier*/ctx[10]);
            if (dirty[0] & /*hoverItemIndex, items*/6 | dirty[1] & /*item, i*/3072) switch_instance_changes.isHover = isItemHover( /*hoverItemIndex*/ctx[2], /*item*/ctx[41], /*i*/ctx[42], /*items*/ctx[1]);
            if (dirty[1] & /*item*/1024) switch_instance_changes.isSelectable = isItemSelectable( /*item*/ctx[41]);
            switch_instance.$set(switch_instance_changes);
          }
        },
        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function create_fragment$g(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let current;
      let mounted;
      let dispose;
      const if_block_creators = [create_if_block$9, create_else_block$4];
      const if_blocks = [];
      function select_block_type(ctx, dirty) {
        if ( /*isVirtualList*/ctx[5]) return 0;
        return 1;
      }
      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      return {
        c() {
          div = element("div");
          if_block.c();
          attr(div, "class", "listContainer svelte-1uyqfml");
          attr(div, "style", /*listStyle*/ctx[14]);
          toggle_class(div, "virtualList", /*isVirtualList*/ctx[5]);
        },
        m(target, anchor) {
          insert(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          /*div_binding*/
          ctx[32](div);
          current = true;
          if (!mounted) {
            dispose = [listen(window, "keydown", /*handleKeyDown*/ctx[17]), listen(window, "resize", /*computePlacement*/ctx[18])];
            mounted = true;
          }
        },
        p(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);
          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            } else {
              if_block.p(ctx, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(div, null);
          }
          if (!current || dirty[0] & /*listStyle*/16384) {
            attr(div, "style", /*listStyle*/ctx[14]);
          }
          if (!current || dirty[0] & /*isVirtualList*/32) {
            toggle_class(div, "virtualList", /*isVirtualList*/ctx[5]);
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          if_blocks[current_block_type_index].d();
          /*div_binding*/
          ctx[32](null);
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function isItemActive(item, value, optionIdentifier) {
      return value && value[optionIdentifier] === item[optionIdentifier];
    }
    function isItemFirst(itemIndex) {
      return itemIndex === 0;
    }
    function isItemHover(hoverItemIndex, item, itemIndex, items) {
      return isItemSelectable(item) && (hoverItemIndex === itemIndex || items.length === 1);
    }
    function isItemSelectable(item) {
      return item.isGroupHeader && item.isSelectable || item.selectable || !item.hasOwnProperty('selectable'); // Default; if `selectable` was not specified, the object is selectable
    }

    function instance$f($$self, $$props, $$invalidate) {
      const dispatch = createEventDispatcher();
      let {
        container = undefined
      } = $$props;
      let {
        VirtualList = null
      } = $$props;
      let {
        Item: Item$1 = Item
      } = $$props;
      let {
        isVirtualList = false
      } = $$props;
      let {
        items = []
      } = $$props;
      let {
        labelIdentifier = 'label'
      } = $$props;
      let {
        getOptionLabel = (option, filterText) => {
          if (option) return option.isCreator ? `Create \"${filterText}\"` : option[labelIdentifier];
        }
      } = $$props;
      let {
        getGroupHeaderLabel = null
      } = $$props;
      let {
        itemHeight = 40
      } = $$props;
      let {
        hoverItemIndex = 0
      } = $$props;
      let {
        value = undefined
      } = $$props;
      let {
        optionIdentifier = 'value'
      } = $$props;
      let {
        hideEmptyState = false
      } = $$props;
      let {
        noOptionsMessage = 'No options'
      } = $$props;
      let {
        isMulti = false
      } = $$props;
      let {
        activeItemIndex = 0
      } = $$props;
      let {
        filterText = ''
      } = $$props;
      let {
        parent = null
      } = $$props;
      let {
        listPlacement = null
      } = $$props;
      let {
        listAutoWidth = null
      } = $$props;
      let {
        listOffset = 5
      } = $$props;
      let isScrollingTimer = 0;
      let isScrolling = false;
      let prev_items;
      onMount(() => {
        if (items.length > 0 && !isMulti && value) {
          const _hoverItemIndex = items.findIndex(item => item[optionIdentifier] === value[optionIdentifier]);
          if (_hoverItemIndex) {
            $$invalidate(2, hoverItemIndex = _hoverItemIndex);
          }
        }
        scrollToActiveItem('active');
        container.addEventListener('scroll', () => {
          clearTimeout(isScrollingTimer);
          isScrollingTimer = setTimeout(() => {
            isScrolling = false;
          }, 100);
        }, false);
      });
      beforeUpdate(() => {
        if (!items) $$invalidate(1, items = []);
        if (items !== prev_items && items.length > 0) {
          $$invalidate(2, hoverItemIndex = 0);
        }
        prev_items = items;
      });
      function handleSelect(item) {
        if (item.isCreator) return;
        dispatch('itemSelected', item);
      }
      function handleHover(i) {
        if (isScrolling) return;
        $$invalidate(2, hoverItemIndex = i);
      }
      function handleClick(args) {
        const {
          item,
          i,
          event
        } = args;
        event.stopPropagation();
        if (value && !isMulti && value[optionIdentifier] === item[optionIdentifier]) return closeList();
        if (item.isCreator) {
          dispatch('itemCreated', filterText);
        } else if (isItemSelectable(item)) {
          $$invalidate(19, activeItemIndex = i);
          $$invalidate(2, hoverItemIndex = i);
          handleSelect(item);
        }
      }
      function closeList() {
        dispatch('closeList');
      }
      async function updateHoverItem(increment) {
        if (isVirtualList) return;
        let isNonSelectableItem = true;
        while (isNonSelectableItem) {
          if (increment > 0 && hoverItemIndex === items.length - 1) {
            $$invalidate(2, hoverItemIndex = 0);
          } else if (increment < 0 && hoverItemIndex === 0) {
            $$invalidate(2, hoverItemIndex = items.length - 1);
          } else {
            $$invalidate(2, hoverItemIndex = hoverItemIndex + increment);
          }
          isNonSelectableItem = !isItemSelectable(items[hoverItemIndex]);
        }
        await tick();
        scrollToActiveItem('hover');
      }
      function handleKeyDown(e) {
        switch (e.key) {
          case 'Escape':
            e.preventDefault();
            closeList();
            break;
          case 'ArrowDown':
            e.preventDefault();
            items.length && updateHoverItem(1);
            break;
          case 'ArrowUp':
            e.preventDefault();
            items.length && updateHoverItem(-1);
            break;
          case 'Enter':
            e.preventDefault();
            if (items.length === 0) break;
            const hoverItem = items[hoverItemIndex];
            if (value && !isMulti && value[optionIdentifier] === hoverItem[optionIdentifier]) {
              closeList();
              break;
            }
            if (hoverItem.isCreator) {
              dispatch('itemCreated', filterText);
            } else {
              $$invalidate(19, activeItemIndex = hoverItemIndex);
              handleSelect(items[hoverItemIndex]);
            }
            break;
          case 'Tab':
            e.preventDefault();
            if (items.length === 0) {
              return closeList();
            }
            if (value && value[optionIdentifier] === items[hoverItemIndex][optionIdentifier]) return closeList();
            $$invalidate(19, activeItemIndex = hoverItemIndex);
            handleSelect(items[hoverItemIndex]);
            break;
        }
      }
      function scrollToActiveItem(className) {
        if (isVirtualList || !container) return;
        let offsetBounding;
        const focusedElemBounding = container.querySelector(`.listItem .${className}`);
        if (focusedElemBounding) {
          offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
        }
        $$invalidate(0, container.scrollTop -= offsetBounding, container);
      }
      let listStyle;
      function computePlacement() {
        const {
          height,
          width
        } = parent.getBoundingClientRect();
        $$invalidate(14, listStyle = '');
        $$invalidate(14, listStyle += `min-width:${width}px;width:${listAutoWidth ? 'auto' : '100%'};`);
        if (listPlacement === 'top' || listPlacement === 'auto' && isOutOfViewport(parent, container).bottom) {
          $$invalidate(14, listStyle += `bottom:${height + listOffset}px;`);
        } else {
          $$invalidate(14, listStyle += `top:${height + listOffset}px;`);
        }
      }
      const mouseover_handler = i => handleHover(i);
      const focus_handler = i => handleHover(i);
      const click_handler = (item, i, event) => handleClick({
        item,
        i,
        event
      });
      const mouseover_handler_1 = i => handleHover(i);
      const focus_handler_1 = i => handleHover(i);
      const click_handler_1 = (item, i, event) => handleClick({
        item,
        i,
        event
      });
      function div_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          container = $$value;
          $$invalidate(0, container);
        });
      }
      $$self.$$set = $$props => {
        if ('container' in $$props) $$invalidate(0, container = $$props.container);
        if ('VirtualList' in $$props) $$invalidate(3, VirtualList = $$props.VirtualList);
        if ('Item' in $$props) $$invalidate(4, Item$1 = $$props.Item);
        if ('isVirtualList' in $$props) $$invalidate(5, isVirtualList = $$props.isVirtualList);
        if ('items' in $$props) $$invalidate(1, items = $$props.items);
        if ('labelIdentifier' in $$props) $$invalidate(20, labelIdentifier = $$props.labelIdentifier);
        if ('getOptionLabel' in $$props) $$invalidate(6, getOptionLabel = $$props.getOptionLabel);
        if ('getGroupHeaderLabel' in $$props) $$invalidate(7, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
        if ('itemHeight' in $$props) $$invalidate(8, itemHeight = $$props.itemHeight);
        if ('hoverItemIndex' in $$props) $$invalidate(2, hoverItemIndex = $$props.hoverItemIndex);
        if ('value' in $$props) $$invalidate(9, value = $$props.value);
        if ('optionIdentifier' in $$props) $$invalidate(10, optionIdentifier = $$props.optionIdentifier);
        if ('hideEmptyState' in $$props) $$invalidate(11, hideEmptyState = $$props.hideEmptyState);
        if ('noOptionsMessage' in $$props) $$invalidate(12, noOptionsMessage = $$props.noOptionsMessage);
        if ('isMulti' in $$props) $$invalidate(21, isMulti = $$props.isMulti);
        if ('activeItemIndex' in $$props) $$invalidate(19, activeItemIndex = $$props.activeItemIndex);
        if ('filterText' in $$props) $$invalidate(13, filterText = $$props.filterText);
        if ('parent' in $$props) $$invalidate(22, parent = $$props.parent);
        if ('listPlacement' in $$props) $$invalidate(23, listPlacement = $$props.listPlacement);
        if ('listAutoWidth' in $$props) $$invalidate(24, listAutoWidth = $$props.listAutoWidth);
        if ('listOffset' in $$props) $$invalidate(25, listOffset = $$props.listOffset);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & /*parent, container*/4194305) {
          {
            if (parent && container) computePlacement();
          }
        }
      };
      return [container, items, hoverItemIndex, VirtualList, Item$1, isVirtualList, getOptionLabel, getGroupHeaderLabel, itemHeight, value, optionIdentifier, hideEmptyState, noOptionsMessage, filterText, listStyle, handleHover, handleClick, handleKeyDown, computePlacement, activeItemIndex, labelIdentifier, isMulti, parent, listPlacement, listAutoWidth, listOffset, mouseover_handler, focus_handler, click_handler, mouseover_handler_1, focus_handler_1, click_handler_1, div_binding];
    }
    class List extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$f, create_fragment$g, safe_not_equal, {
          container: 0,
          VirtualList: 3,
          Item: 4,
          isVirtualList: 5,
          items: 1,
          labelIdentifier: 20,
          getOptionLabel: 6,
          getGroupHeaderLabel: 7,
          itemHeight: 8,
          hoverItemIndex: 2,
          value: 9,
          optionIdentifier: 10,
          hideEmptyState: 11,
          noOptionsMessage: 12,
          isMulti: 21,
          activeItemIndex: 19,
          filterText: 13,
          parent: 22,
          listPlacement: 23,
          listAutoWidth: 24,
          listOffset: 25
        }, add_css$4, [-1, -1]);
      }
    }

    function add_css$3(target) {
      append_styles(target, "svelte-pu1q1n", ".selection.svelte-pu1q1n{text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap}");
    }
    function create_fragment$f(ctx) {
      let div;
      let raw_value = /*getSelectionLabel*/ctx[0]( /*item*/ctx[1]) + "";
      return {
        c() {
          div = element("div");
          attr(div, "class", "selection svelte-pu1q1n");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          div.innerHTML = raw_value;
        },
        p(ctx, [dirty]) {
          if (dirty & /*getSelectionLabel, item*/3 && raw_value !== (raw_value = /*getSelectionLabel*/ctx[0]( /*item*/ctx[1]) + "")) div.innerHTML = raw_value;
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(div);
          }
        }
      };
    }
    function instance$e($$self, $$props, $$invalidate) {
      let {
        getSelectionLabel = undefined
      } = $$props;
      let {
        item = undefined
      } = $$props;
      $$self.$$set = $$props => {
        if ('getSelectionLabel' in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
        if ('item' in $$props) $$invalidate(1, item = $$props.item);
      };
      return [getSelectionLabel, item];
    }
    class Selection extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$e, create_fragment$f, safe_not_equal, {
          getSelectionLabel: 0,
          item: 1
        }, add_css$3);
      }
    }

    function add_css$2(target) {
      append_styles(target, "svelte-liu9pa", ".multiSelectItem.svelte-liu9pa.svelte-liu9pa{background:var(--multiItemBG, #ebedef);margin:var(--multiItemMargin, 5px 5px 0 0);border-radius:var(--multiItemBorderRadius, 16px);height:var(--multiItemHeight, 32px);line-height:var(--multiItemHeight, 32px);display:flex;cursor:default;padding:var(--multiItemPadding, 0 10px 0 15px);max-width:100%}.multiSelectItem_label.svelte-liu9pa.svelte-liu9pa{margin:var(--multiLabelMargin, 0 5px 0 0);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.multiSelectItem.svelte-liu9pa.svelte-liu9pa:hover,.multiSelectItem.active.svelte-liu9pa.svelte-liu9pa{background-color:var(--multiItemActiveBG, #006fff);color:var(--multiItemActiveColor, #fff)}.multiSelectItem.disabled.svelte-liu9pa.svelte-liu9pa:hover{background:var(--multiItemDisabledHoverBg, #ebedef);color:var(--multiItemDisabledHoverColor, #c1c6cc)}.multiSelectItem_clear.svelte-liu9pa.svelte-liu9pa{border-radius:var(--multiClearRadius, 50%);background:var(--multiClearBG, #52616f);min-width:var(--multiClearWidth, 16px);max-width:var(--multiClearWidth, 16px);height:var(--multiClearHeight, 16px);position:relative;top:var(--multiClearTop, 8px);text-align:var(--multiClearTextAlign, center);padding:var(--multiClearPadding, 1px)}.multiSelectItem_clear.svelte-liu9pa.svelte-liu9pa:hover,.active.svelte-liu9pa .multiSelectItem_clear.svelte-liu9pa{background:var(--multiClearHoverBG, #fff)}.multiSelectItem_clear.svelte-liu9pa:hover svg.svelte-liu9pa,.active.svelte-liu9pa .multiSelectItem_clear svg.svelte-liu9pa{fill:var(--multiClearHoverFill, #006fff)}.multiSelectItem_clear.svelte-liu9pa svg.svelte-liu9pa{fill:var(--multiClearFill, #ebedef);vertical-align:top}");
    }
    function get_each_context$6(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i];
      child_ctx[11] = i;
      return child_ctx;
    }

    // (87:8) {#if !isDisabled && !multiFullItemClearable}
    function create_if_block$8(ctx) {
      let div;
      let mounted;
      let dispose;
      function click_handler(...args) {
        return (/*click_handler*/ctx[6]( /*i*/ctx[11], ...args)
        );
      }
      return {
        c() {
          div = element("div");
          div.innerHTML = `<svg width="100%" height="100%" viewBox="-2 -2 50 50" focusable="false" aria-hidden="true" role="presentation" class="svelte-liu9pa"><path d="M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"></path></svg>`;
          attr(div, "class", "multiSelectItem_clear svelte-liu9pa");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          if (!mounted) {
            dispose = listen(div, "click", click_handler);
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          mounted = false;
          dispose();
        }
      };
    }

    // (77:0) {#each value as item, i}
    function create_each_block$6(ctx) {
      let div1;
      let div0;
      let raw_value = /*getSelectionLabel*/ctx[4]( /*item*/ctx[9]) + "";
      let t0;
      let t1;
      let div1_class_value;
      let mounted;
      let dispose;
      let if_block = ! /*isDisabled*/ctx[2] && ! /*multiFullItemClearable*/ctx[3] && create_if_block$8(ctx);
      function click_handler_1(...args) {
        return (/*click_handler_1*/ctx[7]( /*i*/ctx[11], ...args)
        );
      }
      return {
        c() {
          div1 = element("div");
          div0 = element("div");
          t0 = space$1();
          if (if_block) if_block.c();
          t1 = space$1();
          attr(div0, "class", "multiSelectItem_label svelte-liu9pa");
          attr(div1, "class", div1_class_value = "multiSelectItem " + ( /*activeValue*/ctx[1] === /*i*/ctx[11] ? 'active' : '') + " " + ( /*isDisabled*/ctx[2] ? 'disabled' : '') + " svelte-liu9pa");
        },
        m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, div0);
          div0.innerHTML = raw_value;
          append(div1, t0);
          if (if_block) if_block.m(div1, null);
          append(div1, t1);
          if (!mounted) {
            dispose = listen(div1, "click", click_handler_1);
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty & /*getSelectionLabel, value*/17 && raw_value !== (raw_value = /*getSelectionLabel*/ctx[4]( /*item*/ctx[9]) + "")) div0.innerHTML = raw_value;
          if (! /*isDisabled*/ctx[2] && ! /*multiFullItemClearable*/ctx[3]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$8(ctx);
              if_block.c();
              if_block.m(div1, t1);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
          if (dirty & /*activeValue, isDisabled*/6 && div1_class_value !== (div1_class_value = "multiSelectItem " + ( /*activeValue*/ctx[1] === /*i*/ctx[11] ? 'active' : '') + " " + ( /*isDisabled*/ctx[2] ? 'disabled' : '') + " svelte-liu9pa")) {
            attr(div1, "class", div1_class_value);
          }
        },
        d(detaching) {
          if (detaching) {
            detach(div1);
          }
          if (if_block) if_block.d();
          mounted = false;
          dispose();
        }
      };
    }
    function create_fragment$e(ctx) {
      let each_1_anchor;
      let each_value = ensure_array_like( /*value*/ctx[0]);
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
      }
      return {
        c() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          each_1_anchor = empty();
        },
        m(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(target, anchor);
            }
          }
          insert(target, each_1_anchor, anchor);
        },
        p(ctx, [dirty]) {
          if (dirty & /*activeValue, isDisabled, multiFullItemClearable, handleClear, getSelectionLabel, value*/63) {
            each_value = ensure_array_like( /*value*/ctx[0]);
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$6(ctx, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$6(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }
            each_blocks.length = each_value.length;
          }
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(each_1_anchor);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }
    function instance$d($$self, $$props, $$invalidate) {
      const dispatch = createEventDispatcher();
      let {
        value = []
      } = $$props;
      let {
        activeValue = undefined
      } = $$props;
      let {
        isDisabled = false
      } = $$props;
      let {
        multiFullItemClearable = false
      } = $$props;
      let {
        getSelectionLabel = undefined
      } = $$props;
      function handleClear(i, event) {
        event.stopPropagation();
        dispatch('multiItemClear', {
          i
        });
      }
      const click_handler = (i, event) => handleClear(i, event);
      const click_handler_1 = (i, event) => multiFullItemClearable ? handleClear(i, event) : {};
      $$self.$$set = $$props => {
        if ('value' in $$props) $$invalidate(0, value = $$props.value);
        if ('activeValue' in $$props) $$invalidate(1, activeValue = $$props.activeValue);
        if ('isDisabled' in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
        if ('multiFullItemClearable' in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
        if ('getSelectionLabel' in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
      };
      return [value, activeValue, isDisabled, multiFullItemClearable, getSelectionLabel, handleClear, click_handler, click_handler_1];
    }
    class MultiSelection extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$d, create_fragment$e, safe_not_equal, {
          value: 0,
          activeValue: 1,
          isDisabled: 2,
          multiFullItemClearable: 3,
          getSelectionLabel: 4
        }, add_css$2);
      }
    }

    function add_css$1(target) {
      append_styles(target, "svelte-g2cagw", "svelte-virtual-list-viewport.svelte-g2cagw{position:relative;overflow-y:auto;-webkit-overflow-scrolling:touch;display:block}svelte-virtual-list-contents.svelte-g2cagw,svelte-virtual-list-row.svelte-g2cagw{display:block}svelte-virtual-list-row.svelte-g2cagw{overflow:hidden}");
    }
    function get_each_context$5(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[23] = list[i];
      return child_ctx;
    }
    const get_default_slot_changes = dirty => ({
      item: dirty & /*visible*/32,
      i: dirty & /*visible*/32,
      hoverItemIndex: dirty & /*hoverItemIndex*/2
    });
    const get_default_slot_context = ctx => ({
      item: /*row*/ctx[23].data,
      i: /*row*/ctx[23].index,
      hoverItemIndex: /*hoverItemIndex*/ctx[1]
    });

    // (154:69) Missing template
    function fallback_block(ctx) {
      let t;
      return {
        c() {
          t = text$1("Missing template");
        },
        m(target, anchor) {
          insert(target, t, anchor);
        },
        d(detaching) {
          if (detaching) {
            detach(t);
          }
        }
      };
    }

    // (152:8) {#each visible as row (row.index)}
    function create_each_block$5(key_1, ctx) {
      let svelte_virtual_list_row;
      let t;
      let current;
      const default_slot_template = /*#slots*/ctx[15].default;
      const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[14], get_default_slot_context);
      const default_slot_or_fallback = default_slot || fallback_block();
      return {
        key: key_1,
        first: null,
        c() {
          svelte_virtual_list_row = element("svelte-virtual-list-row");
          if (default_slot_or_fallback) default_slot_or_fallback.c();
          t = space$1();
          set_custom_element_data(svelte_virtual_list_row, "class", "svelte-g2cagw");
          this.first = svelte_virtual_list_row;
        },
        m(target, anchor) {
          insert(target, svelte_virtual_list_row, anchor);
          if (default_slot_or_fallback) {
            default_slot_or_fallback.m(svelte_virtual_list_row, null);
          }
          append(svelte_virtual_list_row, t);
          current = true;
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (default_slot) {
            if (default_slot.p && (!current || dirty & /*$$scope, visible, hoverItemIndex*/16418)) {
              update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[14], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[14]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[14], dirty, get_default_slot_changes), get_default_slot_context);
            }
          }
        },
        i(local) {
          if (current) return;
          transition_in(default_slot_or_fallback, local);
          current = true;
        },
        o(local) {
          transition_out(default_slot_or_fallback, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(svelte_virtual_list_row);
          }
          if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
        }
      };
    }
    function create_fragment$d(ctx) {
      let svelte_virtual_list_viewport;
      let svelte_virtual_list_contents;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let svelte_virtual_list_viewport_resize_listener;
      let current;
      let mounted;
      let dispose;
      let each_value = ensure_array_like( /*visible*/ctx[5]);
      const get_key = ctx => /*row*/ctx[23].index;
      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$5(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
      }
      return {
        c() {
          svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
          svelte_virtual_list_contents = element("svelte-virtual-list-contents");
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          set_style(svelte_virtual_list_contents, "padding-top", /*top*/ctx[6] + "px");
          set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ctx[7] + "px");
          set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-g2cagw");
          set_style(svelte_virtual_list_viewport, "height", /*height*/ctx[0]);
          set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-g2cagw");
          add_render_callback(() => /*svelte_virtual_list_viewport_elementresize_handler*/ctx[18].call(svelte_virtual_list_viewport));
        },
        m(target, anchor) {
          insert(target, svelte_virtual_list_viewport, anchor);
          append(svelte_virtual_list_viewport, svelte_virtual_list_contents);
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(svelte_virtual_list_contents, null);
            }
          }

          /*svelte_virtual_list_contents_binding*/
          ctx[16](svelte_virtual_list_contents);
          /*svelte_virtual_list_viewport_binding*/
          ctx[17](svelte_virtual_list_viewport);
          svelte_virtual_list_viewport_resize_listener = add_iframe_resize_listener(svelte_virtual_list_viewport, /*svelte_virtual_list_viewport_elementresize_handler*/ctx[18].bind(svelte_virtual_list_viewport));
          current = true;
          if (!mounted) {
            dispose = listen(svelte_virtual_list_viewport, "scroll", /*handle_scroll*/ctx[8]);
            mounted = true;
          }
        },
        p(ctx, [dirty]) {
          if (dirty & /*$$scope, visible, hoverItemIndex*/16418) {
            each_value = ensure_array_like( /*visible*/ctx[5]);
            group_outros();
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$5, null, get_each_context$5);
            check_outros();
          }
          if (!current || dirty & /*top*/64) {
            set_style(svelte_virtual_list_contents, "padding-top", /*top*/ctx[6] + "px");
          }
          if (!current || dirty & /*bottom*/128) {
            set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ctx[7] + "px");
          }
          if (!current || dirty & /*height*/1) {
            set_style(svelte_virtual_list_viewport, "height", /*height*/ctx[0]);
          }
        },
        i(local) {
          if (current) return;
          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }
          current = true;
        },
        o(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(svelte_virtual_list_viewport);
          }
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          /*svelte_virtual_list_contents_binding*/
          ctx[16](null);
          /*svelte_virtual_list_viewport_binding*/
          ctx[17](null);
          svelte_virtual_list_viewport_resize_listener();
          mounted = false;
          dispose();
        }
      };
    }
    function instance$c($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      let {
        items = undefined
      } = $$props;
      let {
        height = '100%'
      } = $$props;
      let {
        itemHeight = 40
      } = $$props;
      let {
        hoverItemIndex = 0
      } = $$props;
      let {
        start = 0
      } = $$props;
      let {
        end = 0
      } = $$props;
      let height_map = [];
      let rows;
      let viewport;
      let contents;
      let viewport_height = 0;
      let visible;
      let mounted;
      let top = 0;
      let bottom = 0;
      let average_height;
      async function refresh(items, viewport_height, itemHeight) {
        const {
          scrollTop
        } = viewport;
        await tick();
        let content_height = top - scrollTop;
        let i = start;
        while (content_height < viewport_height && i < items.length) {
          let row = rows[i - start];
          if (!row) {
            $$invalidate(10, end = i + 1);
            await tick();
            row = rows[i - start];
          }
          const row_height = height_map[i] = itemHeight || row.offsetHeight;
          content_height += row_height;
          i += 1;
        }
        $$invalidate(10, end = i);
        const remaining = items.length - end;
        average_height = (top + content_height) / end;
        $$invalidate(7, bottom = remaining * average_height);
        height_map.length = items.length;
        if (viewport) $$invalidate(3, viewport.scrollTop = 0, viewport);
      }
      async function handle_scroll() {
        const {
          scrollTop
        } = viewport;
        const old_start = start;
        for (let v = 0; v < rows.length; v += 1) {
          height_map[start + v] = itemHeight || rows[v].offsetHeight;
        }
        let i = 0;
        let y = 0;
        while (i < items.length) {
          const row_height = height_map[i] || average_height;
          if (y + row_height > scrollTop) {
            $$invalidate(9, start = i);
            $$invalidate(6, top = y);
            break;
          }
          y += row_height;
          i += 1;
        }
        while (i < items.length) {
          y += height_map[i] || average_height;
          i += 1;
          if (y > scrollTop + viewport_height) break;
        }
        $$invalidate(10, end = i);
        const remaining = items.length - end;
        average_height = y / end;
        while (i < items.length) height_map[i++] = average_height;
        $$invalidate(7, bottom = remaining * average_height);
        if (start < old_start) {
          await tick();
          let expected_height = 0;
          let actual_height = 0;
          for (let i = start; i < old_start; i += 1) {
            if (rows[i - start]) {
              expected_height += height_map[i];
              actual_height += itemHeight || rows[i - start].offsetHeight;
            }
          }
          const d = actual_height - expected_height;
          viewport.scrollTo(0, scrollTop + d);
        }
      }
      onMount(() => {
        rows = contents.getElementsByTagName('svelte-virtual-list-row');
        $$invalidate(13, mounted = true);
      });
      function svelte_virtual_list_contents_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          contents = $$value;
          $$invalidate(4, contents);
        });
      }
      function svelte_virtual_list_viewport_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          viewport = $$value;
          $$invalidate(3, viewport);
        });
      }
      function svelte_virtual_list_viewport_elementresize_handler() {
        viewport_height = this.offsetHeight;
        $$invalidate(2, viewport_height);
      }
      $$self.$$set = $$props => {
        if ('items' in $$props) $$invalidate(11, items = $$props.items);
        if ('height' in $$props) $$invalidate(0, height = $$props.height);
        if ('itemHeight' in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
        if ('hoverItemIndex' in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
        if ('start' in $$props) $$invalidate(9, start = $$props.start);
        if ('end' in $$props) $$invalidate(10, end = $$props.end);
        if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty & /*items, start, end*/3584) {
          $$invalidate(5, visible = items.slice(start, end).map((data, i) => {
            return {
              index: i + start,
              data
            };
          }));
        }
        if ($$self.$$.dirty & /*mounted, items, viewport_height, itemHeight*/14340) {
          if (mounted) refresh(items, viewport_height, itemHeight);
        }
      };
      return [height, hoverItemIndex, viewport_height, viewport, contents, visible, top, bottom, handle_scroll, start, end, items, itemHeight, mounted, $$scope, slots, svelte_virtual_list_contents_binding, svelte_virtual_list_viewport_binding, svelte_virtual_list_viewport_elementresize_handler];
    }
    class VirtualList extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$c, create_fragment$d, safe_not_equal, {
          items: 11,
          height: 0,
          itemHeight: 12,
          hoverItemIndex: 1,
          start: 9,
          end: 10
        }, add_css$1);
      }
    }

    function create_fragment$c(ctx) {
      let svg;
      let path;
      return {
        c() {
          svg = svg_element("svg");
          path = svg_element("path");
          attr(path, "fill", "currentColor");
          attr(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
          attr(svg, "width", "100%");
          attr(svg, "height", "100%");
          attr(svg, "viewBox", "-2 -2 50 50");
          attr(svg, "focusable", "false");
          attr(svg, "aria-hidden", "true");
          attr(svg, "role", "presentation");
        },
        m(target, anchor) {
          insert(target, svg, anchor);
          append(svg, path);
        },
        p: noop$1,
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(svg);
          }
        }
      };
    }
    class ClearIcon extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, null, create_fragment$c, safe_not_equal, {});
      }
    }

    function debounce$1(func, wait, immediate) {
      let timeout;
      return function executedFunction() {
        let context = this;
        let args = arguments;
        let later = function () {
          timeout = null;
          func.apply(context, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function add_css(target) {
      append_styles(target, "svelte-17l1npl", ".selectContainer.svelte-17l1npl.svelte-17l1npl{--internalPadding:0 16px;border:var(--border, 1px solid #d8dbdf);border-radius:var(--borderRadius, 3px);box-sizing:border-box;height:var(--height, 42px);position:relative;display:flex;align-items:center;padding:var(--padding, var(--internalPadding));background:var(--background, #fff);margin:var(--margin, 0)}.selectContainer.svelte-17l1npl input.svelte-17l1npl{cursor:default;border:none;color:var(--inputColor, #3f4f5f);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--inputPadding, var(--padding, var(--internalPadding)));width:100%;background:transparent;font-size:var(--inputFontSize, 14px);letter-spacing:var(--inputLetterSpacing, -0.08px);position:absolute;left:var(--inputLeft, 0);margin:var(--inputMargin, 0)}.selectContainer.svelte-17l1npl input.svelte-17l1npl::placeholder{color:var(--placeholderColor, #78848f);opacity:var(--placeholderOpacity, 1)}.selectContainer.svelte-17l1npl input.svelte-17l1npl:focus{outline:none}.selectContainer.svelte-17l1npl.svelte-17l1npl:hover{border-color:var(--borderHoverColor, #b2b8bf)}.selectContainer.focused.svelte-17l1npl.svelte-17l1npl{border-color:var(--borderFocusColor, #006fe8)}.selectContainer.disabled.svelte-17l1npl.svelte-17l1npl{background:var(--disabledBackground, #ebedef);border-color:var(--disabledBorderColor, #ebedef);color:var(--disabledColor, #c1c6cc)}.selectContainer.disabled.svelte-17l1npl input.svelte-17l1npl::placeholder{color:var(--disabledPlaceholderColor, #c1c6cc);opacity:var(--disabledPlaceholderOpacity, 1)}.selectedItem.svelte-17l1npl.svelte-17l1npl{line-height:var(--height, 42px);height:var(--height, 42px);overflow-x:hidden;padding:var(--selectedItemPadding, 0 20px 0 0)}.selectedItem.svelte-17l1npl.svelte-17l1npl:focus{outline:none}.clearSelect.svelte-17l1npl.svelte-17l1npl{position:absolute;right:var(--clearSelectRight, 10px);top:var(--clearSelectTop, 11px);bottom:var(--clearSelectBottom, 11px);width:var(--clearSelectWidth, 20px);color:var(--clearSelectColor, #c5cacf);flex:none !important}.clearSelect.svelte-17l1npl.svelte-17l1npl:hover{color:var(--clearSelectHoverColor, #2c3e50)}.selectContainer.focused.svelte-17l1npl .clearSelect.svelte-17l1npl{color:var(--clearSelectFocusColor, #3f4f5f)}.indicator.svelte-17l1npl.svelte-17l1npl{position:absolute;right:var(--indicatorRight, 10px);top:var(--indicatorTop, 11px);width:var(--indicatorWidth, 20px);height:var(--indicatorHeight, 20px);color:var(--indicatorColor, #c5cacf)}.indicator.svelte-17l1npl svg.svelte-17l1npl{display:inline-block;fill:var(--indicatorFill, currentcolor);line-height:1;stroke:var(--indicatorStroke, currentcolor);stroke-width:0}.spinner.svelte-17l1npl.svelte-17l1npl{position:absolute;right:var(--spinnerRight, 10px);top:var(--spinnerLeft, 11px);width:var(--spinnerWidth, 20px);height:var(--spinnerHeight, 20px);color:var(--spinnerColor, #51ce6c);animation:svelte-17l1npl-rotate 0.75s linear infinite}.spinner_icon.svelte-17l1npl.svelte-17l1npl{display:block;height:100%;transform-origin:center center;width:100%;position:absolute;top:0;bottom:0;left:0;right:0;margin:auto;-webkit-transform:none}.spinner_path.svelte-17l1npl.svelte-17l1npl{stroke-dasharray:90;stroke-linecap:round}.multiSelect.svelte-17l1npl.svelte-17l1npl{display:flex;padding:var(--multiSelectPadding, 0 35px 0 16px);height:auto;flex-wrap:wrap;align-items:stretch}.multiSelect.svelte-17l1npl>.svelte-17l1npl{flex:1 1 50px}.selectContainer.multiSelect.svelte-17l1npl input.svelte-17l1npl{padding:var(--multiSelectInputPadding, 0);position:relative;margin:var(--multiSelectInputMargin, 0)}.hasError.svelte-17l1npl.svelte-17l1npl{border:var(--errorBorder, 1px solid #ff2d55);background:var(--errorBackground, #fff)}.a11yText.svelte-17l1npl.svelte-17l1npl{z-index:9999;border:0px;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0px;white-space:nowrap}@keyframes svelte-17l1npl-rotate{100%{transform:rotate(360deg)}}");
    }
    function get_each_context$4(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[103] = list[i];
      return child_ctx;
    }

    // (876:8) {#if isFocused}
    function create_if_block_10(ctx) {
      let span0;
      let t0;
      let t1;
      let span1;
      let t2;
      return {
        c() {
          span0 = element("span");
          t0 = text$1( /*ariaSelection*/ctx[33]);
          t1 = space$1();
          span1 = element("span");
          t2 = text$1( /*ariaContext*/ctx[32]);
          attr(span0, "id", "aria-selection");
          attr(span1, "id", "aria-context");
        },
        m(target, anchor) {
          insert(target, span0, anchor);
          append(span0, t0);
          insert(target, t1, anchor);
          insert(target, span1, anchor);
          append(span1, t2);
        },
        p(ctx, dirty) {
          if (dirty[1] & /*ariaSelection*/4) set_data(t0, /*ariaSelection*/ctx[33]);
          if (dirty[1] & /*ariaContext*/2) set_data(t2, /*ariaContext*/ctx[32]);
        },
        d(detaching) {
          if (detaching) {
            detach(span0);
            detach(t1);
            detach(span1);
          }
        }
      };
    }

    // (884:4) {#if Icon}
    function create_if_block_9(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      const switch_instance_spread_levels = [/*iconProps*/ctx[18]];
      var switch_value = /*Icon*/ctx[17];
      function switch_props(ctx, dirty) {
        let switch_instance_props = {};
        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i]);
        }
        if (dirty !== undefined && dirty[0] & /*iconProps*/262144) {
          switch_instance_props = assign$1(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object( /*iconProps*/ctx[18])]));
        }
        return {
          props: switch_instance_props
        };
      }
      if (switch_value) {
        switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
      }
      return {
        c() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        m(target, anchor) {
          if (switch_instance) mount_component(switch_instance, target, anchor);
          insert(target, switch_instance_anchor, anchor);
          current = true;
        },
        p(ctx, dirty) {
          if (dirty[0] & /*Icon*/131072 && switch_value !== (switch_value = /*Icon*/ctx[17])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            const switch_instance_changes = dirty[0] & /*iconProps*/262144 ? get_spread_update(switch_instance_spread_levels, [get_spread_object( /*iconProps*/ctx[18])]) : {};
            switch_instance.$set(switch_instance_changes);
          }
        },
        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(switch_instance_anchor);
          }
          if (switch_instance) destroy_component(switch_instance, detaching);
        }
      };
    }

    // (888:4) {#if showMultiSelect}
    function create_if_block_8(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      var switch_value = /*MultiSelection*/ctx[26];
      function switch_props(ctx, dirty) {
        return {
          props: {
            value: /*value*/ctx[2],
            getSelectionLabel: /*getSelectionLabel*/ctx[12],
            activeValue: /*activeValue*/ctx[30],
            isDisabled: /*isDisabled*/ctx[9],
            multiFullItemClearable: /*multiFullItemClearable*/ctx[8]
          }
        };
      }
      if (switch_value) {
        switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
        switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ctx[38]);
        switch_instance.$on("focus", /*handleFocus*/ctx[40]);
      }
      return {
        c() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        m(target, anchor) {
          if (switch_instance) mount_component(switch_instance, target, anchor);
          insert(target, switch_instance_anchor, anchor);
          current = true;
        },
        p(ctx, dirty) {
          if (dirty[0] & /*MultiSelection*/67108864 && switch_value !== (switch_value = /*MultiSelection*/ctx[26])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
              switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ctx[38]);
              switch_instance.$on("focus", /*handleFocus*/ctx[40]);
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            const switch_instance_changes = {};
            if (dirty[0] & /*value*/4) switch_instance_changes.value = /*value*/ctx[2];
            if (dirty[0] & /*getSelectionLabel*/4096) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ctx[12];
            if (dirty[0] & /*activeValue*/1073741824) switch_instance_changes.activeValue = /*activeValue*/ctx[30];
            if (dirty[0] & /*isDisabled*/512) switch_instance_changes.isDisabled = /*isDisabled*/ctx[9];
            if (dirty[0] & /*multiFullItemClearable*/256) switch_instance_changes.multiFullItemClearable = /*multiFullItemClearable*/ctx[8];
            switch_instance.$set(switch_instance_changes);
          }
        },
        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(switch_instance_anchor);
          }
          if (switch_instance) destroy_component(switch_instance, detaching);
        }
      };
    }

    // (910:4) {#if !isMulti && showSelectedItem}
    function create_if_block_7$1(ctx) {
      let div;
      let switch_instance;
      let current;
      let mounted;
      let dispose;
      var switch_value = /*Selection*/ctx[25];
      function switch_props(ctx, dirty) {
        return {
          props: {
            item: /*value*/ctx[2],
            getSelectionLabel: /*getSelectionLabel*/ctx[12]
          }
        };
      }
      if (switch_value) {
        switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
      }
      return {
        c() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr(div, "class", "selectedItem svelte-17l1npl");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          if (switch_instance) mount_component(switch_instance, div, null);
          current = true;
          if (!mounted) {
            dispose = listen(div, "focus", /*handleFocus*/ctx[40]);
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*Selection*/33554432 && switch_value !== (switch_value = /*Selection*/ctx[25])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, null);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            const switch_instance_changes = {};
            if (dirty[0] & /*value*/4) switch_instance_changes.item = /*value*/ctx[2];
            if (dirty[0] & /*getSelectionLabel*/4096) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ctx[12];
            switch_instance.$set(switch_instance_changes);
          }
        },
        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          dispose();
        }
      };
    }

    // (919:4) {#if showClearIcon}
    function create_if_block_6$2(ctx) {
      let div;
      let switch_instance;
      let current;
      let mounted;
      let dispose;
      var switch_value = /*ClearIcon*/ctx[23];
      function switch_props(ctx, dirty) {
        return {};
      }
      if (switch_value) {
        switch_instance = construct_svelte_component(switch_value, switch_props());
      }
      return {
        c() {
          div = element("div");
          if (switch_instance) create_component(switch_instance.$$.fragment);
          attr(div, "class", "clearSelect svelte-17l1npl");
          attr(div, "aria-hidden", "true");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          if (switch_instance) mount_component(switch_instance, div, null);
          current = true;
          if (!mounted) {
            dispose = listen(div, "click", prevent_default( /*handleClear*/ctx[27]));
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*ClearIcon*/8388608 && switch_value !== (switch_value = /*ClearIcon*/ctx[23])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = construct_svelte_component(switch_value, switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, div, null);
            } else {
              switch_instance = null;
            }
          }
        },
        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          if (switch_instance) destroy_component(switch_instance);
          mounted = false;
          dispose();
        }
      };
    }

    // (928:4) {#if !showClearIcon && (showIndicator || (showChevron && !value) || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}
    function create_if_block_4$2(ctx) {
      let div;
      function select_block_type(ctx, dirty) {
        if ( /*indicatorSvg*/ctx[22]) return create_if_block_5$2;
        return create_else_block$3;
      }
      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      return {
        c() {
          div = element("div");
          if_block.c();
          attr(div, "class", "indicator svelte-17l1npl");
          attr(div, "aria-hidden", "true");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          if_block.m(div, null);
        },
        p(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);
            if (if_block) {
              if_block.c();
              if_block.m(div, null);
            }
          }
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          if_block.d();
        }
      };
    }

    // (932:12) {:else}
    function create_else_block$3(ctx) {
      let svg;
      let path;
      return {
        c() {
          svg = svg_element("svg");
          path = svg_element("path");
          attr(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
          attr(svg, "width", "100%");
          attr(svg, "height", "100%");
          attr(svg, "viewBox", "0 0 20 20");
          attr(svg, "focusable", "false");
          attr(svg, "aria-hidden", "true");
          attr(svg, "class", "svelte-17l1npl");
        },
        m(target, anchor) {
          insert(target, svg, anchor);
          append(svg, path);
        },
        p: noop$1,
        d(detaching) {
          if (detaching) {
            detach(svg);
          }
        }
      };
    }

    // (930:12) {#if indicatorSvg}
    function create_if_block_5$2(ctx) {
      let html_tag;
      let html_anchor;
      return {
        c() {
          html_tag = new HtmlTag(false);
          html_anchor = empty();
          html_tag.a = html_anchor;
        },
        m(target, anchor) {
          html_tag.m( /*indicatorSvg*/ctx[22], target, anchor);
          insert(target, html_anchor, anchor);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*indicatorSvg*/4194304) html_tag.p( /*indicatorSvg*/ctx[22]);
        },
        d(detaching) {
          if (detaching) {
            detach(html_anchor);
            html_tag.d();
          }
        }
      };
    }

    // (950:4) {#if isWaiting}
    function create_if_block_3$2(ctx) {
      let div;
      return {
        c() {
          div = element("div");
          div.innerHTML = `<svg class="spinner_icon svelte-17l1npl" viewBox="25 25 50 50"><circle class="spinner_path svelte-17l1npl" cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="5" stroke-miterlimit="10"></circle></svg>`;
          attr(div, "class", "spinner svelte-17l1npl");
        },
        m(target, anchor) {
          insert(target, div, anchor);
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
        }
      };
    }

    // (966:4) {#if listOpen}
    function create_if_block_2$4(ctx) {
      let switch_instance;
      let updating_hoverItemIndex;
      let switch_instance_anchor;
      let current;
      const switch_instance_spread_levels = [/*listProps*/ctx[34]];
      function switch_instance_hoverItemIndex_binding(value) {
        /*switch_instance_hoverItemIndex_binding*/ctx[84](value);
      }
      var switch_value = /*List*/ctx[24];
      function switch_props(ctx, dirty) {
        let switch_instance_props = {};
        for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
          switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i]);
        }
        if (dirty !== undefined && dirty[1] & /*listProps*/8) {
          switch_instance_props = assign$1(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object( /*listProps*/ctx[34])]));
        }
        if ( /*hoverItemIndex*/ctx[28] !== void 0) {
          switch_instance_props.hoverItemIndex = /*hoverItemIndex*/ctx[28];
        }
        return {
          props: switch_instance_props
        };
      }
      if (switch_value) {
        switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
        binding_callbacks.push(() => bind(switch_instance, 'hoverItemIndex', switch_instance_hoverItemIndex_binding));
        switch_instance.$on("itemSelected", /*itemSelected*/ctx[43]);
        switch_instance.$on("itemCreated", /*itemCreated*/ctx[44]);
        switch_instance.$on("closeList", /*closeList*/ctx[45]);
      }
      return {
        c() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        m(target, anchor) {
          if (switch_instance) mount_component(switch_instance, target, anchor);
          insert(target, switch_instance_anchor, anchor);
          current = true;
        },
        p(ctx, dirty) {
          if (dirty[0] & /*List*/16777216 && switch_value !== (switch_value = /*List*/ctx[24])) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }
            if (switch_value) {
              switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
              binding_callbacks.push(() => bind(switch_instance, 'hoverItemIndex', switch_instance_hoverItemIndex_binding));
              switch_instance.$on("itemSelected", /*itemSelected*/ctx[43]);
              switch_instance.$on("itemCreated", /*itemCreated*/ctx[44]);
              switch_instance.$on("closeList", /*closeList*/ctx[45]);
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          } else if (switch_value) {
            const switch_instance_changes = dirty[1] & /*listProps*/8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object( /*listProps*/ctx[34])]) : {};
            if (!updating_hoverItemIndex && dirty[0] & /*hoverItemIndex*/268435456) {
              updating_hoverItemIndex = true;
              switch_instance_changes.hoverItemIndex = /*hoverItemIndex*/ctx[28];
              add_flush_callback(() => updating_hoverItemIndex = false);
            }
            switch_instance.$set(switch_instance_changes);
          }
        },
        i(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(switch_instance_anchor);
          }
          if (switch_instance) destroy_component(switch_instance, detaching);
        }
      };
    }

    // (976:4) {#if !isMulti || (isMulti && !showMultiSelect)}
    function create_if_block_1$4(ctx) {
      let input_1;
      let input_1_name_value;
      let input_1_value_value;
      return {
        c() {
          input_1 = element("input");
          attr(input_1, "name", input_1_name_value = /*inputAttributes*/ctx[16].name);
          attr(input_1, "type", "hidden");
          input_1.value = input_1_value_value = /*value*/ctx[2] ? /*getSelectionLabel*/ctx[12]( /*value*/ctx[2]) : null;
          attr(input_1, "class", "svelte-17l1npl");
        },
        m(target, anchor) {
          insert(target, input_1, anchor);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*inputAttributes*/65536 && input_1_name_value !== (input_1_name_value = /*inputAttributes*/ctx[16].name)) {
            attr(input_1, "name", input_1_name_value);
          }
          if (dirty[0] & /*value, getSelectionLabel*/4100 && input_1_value_value !== (input_1_value_value = /*value*/ctx[2] ? /*getSelectionLabel*/ctx[12]( /*value*/ctx[2]) : null)) {
            input_1.value = input_1_value_value;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(input_1);
          }
        }
      };
    }

    // (983:4) {#if isMulti && showMultiSelect}
    function create_if_block$7(ctx) {
      let each_1_anchor;
      let each_value = ensure_array_like( /*value*/ctx[2]);
      let each_blocks = [];
      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
      }
      return {
        c() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }
          each_1_anchor = empty();
        },
        m(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            if (each_blocks[i]) {
              each_blocks[i].m(target, anchor);
            }
          }
          insert(target, each_1_anchor, anchor);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*inputAttributes, value, getSelectionLabel*/69636) {
            each_value = ensure_array_like( /*value*/ctx[2]);
            let i;
            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$4(ctx, each_value, i);
              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$4(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }
            each_blocks.length = each_value.length;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(each_1_anchor);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }

    // (984:8) {#each value as item}
    function create_each_block$4(ctx) {
      let input_1;
      let input_1_name_value;
      let input_1_value_value;
      return {
        c() {
          input_1 = element("input");
          attr(input_1, "name", input_1_name_value = /*inputAttributes*/ctx[16].name);
          attr(input_1, "type", "hidden");
          input_1.value = input_1_value_value = /*item*/ctx[103] ? /*getSelectionLabel*/ctx[12]( /*item*/ctx[103]) : null;
          attr(input_1, "class", "svelte-17l1npl");
        },
        m(target, anchor) {
          insert(target, input_1, anchor);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*inputAttributes*/65536 && input_1_name_value !== (input_1_name_value = /*inputAttributes*/ctx[16].name)) {
            attr(input_1, "name", input_1_name_value);
          }
          if (dirty[0] & /*value, getSelectionLabel*/4100 && input_1_value_value !== (input_1_value_value = /*item*/ctx[103] ? /*getSelectionLabel*/ctx[12]( /*item*/ctx[103]) : null)) {
            input_1.value = input_1_value_value;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(input_1);
          }
        }
      };
    }
    function create_fragment$b(ctx) {
      let div;
      let span;
      let t0;
      let t1;
      let t2;
      let input_1;
      let input_1_readonly_value;
      let t3;
      let t4;
      let t5;
      let t6;
      let t7;
      let t8;
      let t9;
      let div_class_value;
      let current;
      let mounted;
      let dispose;
      let if_block0 = /*isFocused*/ctx[1] && create_if_block_10(ctx);
      let if_block1 = /*Icon*/ctx[17] && create_if_block_9(ctx);
      let if_block2 = /*showMultiSelect*/ctx[35] && create_if_block_8(ctx);
      let input_1_levels = [{
        readOnly: input_1_readonly_value = ! /*isSearchable*/ctx[13]
      }, /*_inputAttributes*/ctx[31], {
        placeholder: /*placeholderText*/ctx[36]
      }, {
        style: /*inputStyles*/ctx[14]
      }, {
        disabled: /*isDisabled*/ctx[9]
      }];
      let input_data = {};
      for (let i = 0; i < input_1_levels.length; i += 1) {
        input_data = assign$1(input_data, input_1_levels[i]);
      }
      let if_block3 = ! /*isMulti*/ctx[7] && /*showSelectedItem*/ctx[29] && create_if_block_7$1(ctx);
      let if_block4 = /*showClearIcon*/ctx[37] && create_if_block_6$2(ctx);
      let if_block5 = ! /*showClearIcon*/ctx[37] && ( /*showIndicator*/ctx[20] || /*showChevron*/ctx[19] && ! /*value*/ctx[2] || ! /*isSearchable*/ctx[13] && ! /*isDisabled*/ctx[9] && ! /*isWaiting*/ctx[4] && ( /*showSelectedItem*/ctx[29] && ! /*isClearable*/ctx[15] || ! /*showSelectedItem*/ctx[29])) && create_if_block_4$2(ctx);
      let if_block6 = /*isWaiting*/ctx[4] && create_if_block_3$2();
      let if_block7 = /*listOpen*/ctx[5] && create_if_block_2$4(ctx);
      let if_block8 = (! /*isMulti*/ctx[7] || /*isMulti*/ctx[7] && ! /*showMultiSelect*/ctx[35]) && create_if_block_1$4(ctx);
      let if_block9 = /*isMulti*/ctx[7] && /*showMultiSelect*/ctx[35] && create_if_block$7(ctx);
      return {
        c() {
          div = element("div");
          span = element("span");
          if (if_block0) if_block0.c();
          t0 = space$1();
          if (if_block1) if_block1.c();
          t1 = space$1();
          if (if_block2) if_block2.c();
          t2 = space$1();
          input_1 = element("input");
          t3 = space$1();
          if (if_block3) if_block3.c();
          t4 = space$1();
          if (if_block4) if_block4.c();
          t5 = space$1();
          if (if_block5) if_block5.c();
          t6 = space$1();
          if (if_block6) if_block6.c();
          t7 = space$1();
          if (if_block7) if_block7.c();
          t8 = space$1();
          if (if_block8) if_block8.c();
          t9 = space$1();
          if (if_block9) if_block9.c();
          attr(span, "aria-live", "polite");
          attr(span, "aria-atomic", "false");
          attr(span, "aria-relevant", "additions text");
          attr(span, "class", "a11yText svelte-17l1npl");
          set_attributes(input_1, input_data);
          toggle_class(input_1, "svelte-17l1npl", true);
          attr(div, "class", div_class_value = "selectContainer " + /*containerClasses*/ctx[21] + " svelte-17l1npl");
          attr(div, "style", /*containerStyles*/ctx[11]);
          toggle_class(div, "hasError", /*hasError*/ctx[10]);
          toggle_class(div, "multiSelect", /*isMulti*/ctx[7]);
          toggle_class(div, "disabled", /*isDisabled*/ctx[9]);
          toggle_class(div, "focused", /*isFocused*/ctx[1]);
        },
        m(target, anchor) {
          insert(target, div, anchor);
          append(div, span);
          if (if_block0) if_block0.m(span, null);
          append(div, t0);
          if (if_block1) if_block1.m(div, null);
          append(div, t1);
          if (if_block2) if_block2.m(div, null);
          append(div, t2);
          append(div, input_1);
          if (input_1.autofocus) input_1.focus();
          /*input_1_binding*/
          ctx[82](input_1);
          set_input_value(input_1, /*filterText*/ctx[3]);
          append(div, t3);
          if (if_block3) if_block3.m(div, null);
          append(div, t4);
          if (if_block4) if_block4.m(div, null);
          append(div, t5);
          if (if_block5) if_block5.m(div, null);
          append(div, t6);
          if (if_block6) if_block6.m(div, null);
          append(div, t7);
          if (if_block7) if_block7.m(div, null);
          append(div, t8);
          if (if_block8) if_block8.m(div, null);
          append(div, t9);
          if (if_block9) if_block9.m(div, null);
          /*div_binding*/
          ctx[85](div);
          current = true;
          if (!mounted) {
            dispose = [listen(window, "click", /*handleWindowEvent*/ctx[41]), listen(window, "focusin", /*handleWindowEvent*/ctx[41]), listen(window, "keydown", /*handleKeyDown*/ctx[39]), listen(input_1, "focus", /*handleFocus*/ctx[40]), listen(input_1, "input", /*input_1_input_handler*/ctx[83]), listen(div, "click", /*handleClick*/ctx[42])];
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if ( /*isFocused*/ctx[1]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_10(ctx);
              if_block0.c();
              if_block0.m(span, null);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          if ( /*Icon*/ctx[17]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
              if (dirty[0] & /*Icon*/131072) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_9(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, t1);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
          if ( /*showMultiSelect*/ctx[35]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);
              if (dirty[1] & /*showMultiSelect*/16) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_8(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div, t2);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
          set_attributes(input_1, input_data = get_spread_update(input_1_levels, [(!current || dirty[0] & /*isSearchable*/8192 && input_1_readonly_value !== (input_1_readonly_value = ! /*isSearchable*/ctx[13])) && {
            readOnly: input_1_readonly_value
          }, dirty[1] & /*_inputAttributes*/1 && /*_inputAttributes*/ctx[31], (!current || dirty[1] & /*placeholderText*/32) && {
            placeholder: /*placeholderText*/ctx[36]
          }, (!current || dirty[0] & /*inputStyles*/16384) && {
            style: /*inputStyles*/ctx[14]
          }, (!current || dirty[0] & /*isDisabled*/512) && {
            disabled: /*isDisabled*/ctx[9]
          }]));
          if (dirty[0] & /*filterText*/8 && input_1.value !== /*filterText*/ctx[3]) {
            set_input_value(input_1, /*filterText*/ctx[3]);
          }
          toggle_class(input_1, "svelte-17l1npl", true);
          if (! /*isMulti*/ctx[7] && /*showSelectedItem*/ctx[29]) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
              if (dirty[0] & /*isMulti, showSelectedItem*/536871040) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_7$1(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div, t4);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
          if ( /*showClearIcon*/ctx[37]) {
            if (if_block4) {
              if_block4.p(ctx, dirty);
              if (dirty[1] & /*showClearIcon*/64) {
                transition_in(if_block4, 1);
              }
            } else {
              if_block4 = create_if_block_6$2(ctx);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(div, t5);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }
          if (! /*showClearIcon*/ctx[37] && ( /*showIndicator*/ctx[20] || /*showChevron*/ctx[19] && ! /*value*/ctx[2] || ! /*isSearchable*/ctx[13] && ! /*isDisabled*/ctx[9] && ! /*isWaiting*/ctx[4] && ( /*showSelectedItem*/ctx[29] && ! /*isClearable*/ctx[15] || ! /*showSelectedItem*/ctx[29]))) {
            if (if_block5) {
              if_block5.p(ctx, dirty);
            } else {
              if_block5 = create_if_block_4$2(ctx);
              if_block5.c();
              if_block5.m(div, t6);
            }
          } else if (if_block5) {
            if_block5.d(1);
            if_block5 = null;
          }
          if ( /*isWaiting*/ctx[4]) {
            if (if_block6) ; else {
              if_block6 = create_if_block_3$2();
              if_block6.c();
              if_block6.m(div, t7);
            }
          } else if (if_block6) {
            if_block6.d(1);
            if_block6 = null;
          }
          if ( /*listOpen*/ctx[5]) {
            if (if_block7) {
              if_block7.p(ctx, dirty);
              if (dirty[0] & /*listOpen*/32) {
                transition_in(if_block7, 1);
              }
            } else {
              if_block7 = create_if_block_2$4(ctx);
              if_block7.c();
              transition_in(if_block7, 1);
              if_block7.m(div, t8);
            }
          } else if (if_block7) {
            group_outros();
            transition_out(if_block7, 1, 1, () => {
              if_block7 = null;
            });
            check_outros();
          }
          if (! /*isMulti*/ctx[7] || /*isMulti*/ctx[7] && ! /*showMultiSelect*/ctx[35]) {
            if (if_block8) {
              if_block8.p(ctx, dirty);
            } else {
              if_block8 = create_if_block_1$4(ctx);
              if_block8.c();
              if_block8.m(div, t9);
            }
          } else if (if_block8) {
            if_block8.d(1);
            if_block8 = null;
          }
          if ( /*isMulti*/ctx[7] && /*showMultiSelect*/ctx[35]) {
            if (if_block9) {
              if_block9.p(ctx, dirty);
            } else {
              if_block9 = create_if_block$7(ctx);
              if_block9.c();
              if_block9.m(div, null);
            }
          } else if (if_block9) {
            if_block9.d(1);
            if_block9 = null;
          }
          if (!current || dirty[0] & /*containerClasses*/2097152 && div_class_value !== (div_class_value = "selectContainer " + /*containerClasses*/ctx[21] + " svelte-17l1npl")) {
            attr(div, "class", div_class_value);
          }
          if (!current || dirty[0] & /*containerStyles*/2048) {
            attr(div, "style", /*containerStyles*/ctx[11]);
          }
          if (!current || dirty[0] & /*containerClasses, hasError*/2098176) {
            toggle_class(div, "hasError", /*hasError*/ctx[10]);
          }
          if (!current || dirty[0] & /*containerClasses, isMulti*/2097280) {
            toggle_class(div, "multiSelect", /*isMulti*/ctx[7]);
          }
          if (!current || dirty[0] & /*containerClasses, isDisabled*/2097664) {
            toggle_class(div, "disabled", /*isDisabled*/ctx[9]);
          }
          if (!current || dirty[0] & /*containerClasses, isFocused*/2097154) {
            toggle_class(div, "focused", /*isFocused*/ctx[1]);
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(if_block4);
          transition_in(if_block7);
          current = true;
        },
        o(local) {
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(if_block4);
          transition_out(if_block7);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          /*input_1_binding*/
          ctx[82](null);
          if (if_block3) if_block3.d();
          if (if_block4) if_block4.d();
          if (if_block5) if_block5.d();
          if (if_block6) if_block6.d();
          if (if_block7) if_block7.d();
          if (if_block8) if_block8.d();
          if (if_block9) if_block9.d();
          /*div_binding*/
          ctx[85](null);
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function convertStringItemsToObjects(_items) {
      return _items.map((item, index) => {
        return {
          index,
          value: item,
          label: `${item}`
        };
      });
    }
    function instance$b($$self, $$props, $$invalidate) {
      let filteredItems;
      let showSelectedItem;
      let showClearIcon;
      let placeholderText;
      let showMultiSelect;
      let listProps;
      let ariaSelection;
      let ariaContext;
      const dispatch = createEventDispatcher();
      let {
        id = null
      } = $$props;
      let {
        container = undefined
      } = $$props;
      let {
        input = undefined
      } = $$props;
      let {
        isMulti = false
      } = $$props;
      let {
        multiFullItemClearable = false
      } = $$props;
      let {
        isDisabled = false
      } = $$props;
      let {
        isCreatable = false
      } = $$props;
      let {
        isFocused = false
      } = $$props;
      let {
        value = null
      } = $$props;
      let {
        filterText = ''
      } = $$props;
      let {
        placeholder = 'Select...'
      } = $$props;
      let {
        placeholderAlwaysShow = false
      } = $$props;
      let {
        items = null
      } = $$props;
      let {
        itemFilter = (label, filterText, option) => `${label}`.toLowerCase().includes(filterText.toLowerCase())
      } = $$props;
      let {
        groupBy = undefined
      } = $$props;
      let {
        groupFilter = groups => groups
      } = $$props;
      let {
        isGroupHeaderSelectable = false
      } = $$props;
      let {
        getGroupHeaderLabel = option => {
          return option[labelIdentifier] || option.id;
        }
      } = $$props;
      let {
        labelIdentifier = 'label'
      } = $$props;
      let {
        getOptionLabel = (option, filterText) => {
          return option.isCreator ? `Create \"${filterText}\"` : option[labelIdentifier];
        }
      } = $$props;
      let {
        optionIdentifier = 'value'
      } = $$props;
      let {
        loadOptions = undefined
      } = $$props;
      let {
        hasError = false
      } = $$props;
      let {
        containerStyles = ''
      } = $$props;
      let {
        getSelectionLabel = option => {
          if (option) return option[labelIdentifier];else return null;
        }
      } = $$props;
      let {
        createGroupHeaderItem = groupValue => {
          return {
            value: groupValue,
            label: groupValue
          };
        }
      } = $$props;
      let {
        createItem = filterText => {
          return {
            value: filterText,
            label: filterText
          };
        }
      } = $$props;
      const getFilteredItems = () => {
        return filteredItems;
      };
      let {
        isSearchable = true
      } = $$props;
      let {
        inputStyles = ''
      } = $$props;
      let {
        isClearable = true
      } = $$props;
      let {
        isWaiting = false
      } = $$props;
      let {
        listPlacement = 'auto'
      } = $$props;
      let {
        listOpen = false
      } = $$props;
      let {
        isVirtualList = false
      } = $$props;
      let {
        loadOptionsInterval = 300
      } = $$props;
      let {
        noOptionsMessage = 'No options'
      } = $$props;
      let {
        hideEmptyState = false
      } = $$props;
      let {
        inputAttributes = {}
      } = $$props;
      let {
        listAutoWidth = true
      } = $$props;
      let {
        itemHeight = 40
      } = $$props;
      let {
        Icon = undefined
      } = $$props;
      let {
        iconProps = {}
      } = $$props;
      let {
        showChevron = false
      } = $$props;
      let {
        showIndicator = false
      } = $$props;
      let {
        containerClasses = ''
      } = $$props;
      let {
        indicatorSvg = undefined
      } = $$props;
      let {
        listOffset = 5
      } = $$props;
      let {
        ClearIcon: ClearIcon$1 = ClearIcon
      } = $$props;
      let {
        Item: Item$1 = Item
      } = $$props;
      let {
        List: List$1 = List
      } = $$props;
      let {
        Selection: Selection$1 = Selection
      } = $$props;
      let {
        MultiSelection: MultiSelection$1 = MultiSelection
      } = $$props;
      let {
        VirtualList: VirtualList$1 = VirtualList
      } = $$props;
      function filterMethod(args) {
        if (args.loadOptions && args.filterText.length > 0) return;
        if (!args.items) return [];
        if (args.items && args.items.length > 0 && typeof args.items[0] !== 'object') {
          args.items = convertStringItemsToObjects(args.items);
        }
        let filterResults = args.items.filter(item => {
          let matchesFilter = itemFilter(getOptionLabel(item, args.filterText), args.filterText, item);
          if (matchesFilter && args.isMulti && args.value && Array.isArray(args.value)) {
            matchesFilter = !args.value.some(x => {
              return x[args.optionIdentifier] === item[args.optionIdentifier];
            });
          }
          return matchesFilter;
        });
        if (args.groupBy) {
          filterResults = filterGroupedItems(filterResults);
        }
        if (args.isCreatable) {
          filterResults = addCreatableItem(filterResults, args.filterText);
        }
        return filterResults;
      }
      function addCreatableItem(_items, _filterText) {
        if (_filterText.length === 0) return _items;
        const itemToCreate = createItem(_filterText);
        if (_items[0] && _filterText === _items[0][labelIdentifier]) return _items;
        itemToCreate.isCreator = true;
        return [..._items, itemToCreate];
      }
      let {
        selectedValue = null
      } = $$props;
      let activeValue;
      let prev_value;
      let prev_filterText;
      let prev_isFocused;
      let prev_isMulti;
      let hoverItemIndex;
      const getItems = debounce$1(async () => {
        $$invalidate(4, isWaiting = true);
        let res = await loadOptions(filterText).catch(err => {
          console.warn('svelte-select loadOptions error :>> ', err);
          dispatch('error', {
            type: 'loadOptions',
            details: err
          });
        });
        if (res && !res.cancelled) {
          if (res) {
            if (res && res.length > 0 && typeof res[0] !== 'object') {
              res = convertStringItemsToObjects(res);
            }
            $$invalidate(81, filteredItems = [...res]);
            dispatch('loaded', {
              items: filteredItems
            });
          } else {
            $$invalidate(81, filteredItems = []);
          }
          if (isCreatable) {
            $$invalidate(81, filteredItems = addCreatableItem(filteredItems, filterText));
          }
          $$invalidate(4, isWaiting = false);
          $$invalidate(1, isFocused = true);
          $$invalidate(5, listOpen = true);
        }
      }, loadOptionsInterval);
      function setValue() {
        if (typeof value === 'string') {
          $$invalidate(2, value = {
            [optionIdentifier]: value,
            label: value
          });
        } else if (isMulti && Array.isArray(value) && value.length > 0) {
          $$invalidate(2, value = value.map(item => typeof item === 'string' ? {
            value: item,
            label: item
          } : item));
        }
      }
      let _inputAttributes;
      function assignInputAttributes() {
        $$invalidate(31, _inputAttributes = Object.assign({
          autocapitalize: 'none',
          autocomplete: 'off',
          autocorrect: 'off',
          spellcheck: false,
          tabindex: 0,
          type: 'text',
          'aria-autocomplete': 'list'
        }, inputAttributes));
        if (id) {
          $$invalidate(31, _inputAttributes.id = id, _inputAttributes);
        }
        if (!isSearchable) {
          $$invalidate(31, _inputAttributes.readonly = true, _inputAttributes);
        }
      }
      function filterGroupedItems(_items) {
        const groupValues = [];
        const groups = {};
        _items.forEach(item => {
          const groupValue = groupBy(item);
          if (!groupValues.includes(groupValue)) {
            groupValues.push(groupValue);
            groups[groupValue] = [];
            if (groupValue) {
              groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
                id: groupValue,
                isGroupHeader: true,
                isSelectable: isGroupHeaderSelectable
              }));
            }
          }
          groups[groupValue].push(Object.assign({
            isGroupItem: !!groupValue
          }, item));
        });
        const sortedGroupedItems = [];
        groupFilter(groupValues).forEach(groupValue => {
          sortedGroupedItems.push(...groups[groupValue]);
        });
        return sortedGroupedItems;
      }
      function dispatchSelectedItem() {
        if (isMulti) {
          if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
            if (checkValueForDuplicates()) {
              dispatch('select', value);
            }
          }
          return;
        }
        if (!prev_value || JSON.stringify(value[optionIdentifier]) !== JSON.stringify(prev_value[optionIdentifier])) {
          dispatch('select', value);
        }
      }
      function setupFocus() {
        if (isFocused || listOpen) {
          handleFocus();
        } else {
          if (input) input.blur();
        }
      }
      function setupMulti() {
        if (value) {
          if (Array.isArray(value)) {
            $$invalidate(2, value = [...value]);
          } else {
            $$invalidate(2, value = [value]);
          }
        }
      }
      function setupSingle() {
        if (value) $$invalidate(2, value = null);
      }
      function setupFilterText() {
        if (filterText.length === 0) return;
        $$invalidate(1, isFocused = true);
        $$invalidate(5, listOpen = true);
        if (loadOptions) {
          getItems();
        } else {
          $$invalidate(5, listOpen = true);
          if (isMulti) {
            $$invalidate(30, activeValue = undefined);
          }
        }
      }
      beforeUpdate(async () => {
        $$invalidate(77, prev_value = value);
        $$invalidate(78, prev_filterText = filterText);
        $$invalidate(79, prev_isFocused = isFocused);
        $$invalidate(80, prev_isMulti = isMulti);
      });
      function checkValueForDuplicates() {
        let noDuplicates = true;
        if (value) {
          const ids = [];
          const uniqueValues = [];
          value.forEach(val => {
            if (!ids.includes(val[optionIdentifier])) {
              ids.push(val[optionIdentifier]);
              uniqueValues.push(val);
            } else {
              noDuplicates = false;
            }
          });
          if (!noDuplicates) $$invalidate(2, value = uniqueValues);
        }
        return noDuplicates;
      }
      function findItem(selection) {
        let matchTo = selection ? selection[optionIdentifier] : value[optionIdentifier];
        return items.find(item => item[optionIdentifier] === matchTo);
      }
      function updateValueDisplay(items) {
        if (!items || items.length === 0 || items.some(item => typeof item !== 'object')) return;
        if (!value || (isMulti ? value.some(selection => !selection || !selection[optionIdentifier]) : !value[optionIdentifier])) return;
        if (Array.isArray(value)) {
          $$invalidate(2, value = value.map(selection => findItem(selection) || selection));
        } else {
          $$invalidate(2, value = findItem() || value);
        }
      }
      function handleMultiItemClear(event) {
        const {
          detail
        } = event;
        const itemToRemove = value[detail ? detail.i : value.length - 1];
        if (value.length === 1) {
          $$invalidate(2, value = undefined);
        } else {
          $$invalidate(2, value = value.filter(item => {
            return item !== itemToRemove;
          }));
        }
        dispatch('clear', itemToRemove);
      }
      function handleKeyDown(e) {
        if (!isFocused) return;
        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            $$invalidate(5, listOpen = true);
            $$invalidate(30, activeValue = undefined);
            break;
          case 'ArrowUp':
            e.preventDefault();
            $$invalidate(5, listOpen = true);
            $$invalidate(30, activeValue = undefined);
            break;
          case 'Tab':
            if (!listOpen) $$invalidate(1, isFocused = false);
            break;
          case 'Backspace':
            if (!isMulti || filterText.length > 0) return;
            if (isMulti && value && value.length > 0) {
              handleMultiItemClear(activeValue !== undefined ? activeValue : value.length - 1);
              if (activeValue === 0 || activeValue === undefined) break;
              $$invalidate(30, activeValue = value.length > activeValue ? activeValue - 1 : undefined);
            }
            break;
          case 'ArrowLeft':
            if (!isMulti || filterText.length > 0) return;
            if (activeValue === undefined) {
              $$invalidate(30, activeValue = value.length - 1);
            } else if (value.length > activeValue && activeValue !== 0) {
              $$invalidate(30, activeValue -= 1);
            }
            break;
          case 'ArrowRight':
            if (!isMulti || filterText.length > 0 || activeValue === undefined) return;
            if (activeValue === value.length - 1) {
              $$invalidate(30, activeValue = undefined);
            } else if (activeValue < value.length - 1) {
              $$invalidate(30, activeValue += 1);
            }
            break;
        }
      }
      function handleFocus() {
        $$invalidate(1, isFocused = true);
        if (input) input.focus();
      }
      function handleWindowEvent(event) {
        if (!container) return;
        const eventTarget = event.path && event.path.length > 0 ? event.path[0] : event.target;
        if (container.contains(eventTarget) || container.contains(event.relatedTarget)) {
          return;
        }
        $$invalidate(1, isFocused = false);
        $$invalidate(5, listOpen = false);
        $$invalidate(30, activeValue = undefined);
        if (input) input.blur();
      }
      function handleClick() {
        if (isDisabled) return;
        $$invalidate(1, isFocused = true);
        $$invalidate(5, listOpen = !listOpen);
      }
      function handleClear() {
        $$invalidate(2, value = undefined);
        $$invalidate(5, listOpen = false);
        dispatch('clear', value);
        handleFocus();
      }
      onMount(() => {
        if (isFocused && input) input.focus();
      });
      function itemSelected(event) {
        const {
          detail
        } = event;
        if (detail) {
          $$invalidate(3, filterText = '');
          const item = Object.assign({}, detail);
          if (!item.isGroupHeader || item.isSelectable) {
            if (isMulti) {
              $$invalidate(2, value = value ? value.concat([item]) : [item]);
            } else {
              $$invalidate(2, value = item);
            }
            $$invalidate(2, value);
            setTimeout(() => {
              $$invalidate(5, listOpen = false);
              $$invalidate(30, activeValue = undefined);
            });
          }
        }
      }
      function itemCreated(event) {
        const {
          detail
        } = event;
        if (isMulti) {
          $$invalidate(2, value = value || []);
          $$invalidate(2, value = [...value, createItem(detail)]);
        } else {
          $$invalidate(2, value = createItem(detail));
        }
        dispatch('itemCreated', detail);
        $$invalidate(3, filterText = '');
        $$invalidate(5, listOpen = false);
        $$invalidate(30, activeValue = undefined);
      }
      function closeList() {
        $$invalidate(3, filterText = '');
        $$invalidate(5, listOpen = false);
      }
      let {
        ariaValues = values => {
          return `Option ${values}, selected.`;
        }
      } = $$props;
      let {
        ariaListOpen = (label, count) => {
          return `You are currently focused on option ${label}. There are ${count} results available.`;
        }
      } = $$props;
      let {
        ariaFocused = () => {
          return `Select is focused, type to refine list, press down to open the menu.`;
        }
      } = $$props;
      function handleAriaSelection() {
        let selected = undefined;
        if (isMulti && value.length > 0) {
          selected = value.map(v => getSelectionLabel(v)).join(', ');
        } else {
          selected = getSelectionLabel(value);
        }
        return ariaValues(selected);
      }
      function handleAriaContent() {
        if (!isFocused || !filteredItems || filteredItems.length === 0) return '';
        let _item = filteredItems[hoverItemIndex];
        if (listOpen && _item) {
          let label = getSelectionLabel(_item);
          let count = filteredItems ? filteredItems.length : 0;
          return ariaListOpen(label, count);
        } else {
          return ariaFocused();
        }
      }
      function input_1_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          input = $$value;
          $$invalidate(6, input);
        });
      }
      function input_1_input_handler() {
        filterText = this.value;
        $$invalidate(3, filterText);
      }
      function switch_instance_hoverItemIndex_binding(value) {
        hoverItemIndex = value;
        $$invalidate(28, hoverItemIndex);
      }
      function div_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
          container = $$value;
          $$invalidate(0, container);
        });
      }
      $$self.$$set = $$props => {
        if ('id' in $$props) $$invalidate(46, id = $$props.id);
        if ('container' in $$props) $$invalidate(0, container = $$props.container);
        if ('input' in $$props) $$invalidate(6, input = $$props.input);
        if ('isMulti' in $$props) $$invalidate(7, isMulti = $$props.isMulti);
        if ('multiFullItemClearable' in $$props) $$invalidate(8, multiFullItemClearable = $$props.multiFullItemClearable);
        if ('isDisabled' in $$props) $$invalidate(9, isDisabled = $$props.isDisabled);
        if ('isCreatable' in $$props) $$invalidate(47, isCreatable = $$props.isCreatable);
        if ('isFocused' in $$props) $$invalidate(1, isFocused = $$props.isFocused);
        if ('value' in $$props) $$invalidate(2, value = $$props.value);
        if ('filterText' in $$props) $$invalidate(3, filterText = $$props.filterText);
        if ('placeholder' in $$props) $$invalidate(48, placeholder = $$props.placeholder);
        if ('placeholderAlwaysShow' in $$props) $$invalidate(49, placeholderAlwaysShow = $$props.placeholderAlwaysShow);
        if ('items' in $$props) $$invalidate(50, items = $$props.items);
        if ('itemFilter' in $$props) $$invalidate(51, itemFilter = $$props.itemFilter);
        if ('groupBy' in $$props) $$invalidate(52, groupBy = $$props.groupBy);
        if ('groupFilter' in $$props) $$invalidate(53, groupFilter = $$props.groupFilter);
        if ('isGroupHeaderSelectable' in $$props) $$invalidate(54, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
        if ('getGroupHeaderLabel' in $$props) $$invalidate(55, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
        if ('labelIdentifier' in $$props) $$invalidate(56, labelIdentifier = $$props.labelIdentifier);
        if ('getOptionLabel' in $$props) $$invalidate(57, getOptionLabel = $$props.getOptionLabel);
        if ('optionIdentifier' in $$props) $$invalidate(58, optionIdentifier = $$props.optionIdentifier);
        if ('loadOptions' in $$props) $$invalidate(59, loadOptions = $$props.loadOptions);
        if ('hasError' in $$props) $$invalidate(10, hasError = $$props.hasError);
        if ('containerStyles' in $$props) $$invalidate(11, containerStyles = $$props.containerStyles);
        if ('getSelectionLabel' in $$props) $$invalidate(12, getSelectionLabel = $$props.getSelectionLabel);
        if ('createGroupHeaderItem' in $$props) $$invalidate(60, createGroupHeaderItem = $$props.createGroupHeaderItem);
        if ('createItem' in $$props) $$invalidate(61, createItem = $$props.createItem);
        if ('isSearchable' in $$props) $$invalidate(13, isSearchable = $$props.isSearchable);
        if ('inputStyles' in $$props) $$invalidate(14, inputStyles = $$props.inputStyles);
        if ('isClearable' in $$props) $$invalidate(15, isClearable = $$props.isClearable);
        if ('isWaiting' in $$props) $$invalidate(4, isWaiting = $$props.isWaiting);
        if ('listPlacement' in $$props) $$invalidate(63, listPlacement = $$props.listPlacement);
        if ('listOpen' in $$props) $$invalidate(5, listOpen = $$props.listOpen);
        if ('isVirtualList' in $$props) $$invalidate(64, isVirtualList = $$props.isVirtualList);
        if ('loadOptionsInterval' in $$props) $$invalidate(65, loadOptionsInterval = $$props.loadOptionsInterval);
        if ('noOptionsMessage' in $$props) $$invalidate(66, noOptionsMessage = $$props.noOptionsMessage);
        if ('hideEmptyState' in $$props) $$invalidate(67, hideEmptyState = $$props.hideEmptyState);
        if ('inputAttributes' in $$props) $$invalidate(16, inputAttributes = $$props.inputAttributes);
        if ('listAutoWidth' in $$props) $$invalidate(68, listAutoWidth = $$props.listAutoWidth);
        if ('itemHeight' in $$props) $$invalidate(69, itemHeight = $$props.itemHeight);
        if ('Icon' in $$props) $$invalidate(17, Icon = $$props.Icon);
        if ('iconProps' in $$props) $$invalidate(18, iconProps = $$props.iconProps);
        if ('showChevron' in $$props) $$invalidate(19, showChevron = $$props.showChevron);
        if ('showIndicator' in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
        if ('containerClasses' in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
        if ('indicatorSvg' in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
        if ('listOffset' in $$props) $$invalidate(70, listOffset = $$props.listOffset);
        if ('ClearIcon' in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
        if ('Item' in $$props) $$invalidate(71, Item$1 = $$props.Item);
        if ('List' in $$props) $$invalidate(24, List$1 = $$props.List);
        if ('Selection' in $$props) $$invalidate(25, Selection$1 = $$props.Selection);
        if ('MultiSelection' in $$props) $$invalidate(26, MultiSelection$1 = $$props.MultiSelection);
        if ('VirtualList' in $$props) $$invalidate(72, VirtualList$1 = $$props.VirtualList);
        if ('selectedValue' in $$props) $$invalidate(73, selectedValue = $$props.selectedValue);
        if ('ariaValues' in $$props) $$invalidate(74, ariaValues = $$props.ariaValues);
        if ('ariaListOpen' in $$props) $$invalidate(75, ariaListOpen = $$props.ariaListOpen);
        if ('ariaFocused' in $$props) $$invalidate(76, ariaFocused = $$props.ariaFocused);
      };
      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] & /*filterText, value, isMulti*/140 | $$self.$$.dirty[1] & /*loadOptions, items, optionIdentifier, groupBy, isCreatable*/405340160) {
          $$invalidate(81, filteredItems = filterMethod({
            loadOptions,
            filterText,
            items,
            value,
            isMulti,
            optionIdentifier,
            groupBy,
            isCreatable
          }));
        }
        if ($$self.$$.dirty[2] & /*selectedValue*/2048) {
          {
            if (selectedValue) console.warn('selectedValue is no longer used. Please use value instead.');
          }
        }
        if ($$self.$$.dirty[1] & /*items*/524288) {
          updateValueDisplay(items);
        }
        if ($$self.$$.dirty[0] & /*value*/4) {
          {
            if (value) setValue();
          }
        }
        if ($$self.$$.dirty[0] & /*inputAttributes, isSearchable*/73728) {
          {
            if (inputAttributes || !isSearchable) assignInputAttributes();
          }
        }
        if ($$self.$$.dirty[0] & /*isMulti*/128 | $$self.$$.dirty[2] & /*prev_isMulti*/262144) {
          {
            if (isMulti) {
              setupMulti();
            }
            if (prev_isMulti && !isMulti) {
              setupSingle();
            }
          }
        }
        if ($$self.$$.dirty[0] & /*isMulti, value*/132) {
          {
            if (isMulti && value && value.length > 1) {
              checkValueForDuplicates();
            }
          }
        }
        if ($$self.$$.dirty[0] & /*value*/4) {
          {
            if (value) dispatchSelectedItem();
          }
        }
        if ($$self.$$.dirty[0] & /*value, isMulti*/132 | $$self.$$.dirty[2] & /*prev_value*/32768) {
          {
            if (!value && isMulti && prev_value) {
              dispatch('select', value);
            }
          }
        }
        if ($$self.$$.dirty[0] & /*isFocused*/2 | $$self.$$.dirty[2] & /*prev_isFocused*/131072) {
          {
            if (isFocused !== prev_isFocused) {
              setupFocus();
            }
          }
        }
        if ($$self.$$.dirty[0] & /*filterText*/8 | $$self.$$.dirty[2] & /*prev_filterText*/65536) {
          {
            if (filterText !== prev_filterText) {
              setupFilterText();
            }
          }
        }
        if ($$self.$$.dirty[0] & /*value, filterText*/12) {
          $$invalidate(29, showSelectedItem = value && filterText.length === 0);
        }
        if ($$self.$$.dirty[0] & /*showSelectedItem, isClearable, isDisabled, isWaiting*/536904208) {
          $$invalidate(37, showClearIcon = showSelectedItem && isClearable && !isDisabled && !isWaiting);
        }
        if ($$self.$$.dirty[0] & /*isMulti, value*/132 | $$self.$$.dirty[1] & /*placeholderAlwaysShow, placeholder*/393216) {
          $$invalidate(36, placeholderText = placeholderAlwaysShow && isMulti ? placeholder : value ? '' : placeholder);
        }
        if ($$self.$$.dirty[0] & /*isMulti, value*/132) {
          $$invalidate(35, showMultiSelect = isMulti && value && value.length > 0);
        }
        if ($$self.$$.dirty[0] & /*filterText, value, isMulti, container*/141 | $$self.$$.dirty[1] & /*optionIdentifier, getGroupHeaderLabel, getOptionLabel*/218103808 | $$self.$$.dirty[2] & /*Item, noOptionsMessage, hideEmptyState, isVirtualList, VirtualList, filteredItems, itemHeight, listPlacement, listAutoWidth, listOffset*/526326) {
          $$invalidate(34, listProps = {
            Item: Item$1,
            filterText,
            optionIdentifier,
            noOptionsMessage,
            hideEmptyState,
            isVirtualList,
            VirtualList: VirtualList$1,
            value,
            isMulti,
            getGroupHeaderLabel,
            items: filteredItems,
            itemHeight,
            getOptionLabel,
            listPlacement,
            parent: container,
            listAutoWidth,
            listOffset
          });
        }
        if ($$self.$$.dirty[0] & /*value, isMulti*/132) {
          $$invalidate(33, ariaSelection = value ? handleAriaSelection() : '');
        }
        if ($$self.$$.dirty[0] & /*hoverItemIndex, isFocused, listOpen*/268435490 | $$self.$$.dirty[2] & /*filteredItems*/524288) {
          $$invalidate(32, ariaContext = handleAriaContent());
        }
      };
      return [container, isFocused, value, filterText, isWaiting, listOpen, input, isMulti, multiFullItemClearable, isDisabled, hasError, containerStyles, getSelectionLabel, isSearchable, inputStyles, isClearable, inputAttributes, Icon, iconProps, showChevron, showIndicator, containerClasses, indicatorSvg, ClearIcon$1, List$1, Selection$1, MultiSelection$1, handleClear, hoverItemIndex, showSelectedItem, activeValue, _inputAttributes, ariaContext, ariaSelection, listProps, showMultiSelect, placeholderText, showClearIcon, handleMultiItemClear, handleKeyDown, handleFocus, handleWindowEvent, handleClick, itemSelected, itemCreated, closeList, id, isCreatable, placeholder, placeholderAlwaysShow, items, itemFilter, groupBy, groupFilter, isGroupHeaderSelectable, getGroupHeaderLabel, labelIdentifier, getOptionLabel, optionIdentifier, loadOptions, createGroupHeaderItem, createItem, getFilteredItems, listPlacement, isVirtualList, loadOptionsInterval, noOptionsMessage, hideEmptyState, listAutoWidth, itemHeight, listOffset, Item$1, VirtualList$1, selectedValue, ariaValues, ariaListOpen, ariaFocused, prev_value, prev_filterText, prev_isFocused, prev_isMulti, filteredItems, input_1_binding, input_1_input_handler, switch_instance_hoverItemIndex_binding, div_binding];
    }
    class Select extends SvelteComponent {
      constructor(options) {
        super();
        init$2(this, options, instance$b, create_fragment$b, safe_not_equal, {
          id: 46,
          container: 0,
          input: 6,
          isMulti: 7,
          multiFullItemClearable: 8,
          isDisabled: 9,
          isCreatable: 47,
          isFocused: 1,
          value: 2,
          filterText: 3,
          placeholder: 48,
          placeholderAlwaysShow: 49,
          items: 50,
          itemFilter: 51,
          groupBy: 52,
          groupFilter: 53,
          isGroupHeaderSelectable: 54,
          getGroupHeaderLabel: 55,
          labelIdentifier: 56,
          getOptionLabel: 57,
          optionIdentifier: 58,
          loadOptions: 59,
          hasError: 10,
          containerStyles: 11,
          getSelectionLabel: 12,
          createGroupHeaderItem: 60,
          createItem: 61,
          getFilteredItems: 62,
          isSearchable: 13,
          inputStyles: 14,
          isClearable: 15,
          isWaiting: 4,
          listPlacement: 63,
          listOpen: 5,
          isVirtualList: 64,
          loadOptionsInterval: 65,
          noOptionsMessage: 66,
          hideEmptyState: 67,
          inputAttributes: 16,
          listAutoWidth: 68,
          itemHeight: 69,
          Icon: 17,
          iconProps: 18,
          showChevron: 19,
          showIndicator: 20,
          containerClasses: 21,
          indicatorSvg: 22,
          listOffset: 70,
          ClearIcon: 23,
          Item: 71,
          List: 24,
          Selection: 25,
          MultiSelection: 26,
          VirtualList: 72,
          selectedValue: 73,
          handleClear: 27,
          ariaValues: 74,
          ariaListOpen: 75,
          ariaFocused: 76
        }, add_css, [-1, -1, -1, -1]);
      }
      get getFilteredItems() {
        return this.$$.ctx[62];
      }
      get handleClear() {
        return this.$$.ctx[27];
      }
    }

    var dist = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.generateUrl = exports.generateRemoteUrl = exports.generateOcsUrl = exports.generateFilePath = void 0;
    exports.getAppRootUrl = getAppRootUrl;
    exports.getRootUrl = getRootUrl;
    exports.linkTo = exports.imagePath = void 0;

    /**
     * Get an url with webroot to a file in an app
     *
     * @param {string} app the id of the app the file belongs to
     * @param {string} file the file path relative to the app folder
     * @return {string} URL with webroot to a file
     */
    const linkTo = (app, file) => generateFilePath(app, '', file);

    /**
     * Creates a relative url for remote use
     *
     * @param {string} service id
     * @return {string} the url
     */
    exports.linkTo = linkTo;
    const linkToRemoteBase = service => getRootUrl() + '/remote.php/' + service;

    /**
     * @brief Creates an absolute url for remote use
     * @param {string} service id
     * @return {string} the url
     */
    const generateRemoteUrl = service => window.location.protocol + '//' + window.location.host + linkToRemoteBase(service);

    /**
     * Get the base path for the given OCS API service
     *
     * @param {string} url OCS API service url
     * @param {object} params parameters to be replaced into the service url
     * @param {UrlOptions} options options for the parameter replacement
     * @param {boolean} options.escape Set to false if parameters should not be URL encoded (default true)
     * @param {Number} options.ocsVersion OCS version to use (defaults to 2)
     * @return {string} Absolute path for the OCS URL
     */
    exports.generateRemoteUrl = generateRemoteUrl;
    const generateOcsUrl = (url, params, options) => {
      const allOptions = Object.assign({
        ocsVersion: 2
      }, options || {});
      const version = allOptions.ocsVersion === 1 ? 1 : 2;
      return window.location.protocol + '//' + window.location.host + getRootUrl() + '/ocs/v' + version + '.php' + _generateUrlPath(url, params, options);
    };
    exports.generateOcsUrl = generateOcsUrl;
    /**
     * Generate a url path, which can contain parameters
     *
     * Parameters will be URL encoded automatically
     *
     * @param {string} url address (can contain placeholders e.g. /call/{token} would replace {token} with the value of params.token
     * @param {object} params parameters to be replaced into the address
     * @param {UrlOptions} options options for the parameter replacement
     * @return {string} Path part for the given URL
     */
    const _generateUrlPath = (url, params, options) => {
      const allOptions = Object.assign({
        escape: true
      }, options || {});
      const _build = function (text, vars) {
        vars = vars || {};
        return text.replace(/{([^{}]*)}/g, function (a, b) {
          var r = vars[b];
          if (allOptions.escape) {
            return typeof r === 'string' || typeof r === 'number' ? encodeURIComponent(r.toString()) : encodeURIComponent(a);
          } else {
            return typeof r === 'string' || typeof r === 'number' ? r.toString() : a;
          }
        });
      };
      if (url.charAt(0) !== '/') {
        url = '/' + url;
      }
      return _build(url, params || {});
    };

    /**
     * Generate the url with webroot for the given relative url, which can contain parameters
     *
     * Parameters will be URL encoded automatically
     *
     * @param {string} url address (can contain placeholders e.g. /call/{token} would replace {token} with the value of params.token
     * @param {object} params parameters to be replaced into the url
     * @param {UrlOptions} options options for the parameter replacement
     * @param {boolean} options.noRewrite True if you want to force index.php being added
     * @param {boolean} options.escape Set to false if parameters should not be URL encoded (default true)
     * @return {string} URL with webroot for the given relative URL
     */
    const generateUrl = (url, params, options) => {
      var _window;
      const allOptions = Object.assign({
        noRewrite: false
      }, options || {});
      if (((_window = window) === null || _window === void 0 || (_window = _window.OC) === null || _window === void 0 || (_window = _window.config) === null || _window === void 0 ? void 0 : _window.modRewriteWorking) === true && !allOptions.noRewrite) {
        return getRootUrl() + _generateUrlPath(url, params, options);
      }
      return getRootUrl() + '/index.php' + _generateUrlPath(url, params, options);
    };

    /**
     * Get the path with webroot to an image file
     * if no extension is given for the image, it will automatically decide
     * between .png and .svg based on what the browser supports
     *
     * @param {string} app the app id to which the image belongs
     * @param {string} file the name of the image file
     * @return {string}
     */
    exports.generateUrl = generateUrl;
    const imagePath = (app, file) => {
      if (file.indexOf('.') === -1) {
        //if no extension is given, use svg
        return generateFilePath(app, 'img', file + '.svg');
      }
      return generateFilePath(app, 'img', file);
    };

    /**
     * Get the url with webroot for a file in an app
     *
     * @param {string} app the id of the app
     * @param {string} type the type of the file to link to (e.g. css,img,ajax.template)
     * @param {string} file the filename
     * @return {string} URL with webroot for a file in an app
     */
    exports.imagePath = imagePath;
    const generateFilePath = (app, type, file) => {
      var _window2;
      const isCore = ((_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.OC) === null || _window2 === void 0 || (_window2 = _window2.coreApps) === null || _window2 === void 0 ? void 0 : _window2.indexOf(app)) !== -1;
      let link = getRootUrl();
      if (file.substring(file.length - 3) === 'php' && !isCore) {
        link += '/index.php/apps/' + app;
        if (file !== 'index.php') {
          link += '/';
          if (type) {
            link += encodeURI(type + '/');
          }
          link += file;
        }
      } else if (file.substring(file.length - 3) !== 'php' && !isCore) {
        link = getAppRootUrl(app);
        if (type) {
          link += '/' + type + '/';
        }
        if (link.substring(link.length - 1) !== '/') {
          link += '/';
        }
        link += file;
      } else {
        if ((app === 'settings' || app === 'core' || app === 'search') && type === 'ajax') {
          link += '/index.php/';
        } else {
          link += '/';
        }
        if (!isCore) {
          link += 'apps/';
        }
        if (app !== '') {
          app += '/';
          link += app;
        }
        if (type) {
          link += type + '/';
        }
        link += file;
      }
      return link;
    };

    /**
     * Return the web root path where this Nextcloud instance
     * is accessible, with a leading slash.
     * For example "/nextcloud".
     *
     * @return {string} web root path
     */
    exports.generateFilePath = generateFilePath;
    function getRootUrl() {
      let webroot = window._oc_webroot;
      if (typeof webroot === 'undefined') {
        webroot = location.pathname;
        const pos = webroot.indexOf('/index.php/');
        if (pos !== -1) {
          webroot = webroot.substr(0, pos);
        } else {
          webroot = webroot.substr(0, webroot.lastIndexOf('/'));
        }
      }
      return webroot;
    }

    /**
     * Return the web root path for a given app
     * @param {string} app The ID of the app
     */
    function getAppRootUrl(app) {
      var _window$_oc_appswebro, _webroots$app;
      const webroots = (_window$_oc_appswebro = window._oc_appswebroots) !== null && _window$_oc_appswebro !== void 0 ? _window$_oc_appswebro : {};
      return (_webroots$app = webroots[app]) !== null && _webroots$app !== void 0 ? _webroots$app : '';
    }
    });

    unwrapExports(dist);
    var dist_1 = dist.generateUrl;
    dist.generateRemoteUrl;
    var dist_3 = dist.generateOcsUrl;
    dist.generateFilePath;
    dist.getAppRootUrl;
    dist.getRootUrl;
    dist.linkTo;
    dist.imagePath;

    function get_each_context$3(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[16] = list[i];
      return child_ctx;
    }

    // (88:0) {#if dialogVisible}
    function create_if_block$6(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot$2]
          },
          $$scope: {
            ctx
          }
        }
      });
      return {
        c() {
          create_component(overlay.$$.fragment);
        },
        m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty & /*$$scope, sharees, deleteShareAction, requestToken, clientUuid, loading, selectedSharee*/524638) {
            overlay_changes.$$scope = {
              dirty,
              ctx
            };
          }
          overlay.$set(overlay_changes);
        },
        i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    }

    // (104:4) {#if !sharees || !sharees.length}
    function create_if_block_2$3(ctx) {
      var p;
      var em;
      return {
        c() {
          p = element("p");
          em = element("em");
          em.textContent = "".concat(translate("timemanager", "You haven't shared this client with anyone"));
        },
        m(target, anchor) {
          insert(target, p, anchor);
          append(p, em);
        },
        d(detaching) {
          if (detaching) {
            detach(p);
          }
        }
      };
    }

    // (126:8) {:else}
    function create_else_block$2(ctx) {
      var img;
      var img_src_value;
      var img_srcset_value;
      return {
        c() {
          img = element("img");
          if (!src_url_equal(img.src, img_src_value = dist_1("avatar/".concat( /*sharee*/ctx[16].recipient_id, "/32")))) attr(img, "src", img_src_value);
          if (!srcset_url_equal(img, img_srcset_value = "".concat(dist_1("avatar/".concat( /*sharee*/ctx[16].recipient_id, "/32")), " 1x, ").concat(dist_1("avatar/".concat( /*sharee*/ctx[16].recipient_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_1("avatar/".concat( /*sharee*/ctx[16].recipient_id, "/128")), " 4x"))) attr(img, "srcset", img_srcset_value);
          attr(img, "alt", "");
        },
        m(target, anchor) {
          insert(target, img, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*sharees*/4 && !src_url_equal(img.src, img_src_value = dist_1("avatar/".concat( /*sharee*/ctx[16].recipient_id, "/32")))) {
            attr(img, "src", img_src_value);
          }
          if (dirty & /*sharees*/4 && img_srcset_value !== (img_srcset_value = "".concat(dist_1("avatar/".concat( /*sharee*/ctx[16].recipient_id, "/32")), " 1x, ").concat(dist_1("avatar/".concat( /*sharee*/ctx[16].recipient_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_1("avatar/".concat( /*sharee*/ctx[16].recipient_id, "/128")), " 4x"))) {
            attr(img, "srcset", img_srcset_value);
          }
        },
        d(detaching) {
          if (detaching) {
            detach(img);
          }
        }
      };
    }

    // (113:8) {#if sharee.recipient_type === "group"}
    function create_if_block_1$3(ctx) {
      var span;
      return {
        c() {
          span = element("span");
          span.innerHTML = "<svg fill=\"currentColor\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" class=\"material-design-icon__svg\"><path d=\"M12,5.5A3.5,3.5 0 0,1 15.5,9A3.5,3.5 0 0,1 12,12.5A3.5,3.5 0 0,1 8.5,9A3.5,3.5 0 0,1 12,5.5M5,8C5.56,8 6.08,8.15 6.53,8.42C6.38,9.85 6.8,11.27 7.66,12.38C7.16,13.34 6.16,14 5,14A3,3 0 0,1 2,11A3,3 0 0,1 5,8M19,8A3,3 0 0,1 22,11A3,3 0 0,1 19,14C17.84,14 16.84,13.34 16.34,12.38C17.2,11.27 17.62,9.85 17.47,8.42C17.92,8.15 18.44,8 19,8M5.5,18.25C5.5,16.18 8.41,14.5 12,14.5C15.59,14.5 18.5,16.18 18.5,18.25V20H5.5V18.25M0,20V18.5C0,17.11 1.89,15.94 4.45,15.6C3.86,16.28 3.5,17.22 3.5,18.25V20H0M24,20H20.5V18.25C20.5,17.22 20.14,16.28 19.55,15.6C22.11,15.94 24,17.11 24,18.5V20Z\"></path></svg>";
          attr(span, "aria-hidden", "true");
          attr(span, "role", "img");
          attr(span, "class", "material-design-icon account-group-icon");
        },
        m(target, anchor) {
          insert(target, span, anchor);
        },
        p: noop$1,
        d(detaching) {
          if (detaching) {
            detach(span);
          }
        }
      };
    }

    // (110:5) {#each sharees as sharee}
    function create_each_block$3(ctx) {
      var li;
      var figure;
      var t0;
      var figcaption;
      var t1_value = ( /*sharee*/ctx[16].recipient_display_name || /*sharee*/ctx[16].recipient_id) + "";
      var t1;
      var t2;
      var form_1;
      var input0;
      var t3;
      var input1;
      var input1_value_value;
      var t4;
      var input2;
      var t5;
      var button;
      var t7;
      function select_block_type(ctx, dirty) {
        if ( /*sharee*/ctx[16].recipient_type === "group") return create_if_block_1$3;
        return create_else_block$2;
      }
      var current_block_type = select_block_type(ctx);
      var if_block = current_block_type(ctx);
      return {
        c() {
          li = element("li");
          figure = element("figure");
          if_block.c();
          t0 = space$1();
          figcaption = element("figcaption");
          t1 = text$1(t1_value);
          t2 = space$1();
          form_1 = element("form");
          input0 = element("input");
          t3 = space$1();
          input1 = element("input");
          t4 = space$1();
          input2 = element("input");
          t5 = space$1();
          button = element("button");
          button.textContent = "".concat(translate("timemanager", "Delete"));
          t7 = space$1();
          attr(input0, "type", "hidden");
          attr(input0, "name", "client_uuid");
          input0.value = /*clientUuid*/ctx[3];
          attr(input1, "type", "hidden");
          attr(input1, "name", "uuid");
          input1.value = input1_value_value = /*sharee*/ctx[16].uuid;
          attr(input2, "type", "hidden");
          attr(input2, "name", "requesttoken");
          input2.value = /*requestToken*/ctx[4];
          attr(button, "type", "submit");
          attr(button, "name", "action");
          button.value = "delete";
          attr(button, "class", "btn small");
          attr(form_1, "action", /*deleteShareAction*/ctx[1]);
          attr(form_1, "method", "post");
        },
        m(target, anchor) {
          insert(target, li, anchor);
          append(li, figure);
          if_block.m(figure, null);
          append(figure, t0);
          append(figure, figcaption);
          append(figcaption, t1);
          append(li, t2);
          append(li, form_1);
          append(form_1, input0);
          append(form_1, t3);
          append(form_1, input1);
          append(form_1, t4);
          append(form_1, input2);
          append(form_1, t5);
          append(form_1, button);
          append(li, t7);
        },
        p(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);
            if (if_block) {
              if_block.c();
              if_block.m(figure, t0);
            }
          }
          if (dirty & /*sharees*/4 && t1_value !== (t1_value = ( /*sharee*/ctx[16].recipient_display_name || /*sharee*/ctx[16].recipient_id) + "")) set_data(t1, t1_value);
          if (dirty & /*clientUuid*/8) {
            input0.value = /*clientUuid*/ctx[3];
          }
          if (dirty & /*sharees*/4 && input1_value_value !== (input1_value_value = /*sharee*/ctx[16].uuid)) {
            input1.value = input1_value_value;
          }
          if (dirty & /*requestToken*/16) {
            input2.value = /*requestToken*/ctx[4];
          }
          if (dirty & /*deleteShareAction*/2) {
            attr(form_1, "action", /*deleteShareAction*/ctx[1]);
          }
        },
        d(detaching) {
          if (detaching) {
            detach(li);
          }
          if_block.d();
        }
      };
    }

    // (89:1) <Overlay>
    function create_default_slot$2(ctx) {
      var div2;
      var label;
      var t0_value = translate("timemanager", "Share with") + "";
      var t0;
      var t1;
      var select;
      var t2;
      var div0;
      var h4;
      var t4;
      var t5;
      var ul;
      var t6;
      var aside;
      var p0;
      var t8;
      var p1;
      var t10;
      var p2;
      var t12;
      var div1;
      var button0;
      var t14;
      var button1;
      var current;
      var mounted;
      var dispose;
      select = new Select({
        props: {
          noOptionsMessage: /*loading*/ctx[8] ? translate("timemanager", "Loading...") : translate("timemanager", "No options"),
          placeholder: translate("timemanager", "Search..."),
          inputAttributes: {
            id: "sharee-select"
          },
          loadOptions: /*search*/ctx[10],
          value: /*selectedSharee*/ctx[6]
        }
      });
      select.$on("select", /*handleSelectSharee*/ctx[12]);
      var if_block = (! /*sharees*/ctx[2] || ! /*sharees*/ctx[2].length) && create_if_block_2$3();
      var each_value = ensure_array_like( /*sharees*/ctx[2]);
      var each_blocks = [];
      for (var i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
      }
      return {
        c() {
          div2 = element("div");
          label = element("label");
          t0 = text$1(t0_value);
          t1 = space$1();
          create_component(select.$$.fragment);
          t2 = space$1();
          div0 = element("div");
          h4 = element("h4");
          h4.textContent = "".concat(translate("timemanager", "Existing shares"));
          t4 = space$1();
          if (if_block) if_block.c();
          t5 = space$1();
          ul = element("ul");
          for (var _i = 0; _i < each_blocks.length; _i += 1) {
            each_blocks[_i].c();
          }
          t6 = space$1();
          aside = element("aside");
          p0 = element("p");
          p0.textContent = "".concat(translate("timemanager", "You automatically grant read-only access to projects and tasks by sharing."));
          t8 = space$1();
          p1 = element("p");
          p1.textContent = "".concat(translate("timemanager", "Users you share with can create time entries."));
          t10 = space$1();
          p2 = element("p");
          p2.textContent = "".concat(translate("timemanager", "You can see all time entries, while others can only see and edit their own time entries."));
          t12 = space$1();
          div1 = element("div");
          button0 = element("button");
          button0.textContent = "".concat(translate("timemanager", "Add"));
          t14 = space$1();
          button1 = element("button");
          button1.textContent = "".concat(translate("timemanager", "Cancel"));
          attr(label, "for", "sharee-select");
          attr(label, "class", "sharees");
          attr(h4, "class", "tm_label");
          attr(div0, "class", "sharee-list");
          attr(button0, "class", "button primary");
          attr(button1, "class", "button");
          attr(div1, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(div2, "class", "inner tm_new-item sharing-dialog");
        },
        m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, label);
          append(label, t0);
          append(label, t1);
          mount_component(select, label, null);
          append(div2, t2);
          append(div2, div0);
          append(div0, h4);
          append(div0, t4);
          if (if_block) if_block.m(div0, null);
          append(div0, t5);
          append(div0, ul);
          for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
            if (each_blocks[_i2]) {
              each_blocks[_i2].m(ul, null);
            }
          }
          append(div0, t6);
          append(div0, aside);
          append(aside, p0);
          append(aside, t8);
          append(aside, p1);
          append(aside, t10);
          append(aside, p2);
          append(div2, t12);
          append(div2, div1);
          append(div1, button0);
          append(div1, t14);
          append(div1, button1);
          current = true;
          if (!mounted) {
            dispose = [listen(button0, "click", prevent_default( /*addShare*/ctx[9])), listen(button1, "click", prevent_default( /*closeDialog*/ctx[11]))];
            mounted = true;
          }
        },
        p(ctx, dirty) {
          var select_changes = {};
          if (dirty & /*loading*/256) select_changes.noOptionsMessage = /*loading*/ctx[8] ? translate("timemanager", "Loading...") : translate("timemanager", "No options");
          if (dirty & /*selectedSharee*/64) select_changes.value = /*selectedSharee*/ctx[6];
          select.$set(select_changes);
          if (! /*sharees*/ctx[2] || ! /*sharees*/ctx[2].length) {
            if (if_block) ; else {
              if_block = create_if_block_2$3();
              if_block.c();
              if_block.m(div0, t5);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
          if (dirty & /*deleteShareAction, requestToken, sharees, clientUuid*/30) {
            each_value = ensure_array_like( /*sharees*/ctx[2]);
            var _i3;
            for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
              var child_ctx = get_each_context$3(ctx, each_value, _i3);
              if (each_blocks[_i3]) {
                each_blocks[_i3].p(child_ctx, dirty);
              } else {
                each_blocks[_i3] = create_each_block$3(child_ctx);
                each_blocks[_i3].c();
                each_blocks[_i3].m(ul, null);
              }
            }
            for (; _i3 < each_blocks.length; _i3 += 1) {
              each_blocks[_i3].d(1);
            }
            each_blocks.length = each_value.length;
          }
        },
        i(local) {
          if (current) return;
          transition_in(select.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(select.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div2);
          }
          destroy_component(select);
          if (if_block) if_block.d();
          destroy_each(each_blocks, detaching);
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function create_fragment$a(ctx) {
      var t0;
      var form_1;
      var input0;
      var t1;
      var input1;
      var input1_value_value;
      var t2;
      var input2;
      var input2_value_value;
      var t3;
      var input3;
      var t4;
      var button;
      var current;
      var if_block = /*dialogVisible*/ctx[7] && create_if_block$6(ctx);
      return {
        c() {
          if (if_block) if_block.c();
          t0 = space$1();
          form_1 = element("form");
          input0 = element("input");
          t1 = space$1();
          input1 = element("input");
          t2 = space$1();
          input2 = element("input");
          t3 = space$1();
          input3 = element("input");
          t4 = space$1();
          button = element("button");
          button.textContent = "".concat(translate("timemanager", "Share client"));
          attr(input0, "type", "hidden");
          attr(input0, "name", "client_uuid");
          input0.value = /*clientUuid*/ctx[3];
          attr(input1, "type", "hidden");
          attr(input1, "name", "user_id");
          input1.value = input1_value_value = /*selectedSharee*/ctx[6] && /*selectedSharee*/ctx[6].value.shareType === 0 ? /*selectedSharee*/ctx[6].value.shareWith : "";
          attr(input2, "type", "hidden");
          attr(input2, "name", "group_id");
          input2.value = input2_value_value = /*selectedSharee*/ctx[6] && /*selectedSharee*/ctx[6].value.shareType === 1 ? /*selectedSharee*/ctx[6].value.shareWith : "";
          attr(input3, "type", "hidden");
          attr(input3, "name", "requesttoken");
          input3.value = /*requestToken*/ctx[4];
          attr(button, "type", "submit");
          attr(button, "name", "action");
          button.value = "share";
          attr(button, "class", "btn");
          attr(form_1, "action", /*shareAction*/ctx[0]);
          attr(form_1, "method", "post");
        },
        m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, t0, anchor);
          insert(target, form_1, anchor);
          append(form_1, input0);
          append(form_1, t1);
          append(form_1, input1);
          append(form_1, t2);
          append(form_1, input2);
          append(form_1, t3);
          append(form_1, input3);
          append(form_1, t4);
          append(form_1, button);
          /*form_1_binding*/
          ctx[14](form_1);
          current = true;
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if ( /*dialogVisible*/ctx[7]) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty & /*dialogVisible*/128) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$6(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(t0.parentNode, t0);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
          if (!current || dirty & /*clientUuid*/8) {
            input0.value = /*clientUuid*/ctx[3];
          }
          if (!current || dirty & /*selectedSharee*/64 && input1_value_value !== (input1_value_value = /*selectedSharee*/ctx[6] && /*selectedSharee*/ctx[6].value.shareType === 0 ? /*selectedSharee*/ctx[6].value.shareWith : "")) {
            input1.value = input1_value_value;
          }
          if (!current || dirty & /*selectedSharee*/64 && input2_value_value !== (input2_value_value = /*selectedSharee*/ctx[6] && /*selectedSharee*/ctx[6].value.shareType === 1 ? /*selectedSharee*/ctx[6].value.shareWith : "")) {
            input2.value = input2_value_value;
          }
          if (!current || dirty & /*requestToken*/16) {
            input3.value = /*requestToken*/ctx[4];
          }
          if (!current || dirty & /*shareAction*/1) {
            attr(form_1, "action", /*shareAction*/ctx[0]);
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(t0);
            detach(form_1);
          }
          if (if_block) if_block.d(detaching);
          /*form_1_binding*/
          ctx[14](null);
        }
      };
    }
    function instance$a($$self, $$props, $$invalidate) {
      var dialogVisible;
      var loading;
      var shareAction = $$props.shareAction;
      var deleteShareAction = $$props.deleteShareAction;
      var sharees = $$props.sharees;
      var clientUuid = $$props.clientUuid;
      var requestToken = $$props.requestToken;
      var userId = $$props.userId;
      var form;
      var selectedSharee;
      onMount(function () {
        Helpers.hideFallbacks("ShareDialog.svelte");
        if (form) {
          form.addEventListener("submit", submit);
          return function () {
            form.removeEventListener("submit", submit);
          };
        }
      });
      var submit = function submit(e) {
        e.preventDefault();
        $$invalidate(7, dialogVisible = true);
      };
      var addShare = function addShare() {
        form.submit();
      };
      var search = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(query) {
          var response, _yield$response$json$, users, exact, groups, existing_users, existing_groups, adjustGroupLabel, result;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!(typeof query === "undefined")) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return");
              case 2:
                $$invalidate(8, loading = true);
                _context.next = 5;
                return fetch(dist_3("apps/files_sharing/api/v1/sharees?search=".concat(query, "&format=json&perPage=20&itemType=[0]")), {
                  headers: {
                    requesttoken: requestToken,
                    "content-type": "application/json"
                  }
                });
              case 5:
                response = _context.sent;
                $$invalidate(8, loading = false);
                if (!response.ok) {
                  _context.next = 19;
                  break;
                }
                _context.next = 10;
                return response.json();
              case 10:
                _yield$response$json$ = _context.sent.ocs.data;
                users = _yield$response$json$.users;
                exact = _yield$response$json$.exact;
                groups = _yield$response$json$.groups;
                existing_users = sharees.filter(function (s) {
                  return s.recipient_type === "user";
                }).map(function (share) {
                  return share.recipient_id;
                });
                existing_groups = sharees.filter(function (s) {
                  return s.recipient_type === "group";
                }).map(function (share) {
                  return share.recipient_id;
                });
                adjustGroupLabel = function adjustGroupLabel(userOrGroup) {
                  var _userOrGroup$value;
                  return ((_userOrGroup$value = userOrGroup.value) === null || _userOrGroup$value === void 0 ? void 0 : _userOrGroup$value.shareType) === 1 ? _objectSpread2(_objectSpread2({}, userOrGroup), {}, {
                    label: "".concat(userOrGroup.label, " ").concat(translate("timemanager", "(Group)"))
                  }) : userOrGroup;
                };
                result = [].concat(_toConsumableArray(users), _toConsumableArray(exact.users), _toConsumableArray(groups), _toConsumableArray(exact.groups)).filter(function (user) {
                  return !existing_users.includes(user.value.shareWith) && user.value.shareWith !== userId;
                }).filter(function (group) {
                  return !existing_groups.includes(group.value.shareWith);
                }).map(adjustGroupLabel);
                return _context.abrupt("return", result);
              case 19:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function search(_x) {
          return _ref3.apply(this, arguments);
        };
      }();
      var closeDialog = function closeDialog() {
        $$invalidate(7, dialogVisible = false);
      };
      var handleSelectSharee = function handleSelectSharee(event) {
        $$invalidate(6, selectedSharee = event.detail);
      };
      function form_1_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          form = $$value;
          $$invalidate(5, form);
        });
      }
      $$self.$$set = function ($$props) {
        if ('shareAction' in $$props) $$invalidate(0, shareAction = $$props.shareAction);
        if ('deleteShareAction' in $$props) $$invalidate(1, deleteShareAction = $$props.deleteShareAction);
        if ('sharees' in $$props) $$invalidate(2, sharees = $$props.sharees);
        if ('clientUuid' in $$props) $$invalidate(3, clientUuid = $$props.clientUuid);
        if ('requestToken' in $$props) $$invalidate(4, requestToken = $$props.requestToken);
        if ('userId' in $$props) $$invalidate(13, userId = $$props.userId);
      };
      $$invalidate(7, dialogVisible = false);
      $$invalidate(8, loading = false);
      return [shareAction, deleteShareAction, sharees, clientUuid, requestToken, form, selectedSharee, dialogVisible, loading, addShare, search, closeDialog, handleSelectSharee, userId, form_1_binding];
    }
    var ShareDialog = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(ShareDialog, _SvelteComponent);
      var _super = _createSuper$1(ShareDialog);
      function ShareDialog(options) {
        var _this;
        _classCallCheck$1(this, ShareDialog);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$a, create_fragment$a, safe_not_equal, {
          shareAction: 0,
          deleteShareAction: 1,
          sharees: 2,
          clientUuid: 3,
          requestToken: 4,
          userId: 13
        });
        return _this;
      }
      return _createClass$1(ShareDialog);
    }(SvelteComponent);

    function get_each_context$2(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[2] = list[i];
      return child_ctx;
    }

    // (15:0) {#if sharees && sharees.length}
    function create_if_block_1$2(ctx) {
      var span;
      var t1;
      var ul;
      var each_value = ensure_array_like( /*sharees*/ctx[0]);
      var each_blocks = [];
      for (var i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
      }
      return {
        c() {
          span = element("span");
          span.textContent = "".concat(translate("timemanager", "Shared with"));
          t1 = space$1();
          ul = element("ul");
          for (var _i = 0; _i < each_blocks.length; _i += 1) {
            each_blocks[_i].c();
          }
          attr(span, "class", "tm_label");
          attr(ul, "class", "existing-sharees");
        },
        m(target, anchor) {
          insert(target, span, anchor);
          insert(target, t1, anchor);
          insert(target, ul, anchor);
          for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
            if (each_blocks[_i2]) {
              each_blocks[_i2].m(ul, null);
            }
          }
        },
        p(ctx, dirty) {
          if (dirty & /*sharees*/1) {
            each_value = ensure_array_like( /*sharees*/ctx[0]);
            var _i3;
            for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
              var child_ctx = get_each_context$2(ctx, each_value, _i3);
              if (each_blocks[_i3]) {
                each_blocks[_i3].p(child_ctx, dirty);
              } else {
                each_blocks[_i3] = create_each_block$2(child_ctx);
                each_blocks[_i3].c();
                each_blocks[_i3].m(ul, null);
              }
            }
            for (; _i3 < each_blocks.length; _i3 += 1) {
              each_blocks[_i3].d(1);
            }
            each_blocks.length = each_value.length;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(span);
            detach(t1);
            detach(ul);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }

    // (28:4) {:else}
    function create_else_block$1(ctx) {
      var img;
      var img_src_value;
      var img_srcset_value;
      return {
        c() {
          img = element("img");
          if (!src_url_equal(img.src, img_src_value = dist_1("avatar/".concat( /*sharee*/ctx[2].recipient_id, "/32")))) attr(img, "src", img_src_value);
          if (!srcset_url_equal(img, img_srcset_value = "".concat(dist_1("avatar/".concat( /*sharee*/ctx[2].recipient_id, "/32")), " 1x, ").concat(dist_1("avatar/".concat( /*sharee*/ctx[2].recipient_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_1("avatar/".concat( /*sharee*/ctx[2].recipient_id, "/128")), " 4x"))) attr(img, "srcset", img_srcset_value);
          attr(img, "alt", "");
        },
        m(target, anchor) {
          insert(target, img, anchor);
        },
        p(ctx, dirty) {
          if (dirty & /*sharees*/1 && !src_url_equal(img.src, img_src_value = dist_1("avatar/".concat( /*sharee*/ctx[2].recipient_id, "/32")))) {
            attr(img, "src", img_src_value);
          }
          if (dirty & /*sharees*/1 && img_srcset_value !== (img_srcset_value = "".concat(dist_1("avatar/".concat( /*sharee*/ctx[2].recipient_id, "/32")), " 1x, ").concat(dist_1("avatar/".concat( /*sharee*/ctx[2].recipient_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_1("avatar/".concat( /*sharee*/ctx[2].recipient_id, "/128")), " 4x"))) {
            attr(img, "srcset", img_srcset_value);
          }
        },
        d(detaching) {
          if (detaching) {
            detach(img);
          }
        }
      };
    }

    // (20:4) {#if sharee.recipient_type === "group"}
    function create_if_block_2$2(ctx) {
      var span;
      return {
        c() {
          span = element("span");
          span.innerHTML = "<svg fill=\"currentColor\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" class=\"material-design-icon__svg\"><path d=\"M12,5.5A3.5,3.5 0 0,1 15.5,9A3.5,3.5 0 0,1 12,12.5A3.5,3.5 0 0,1 8.5,9A3.5,3.5 0 0,1 12,5.5M5,8C5.56,8 6.08,8.15 6.53,8.42C6.38,9.85 6.8,11.27 7.66,12.38C7.16,13.34 6.16,14 5,14A3,3 0 0,1 2,11A3,3 0 0,1 5,8M19,8A3,3 0 0,1 22,11A3,3 0 0,1 19,14C17.84,14 16.84,13.34 16.34,12.38C17.2,11.27 17.62,9.85 17.47,8.42C17.92,8.15 18.44,8 19,8M5.5,18.25C5.5,16.18 8.41,14.5 12,14.5C15.59,14.5 18.5,16.18 18.5,18.25V20H5.5V18.25M0,20V18.5C0,17.11 1.89,15.94 4.45,15.6C3.86,16.28 3.5,17.22 3.5,18.25V20H0M24,20H20.5V18.25C20.5,17.22 20.14,16.28 19.55,15.6C22.11,15.94 24,17.11 24,18.5V20Z\"></path></svg>";
          attr(span, "aria-hidden", "true");
          attr(span, "role", "img");
          attr(span, "class", "material-design-icon account-group-icon");
        },
        m(target, anchor) {
          insert(target, span, anchor);
        },
        p: noop$1,
        d(detaching) {
          if (detaching) {
            detach(span);
          }
        }
      };
    }

    // (18:2) {#each sharees as sharee}
    function create_each_block$2(ctx) {
      var li;
      var t0;
      var t1_value = ( /*sharee*/ctx[2].recipient_display_name || /*sharee*/ctx[2].recipient_id) + "";
      var t1;
      var t2;
      function select_block_type(ctx, dirty) {
        if ( /*sharee*/ctx[2].recipient_type === "group") return create_if_block_2$2;
        return create_else_block$1;
      }
      var current_block_type = select_block_type(ctx);
      var if_block = current_block_type(ctx);
      return {
        c() {
          li = element("li");
          if_block.c();
          t0 = space$1();
          t1 = text$1(t1_value);
          t2 = space$1();
        },
        m(target, anchor) {
          insert(target, li, anchor);
          if_block.m(li, null);
          append(li, t0);
          append(li, t1);
          append(li, t2);
        },
        p(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);
            if (if_block) {
              if_block.c();
              if_block.m(li, t0);
            }
          }
          if (dirty & /*sharees*/1 && t1_value !== (t1_value = ( /*sharee*/ctx[2].recipient_display_name || /*sharee*/ctx[2].recipient_id) + "")) set_data(t1, t1_value);
        },
        d(detaching) {
          if (detaching) {
            detach(li);
          }
          if_block.d();
        }
      };
    }

    // (44:0) {#if sharedBy}
    function create_if_block$5(ctx) {
      var span;
      var t1;
      var ul;
      var li;
      var img;
      var img_src_value;
      var img_srcset_value;
      var t2;
      var t3_value = ( /*sharedBy*/ctx[1].author_display_name || /*sharedBy*/ctx[1].author_user_id) + "";
      var t3;
      return {
        c() {
          span = element("span");
          span.textContent = "".concat(translate("timemanager", "Shared with you by"));
          t1 = space$1();
          ul = element("ul");
          li = element("li");
          img = element("img");
          t2 = space$1();
          t3 = text$1(t3_value);
          attr(span, "class", "tm_label");
          if (!src_url_equal(img.src, img_src_value = dist_1("avatar/".concat( /*sharedBy*/ctx[1].author_user_id, "/32")))) attr(img, "src", img_src_value);
          if (!srcset_url_equal(img, img_srcset_value = "".concat(dist_1("avatar/".concat( /*sharedBy*/ctx[1].author_user_id, "/32")), " 1x, ").concat(dist_1("avatar/".concat( /*sharedBy*/ctx[1].author_user_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_1("avatar/".concat( /*sharedBy*/ctx[1].author_user_id, "/128")), " 4x"))) attr(img, "srcset", img_srcset_value);
          attr(img, "alt", "");
          attr(ul, "class", "existing-sharees");
        },
        m(target, anchor) {
          insert(target, span, anchor);
          insert(target, t1, anchor);
          insert(target, ul, anchor);
          append(ul, li);
          append(li, img);
          append(li, t2);
          append(li, t3);
        },
        p(ctx, dirty) {
          if (dirty & /*sharedBy*/2 && !src_url_equal(img.src, img_src_value = dist_1("avatar/".concat( /*sharedBy*/ctx[1].author_user_id, "/32")))) {
            attr(img, "src", img_src_value);
          }
          if (dirty & /*sharedBy*/2 && img_srcset_value !== (img_srcset_value = "".concat(dist_1("avatar/".concat( /*sharedBy*/ctx[1].author_user_id, "/32")), " 1x, ").concat(dist_1("avatar/".concat( /*sharedBy*/ctx[1].author_user_id, "/64")), " 2x,\n\t\t\t\t\t").concat(dist_1("avatar/".concat( /*sharedBy*/ctx[1].author_user_id, "/128")), " 4x"))) {
            attr(img, "srcset", img_srcset_value);
          }
          if (dirty & /*sharedBy*/2 && t3_value !== (t3_value = ( /*sharedBy*/ctx[1].author_display_name || /*sharedBy*/ctx[1].author_user_id) + "")) set_data(t3, t3_value);
        },
        d(detaching) {
          if (detaching) {
            detach(span);
            detach(t1);
            detach(ul);
          }
        }
      };
    }
    function create_fragment$9(ctx) {
      var t;
      var if_block1_anchor;
      var if_block0 = /*sharees*/ctx[0] && /*sharees*/ctx[0].length && create_if_block_1$2(ctx);
      var if_block1 = /*sharedBy*/ctx[1] && create_if_block$5(ctx);
      return {
        c() {
          if (if_block0) if_block0.c();
          t = space$1();
          if (if_block1) if_block1.c();
          if_block1_anchor = empty();
        },
        m(target, anchor) {
          if (if_block0) if_block0.m(target, anchor);
          insert(target, t, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert(target, if_block1_anchor, anchor);
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if ( /*sharees*/ctx[0] && /*sharees*/ctx[0].length) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_1$2(ctx);
              if_block0.c();
              if_block0.m(t.parentNode, t);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          if ( /*sharedBy*/ctx[1]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block$5(ctx);
              if_block1.c();
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(t);
            detach(if_block1_anchor);
          }
          if (if_block0) if_block0.d(detaching);
          if (if_block1) if_block1.d(detaching);
        }
      };
    }
    function instance$9($$self, $$props, $$invalidate) {
      var sharees = $$props.sharees;
      var sharedBy = $$props.sharedBy;
      onMount(function () {
        Helpers.hideFallbacks("ShareDialog.svelte");
      });
      $$self.$$set = function ($$props) {
        if ('sharees' in $$props) $$invalidate(0, sharees = $$props.sharees);
        if ('sharedBy' in $$props) $$invalidate(1, sharedBy = $$props.sharedBy);
      };
      return [sharees, sharedBy];
    }
    var ShareStatus = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(ShareStatus, _SvelteComponent);
      var _super = _createSuper$1(ShareStatus);
      function ShareStatus(options) {
        var _this;
        _classCallCheck$1(this, ShareStatus);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$9, create_fragment$9, safe_not_equal, {
          sharees: 0,
          sharedBy: 1
        });
        return _this;
      }
      return _createClass$1(ShareStatus);
    }(SvelteComponent);

    function create_if_block$4(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot$1]
          },
          $$scope: {
            ctx
          }
        }
      });
      return {
        c() {
          create_component(overlay.$$.fragment);
        },
        m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty & /*$$scope*/128) {
            overlay_changes.$$scope = {
              dirty,
              ctx
            };
          }
          overlay.$set(overlay_changes);
        },
        i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    }

    // (56:1) <Overlay>
    function create_default_slot$1(ctx) {
      var div1;
      var t0_value = translate('timemanager', 'Do you want to delete this time entry?') + "";
      var t0;
      var t1;
      var div0;
      var button0;
      var t3;
      var button1;
      var mounted;
      var dispose;
      return {
        c() {
          div1 = element("div");
          t0 = text$1(t0_value);
          t1 = space$1();
          div0 = element("div");
          button0 = element("button");
          button0.textContent = "".concat(translate('timemanager', 'Delete'));
          t3 = space$1();
          button1 = element("button");
          button1.textContent = "".concat(translate('timemanager', 'Cancel'));
          attr(button0, "class", "button primary");
          attr(button1, "class", "button");
          attr(div0, "class", "oc-dialog-buttonrow twobuttons reverse");
          attr(div1, "class", "inner tm_new-item");
        },
        m(target, anchor) {
          insert(target, div1, anchor);
          append(div1, t0);
          append(div1, t1);
          append(div1, div0);
          append(div0, button0);
          append(div0, t3);
          append(div0, button1);
          if (!mounted) {
            dispose = [listen(button0, "click", prevent_default( /*doDelete*/ctx[5])), listen(button1, "click", prevent_default( /*cancelDelete*/ctx[6]))];
            mounted = true;
          }
        },
        p: noop$1,
        d(detaching) {
          if (detaching) {
            detach(div1);
          }
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function create_fragment$8(ctx) {
      var t0;
      var form;
      var input0;
      var t1;
      var input1;
      var t2;
      var button;
      var current;
      var mounted;
      var dispose;
      var if_block = /*confirmation*/ctx[3] && create_if_block$4(ctx);
      return {
        c() {
          if (if_block) if_block.c();
          t0 = space$1();
          form = element("form");
          input0 = element("input");
          t1 = space$1();
          input1 = element("input");
          t2 = space$1();
          button = element("button");
          button.textContent = "".concat(translate('timemanager', 'Delete'));
          attr(input0, "type", "hidden");
          attr(input0, "name", "uuid");
          input0.value = /*deleteTimeEntryUuid*/ctx[1];
          attr(input1, "type", "hidden");
          attr(input1, "name", "requesttoken");
          input1.value = /*requestToken*/ctx[2];
          attr(button, "type", "submit");
          attr(button, "name", "action");
          button.value = "delete";
          attr(button, "class", "btn");
          attr(form, "action", /*deleteTimeEntryAction*/ctx[0]);
          attr(form, "method", "post");
          attr(form, "class", "tm_inline-hover-form");
        },
        m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, t0, anchor);
          insert(target, form, anchor);
          append(form, input0);
          append(form, t1);
          append(form, input1);
          append(form, t2);
          append(form, button);
          current = true;
          if (!mounted) {
            dispose = listen(form, "submit", /*submit*/ctx[4]);
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if ( /*confirmation*/ctx[3]) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty & /*confirmation*/8) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$4(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(t0.parentNode, t0);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
          if (!current || dirty & /*deleteTimeEntryUuid*/2) {
            input0.value = /*deleteTimeEntryUuid*/ctx[1];
          }
          if (!current || dirty & /*requestToken*/4) {
            input1.value = /*requestToken*/ctx[2];
          }
          if (!current || dirty & /*deleteTimeEntryAction*/1) {
            attr(form, "action", /*deleteTimeEntryAction*/ctx[0]);
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(t0);
            detach(form);
          }
          if (if_block) if_block.d(detaching);
          mounted = false;
          dispose();
        }
      };
    }
    function instance$8($$self, $$props, $$invalidate) {
      var confirmation;
      var deleteTimeEntryAction = $$props.deleteTimeEntryAction;
      var deleteTimeEntryUuid = $$props.deleteTimeEntryUuid;
      var requestToken = $$props.requestToken;
      onMount(function () {
        Helpers.hideFallbacks("DeleteTimeEntryButton.svelte@".concat(deleteTimeEntryUuid));
      });
      var submit = function submit(e) {
        e.preventDefault();
        $$invalidate(3, confirmation = true);
      };
      var doDelete = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var _element, response;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                $$invalidate(3, confirmation = false);
                _context.prev = 1;
                _element = document.querySelector("#content.app-timemanager [data-remove-on-delete='".concat(deleteTimeEntryUuid, "']"));
                if (_element) {
                  _element.classList.add("warning");
                }
                _context.next = 6;
                return window.fetch(deleteTimeEntryAction, {
                  method: "POST",
                  body: JSON.stringify({
                    uuid: deleteTimeEntryUuid
                  }),
                  headers: {
                    requesttoken: requestToken,
                    "content-type": "application/json"
                  }
                });
              case 6:
                response = _context.sent;
                if (response && response.ok) {
                  _element.remove();
                  document.querySelector(".app-timemanager [data-current-link]").click();
                }
                _context.next = 13;
                break;
              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](1);
                console.error(_context.t0);
              case 13:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[1, 10]]);
        }));
        return function doDelete() {
          return _ref3.apply(this, arguments);
        };
      }();
      var cancelDelete = function cancelDelete() {
        $$invalidate(3, confirmation = false);
      };
      $$self.$$set = function ($$props) {
        if ('deleteTimeEntryAction' in $$props) $$invalidate(0, deleteTimeEntryAction = $$props.deleteTimeEntryAction);
        if ('deleteTimeEntryUuid' in $$props) $$invalidate(1, deleteTimeEntryUuid = $$props.deleteTimeEntryUuid);
        if ('requestToken' in $$props) $$invalidate(2, requestToken = $$props.requestToken);
      };
      $$invalidate(3, confirmation = false);
      return [deleteTimeEntryAction, deleteTimeEntryUuid, requestToken, confirmation, submit, doDelete, cancelDelete];
    }
    var DeleteTimeEntryButton = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(DeleteTimeEntryButton, _SvelteComponent);
      var _super = _createSuper$1(DeleteTimeEntryButton);
      function DeleteTimeEntryButton(options) {
        var _this;
        _classCallCheck$1(this, DeleteTimeEntryButton);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$8, create_fragment$8, safe_not_equal, {
          deleteTimeEntryAction: 0,
          deleteTimeEntryUuid: 1,
          requestToken: 2
        });
        return _this;
      }
      return _createClass$1(DeleteTimeEntryButton);
    }(SvelteComponent);

    var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
    var propertyIsEnumerable = functionUncurryThis($propertyIsEnumerable);
    var push$1 = functionUncurryThis([].push);

    // in some IE versions, `propertyIsEnumerable` returns incorrect result on integer keys
    // of `null` prototype objects
    var IE_BUG = descriptors && fails(function () {
      // eslint-disable-next-line es/no-object-create -- safe
      var O = Object.create(null);
      O[2] = 2;
      return !propertyIsEnumerable(O, 2);
    });

    // `Object.{ entries, values }` methods implementation
    var createMethod = function (TO_ENTRIES) {
      return function (it) {
        var O = toIndexedObject(it);
        var keys = objectKeys(O);
        var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
        var length = keys.length;
        var i = 0;
        var result = [];
        var key;
        while (length > i) {
          key = keys[i++];
          if (!descriptors || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
            push$1(result, TO_ENTRIES ? [key, O[key]] : O[key]);
          }
        }
        return result;
      };
    };
    var objectToArray = {
      // `Object.entries` method
      // https://tc39.es/ecma262/#sec-object.entries
      entries: createMethod(true),
      // `Object.values` method
      // https://tc39.es/ecma262/#sec-object.values
      values: createMethod(false)
    };

    var $values = objectToArray.values;

    // `Object.values` method
    // https://tc39.es/ecma262/#sec-object.values
    _export({
      target: 'Object',
      stat: true
    }, {
      values: function values(O) {
        return $values(O);
      }
    });

    // `SameValue` abstract operation
    // https://tc39.es/ecma262/#sec-samevalue
    // eslint-disable-next-line es/no-object-is -- safe
    var sameValue = Object.is || function is(x, y) {
      // eslint-disable-next-line no-self-compare -- NaN check
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    };

    // @@search logic
    fixRegexpWellKnownSymbolLogic('search', function (SEARCH, nativeSearch, maybeCallNative) {
      return [
      // `String.prototype.search` method
      // https://tc39.es/ecma262/#sec-string.prototype.search
      function search(regexp) {
        var O = requireObjectCoercible(this);
        var searcher = isNullOrUndefined(regexp) ? undefined : getMethod(regexp, SEARCH);
        return searcher ? functionCall(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString_1(O));
      },
      // `RegExp.prototype[@@search]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
      function (string) {
        var rx = anObject(this);
        var S = toString_1(string);
        var res = maybeCallNative(nativeSearch, rx, S);
        if (res.done) return res.value;
        var previousLastIndex = rx.lastIndex;
        if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
        var result = regexpExecAbstract(rx, S);
        if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
        return result === null ? -1 : result.index;
      }];
    });

    var $TypeError = TypeError;
    var deletePropertyOrThrow = function (O, P) {
      if (!delete O[P]) throw $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
    };

    var $Array = Array;
    var max$1 = Math.max;
    var arraySliceSimple = function (O, start, end) {
      var length = lengthOfArrayLike(O);
      var k = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === undefined ? length : end, length);
      var result = $Array(max$1(fin - k, 0));
      for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
      result.length = n;
      return result;
    };

    var floor = Math.floor;
    var mergeSort = function (array, comparefn) {
      var length = array.length;
      var middle = floor(length / 2);
      return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySliceSimple(array, 0, middle), comparefn), mergeSort(arraySliceSimple(array, middle), comparefn), comparefn);
    };
    var insertionSort = function (array, comparefn) {
      var length = array.length;
      var i = 1;
      var element, j;
      while (i < length) {
        j = i;
        element = array[i];
        while (j && comparefn(array[j - 1], element) > 0) {
          array[j] = array[--j];
        }
        if (j !== i++) array[j] = element;
      }
      return array;
    };
    var merge = function (array, left, right, comparefn) {
      var llength = left.length;
      var rlength = right.length;
      var lindex = 0;
      var rindex = 0;
      while (lindex < llength || rindex < rlength) {
        array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
      }
      return array;
    };
    var arraySort = mergeSort;

    var firefox = engineUserAgent.match(/firefox\/(\d+)/i);
    var engineFfVersion = !!firefox && +firefox[1];

    var engineIsIeOrEdge = /MSIE|Trident/.test(engineUserAgent);

    var webkit = engineUserAgent.match(/AppleWebKit\/(\d+)\./);
    var engineWebkitVersion = !!webkit && +webkit[1];

    var test = [];
    var nativeSort = functionUncurryThis(test.sort);
    var push = functionUncurryThis(test.push);

    // IE8-
    var FAILS_ON_UNDEFINED = fails(function () {
      test.sort(undefined);
    });
    // V8 bug
    var FAILS_ON_NULL = fails(function () {
      test.sort(null);
    });
    // Old WebKit
    var STRICT_METHOD = arrayMethodIsStrict('sort');
    var STABLE_SORT = !fails(function () {
      // feature detection can be too slow, so check engines versions
      if (engineV8Version) return engineV8Version < 70;
      if (engineFfVersion && engineFfVersion > 3) return;
      if (engineIsIeOrEdge) return true;
      if (engineWebkitVersion) return engineWebkitVersion < 603;
      var result = '';
      var code, chr, value, index;

      // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
      for (code = 65; code < 76; code++) {
        chr = String.fromCharCode(code);
        switch (code) {
          case 66:
          case 69:
          case 70:
          case 72:
            value = 3;
            break;
          case 68:
          case 71:
            value = 4;
            break;
          default:
            value = 2;
        }
        for (index = 0; index < 47; index++) {
          test.push({
            k: chr + index,
            v: value
          });
        }
      }
      test.sort(function (a, b) {
        return b.v - a.v;
      });
      for (index = 0; index < test.length; index++) {
        chr = test[index].k.charAt(0);
        if (result.charAt(result.length - 1) !== chr) result += chr;
      }
      return result !== 'DGBEFHACIJK';
    });
    var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
    var getSortCompare = function (comparefn) {
      return function (x, y) {
        if (y === undefined) return -1;
        if (x === undefined) return 1;
        if (comparefn !== undefined) return +comparefn(x, y) || 0;
        return toString_1(x) > toString_1(y) ? 1 : -1;
      };
    };

    // `Array.prototype.sort` method
    // https://tc39.es/ecma262/#sec-array.prototype.sort
    _export({
      target: 'Array',
      proto: true,
      forced: FORCED
    }, {
      sort: function sort(comparefn) {
        if (comparefn !== undefined) aCallable(comparefn);
        var array = toObject(this);
        if (STABLE_SORT) return comparefn === undefined ? nativeSort(array) : nativeSort(array, comparefn);
        var items = [];
        var arrayLength = lengthOfArrayLike(array);
        var itemsLength, index;
        for (index = 0; index < arrayLength; index++) {
          if (index in array) push(items, array[index]);
        }
        arraySort(items, getSortCompare(comparefn));
        itemsLength = lengthOfArrayLike(items);
        index = 0;
        while (index < itemsLength) array[index] = items[index++];
        while (index < arrayLength) deletePropertyOrThrow(array, index++);
        return array;
      }
    });

    var $find = arrayIteration.find;

    var FIND = 'find';
    var SKIPS_HOLES = true;

    // Shouldn't skip holes
    // eslint-disable-next-line es/no-array-prototype-find -- testing
    if (FIND in []) Array(1)[FIND](function () {
      SKIPS_HOLES = false;
    });

    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    _export({
      target: 'Array',
      proto: true,
      forced: SKIPS_HOLES
    }, {
      find: function find(callbackfn /* , that = undefined */) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });

    // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
    addToUnscopables(FIND);

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read$1 = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write$1 = 'write';
    var afterWrite$1 = 'afterWrite';
    var modifierPhases = [beforeRead, read$1, afterRead, beforeMain, main, afterMain, beforeWrite, write$1, afterWrite$1];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }
      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node;
    }

    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }
    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }
    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }
      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]

        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];
          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }
    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules

    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }

    var max = Math.max;
    var min = Math.min;
    var round = Math.round;

    function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function (item) {
          return item.brand + "/" + item.version;
        }).join(' ');
      }
      return navigator.userAgent;
    }

    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }

    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      var _ref = isElement(element) ? getWindow(element) : window,
        visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width: width,
        height: height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x: x,
        y: y
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;
      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }
      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains$1(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;
        do {
          if (next && parent.isSameNode(next)) {
            return true;
          } // $FlowFixMe[prop-missing]: need a better way to handle this...

          next = next.parentNode || next.host;
        } while (next);
      } // Give up, the result is false

      return false;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement(element) ? element.ownerDocument :
      // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }
      return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot ||
        // step into the shadow DOM of the parent of a slotted node
        element.parentNode || (
        // DOM Element detected
        isShadowRoot(element) ? element.host : null) ||
        // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback
      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) ||
      // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }
      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block

    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle$1(element);
        if (elementCss.position === 'fixed') {
          return null;
        }
      }
      var currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.

    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
        return window;
      }
      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1));
    }
    function withinMaxClamp(min, value, max) {
      var v = within(min, value, max);
      return v > max ? max : v;
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };
    function arrow(_ref) {
      var _state$modifiersData$;
      var state = _ref.state,
        name = _ref.name,
        options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';
      if (!arrowElement || !popperOffsets) {
        return;
      }
      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }
    function effect$1(_ref2) {
      var state = _ref2.state,
        options = _ref2.options;
      var _options$element = options.element,
        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
      if (arrowElement == null) {
        return;
      } // CSS selector

      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
          return;
        }
      }
      if (!contains$1(state.elements.popper, arrowElement)) {
        return;
      }
      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules

    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref, win) {
      var x = _ref.x,
        y = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x * dpr) / dpr || 0,
        y: round(y * dpr) / dpr || 0
      };
    }
    function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper = _ref2.popper,
        popperRect = _ref2.popperRect,
        placement = _ref2.placement,
        variation = _ref2.variation,
        offsets = _ref2.offsets,
        position = _ref2.position,
        gpuAcceleration = _ref2.gpuAcceleration,
        adaptive = _ref2.adaptive,
        roundOffsets = _ref2.roundOffsets,
        isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x,
        x = _offsets$x === void 0 ? 0 : _offsets$x,
        _offsets$y = offsets.y,
        y = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };
      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';
        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);
          if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

        offsetParent = offsetParent;
        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp];
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp];
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
      }, getWindow(popper)) : {
        x: x,
        y: y
      };
      x = _ref4.x;
      y = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }
    function computeStyles(_ref5) {
      var state = _ref5.state,
        options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
        _options$adaptive = options.adaptive,
        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
        _options$roundOffsets = options.roundOffsets,
        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
      };
      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }
      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules

    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };
    function effect(_ref) {
      var state = _ref.state,
        instance = _ref.instance,
        options = _ref.options;
      var _options$scroll = options.scroll,
        scroll = _options$scroll === void 0 ? true : _options$scroll,
        _options$resize = options.resize,
        resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }
      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }
      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }
        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules

    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === 'fixed') {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }
      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;
      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;
      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }
      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
        overflow = _getComputedStyle.overflow,
        overflowX = _getComputedStyle.overflowX,
        overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }
      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }
      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;
      if (list === void 0) {
        list = [];
      }
      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList :
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === 'fixed');
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`

    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

      return clippingParents.filter(function (clippingParent) {
        return isElement(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents

    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
        element = _ref.element,
        placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;
        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;
        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;
        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';
        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;
          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }
      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options,
        _options$placement = _options.placement,
        placement = _options$placement === void 0 ? state.placement : _options$placement,
        _options$strategy = _options.strategy,
        strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
        _options$boundary = _options.boundary,
        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
        _options$rootBoundary = _options.rootBoundary,
        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
        _options$elementConte = _options.elementContext,
        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
        _options$altBoundary = _options.altBoundary,
        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
        _options$padding = _options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }
      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options,
        placement = _options.placement,
        boundary = _options.boundary,
        rootBoundary = _options.rootBoundary,
        padding = _options.padding,
        flipVariations = _options.flipVariations,
        _options$allowedAutoP = _options.allowedAutoPlacements,
        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    function flip(_ref) {
      var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
      if (state.modifiersData[name]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
        specifiedFallbackPlacements = options.fallbackPlacements,
        padding = options.padding,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        _options$flipVariatio = options.flipVariations,
        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
        allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];
      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);
            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
          if (_ret === "break") break;
        }
      }
      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules

    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }
    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }
    function hide(_ref) {
      var state = _ref.state,
        name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules

    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
          placement: placement
        })) : offset,
        skidding = _ref[0],
        distance = _ref[1];
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }
    function offset(_ref2) {
      var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
      var _options$offset = options.offset,
        offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
        x = _data$state$placement.x,
        y = _data$state$placement.y;
      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }
      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules

    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
        name = _ref.name;
      // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules

    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
      var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        padding = options.padding,
        _options$tether = options.tether,
        tether = _options$tether === void 0 ? true : _options$tether,
        _options$tetherOffset = options.tetherOffset,
        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };
      if (!popperOffsets) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min$1 = offset + overflow[mainSide];
        var max$1 = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === 'x' ? top : left;
        var _altSide = mainAxis === 'x' ? bottom : right;
        var _offset = popperOffsets[altAxis];
        var _len = altAxis === 'y' ? 'height' : 'width';
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules

    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.

    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' ||
        // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }
      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }
    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }
        return pending;
      };
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions,
        _generatorOptions$def = _generatorOptions.defaultModifiers,
        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
        _generatorOptions$def2 = _generatorOptions.defaultOptions,
        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }
        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(setOptionsAction) {
            var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            });
            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state.elements,
              reference = _state$elements.reference,
              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {
              return;
            } // Store the reference and popper rects to be read by modifiers

            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }
              var _state$orderedModifie = state.orderedModifiers[index],
                fn = _state$orderedModifie.fn,
                _state$orderedModifie2 = _state$orderedModifie.options,
                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                name = _state$orderedModifie.name;
              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements(reference, popper)) {
          return instance;
        }
        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref) {
            var name = _ref.name,
              _ref$options = _ref.options,
              options = _ref$options === void 0 ? {} : _ref$options,
              effect = _ref.effect;
            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });
              var noopFn = function noopFn() {};
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }
        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    function createPopperActions(initOptions) {
      let popperInstance = null;
      let referenceNode;
      let contentNode;
      let options = initOptions;
      const initPopper = () => {
        if (referenceNode !== undefined && contentNode !== undefined) {
          popperInstance = createPopper(referenceNode, contentNode, options);
        }
      };
      const deinitPopper = () => {
        if (popperInstance !== null) {
          popperInstance.destroy();
          popperInstance = null;
        }
      };
      const referenceAction = node => {
        if ('subscribe' in node) {
          setupVirtualElementObserver(node);
          return {};
        } else {
          referenceNode = node;
          initPopper();
          return {
            destroy() {
              deinitPopper();
            }
          };
        }
      };
      const setupVirtualElementObserver = node => {
        const unsubscribe = node.subscribe($node => {
          if (referenceNode === undefined) {
            referenceNode = $node;
            initPopper();
          } else {
            // Preserve the reference to the virtual element.
            Object.assign(referenceNode, $node);
            popperInstance?.update();
          }
        });
        onDestroy(unsubscribe);
      };
      const contentAction = (node, contentOptions) => {
        contentNode = node;
        options = {
          ...initOptions,
          ...contentOptions
        };
        initPopper();
        return {
          update(newContentOptions) {
            options = {
              ...initOptions,
              ...newContentOptions
            };
            popperInstance?.setOptions(options);
          },
          destroy() {
            deinitPopper();
          }
        };
      };
      return [referenceAction, contentAction, () => popperInstance];
    }

    /**
     * Fuse.js v6.6.2 - Lightweight fuzzy-search (http://fusejs.io)
     *
     * Copyright (c) 2022 Kiro Risk (http://kiro.me)
     * All Rights Reserved. Apache Software License 2.0
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     */

    function isArray$2(value) {
      return !Array.isArray ? getTag(value) === '[object Array]' : Array.isArray(value);
    }

    // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
    const INFINITY = 1 / 0;
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      let result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result;
    }
    function toString$1(value) {
      return value == null ? '' : baseToString(value);
    }
    function isString$1(value) {
      return typeof value === 'string';
    }
    function isNumber$1(value) {
      return typeof value === 'number';
    }

    // Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
    function isBoolean$1(value) {
      return value === true || value === false || isObjectLike(value) && getTag(value) == '[object Boolean]';
    }
    function isObject$1(value) {
      return typeof value === 'object';
    }

    // Checks if `value` is object-like.
    function isObjectLike(value) {
      return isObject$1(value) && value !== null;
    }
    function isDefined(value) {
      return value !== undefined && value !== null;
    }
    function isBlank(value) {
      return !value.trim().length;
    }

    // Gets the `toStringTag` of `value`.
    // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
    function getTag(value) {
      return value == null ? value === undefined ? '[object Undefined]' : '[object Null]' : Object.prototype.toString.call(value);
    }
    const EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';
    const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
    const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = key => `Invalid value for key ${key}`;
    const PATTERN_LENGTH_TOO_LARGE = max => `Pattern length exceeds max of ${max}.`;
    const MISSING_KEY_PROPERTY = name => `Missing ${name} property in key`;
    const INVALID_KEY_WEIGHT_VALUE = key => `Property 'weight' in key '${key}' must be a positive integer`;
    const hasOwn = Object.prototype.hasOwnProperty;
    class KeyStore {
      constructor(keys) {
        this._keys = [];
        this._keyMap = {};
        let totalWeight = 0;
        keys.forEach(key => {
          let obj = createKey(key);
          totalWeight += obj.weight;
          this._keys.push(obj);
          this._keyMap[obj.id] = obj;
          totalWeight += obj.weight;
        });

        // Normalize weights so that their sum is equal to 1
        this._keys.forEach(key => {
          key.weight /= totalWeight;
        });
      }
      get(keyId) {
        return this._keyMap[keyId];
      }
      keys() {
        return this._keys;
      }
      toJSON() {
        return JSON.stringify(this._keys);
      }
    }
    function createKey(key) {
      let path = null;
      let id = null;
      let src = null;
      let weight = 1;
      let getFn = null;
      if (isString$1(key) || isArray$2(key)) {
        src = key;
        path = createKeyPath(key);
        id = createKeyId(key);
      } else {
        if (!hasOwn.call(key, 'name')) {
          throw new Error(MISSING_KEY_PROPERTY('name'));
        }
        const name = key.name;
        src = name;
        if (hasOwn.call(key, 'weight')) {
          weight = key.weight;
          if (weight <= 0) {
            throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
          }
        }
        path = createKeyPath(name);
        id = createKeyId(name);
        getFn = key.getFn;
      }
      return {
        path,
        id,
        weight,
        src,
        getFn
      };
    }
    function createKeyPath(key) {
      return isArray$2(key) ? key : key.split('.');
    }
    function createKeyId(key) {
      return isArray$2(key) ? key.join('.') : key;
    }
    function get(obj, path) {
      let list = [];
      let arr = false;
      const deepGet = (obj, path, index) => {
        if (!isDefined(obj)) {
          return;
        }
        if (!path[index]) {
          // If there's no path left, we've arrived at the object we care about.
          list.push(obj);
        } else {
          let key = path[index];
          const value = obj[key];
          if (!isDefined(value)) {
            return;
          }

          // If we're at the last value in the path, and if it's a string/number/bool,
          // add it to the list
          if (index === path.length - 1 && (isString$1(value) || isNumber$1(value) || isBoolean$1(value))) {
            list.push(toString$1(value));
          } else if (isArray$2(value)) {
            arr = true;
            // Search each item in the array.
            for (let i = 0, len = value.length; i < len; i += 1) {
              deepGet(value[i], path, index + 1);
            }
          } else if (path.length) {
            // An object. Recurse further.
            deepGet(value, path, index + 1);
          }
        }
      };

      // Backwards compatibility (since path used to be a string)
      deepGet(obj, isString$1(path) ? path.split('.') : path, 0);
      return arr ? list : list[0];
    }
    const MatchOptions = {
      // Whether the matches should be included in the result set. When `true`, each record in the result
      // set will include the indices of the matched characters.
      // These can consequently be used for highlighting purposes.
      includeMatches: false,
      // When `true`, the matching function will continue to the end of a search pattern even if
      // a perfect match has already been located in the string.
      findAllMatches: false,
      // Minimum number of characters that must be matched before a result is considered a match
      minMatchCharLength: 1
    };
    const BasicOptions = {
      // When `true`, the algorithm continues searching to the end of the input even if a perfect
      // match is found before the end of the same input.
      isCaseSensitive: false,
      // When true, the matching function will continue to the end of a search pattern even if
      includeScore: false,
      // List of properties that will be searched. This also supports nested properties.
      keys: [],
      // Whether to sort the result list, by score
      shouldSort: true,
      // Default sort function: sort by ascending score, ascending index
      sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
    };
    const FuzzyOptions = {
      // Approximately where in the text is the pattern expected to be found?
      location: 0,
      // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
      // (of both letters and location), a threshold of '1.0' would match anything.
      threshold: 0.6,
      // Determines how close the match must be to the fuzzy location (specified above).
      // An exact letter match which is 'distance' characters away from the fuzzy location
      // would score as a complete mismatch. A distance of '0' requires the match be at
      // the exact location specified, a threshold of '1000' would require a perfect match
      // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
      distance: 100
    };
    const AdvancedOptions = {
      // When `true`, it enables the use of unix-like search commands
      useExtendedSearch: false,
      // The get function to use when fetching an object's properties.
      // The default will search nested paths *ie foo.bar.baz*
      getFn: get,
      // When `true`, search will ignore `location` and `distance`, so it won't matter
      // where in the string the pattern appears.
      // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
      ignoreLocation: false,
      // When `true`, the calculation for the relevance score (used for sorting) will
      // ignore the field-length norm.
      // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
      ignoreFieldNorm: false,
      // The weight to determine how much field length norm effects scoring.
      fieldNormWeight: 1
    };
    var Config = {
      ...BasicOptions,
      ...MatchOptions,
      ...FuzzyOptions,
      ...AdvancedOptions
    };
    const SPACE = /[^ ]+/g;

    // Field-length norm: the shorter the field, the higher the weight.
    // Set to 3 decimals to reduce index size.
    function norm(weight = 1, mantissa = 3) {
      const cache = new Map();
      const m = Math.pow(10, mantissa);
      return {
        get(value) {
          const numTokens = value.match(SPACE).length;
          if (cache.has(numTokens)) {
            return cache.get(numTokens);
          }

          // Default function is 1/sqrt(x), weight makes that variable
          const norm = 1 / Math.pow(numTokens, 0.5 * weight);

          // In place of `toFixed(mantissa)`, for faster computation
          const n = parseFloat(Math.round(norm * m) / m);
          cache.set(numTokens, n);
          return n;
        },
        clear() {
          cache.clear();
        }
      };
    }
    class FuseIndex {
      constructor({
        getFn = Config.getFn,
        fieldNormWeight = Config.fieldNormWeight
      } = {}) {
        this.norm = norm(fieldNormWeight, 3);
        this.getFn = getFn;
        this.isCreated = false;
        this.setIndexRecords();
      }
      setSources(docs = []) {
        this.docs = docs;
      }
      setIndexRecords(records = []) {
        this.records = records;
      }
      setKeys(keys = []) {
        this.keys = keys;
        this._keysMap = {};
        keys.forEach((key, idx) => {
          this._keysMap[key.id] = idx;
        });
      }
      create() {
        if (this.isCreated || !this.docs.length) {
          return;
        }
        this.isCreated = true;

        // List is Array<String>
        if (isString$1(this.docs[0])) {
          this.docs.forEach((doc, docIndex) => {
            this._addString(doc, docIndex);
          });
        } else {
          // List is Array<Object>
          this.docs.forEach((doc, docIndex) => {
            this._addObject(doc, docIndex);
          });
        }
        this.norm.clear();
      }
      // Adds a doc to the end of the index
      add(doc) {
        const idx = this.size();
        if (isString$1(doc)) {
          this._addString(doc, idx);
        } else {
          this._addObject(doc, idx);
        }
      }
      // Removes the doc at the specified index of the index
      removeAt(idx) {
        this.records.splice(idx, 1);

        // Change ref index of every subsquent doc
        for (let i = idx, len = this.size(); i < len; i += 1) {
          this.records[i].i -= 1;
        }
      }
      getValueForItemAtKeyId(item, keyId) {
        return item[this._keysMap[keyId]];
      }
      size() {
        return this.records.length;
      }
      _addString(doc, docIndex) {
        if (!isDefined(doc) || isBlank(doc)) {
          return;
        }
        let record = {
          v: doc,
          i: docIndex,
          n: this.norm.get(doc)
        };
        this.records.push(record);
      }
      _addObject(doc, docIndex) {
        let record = {
          i: docIndex,
          $: {}
        };

        // Iterate over every key (i.e, path), and fetch the value at that key
        this.keys.forEach((key, keyIndex) => {
          let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
          if (!isDefined(value)) {
            return;
          }
          if (isArray$2(value)) {
            let subRecords = [];
            const stack = [{
              nestedArrIndex: -1,
              value
            }];
            while (stack.length) {
              const {
                nestedArrIndex,
                value
              } = stack.pop();
              if (!isDefined(value)) {
                continue;
              }
              if (isString$1(value) && !isBlank(value)) {
                let subRecord = {
                  v: value,
                  i: nestedArrIndex,
                  n: this.norm.get(value)
                };
                subRecords.push(subRecord);
              } else if (isArray$2(value)) {
                value.forEach((item, k) => {
                  stack.push({
                    nestedArrIndex: k,
                    value: item
                  });
                });
              } else ;
            }
            record.$[keyIndex] = subRecords;
          } else if (isString$1(value) && !isBlank(value)) {
            let subRecord = {
              v: value,
              n: this.norm.get(value)
            };
            record.$[keyIndex] = subRecord;
          }
        });
        this.records.push(record);
      }
      toJSON() {
        return {
          keys: this.keys,
          records: this.records
        };
      }
    }
    function createIndex(keys, docs, {
      getFn = Config.getFn,
      fieldNormWeight = Config.fieldNormWeight
    } = {}) {
      const myIndex = new FuseIndex({
        getFn,
        fieldNormWeight
      });
      myIndex.setKeys(keys.map(createKey));
      myIndex.setSources(docs);
      myIndex.create();
      return myIndex;
    }
    function parseIndex(data, {
      getFn = Config.getFn,
      fieldNormWeight = Config.fieldNormWeight
    } = {}) {
      const {
        keys,
        records
      } = data;
      const myIndex = new FuseIndex({
        getFn,
        fieldNormWeight
      });
      myIndex.setKeys(keys);
      myIndex.setIndexRecords(records);
      return myIndex;
    }
    function computeScore$1(pattern, {
      errors = 0,
      currentLocation = 0,
      expectedLocation = 0,
      distance = Config.distance,
      ignoreLocation = Config.ignoreLocation
    } = {}) {
      const accuracy = errors / pattern.length;
      if (ignoreLocation) {
        return accuracy;
      }
      const proximity = Math.abs(expectedLocation - currentLocation);
      if (!distance) {
        // Dodge divide by zero error.
        return proximity ? 1.0 : accuracy;
      }
      return accuracy + proximity / distance;
    }
    function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
      let indices = [];
      let start = -1;
      let end = -1;
      let i = 0;
      for (let len = matchmask.length; i < len; i += 1) {
        let match = matchmask[i];
        if (match && start === -1) {
          start = i;
        } else if (!match && start !== -1) {
          end = i - 1;
          if (end - start + 1 >= minMatchCharLength) {
            indices.push([start, end]);
          }
          start = -1;
        }
      }

      // (i-1 - start) + 1 => i - start
      if (matchmask[i - 1] && i - start >= minMatchCharLength) {
        indices.push([start, i - 1]);
      }
      return indices;
    }

    // Machine word size
    const MAX_BITS = 32;
    function search(text, pattern, patternAlphabet, {
      location = Config.location,
      distance = Config.distance,
      threshold = Config.threshold,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      includeMatches = Config.includeMatches,
      ignoreLocation = Config.ignoreLocation
    } = {}) {
      if (pattern.length > MAX_BITS) {
        throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
      }
      const patternLen = pattern.length;
      // Set starting location at beginning text and initialize the alphabet.
      const textLen = text.length;
      // Handle the case when location > text.length
      const expectedLocation = Math.max(0, Math.min(location, textLen));
      // Highest score beyond which we give up.
      let currentThreshold = threshold;
      // Is there a nearby exact match? (speedup)
      let bestLocation = expectedLocation;

      // Performance: only computer matches when the minMatchCharLength > 1
      // OR if `includeMatches` is true.
      const computeMatches = minMatchCharLength > 1 || includeMatches;
      // A mask of the matches, used for building the indices
      const matchMask = computeMatches ? Array(textLen) : [];
      let index;

      // Get all exact matches, here for speed up
      while ((index = text.indexOf(pattern, bestLocation)) > -1) {
        let score = computeScore$1(pattern, {
          currentLocation: index,
          expectedLocation,
          distance,
          ignoreLocation
        });
        currentThreshold = Math.min(score, currentThreshold);
        bestLocation = index + patternLen;
        if (computeMatches) {
          let i = 0;
          while (i < patternLen) {
            matchMask[index + i] = 1;
            i += 1;
          }
        }
      }

      // Reset the best location
      bestLocation = -1;
      let lastBitArr = [];
      let finalScore = 1;
      let binMax = patternLen + textLen;
      const mask = 1 << patternLen - 1;
      for (let i = 0; i < patternLen; i += 1) {
        // Scan for the best match; each iteration allows for one more error.
        // Run a binary search to determine how far from the match location we can stray
        // at this error level.
        let binMin = 0;
        let binMid = binMax;
        while (binMin < binMid) {
          const score = computeScore$1(pattern, {
            errors: i,
            currentLocation: expectedLocation + binMid,
            expectedLocation,
            distance,
            ignoreLocation
          });
          if (score <= currentThreshold) {
            binMin = binMid;
          } else {
            binMax = binMid;
          }
          binMid = Math.floor((binMax - binMin) / 2 + binMin);
        }

        // Use the result from this iteration as the maximum for the next.
        binMax = binMid;
        let start = Math.max(1, expectedLocation - binMid + 1);
        let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;

        // Initialize the bit array
        let bitArr = Array(finish + 2);
        bitArr[finish + 1] = (1 << i) - 1;
        for (let j = finish; j >= start; j -= 1) {
          let currentLocation = j - 1;
          let charMatch = patternAlphabet[text.charAt(currentLocation)];
          if (computeMatches) {
            // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
            matchMask[currentLocation] = +!!charMatch;
          }

          // First pass: exact match
          bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;

          // Subsequent passes: fuzzy match
          if (i) {
            bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
          }
          if (bitArr[j] & mask) {
            finalScore = computeScore$1(pattern, {
              errors: i,
              currentLocation,
              expectedLocation,
              distance,
              ignoreLocation
            });

            // This match will almost certainly be better than any existing match.
            // But check anyway.
            if (finalScore <= currentThreshold) {
              // Indeed it is
              currentThreshold = finalScore;
              bestLocation = currentLocation;

              // Already passed `loc`, downhill from here on in.
              if (bestLocation <= expectedLocation) {
                break;
              }

              // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
              start = Math.max(1, 2 * expectedLocation - bestLocation);
            }
          }
        }

        // No hope for a (better) match at greater error levels.
        const score = computeScore$1(pattern, {
          errors: i + 1,
          currentLocation: expectedLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (score > currentThreshold) {
          break;
        }
        lastBitArr = bitArr;
      }
      const result = {
        isMatch: bestLocation >= 0,
        // Count exact matches (those with a score of 0) to be "almost" exact
        score: Math.max(0.001, finalScore)
      };
      if (computeMatches) {
        const indices = convertMaskToIndices(matchMask, minMatchCharLength);
        if (!indices.length) {
          result.isMatch = false;
        } else if (includeMatches) {
          result.indices = indices;
        }
      }
      return result;
    }
    function createPatternAlphabet(pattern) {
      let mask = {};
      for (let i = 0, len = pattern.length; i < len; i += 1) {
        const char = pattern.charAt(i);
        mask[char] = (mask[char] || 0) | 1 << len - i - 1;
      }
      return mask;
    }
    class BitapSearch {
      constructor(pattern, {
        location = Config.location,
        threshold = Config.threshold,
        distance = Config.distance,
        includeMatches = Config.includeMatches,
        findAllMatches = Config.findAllMatches,
        minMatchCharLength = Config.minMatchCharLength,
        isCaseSensitive = Config.isCaseSensitive,
        ignoreLocation = Config.ignoreLocation
      } = {}) {
        this.options = {
          location,
          threshold,
          distance,
          includeMatches,
          findAllMatches,
          minMatchCharLength,
          isCaseSensitive,
          ignoreLocation
        };
        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
        this.chunks = [];
        if (!this.pattern.length) {
          return;
        }
        const addChunk = (pattern, startIndex) => {
          this.chunks.push({
            pattern,
            alphabet: createPatternAlphabet(pattern),
            startIndex
          });
        };
        const len = this.pattern.length;
        if (len > MAX_BITS) {
          let i = 0;
          const remainder = len % MAX_BITS;
          const end = len - remainder;
          while (i < end) {
            addChunk(this.pattern.substr(i, MAX_BITS), i);
            i += MAX_BITS;
          }
          if (remainder) {
            const startIndex = len - MAX_BITS;
            addChunk(this.pattern.substr(startIndex), startIndex);
          }
        } else {
          addChunk(this.pattern, 0);
        }
      }
      searchIn(text) {
        const {
          isCaseSensitive,
          includeMatches
        } = this.options;
        if (!isCaseSensitive) {
          text = text.toLowerCase();
        }

        // Exact match
        if (this.pattern === text) {
          let result = {
            isMatch: true,
            score: 0
          };
          if (includeMatches) {
            result.indices = [[0, text.length - 1]];
          }
          return result;
        }

        // Otherwise, use Bitap algorithm
        const {
          location,
          distance,
          threshold,
          findAllMatches,
          minMatchCharLength,
          ignoreLocation
        } = this.options;
        let allIndices = [];
        let totalScore = 0;
        let hasMatches = false;
        this.chunks.forEach(({
          pattern,
          alphabet,
          startIndex
        }) => {
          const {
            isMatch,
            score,
            indices
          } = search(text, pattern, alphabet, {
            location: location + startIndex,
            distance,
            threshold,
            findAllMatches,
            minMatchCharLength,
            includeMatches,
            ignoreLocation
          });
          if (isMatch) {
            hasMatches = true;
          }
          totalScore += score;
          if (isMatch && indices) {
            allIndices = [...allIndices, ...indices];
          }
        });
        let result = {
          isMatch: hasMatches,
          score: hasMatches ? totalScore / this.chunks.length : 1
        };
        if (hasMatches && includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    class BaseMatch {
      constructor(pattern) {
        this.pattern = pattern;
      }
      static isMultiMatch(pattern) {
        return getMatch(pattern, this.multiRegex);
      }
      static isSingleMatch(pattern) {
        return getMatch(pattern, this.singleRegex);
      }
      search( /*text*/) {}
    }
    function getMatch(pattern, exp) {
      const matches = pattern.match(exp);
      return matches ? matches[1] : null;
    }

    // Token: 'file

    class ExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'exact';
      }
      static get multiRegex() {
        return /^="(.*)"$/;
      }
      static get singleRegex() {
        return /^=(.*)$/;
      }
      search(text) {
        const isMatch = text === this.pattern;
        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }

    // Token: !fire

    class InverseExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'inverse-exact';
      }
      static get multiRegex() {
        return /^!"(.*)"$/;
      }
      static get singleRegex() {
        return /^!(.*)$/;
      }
      search(text) {
        const index = text.indexOf(this.pattern);
        const isMatch = index === -1;
        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }

    // Token: ^file

    class PrefixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'prefix-exact';
      }
      static get multiRegex() {
        return /^\^"(.*)"$/;
      }
      static get singleRegex() {
        return /^\^(.*)$/;
      }
      search(text) {
        const isMatch = text.startsWith(this.pattern);
        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }

    // Token: !^fire

    class InversePrefixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'inverse-prefix-exact';
      }
      static get multiRegex() {
        return /^!\^"(.*)"$/;
      }
      static get singleRegex() {
        return /^!\^(.*)$/;
      }
      search(text) {
        const isMatch = !text.startsWith(this.pattern);
        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }

    // Token: .file$

    class SuffixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'suffix-exact';
      }
      static get multiRegex() {
        return /^"(.*)"\$$/;
      }
      static get singleRegex() {
        return /^(.*)\$$/;
      }
      search(text) {
        const isMatch = text.endsWith(this.pattern);
        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [text.length - this.pattern.length, text.length - 1]
        };
      }
    }

    // Token: !.file$

    class InverseSuffixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'inverse-suffix-exact';
      }
      static get multiRegex() {
        return /^!"(.*)"\$$/;
      }
      static get singleRegex() {
        return /^!(.*)\$$/;
      }
      search(text) {
        const isMatch = !text.endsWith(this.pattern);
        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }
    class FuzzyMatch extends BaseMatch {
      constructor(pattern, {
        location = Config.location,
        threshold = Config.threshold,
        distance = Config.distance,
        includeMatches = Config.includeMatches,
        findAllMatches = Config.findAllMatches,
        minMatchCharLength = Config.minMatchCharLength,
        isCaseSensitive = Config.isCaseSensitive,
        ignoreLocation = Config.ignoreLocation
      } = {}) {
        super(pattern);
        this._bitapSearch = new BitapSearch(pattern, {
          location,
          threshold,
          distance,
          includeMatches,
          findAllMatches,
          minMatchCharLength,
          isCaseSensitive,
          ignoreLocation
        });
      }
      static get type() {
        return 'fuzzy';
      }
      static get multiRegex() {
        return /^"(.*)"$/;
      }
      static get singleRegex() {
        return /^(.*)$/;
      }
      search(text) {
        return this._bitapSearch.searchIn(text);
      }
    }

    // Token: 'file

    class IncludeMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'include';
      }
      static get multiRegex() {
        return /^'"(.*)"$/;
      }
      static get singleRegex() {
        return /^'(.*)$/;
      }
      search(text) {
        let location = 0;
        let index;
        const indices = [];
        const patternLen = this.pattern.length;

        // Get all exact matches
        while ((index = text.indexOf(this.pattern, location)) > -1) {
          location = index + patternLen;
          indices.push([index, location - 1]);
        }
        const isMatch = !!indices.length;
        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices
        };
      }
    }

    // ❗Order is important. DO NOT CHANGE.
    const searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];
    const searchersLen = searchers.length;

    // Regex to split by spaces, but keep anything in quotes together
    const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
    const OR_TOKEN = '|';

    // Return a 2D array representation of the query, for simpler parsing.
    // Example:
    // "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
    function parseQuery(pattern, options = {}) {
      return pattern.split(OR_TOKEN).map(item => {
        let query = item.trim().split(SPACE_RE).filter(item => item && !!item.trim());
        let results = [];
        for (let i = 0, len = query.length; i < len; i += 1) {
          const queryItem = query[i];

          // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
          let found = false;
          let idx = -1;
          while (!found && ++idx < searchersLen) {
            const searcher = searchers[idx];
            let token = searcher.isMultiMatch(queryItem);
            if (token) {
              results.push(new searcher(token, options));
              found = true;
            }
          }
          if (found) {
            continue;
          }

          // 2. Handle single query matches (i.e, once that are *not* quoted)
          idx = -1;
          while (++idx < searchersLen) {
            const searcher = searchers[idx];
            let token = searcher.isSingleMatch(queryItem);
            if (token) {
              results.push(new searcher(token, options));
              break;
            }
          }
        }
        return results;
      });
    }

    // These extended matchers can return an array of matches, as opposed
    // to a singl match
    const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

    /**
     * Command-like searching
     * ======================
     *
     * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
     * search in a given text.
     *
     * Search syntax:
     *
     * | Token       | Match type                 | Description                            |
     * | ----------- | -------------------------- | -------------------------------------- |
     * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
     * | `=scheme`   | exact-match                | Items that are `scheme`                |
     * | `'python`   | include-match              | Items that include `python`            |
     * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
     * | `^java`     | prefix-exact-match         | Items that start with `java`           |
     * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
     * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
     * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
     *
     * A single pipe character acts as an OR operator. For example, the following
     * query matches entries that start with `core` and end with either`go`, `rb`,
     * or`py`.
     *
     * ```
     * ^core go$ | rb$ | py$
     * ```
     */
    class ExtendedSearch {
      constructor(pattern, {
        isCaseSensitive = Config.isCaseSensitive,
        includeMatches = Config.includeMatches,
        minMatchCharLength = Config.minMatchCharLength,
        ignoreLocation = Config.ignoreLocation,
        findAllMatches = Config.findAllMatches,
        location = Config.location,
        threshold = Config.threshold,
        distance = Config.distance
      } = {}) {
        this.query = null;
        this.options = {
          isCaseSensitive,
          includeMatches,
          minMatchCharLength,
          findAllMatches,
          ignoreLocation,
          location,
          threshold,
          distance
        };
        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
        this.query = parseQuery(this.pattern, this.options);
      }
      static condition(_, options) {
        return options.useExtendedSearch;
      }
      searchIn(text) {
        const query = this.query;
        if (!query) {
          return {
            isMatch: false,
            score: 1
          };
        }
        const {
          includeMatches,
          isCaseSensitive
        } = this.options;
        text = isCaseSensitive ? text : text.toLowerCase();
        let numMatches = 0;
        let allIndices = [];
        let totalScore = 0;

        // ORs
        for (let i = 0, qLen = query.length; i < qLen; i += 1) {
          const searchers = query[i];

          // Reset indices
          allIndices.length = 0;
          numMatches = 0;

          // ANDs
          for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {
            const searcher = searchers[j];
            const {
              isMatch,
              indices,
              score
            } = searcher.search(text);
            if (isMatch) {
              numMatches += 1;
              totalScore += score;
              if (includeMatches) {
                const type = searcher.constructor.type;
                if (MultiMatchSet.has(type)) {
                  allIndices = [...allIndices, ...indices];
                } else {
                  allIndices.push(indices);
                }
              }
            } else {
              totalScore = 0;
              numMatches = 0;
              allIndices.length = 0;
              break;
            }
          }

          // OR condition, so if TRUE, return
          if (numMatches) {
            let result = {
              isMatch: true,
              score: totalScore / numMatches
            };
            if (includeMatches) {
              result.indices = allIndices;
            }
            return result;
          }
        }

        // Nothing was matched
        return {
          isMatch: false,
          score: 1
        };
      }
    }
    const registeredSearchers = [];
    function register(...args) {
      registeredSearchers.push(...args);
    }
    function createSearcher(pattern, options) {
      for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
        let searcherClass = registeredSearchers[i];
        if (searcherClass.condition(pattern, options)) {
          return new searcherClass(pattern, options);
        }
      }
      return new BitapSearch(pattern, options);
    }
    const LogicalOperator = {
      AND: '$and',
      OR: '$or'
    };
    const KeyType = {
      PATH: '$path',
      PATTERN: '$val'
    };
    const isExpression = query => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
    const isPath = query => !!query[KeyType.PATH];
    const isLeaf = query => !isArray$2(query) && isObject$1(query) && !isExpression(query);
    const convertToExplicit = query => ({
      [LogicalOperator.AND]: Object.keys(query).map(key => ({
        [key]: query[key]
      }))
    });

    // When `auto` is `true`, the parse function will infer and initialize and add
    // the appropriate `Searcher` instance
    function parse$2(query, options, {
      auto = true
    } = {}) {
      const next = query => {
        let keys = Object.keys(query);
        const isQueryPath = isPath(query);
        if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
          return next(convertToExplicit(query));
        }
        if (isLeaf(query)) {
          const key = isQueryPath ? query[KeyType.PATH] : keys[0];
          const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];
          if (!isString$1(pattern)) {
            throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
          }
          const obj = {
            keyId: createKeyId(key),
            pattern
          };
          if (auto) {
            obj.searcher = createSearcher(pattern, options);
          }
          return obj;
        }
        let node = {
          children: [],
          operator: keys[0]
        };
        keys.forEach(key => {
          const value = query[key];
          if (isArray$2(value)) {
            value.forEach(item => {
              node.children.push(next(item));
            });
          }
        });
        return node;
      };
      if (!isExpression(query)) {
        query = convertToExplicit(query);
      }
      return next(query);
    }

    // Practical scoring function
    function computeScore(results, {
      ignoreFieldNorm = Config.ignoreFieldNorm
    }) {
      results.forEach(result => {
        let totalScore = 1;
        result.matches.forEach(({
          key,
          norm,
          score
        }) => {
          const weight = key ? key.weight : null;
          totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));
        });
        result.score = totalScore;
      });
    }
    function transformMatches(result, data) {
      const matches = result.matches;
      data.matches = [];
      if (!isDefined(matches)) {
        return;
      }
      matches.forEach(match => {
        if (!isDefined(match.indices) || !match.indices.length) {
          return;
        }
        const {
          indices,
          value
        } = match;
        let obj = {
          indices,
          value
        };
        if (match.key) {
          obj.key = match.key.src;
        }
        if (match.idx > -1) {
          obj.refIndex = match.idx;
        }
        data.matches.push(obj);
      });
    }
    function transformScore(result, data) {
      data.score = result.score;
    }
    function format$1(results, docs, {
      includeMatches = Config.includeMatches,
      includeScore = Config.includeScore
    } = {}) {
      const transformers = [];
      if (includeMatches) transformers.push(transformMatches);
      if (includeScore) transformers.push(transformScore);
      return results.map(result => {
        const {
          idx
        } = result;
        const data = {
          item: docs[idx],
          refIndex: idx
        };
        if (transformers.length) {
          transformers.forEach(transformer => {
            transformer(result, data);
          });
        }
        return data;
      });
    }
    class Fuse {
      constructor(docs, options = {}, index) {
        this.options = {
          ...Config,
          ...options
        };
        if (this.options.useExtendedSearch && !true) {
          throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
        }
        this._keyStore = new KeyStore(this.options.keys);
        this.setCollection(docs, index);
      }
      setCollection(docs, index) {
        this._docs = docs;
        if (index && !(index instanceof FuseIndex)) {
          throw new Error(INCORRECT_INDEX_TYPE);
        }
        this._myIndex = index || createIndex(this.options.keys, this._docs, {
          getFn: this.options.getFn,
          fieldNormWeight: this.options.fieldNormWeight
        });
      }
      add(doc) {
        if (!isDefined(doc)) {
          return;
        }
        this._docs.push(doc);
        this._myIndex.add(doc);
      }
      remove(predicate = ( /* doc, idx */) => false) {
        const results = [];
        for (let i = 0, len = this._docs.length; i < len; i += 1) {
          const doc = this._docs[i];
          if (predicate(doc, i)) {
            this.removeAt(i);
            i -= 1;
            len -= 1;
            results.push(doc);
          }
        }
        return results;
      }
      removeAt(idx) {
        this._docs.splice(idx, 1);
        this._myIndex.removeAt(idx);
      }
      getIndex() {
        return this._myIndex;
      }
      search(query, {
        limit = -1
      } = {}) {
        const {
          includeMatches,
          includeScore,
          shouldSort,
          sortFn,
          ignoreFieldNorm
        } = this.options;
        let results = isString$1(query) ? isString$1(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
        computeScore(results, {
          ignoreFieldNorm
        });
        if (shouldSort) {
          results.sort(sortFn);
        }
        if (isNumber$1(limit) && limit > -1) {
          results = results.slice(0, limit);
        }
        return format$1(results, this._docs, {
          includeMatches,
          includeScore
        });
      }
      _searchStringList(query) {
        const searcher = createSearcher(query, this.options);
        const {
          records
        } = this._myIndex;
        const results = [];

        // Iterate over every string in the index
        records.forEach(({
          v: text,
          i: idx,
          n: norm
        }) => {
          if (!isDefined(text)) {
            return;
          }
          const {
            isMatch,
            score,
            indices
          } = searcher.searchIn(text);
          if (isMatch) {
            results.push({
              item: text,
              idx,
              matches: [{
                score,
                value: text,
                norm,
                indices
              }]
            });
          }
        });
        return results;
      }
      _searchLogical(query) {
        const expression = parse$2(query, this.options);
        const evaluate = (node, item, idx) => {
          if (!node.children) {
            const {
              keyId,
              searcher
            } = node;
            const matches = this._findMatches({
              key: this._keyStore.get(keyId),
              value: this._myIndex.getValueForItemAtKeyId(item, keyId),
              searcher
            });
            if (matches && matches.length) {
              return [{
                idx,
                item,
                matches
              }];
            }
            return [];
          }
          const res = [];
          for (let i = 0, len = node.children.length; i < len; i += 1) {
            const child = node.children[i];
            const result = evaluate(child, item, idx);
            if (result.length) {
              res.push(...result);
            } else if (node.operator === LogicalOperator.AND) {
              return [];
            }
          }
          return res;
        };
        const records = this._myIndex.records;
        const resultMap = {};
        const results = [];
        records.forEach(({
          $: item,
          i: idx
        }) => {
          if (isDefined(item)) {
            let expResults = evaluate(expression, item, idx);
            if (expResults.length) {
              // Dedupe when adding
              if (!resultMap[idx]) {
                resultMap[idx] = {
                  idx,
                  item,
                  matches: []
                };
                results.push(resultMap[idx]);
              }
              expResults.forEach(({
                matches
              }) => {
                resultMap[idx].matches.push(...matches);
              });
            }
          }
        });
        return results;
      }
      _searchObjectList(query) {
        const searcher = createSearcher(query, this.options);
        const {
          keys,
          records
        } = this._myIndex;
        const results = [];

        // List is Array<Object>
        records.forEach(({
          $: item,
          i: idx
        }) => {
          if (!isDefined(item)) {
            return;
          }
          let matches = [];

          // Iterate over every key (i.e, path), and fetch the value at that key
          keys.forEach((key, keyIndex) => {
            matches.push(...this._findMatches({
              key,
              value: item[keyIndex],
              searcher
            }));
          });
          if (matches.length) {
            results.push({
              idx,
              item,
              matches
            });
          }
        });
        return results;
      }
      _findMatches({
        key,
        value,
        searcher
      }) {
        if (!isDefined(value)) {
          return [];
        }
        let matches = [];
        if (isArray$2(value)) {
          value.forEach(({
            v: text,
            i: idx,
            n: norm
          }) => {
            if (!isDefined(text)) {
              return;
            }
            const {
              isMatch,
              score,
              indices
            } = searcher.searchIn(text);
            if (isMatch) {
              matches.push({
                score,
                key,
                value: text,
                idx,
                norm,
                indices
              });
            }
          });
        } else {
          const {
            v: text,
            n: norm
          } = value;
          const {
            isMatch,
            score,
            indices
          } = searcher.searchIn(text);
          if (isMatch) {
            matches.push({
              score,
              key,
              value: text,
              norm,
              indices
            });
          }
        }
        return matches;
      }
    }
    Fuse.version = '6.6.2';
    Fuse.createIndex = createIndex;
    Fuse.parseIndex = parseIndex;
    Fuse.config = Config;
    {
      Fuse.parseQuery = parse$2;
    }
    {
      register(ExtendedSearch);
    }

    function get_each_context$1(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[83] = list[i];
      return child_ctx;
    }
    function get_each_context_1$1(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[86] = list[i];
      return child_ctx;
    }
    function get_each_context_2$1(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[89] = list[i];
      child_ctx[90] = list;
      child_ctx[91] = i;
      return child_ctx;
    }
    function get_each_context_3(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[92] = list[i];
      child_ctx[93] = list;
      child_ctx[94] = i;
      return child_ctx;
    }
    function get_each_context_4(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[95] = list[i];
      child_ctx[96] = list;
      child_ctx[94] = i;
      return child_ctx;
    }

    // (429:2) {#if showNoteAutosuggest && noteAutosuggestList?.length}
    function create_if_block_7(ctx) {
      var div;
      var ul;
      var mounted;
      var dispose;
      var each_value_4 = ensure_array_like( /*noteAutosuggestList*/ctx[5]);
      var each_blocks = [];
      for (var i = 0; i < each_value_4.length; i += 1) {
        each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
      }
      return {
        c() {
          div = element("div");
          ul = element("ul");
          for (var _i = 0; _i < each_blocks.length; _i += 1) {
            each_blocks[_i].c();
          }
          attr(ul, "class", "result");
          attr(div, "class", "note-autosuggest popover");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          append(div, ul);
          for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
            if (each_blocks[_i2]) {
              each_blocks[_i2].m(ul, null);
            }
          }
          if (!mounted) {
            dispose = action_destroyer(/*noteSuggestPopperContent*/ctx[29].call(null, div, /*extraOpts*/ctx[25]));
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*noteAutosuggestButtons, noteAutosuggestList, note, duration, selected, showNoteAutosuggest, currentFocusNoteIndex*/4458722) {
            each_value_4 = ensure_array_like( /*noteAutosuggestList*/ctx[5]);
            var _i3;
            for (_i3 = 0; _i3 < each_value_4.length; _i3 += 1) {
              var child_ctx = get_each_context_4(ctx, each_value_4, _i3);
              if (each_blocks[_i3]) {
                each_blocks[_i3].p(child_ctx, dirty);
              } else {
                each_blocks[_i3] = create_each_block_4(child_ctx);
                each_blocks[_i3].c();
                each_blocks[_i3].m(ul, null);
              }
            }
            for (; _i3 < each_blocks.length; _i3 += 1) {
              each_blocks[_i3].d(1);
            }
            each_blocks.length = each_value_4.length;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          destroy_each(each_blocks, detaching);
          mounted = false;
          dispose();
        }
      };
    }

    // (432:5) {#each noteAutosuggestList as suggestion, index}
    function create_each_block_4(ctx) {
      var _ctx$95$time$note, _ctx$, _ctx$95$client$name, _ctx$2, _ctx$95$project$name, _ctx$3, _ctx$95$task$name, _ctx$4;
      var li;
      var a;
      var t0_value = ( /*suggestion*/(_ctx$95$time$note = (_ctx$ = ctx[95]) === null || _ctx$ === void 0 || (_ctx$ = _ctx$.time) === null || _ctx$ === void 0 ? void 0 : _ctx$.note) !== null && _ctx$95$time$note !== void 0 ? _ctx$95$time$note : "") + "";
      var t0;
      var t1;
      var t2_value = ( /*suggestion*/(_ctx$95$client$name = (_ctx$2 = ctx[95]) === null || _ctx$2 === void 0 || (_ctx$2 = _ctx$2.client) === null || _ctx$2 === void 0 ? void 0 : _ctx$2.name) !== null && _ctx$95$client$name !== void 0 ? _ctx$95$client$name : "") + "";
      var t2;
      var t3;
      var t4_value = ( /*suggestion*/(_ctx$95$project$name = (_ctx$3 = ctx[95]) === null || _ctx$3 === void 0 || (_ctx$3 = _ctx$3.project) === null || _ctx$3 === void 0 ? void 0 : _ctx$3.name) !== null && _ctx$95$project$name !== void 0 ? _ctx$95$project$name : "") + "";
      var t4;
      var t5;
      var t6_value = ( /*suggestion*/(_ctx$95$task$name = (_ctx$4 = ctx[95]) === null || _ctx$4 === void 0 || (_ctx$4 = _ctx$4.task) === null || _ctx$4 === void 0 ? void 0 : _ctx$4.name) !== null && _ctx$95$task$name !== void 0 ? _ctx$95$task$name : "") + "";
      var t6;
      var t7;
      var index = /*index*/ctx[94];
      var t8;
      var mounted;
      var dispose;
      var assign_a = function assign_a() {
        return (/*a_binding*/ctx[49](a, index)
        );
      };
      var unassign_a = function unassign_a() {
        return (/*a_binding*/ctx[49](null, index)
        );
      };
      function click_handler_1() {
        var _ctx;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (/*click_handler_1*/(_ctx = ctx)[50].apply(_ctx, [/*suggestion*/ctx[95]].concat(args))
        );
      }
      function focus_handler_1() {
        return (/*focus_handler_1*/ctx[51]( /*index*/ctx[94])
        );
      }
      return {
        c() {
          li = element("li");
          a = element("a");
          t0 = text$1(t0_value);
          t1 = text$1(" (");
          t2 = text$1(t2_value);
          t3 = text$1(" › ");
          t4 = text$1(t4_value);
          t5 = text$1(" › ");
          t6 = text$1(t6_value);
          t7 = text$1(")");
          t8 = space$1();
          attr(a, "class", "task");
          attr(a, "href", "?");
          attr(a, "tabindex", -1);
        },
        m(target, anchor) {
          insert(target, li, anchor);
          append(li, a);
          append(a, t0);
          append(a, t1);
          append(a, t2);
          append(a, t3);
          append(a, t4);
          append(a, t5);
          append(a, t6);
          append(a, t7);
          assign_a();
          append(li, t8);
          if (!mounted) {
            dispose = [listen(a, "click", click_handler_1), listen(a, "focus", focus_handler_1)];
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          var _ctx$95$time$note2, _ctx$5, _ctx$95$client$name2, _ctx$6, _ctx$95$project$name2, _ctx$7, _ctx$95$task$name2, _ctx$8;
          ctx = new_ctx;
          if (dirty[0] & /*noteAutosuggestList*/32 && t0_value !== (t0_value = ( /*suggestion*/(_ctx$95$time$note2 = (_ctx$5 = ctx[95]) === null || _ctx$5 === void 0 || (_ctx$5 = _ctx$5.time) === null || _ctx$5 === void 0 ? void 0 : _ctx$5.note) !== null && _ctx$95$time$note2 !== void 0 ? _ctx$95$time$note2 : "") + "")) set_data(t0, t0_value);
          if (dirty[0] & /*noteAutosuggestList*/32 && t2_value !== (t2_value = ( /*suggestion*/(_ctx$95$client$name2 = (_ctx$6 = ctx[95]) === null || _ctx$6 === void 0 || (_ctx$6 = _ctx$6.client) === null || _ctx$6 === void 0 ? void 0 : _ctx$6.name) !== null && _ctx$95$client$name2 !== void 0 ? _ctx$95$client$name2 : "") + "")) set_data(t2, t2_value);
          if (dirty[0] & /*noteAutosuggestList*/32 && t4_value !== (t4_value = ( /*suggestion*/(_ctx$95$project$name2 = (_ctx$7 = ctx[95]) === null || _ctx$7 === void 0 || (_ctx$7 = _ctx$7.project) === null || _ctx$7 === void 0 ? void 0 : _ctx$7.name) !== null && _ctx$95$project$name2 !== void 0 ? _ctx$95$project$name2 : "") + "")) set_data(t4, t4_value);
          if (dirty[0] & /*noteAutosuggestList*/32 && t6_value !== (t6_value = ( /*suggestion*/(_ctx$95$task$name2 = (_ctx$8 = ctx[95]) === null || _ctx$8 === void 0 || (_ctx$8 = _ctx$8.task) === null || _ctx$8 === void 0 ? void 0 : _ctx$8.name) !== null && _ctx$95$task$name2 !== void 0 ? _ctx$95$task$name2 : "") + "")) set_data(t6, t6_value);
          if (index !== /*index*/ctx[94]) {
            unassign_a();
            index = /*index*/ctx[94];
            assign_a();
          }
        },
        d(detaching) {
          if (detaching) {
            detach(li);
          }
          unassign_a();
          mounted = false;
          run_all(dispose);
        }
      };
    }

    // (497:1) {#if showDurationSelector}
    function create_if_block_6$1(ctx) {
      var div;
      var span1;
      var label0;
      var html_tag;
      var raw0_value = translate("timemanager", "Duration (in hrs.)") + "";
      var t0;
      var input0;
      var t1;
      var span0;
      var label1;
      var html_tag_1;
      var raw1_value = translate("timemanager", "Start time") + "";
      var t2;
      var input1;
      var t3;
      var label2;
      var html_tag_2;
      var raw2_value = translate("timemanager", "End time") + "";
      var t4;
      var input2;
      var t5;
      var label3;
      var html_tag_3;
      var raw3_value = translate("timemanager", "Date") + "";
      var t6;
      var input3;
      var mounted;
      var dispose;
      return {
        c() {
          div = element("div");
          span1 = element("span");
          label0 = element("label");
          html_tag = new HtmlTag(false);
          t0 = space$1();
          input0 = element("input");
          t1 = space$1();
          span0 = element("span");
          label1 = element("label");
          html_tag_1 = new HtmlTag(false);
          t2 = space$1();
          input1 = element("input");
          t3 = space$1();
          label2 = element("label");
          html_tag_2 = new HtmlTag(false);
          t4 = space$1();
          input2 = element("input");
          t5 = space$1();
          label3 = element("label");
          html_tag_3 = new HtmlTag(false);
          t6 = space$1();
          input3 = element("input");
          html_tag.a = t0;
          attr(input0, "id", "quick-add-time");
          attr(input0, "type", "text");
          attr(input0, "name", "duration");
          attr(input0, "placeholder", "");
          attr(input0, "class", "duration-input");
          html_tag_1.a = t2;
          attr(input1, "type", "time");
          attr(input1, "name", "startTime");
          attr(input1, "placeholder", "--:--");
          attr(input1, "class", "time-input");
          attr(input1, "pattern", "[0-9]" + 2 + ":[0-9]" + 2);
          input1.required = true;
          attr(input1, "data-hideevent", "skip");
          html_tag_2.a = t4;
          attr(input2, "type", "time");
          attr(input2, "name", "endTime");
          attr(input2, "placeholder", "--:--");
          attr(input2, "class", "time-input");
          attr(input2, "pattern", "[0-9]" + 2 + ":[0-9]" + 2);
          input2.required = true;
          attr(input2, "data-hideevent", "skip");
          attr(span0, "class", "flex-fields");
          attr(span1, "class", "flex-fields");
          html_tag_3.a = t6;
          attr(input3, "type", "date");
          attr(input3, "name", "date");
          attr(input3, "class", "date-input");
          attr(input3, "data-hideevent", "skip");
          attr(div, "class", "duration-selector-popover popover");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          append(div, span1);
          append(span1, label0);
          html_tag.m(raw0_value, label0);
          append(label0, t0);
          append(label0, input0);
          set_input_value(input0, /*duration*/ctx[7]);
          /*input0_binding_1*/
          ctx[55](input0);
          append(span1, t1);
          append(span1, span0);
          append(span0, label1);
          html_tag_1.m(raw1_value, label1);
          append(label1, t2);
          append(label1, input1);
          set_input_value(input1, /*startTime*/ctx[8]);
          append(span0, t3);
          append(span0, label2);
          html_tag_2.m(raw2_value, label2);
          append(label2, t4);
          append(label2, input2);
          set_input_value(input2, /*endTime*/ctx[9]);
          append(div, t5);
          append(div, label3);
          html_tag_3.m(raw3_value, label3);
          append(label3, t6);
          append(label3, input3);
          set_input_value(input3, /*date*/ctx[10]);
          if (!mounted) {
            dispose = [listen(input0, "input", /*input0_input_handler_1*/ctx[53]), listen(input0, "input", /*input_handler_1*/ctx[54]), listen(input1, "input", /*input1_input_handler*/ctx[56]), listen(input1, "input", /*input_handler_2*/ctx[57]), listen(input2, "input", /*input2_input_handler*/ctx[58]), listen(input2, "input", /*input_handler_3*/ctx[59]), listen(input3, "input", /*input3_input_handler*/ctx[60]), listen(input3, "blur", /*blur_handler*/ctx[61]), action_destroyer(/*durationSelectorPopperContent*/ctx[31].call(null, div, /*extraOpts*/ctx[25])), listen(div, "click", click_handler_2), listen(div, "keypress", keypress_handler)];
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*duration*/128 && input0.value !== /*duration*/ctx[7]) {
            set_input_value(input0, /*duration*/ctx[7]);
          }
          if (dirty[0] & /*startTime*/256) {
            set_input_value(input1, /*startTime*/ctx[8]);
          }
          if (dirty[0] & /*endTime*/512) {
            set_input_value(input2, /*endTime*/ctx[9]);
          }
          if (dirty[0] & /*date*/1024) {
            set_input_value(input3, /*date*/ctx[10]);
          }
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }

          /*input0_binding_1*/
          ctx[55](null);
          mounted = false;
          run_all(dispose);
        }
      };
    }

    // (605:2) {:else}
    function create_else_block(ctx) {
      var t0_value = translate("timemanager", "Client, project or task") + "";
      var t0;
      var t1;
      var input;
      var input_value_value;
      var input_title_value;
      var mounted;
      var dispose;
      return {
        c() {
          t0 = text$1(t0_value);
          t1 = space$1();
          input = element("input");
          attr(input, "data-hideevent", "skip");
          attr(input, "type", "text");
          attr(input, "placeholder", translate("timemanager", "Select..."));
          input.disabled = /*showTaskSelector*/ctx[0];
          input.value = input_value_value = /*selected*/ctx[18] ? "".concat( /*selected*/ctx[18].client.label, " \u203A ").concat( /*selected*/ctx[18].project.label, " \u203A ").concat( /*selected*/ctx[18].task.label) : "";
          attr(input, "title", input_title_value = /*selected*/ctx[18] ? "".concat( /*selected*/ctx[18].client.label, " \u203A ").concat( /*selected*/ctx[18].project.label, " \u203A ").concat( /*selected*/ctx[18].task.label) : "");
        },
        m(target, anchor) {
          insert(target, t0, anchor);
          insert(target, t1, anchor);
          insert(target, input, anchor);
          if (!mounted) {
            dispose = [action_destroyer(/*taskSelectorPopperRef*/ctx[26].call(null, input)), listen(input, "focus", /*handleShowTaskSelector*/ctx[36])];
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*showTaskSelector*/1) {
            input.disabled = /*showTaskSelector*/ctx[0];
          }
          if (dirty[0] & /*selected*/262144 && input_value_value !== (input_value_value = /*selected*/ctx[18] ? "".concat( /*selected*/ctx[18].client.label, " \u203A ").concat( /*selected*/ctx[18].project.label, " \u203A ").concat( /*selected*/ctx[18].task.label) : "") && input.value !== input_value_value) {
            input.value = input_value_value;
          }
          if (dirty[0] & /*selected*/262144 && input_title_value !== (input_title_value = /*selected*/ctx[18] ? "".concat( /*selected*/ctx[18].client.label, " \u203A ").concat( /*selected*/ctx[18].project.label, " \u203A ").concat( /*selected*/ctx[18].task.label) : "")) {
            attr(input, "title", input_title_value);
          }
        },
        d(detaching) {
          if (detaching) {
            detach(t0);
            detach(t1);
            detach(input);
          }
          mounted = false;
          run_all(dispose);
        }
      };
    }

    // (581:2) {#if selected && !showTaskSelector}
    function create_if_block_5$1(ctx) {
      var a;
      var ul;
      var li0;
      var span0;
      var t1;
      var span1;
      var t2_value = /*selected*/ctx[18].client.label + "";
      var t2;
      var t3;
      var li1;
      var span2;
      var t5;
      var span3;
      var t6_value = /*selected*/ctx[18].project.label + "";
      var t6;
      var t7;
      var li2;
      var span4;
      var t9;
      var span5;
      var t10_value = /*selected*/ctx[18].task.label + "";
      var t10;
      var t11;
      var input;
      var mounted;
      var dispose;
      return {
        c() {
          a = element("a");
          ul = element("ul");
          li0 = element("li");
          span0 = element("span");
          span0.textContent = "".concat(translate("timemanager", "Client"));
          t1 = space$1();
          span1 = element("span");
          t2 = text$1(t2_value);
          t3 = space$1();
          li1 = element("li");
          span2 = element("span");
          span2.textContent = "".concat(translate("timemanager", "Project"));
          t5 = space$1();
          span3 = element("span");
          t6 = text$1(t6_value);
          t7 = space$1();
          li2 = element("li");
          span4 = element("span");
          span4.textContent = "".concat(translate("timemanager", "Task"));
          t9 = space$1();
          span5 = element("span");
          t10 = text$1(t10_value);
          t11 = space$1();
          input = element("input");
          attr(span0, "class", "label muted");
          attr(span1, "class", "value muted");
          attr(span2, "class", "label muted");
          attr(span3, "class", "value muted");
          attr(span4, "class", "label");
          attr(span5, "class", "value");
          attr(a, "href", dist_1("apps/timemanager/404"));
          attr(a, "class", "combo-entry-wrapper");
          attr(input, "class", "hidden-visually");
          attr(input, "name", "show-task-selector");
        },
        m(target, anchor) {
          insert(target, a, anchor);
          append(a, ul);
          append(ul, li0);
          append(li0, span0);
          append(li0, t1);
          append(li0, span1);
          append(span1, t2);
          append(ul, t3);
          append(ul, li1);
          append(li1, span2);
          append(li1, t5);
          append(li1, span3);
          append(span3, t6);
          append(ul, t7);
          append(ul, li2);
          append(li2, span4);
          append(li2, t9);
          append(li2, span5);
          append(span5, t10);
          insert(target, t11, anchor);
          insert(target, input, anchor);
          if (!mounted) {
            dispose = [listen(a, "focus", /*handleShowTaskSelector*/ctx[36]), listen(a, "click", /*handleShowTaskSelector*/ctx[36]), listen(input, "focus", /*handleShowTaskSelector*/ctx[36])];
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*selected*/262144 && t2_value !== (t2_value = /*selected*/ctx[18].client.label + "")) set_data(t2, t2_value);
          if (dirty[0] & /*selected*/262144 && t6_value !== (t6_value = /*selected*/ctx[18].project.label + "")) set_data(t6, t6_value);
          if (dirty[0] & /*selected*/262144 && t10_value !== (t10_value = /*selected*/ctx[18].task.label + "")) set_data(t10, t10_value);
        },
        d(detaching) {
          if (detaching) {
            detach(a);
            detach(t11);
            detach(input);
          }
          mounted = false;
          run_all(dispose);
        }
      };
    }

    // (619:1) {#if showTaskSelector}
    function create_if_block$3(ctx) {
      var _ctx$9;
      var div3;
      var label;
      var span;
      var t1;
      var input;
      var t2;
      var div0;
      var t3;
      var div1;
      var t4;
      var div2;
      var mounted;
      var dispose;
      var if_block0 = /*lastUsed*/((_ctx$9 = ctx[32]) === null || _ctx$9 === void 0 ? void 0 : _ctx$9.length) && ! /*searchValue*/ctx[14] && create_if_block_3$1(ctx);
      function select_block_type_1(ctx, dirty) {
        var _ctx$10, _ctx$11;
        if ( /*searchResults*/(_ctx$10 = ctx[23]) !== null && _ctx$10 !== void 0 && _ctx$10.length) return create_if_block_1$1;
        if ( /*searchValue*/(_ctx$11 = ctx[14]) !== null && _ctx$11 !== void 0 && _ctx$11.length) return create_if_block_2$1;
      }
      var current_block_type = select_block_type_1(ctx);
      var if_block1 = current_block_type && current_block_type(ctx);
      return {
        c() {
          div3 = element("div");
          label = element("label");
          span = element("span");
          span.textContent = "".concat(translate("timemanager", "Type to search for client, project or task"));
          t1 = space$1();
          input = element("input");
          t2 = space$1();
          div0 = element("div");
          if (if_block0) if_block0.c();
          t3 = space$1();
          div1 = element("div");
          if (if_block1) if_block1.c();
          t4 = space$1();
          div2 = element("div");
          attr(span, "class", "hidden-visually");
          attr(input, "class", "search-input icon-search button-w-icon");
          attr(input, "type", "text");
          attr(input, "placeholder", translate("timemanager", "Type to search for client, project or task"));
          attr(input, "autocapitalize", "none");
          attr(input, "autocomplete", "off");
          attr(input, "autocorrect", "off");
          attr(input, "spellcheck", "false");
          attr(input, "aria-autocomplete", "list");
          input.autofocus = true;
          attr(input, "data-cy", "quick-add-task-search");
          attr(label, "class", "search");
          attr(div0, "class", "last-used");
          attr(div1, "class", "search-results");
          attr(div2, "class", "popover-arrow");
          attr(div2, "data-popper-arrow", "");
          attr(div3, "class", "task-selector-popover popover");
        },
        m(target, anchor) {
          insert(target, div3, anchor);
          append(div3, label);
          append(label, span);
          append(label, t1);
          append(label, input);
          /*input_binding*/
          ctx[62](input);
          set_input_value(input, /*searchValue*/ctx[14]);
          append(div3, t2);
          append(div3, div0);
          if (if_block0) if_block0.m(div0, null);
          append(div3, t3);
          append(div3, div1);
          if (if_block1) if_block1.m(div1, null);
          append(div3, t4);
          append(div3, div2);
          input.focus();
          if (!mounted) {
            dispose = [listen(input, "input", /*input_input_handler*/ctx[63]), listen(input, "input", /*input_handler_4*/ctx[64]), action_destroyer(/*taskSelectorPopperContent*/ctx[27].call(null, div3, /*extraOpts*/ctx[25])), listen(div3, "click", click_handler_5), listen(div3, "keypress", keypress_handler_1)];
            mounted = true;
          }
        },
        p(ctx, dirty) {
          var _ctx$12;
          if (dirty[0] & /*searchValue*/16384 && input.value !== /*searchValue*/ctx[14]) {
            set_input_value(input, /*searchValue*/ctx[14]);
          }
          if ( /*lastUsed*/(_ctx$12 = ctx[32]) !== null && _ctx$12 !== void 0 && _ctx$12.length && ! /*searchValue*/ctx[14]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_3$1(ctx);
              if_block0.c();
              if_block0.m(div0, null);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if (if_block1) if_block1.d(1);
            if_block1 = current_block_type && current_block_type(ctx);
            if (if_block1) {
              if_block1.c();
              if_block1.m(div1, null);
            }
          }
        },
        d(detaching) {
          if (detaching) {
            detach(div3);
          }

          /*input_binding*/
          ctx[62](null);
          if (if_block0) if_block0.d();
          if (if_block1) {
            if_block1.d();
          }
          mounted = false;
          run_all(dispose);
        }
      };
    }

    // (648:4) {#if lastUsed?.length && !searchValue}
    function create_if_block_3$1(ctx) {
      var ul;
      var each_value_3 = ensure_array_like( /*lastUsed*/ctx[32]);
      var each_blocks = [];
      for (var i = 0; i < each_value_3.length; i += 1) {
        each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
      }
      return {
        c() {
          ul = element("ul");
          for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {
            each_blocks[_i4].c();
          }
          attr(ul, "class", "result");
        },
        m(target, anchor) {
          insert(target, ul, anchor);
          for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
            if (each_blocks[_i5]) {
              each_blocks[_i5].m(ul, null);
            }
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*lastUsedTasksButtons, selected, showTaskSelector, currentLastestFocusTaskIndex*/1310737 | dirty[1] & /*lastUsed*/2) {
            each_value_3 = ensure_array_like( /*lastUsed*/ctx[32]);
            var _i6;
            for (_i6 = 0; _i6 < each_value_3.length; _i6 += 1) {
              var child_ctx = get_each_context_3(ctx, each_value_3, _i6);
              if (each_blocks[_i6]) {
                each_blocks[_i6].p(child_ctx, dirty);
              } else {
                each_blocks[_i6] = create_each_block_3(child_ctx);
                each_blocks[_i6].c();
                each_blocks[_i6].m(ul, null);
              }
            }
            for (; _i6 < each_blocks.length; _i6 += 1) {
              each_blocks[_i6].d(1);
            }
            each_blocks.length = each_value_3.length;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(ul);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }

    // (652:8) {#if index === 0}
    function create_if_block_4$1(ctx) {
      var span;
      return {
        c() {
          span = element("span");
          span.textContent = "".concat(translate("timemanager", "Last used"));
          attr(span, "class", "client");
        },
        m(target, anchor) {
          insert(target, span, anchor);
        },
        d(detaching) {
          if (detaching) {
            detach(span);
          }
        }
      };
    }

    // (650:6) {#each lastUsed as entry, index}
    function create_each_block_3(ctx) {
      var li3;
      var t0;
      var a;
      var ul;
      var li0;
      var span0;
      var t2;
      var span1;
      var t4;
      var li1;
      var span2;
      var t6;
      var span3;
      var t8;
      var li2;
      var span4;
      var t10;
      var span5;
      var index = /*index*/ctx[94];
      var t12;
      var mounted;
      var dispose;
      var if_block = /*index*/ctx[94] === 0 && create_if_block_4$1();
      var assign_a = function assign_a() {
        return (/*a_binding_1*/ctx[65](a, index)
        );
      };
      var unassign_a = function unassign_a() {
        return (/*a_binding_1*/ctx[65](null, index)
        );
      };
      function click_handler_3() {
        var _ctx2;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return (/*click_handler_3*/(_ctx2 = ctx)[66].apply(_ctx2, [/*entry*/ctx[92]].concat(args))
        );
      }
      function focus_handler_2() {
        return (/*focus_handler_2*/ctx[67]( /*index*/ctx[94])
        );
      }
      return {
        c() {
          li3 = element("li");
          if (if_block) if_block.c();
          t0 = space$1();
          a = element("a");
          ul = element("ul");
          li0 = element("li");
          span0 = element("span");
          span0.textContent = "".concat(translate("timemanager", "Client"));
          t2 = space$1();
          span1 = element("span");
          span1.textContent = "".concat( /*entry*/ctx[92].client.name);
          t4 = space$1();
          li1 = element("li");
          span2 = element("span");
          span2.textContent = "".concat(translate("timemanager", "Project"));
          t6 = space$1();
          span3 = element("span");
          span3.textContent = "".concat( /*entry*/ctx[92].project.name);
          t8 = space$1();
          li2 = element("li");
          span4 = element("span");
          span4.textContent = "".concat(translate("timemanager", "Task"));
          t10 = space$1();
          span5 = element("span");
          span5.textContent = "".concat( /*entry*/ctx[92].task.name);
          t12 = space$1();
          attr(span0, "class", "label muted");
          attr(span1, "class", "value muted");
          attr(span2, "class", "label muted");
          attr(span3, "class", "value muted");
          attr(span4, "class", "label");
          attr(span5, "class", "value");
          attr(a, "class", "task last-used-wrapper");
          attr(a, "href", dist_1("apps/timemanager/404"));
          attr(a, "tabindex", -1);
        },
        m(target, anchor) {
          insert(target, li3, anchor);
          if (if_block) if_block.m(li3, null);
          append(li3, t0);
          append(li3, a);
          append(a, ul);
          append(ul, li0);
          append(li0, span0);
          append(li0, t2);
          append(li0, span1);
          append(ul, t4);
          append(ul, li1);
          append(li1, span2);
          append(li1, t6);
          append(li1, span3);
          append(ul, t8);
          append(ul, li2);
          append(li2, span4);
          append(li2, t10);
          append(li2, span5);
          assign_a();
          append(li3, t12);
          if (!mounted) {
            dispose = [listen(a, "click", click_handler_3), listen(a, "focus", focus_handler_2)];
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (index !== /*index*/ctx[94]) {
            unassign_a();
            index = /*index*/ctx[94];
            assign_a();
          }
        },
        d(detaching) {
          if (detaching) {
            detach(li3);
          }
          if (if_block) if_block.d();
          unassign_a();
          mounted = false;
          run_all(dispose);
        }
      };
    }

    // (739:34) 
    function create_if_block_2$1(ctx) {
      var p;
      return {
        c() {
          p = element("p");
          p.textContent = "".concat(translate("timemanager", "Nothing found"));
          attr(p, "class", "no-result");
        },
        m(target, anchor) {
          insert(target, p, anchor);
        },
        p: noop$1,
        d(detaching) {
          if (detaching) {
            detach(p);
          }
        }
      };
    }

    // (695:4) {#if searchResults?.length}
    function create_if_block_1$1(ctx) {
      var each_1_anchor;
      var each_value = ensure_array_like( /*searchResults*/ctx[23]);
      var each_blocks = [];
      for (var i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
      }
      return {
        c() {
          for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {
            each_blocks[_i7].c();
          }
          each_1_anchor = empty();
        },
        m(target, anchor) {
          for (var _i8 = 0; _i8 < each_blocks.length; _i8 += 1) {
            if (each_blocks[_i8]) {
              each_blocks[_i8].m(target, anchor);
            }
          }
          insert(target, each_1_anchor, anchor);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*searchResults, tasksButtons, selected, showTaskSelector, currentFocusTaskIndex*/10747913) {
            each_value = ensure_array_like( /*searchResults*/ctx[23]);
            var _i9;
            for (_i9 = 0; _i9 < each_value.length; _i9 += 1) {
              var child_ctx = get_each_context$1(ctx, each_value, _i9);
              if (each_blocks[_i9]) {
                each_blocks[_i9].p(child_ctx, dirty);
              } else {
                each_blocks[_i9] = create_each_block$1(child_ctx);
                each_blocks[_i9].c();
                each_blocks[_i9].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }
            for (; _i9 < each_blocks.length; _i9 += 1) {
              each_blocks[_i9].d(1);
            }
            each_blocks.length = each_value.length;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(each_1_anchor);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }

    // (705:12) {#each project.tasks as task}
    function create_each_block_2$1(ctx) {
      var li;
      var a;
      var t0_value = /*task*/ctx[89].label + "";
      var t0;
      var task = /*task*/ctx[89];
      var t1;
      var mounted;
      var dispose;
      var assign_a = function assign_a() {
        return (/*a_binding_2*/ctx[68](a, task)
        );
      };
      var unassign_a = function unassign_a() {
        return (/*a_binding_2*/ctx[68](null, task)
        );
      };
      function click_handler_4() {
        var _ctx3;
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return (/*click_handler_4*/(_ctx3 = ctx)[69].apply(_ctx3, [/*client*/ctx[83], /*project*/ctx[86], /*task*/ctx[89]].concat(args))
        );
      }
      function focus_handler_3() {
        return (/*focus_handler_3*/ctx[70]( /*task*/ctx[89])
        );
      }
      return {
        c() {
          li = element("li");
          a = element("a");
          t0 = text$1(t0_value);
          t1 = space$1();
          attr(a, "href", dist_1("apps/timemanager/404"));
          attr(a, "class", "task");
          attr(a, "tabindex", -1);
        },
        m(target, anchor) {
          insert(target, li, anchor);
          append(li, a);
          append(a, t0);
          assign_a();
          append(li, t1);
          if (!mounted) {
            dispose = [listen(a, "click", click_handler_4), listen(a, "focus", focus_handler_3)];
            mounted = true;
          }
        },
        p(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] & /*searchResults*/8388608 && t0_value !== (t0_value = /*task*/ctx[89].label + "")) set_data(t0, t0_value);
          if (task !== /*task*/ctx[89]) {
            unassign_a();
            task = /*task*/ctx[89];
            assign_a();
          }
        },
        d(detaching) {
          if (detaching) {
            detach(li);
          }
          unassign_a();
          mounted = false;
          run_all(dispose);
        }
      };
    }

    // (701:9) {#each client.projects as project}
    function create_each_block_1$1(ctx) {
      var li;
      var span;
      var t0_value = /*project*/ctx[86].label + "";
      var t0;
      var t1;
      var ul;
      var t2;
      var each_value_2 = ensure_array_like( /*project*/ctx[86].tasks);
      var each_blocks = [];
      for (var i = 0; i < each_value_2.length; i += 1) {
        each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
      }
      return {
        c() {
          li = element("li");
          span = element("span");
          t0 = text$1(t0_value);
          t1 = space$1();
          ul = element("ul");
          for (var _i10 = 0; _i10 < each_blocks.length; _i10 += 1) {
            each_blocks[_i10].c();
          }
          t2 = space$1();
          attr(span, "class", "project");
        },
        m(target, anchor) {
          insert(target, li, anchor);
          append(li, span);
          append(span, t0);
          append(li, t1);
          append(li, ul);
          for (var _i11 = 0; _i11 < each_blocks.length; _i11 += 1) {
            if (each_blocks[_i11]) {
              each_blocks[_i11].m(ul, null);
            }
          }
          append(li, t2);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*searchResults*/8388608 && t0_value !== (t0_value = /*project*/ctx[86].label + "")) set_data(t0, t0_value);
          if (dirty[0] & /*tasksButtons, searchResults, selected, showTaskSelector, currentFocusTaskIndex*/10747913) {
            each_value_2 = ensure_array_like( /*project*/ctx[86].tasks);
            var _i12;
            for (_i12 = 0; _i12 < each_value_2.length; _i12 += 1) {
              var child_ctx = get_each_context_2$1(ctx, each_value_2, _i12);
              if (each_blocks[_i12]) {
                each_blocks[_i12].p(child_ctx, dirty);
              } else {
                each_blocks[_i12] = create_each_block_2$1(child_ctx);
                each_blocks[_i12].c();
                each_blocks[_i12].m(ul, null);
              }
            }
            for (; _i12 < each_blocks.length; _i12 += 1) {
              each_blocks[_i12].d(1);
            }
            each_blocks.length = each_value_2.length;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(li);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }

    // (696:5) {#each searchResults as client}
    function create_each_block$1(ctx) {
      var ul1;
      var li;
      var span;
      var t0_value = /*client*/ctx[83].label + "";
      var t0;
      var t1;
      var ul0;
      var t2;
      var each_value_1 = ensure_array_like( /*client*/ctx[83].projects);
      var each_blocks = [];
      for (var i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
      }
      return {
        c() {
          ul1 = element("ul");
          li = element("li");
          span = element("span");
          t0 = text$1(t0_value);
          t1 = space$1();
          ul0 = element("ul");
          for (var _i13 = 0; _i13 < each_blocks.length; _i13 += 1) {
            each_blocks[_i13].c();
          }
          t2 = space$1();
          attr(span, "class", "client");
          attr(ul1, "class", "result");
        },
        m(target, anchor) {
          insert(target, ul1, anchor);
          append(ul1, li);
          append(li, span);
          append(span, t0);
          append(li, t1);
          append(li, ul0);
          for (var _i14 = 0; _i14 < each_blocks.length; _i14 += 1) {
            if (each_blocks[_i14]) {
              each_blocks[_i14].m(ul0, null);
            }
          }
          append(ul1, t2);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*searchResults*/8388608 && t0_value !== (t0_value = /*client*/ctx[83].label + "")) set_data(t0, t0_value);
          if (dirty[0] & /*searchResults, tasksButtons, selected, showTaskSelector, currentFocusTaskIndex*/10747913) {
            each_value_1 = ensure_array_like( /*client*/ctx[83].projects);
            var _i15;
            for (_i15 = 0; _i15 < each_value_1.length; _i15 += 1) {
              var child_ctx = get_each_context_1$1(ctx, each_value_1, _i15);
              if (each_blocks[_i15]) {
                each_blocks[_i15].p(child_ctx, dirty);
              } else {
                each_blocks[_i15] = create_each_block_1$1(child_ctx);
                each_blocks[_i15].c();
                each_blocks[_i15].m(ul0, null);
              }
            }
            for (; _i15 < each_blocks.length; _i15 += 1) {
              each_blocks[_i15].d(1);
            }
            each_blocks.length = each_value_1.length;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(ul1);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }
    function create_fragment$7(ctx) {
      var _ctx$13;
      var form;
      var label0;
      var t0_value = translate("timemanager", "Note") + "";
      var t0;
      var t1;
      var input0;
      var t2;
      var t3;
      var label1;
      var html_tag;
      var raw_value = translate("timemanager", "Duration (in hrs.) & Date") + "";
      var t4;
      var input1;
      var input1_value_value;
      var t5;
      var t6;
      var label2;
      var input2;
      var t7;
      var label2_class_value;
      var t8;
      var t9;
      var span;
      var button;
      var t10_value = translate("timemanager", "Add") + "";
      var t10;
      var form_class_value;
      var mounted;
      var dispose;
      var if_block0 = /*showNoteAutosuggest*/ctx[1] && ( /*noteAutosuggestList*/(_ctx$13 = ctx[5]) === null || _ctx$13 === void 0 ? void 0 : _ctx$13.length) && create_if_block_7(ctx);
      var if_block1 = /*showDurationSelector*/ctx[2] && create_if_block_6$1(ctx);
      function select_block_type(ctx, dirty) {
        if ( /*selected*/ctx[18] && ! /*showTaskSelector*/ctx[0]) return create_if_block_5$1;
        return create_else_block;
      }
      var current_block_type = select_block_type(ctx);
      var if_block2 = current_block_type(ctx);
      var if_block3 = /*showTaskSelector*/ctx[0] && create_if_block$3(ctx);
      return {
        c() {
          var _ctx$14;
          form = element("form");
          label0 = element("label");
          t0 = text$1(t0_value);
          t1 = space$1();
          input0 = element("input");
          t2 = space$1();
          if (if_block0) if_block0.c();
          t3 = space$1();
          label1 = element("label");
          html_tag = new HtmlTag(false);
          t4 = space$1();
          input1 = element("input");
          t5 = space$1();
          if (if_block1) if_block1.c();
          t6 = space$1();
          label2 = element("label");
          input2 = element("input");
          t7 = space$1();
          if_block2.c();
          t8 = space$1();
          if (if_block3) if_block3.c();
          t9 = space$1();
          span = element("span");
          button = element("button");
          t10 = text$1(t10_value);
          attr(input0, "type", "text");
          attr(input0, "name", "note");
          attr(input0, "class", "note");
          attr(input0, "placeholder", translate("timemanager", "Describe what you did..."));
          attr(input0, "autocapitalize", "none");
          attr(input0, "autocomplete", "off");
          attr(input0, "autocorrect", "off");
          attr(input0, "spellcheck", "false");
          attr(input0, "aria-autocomplete", "list");
          attr(label0, "class", "note");
          html_tag.a = t4;
          attr(input1, "class", "duration-trigger");
          attr(input1, "type", "text");
          input1.value = input1_value_value = translate("timemanager", "{duration} hrs. on {date}", {
            duration: /*duration*/(_ctx$14 = ctx[7]) !== null && _ctx$14 !== void 0 ? _ctx$14 : 0,
            date: /*date*/ctx[10] && isDate$1(startOfDay(parse$3( /*date*/ctx[10], dateFormat$1, new Date()), /*localeOptions*/ctx[24])) ? format$2(startOfDay(parse$3( /*date*/ctx[10], dateFormat$1, new Date()), /*localeOptions*/ctx[24]), "PP", /*localeOptions*/ctx[24]) : "?"
          });
          input1.disabled = /*showDurationSelector*/ctx[2];
          attr(input1, "data-cy", "quick-add-duration");
          attr(input1, "data-hideevent", "skip");
          attr(input2, "type", "hidden");
          attr(label2, "class", label2_class_value = "task-selector-trigger".concat( /*taskError*/ctx[19] ? " error" : ""));
          attr(label2, "data-cy", "task-selector-trigger");
          button.disabled = /*loading*/ctx[17];
          attr(button, "type", "submit");
          attr(button, "class", "button primary button-w-icon icon-add");
          attr(span, "class", "actions");
          attr(form, "class", form_class_value = "quick-add".concat( /*loading*/ctx[17] ? " icon-loading" : ""));
          attr(form, "data-cy", "quick-add-form");
        },
        m(target, anchor) {
          insert(target, form, anchor);
          append(form, label0);
          append(label0, t0);
          append(label0, t1);
          append(label0, input0);
          set_input_value(input0, /*note*/ctx[11]);
          /*input0_binding*/
          ctx[46](input0);
          append(label0, t2);
          if (if_block0) if_block0.m(label0, null);
          append(form, t3);
          append(form, label1);
          html_tag.m(raw_value, label1);
          append(label1, t4);
          append(label1, input1);
          /*input1_binding*/
          ctx[52](input1);
          append(form, t5);
          if (if_block1) if_block1.m(form, null);
          append(form, t6);
          append(form, label2);
          append(label2, input2);
          append(label2, t7);
          if_block2.m(label2, null);
          append(form, t8);
          if (if_block3) if_block3.m(form, null);
          append(form, t9);
          append(form, span);
          append(span, button);
          append(button, t10);
          if (!mounted) {
            dispose = [listen(window, "keydown", /*handleKeyDown*/ctx[33]), action_destroyer(/*noteSuggestPopperRef*/ctx[28].call(null, input0)), listen(input0, "input", /*input0_input_handler*/ctx[45]), listen(input0, "input", /*input_handler*/ctx[47]), listen(input0, "focus", /*focus_handler*/ctx[48]), listen(input0, "click", click_handler), action_destroyer(/*durationSelectorPopperRef*/ctx[30].call(null, input1)), listen(input1, "focus", /*handleShowDurationSelector*/ctx[37]), listen(input1, "click", /*handleShowDurationSelector*/ctx[37]), listen(input1, "change", change_handler), listen(form, "submit", /*submit_handler*/ctx[71])];
            mounted = true;
          }
        },
        p(ctx, dirty) {
          var _ctx$15, _ctx$16;
          if (dirty[0] & /*note*/2048 && input0.value !== /*note*/ctx[11]) {
            set_input_value(input0, /*note*/ctx[11]);
          }
          if ( /*showNoteAutosuggest*/ctx[1] && /*noteAutosuggestList*/(_ctx$15 = ctx[5]) !== null && _ctx$15 !== void 0 && _ctx$15.length) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_7(ctx);
              if_block0.c();
              if_block0.m(label0, null);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }
          if (dirty[0] & /*duration, date*/1152 && input1_value_value !== (input1_value_value = translate("timemanager", "{duration} hrs. on {date}", {
            duration: /*duration*/(_ctx$16 = ctx[7]) !== null && _ctx$16 !== void 0 ? _ctx$16 : 0,
            date: /*date*/ctx[10] && isDate$1(startOfDay(parse$3( /*date*/ctx[10], dateFormat$1, new Date()), /*localeOptions*/ctx[24])) ? format$2(startOfDay(parse$3( /*date*/ctx[10], dateFormat$1, new Date()), /*localeOptions*/ctx[24]), "PP", /*localeOptions*/ctx[24]) : "?"
          })) && input1.value !== input1_value_value) {
            input1.value = input1_value_value;
          }
          if (dirty[0] & /*showDurationSelector*/4) {
            input1.disabled = /*showDurationSelector*/ctx[2];
          }
          if ( /*showDurationSelector*/ctx[2]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block_6$1(ctx);
              if_block1.c();
              if_block1.m(form, t6);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
            if_block2.p(ctx, dirty);
          } else {
            if_block2.d(1);
            if_block2 = current_block_type(ctx);
            if (if_block2) {
              if_block2.c();
              if_block2.m(label2, null);
            }
          }
          if (dirty[0] & /*taskError*/524288 && label2_class_value !== (label2_class_value = "task-selector-trigger".concat( /*taskError*/ctx[19] ? " error" : ""))) {
            attr(label2, "class", label2_class_value);
          }
          if ( /*showTaskSelector*/ctx[0]) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
            } else {
              if_block3 = create_if_block$3(ctx);
              if_block3.c();
              if_block3.m(form, t9);
            }
          } else if (if_block3) {
            if_block3.d(1);
            if_block3 = null;
          }
          if (dirty[0] & /*loading*/131072) {
            button.disabled = /*loading*/ctx[17];
          }
          if (dirty[0] & /*loading*/131072 && form_class_value !== (form_class_value = "quick-add".concat( /*loading*/ctx[17] ? " icon-loading" : ""))) {
            attr(form, "class", form_class_value);
          }
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(form);
          }

          /*input0_binding*/
          ctx[46](null);
          if (if_block0) if_block0.d();
          /*input1_binding*/
          ctx[52](null);
          if (if_block1) if_block1.d();
          if_block2.d();
          if (if_block3) if_block3.d();
          mounted = false;
          run_all(dispose);
        }
      };
    }
    var dateFormat$1 = "yyyy-MM-dd";
    var click_handler = function click_handler(event) {
      event.preventDefault();
      event.stopPropagation();
    };
    var change_handler = function change_handler() {};
    var click_handler_2 = function click_handler_2(event) {
      var _event$target, _event$target$getAttr;
      // Fix inputs triggering the hide event
      if ((event === null || event === void 0 || (_event$target = event.target) === null || _event$target === void 0 || (_event$target$getAttr = _event$target.getAttribute) === null || _event$target$getAttr === void 0 ? void 0 : _event$target$getAttr.call(_event$target, "data-hideEvent")) === "skip") {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
    };
    var keypress_handler = function keypress_handler() {};
    var click_handler_5 = function click_handler_5(event) {
      event.stopPropagation();
      event.preventDefault();
    };
    var keypress_handler_1 = function keypress_handler_1() {};
    function instance$7($$self, $$props, $$invalidate) {
      var _Object$values;
      var loading;
      var taskError;
      var selected;
      var searchResultsNumTasks;
      var currentFocusTaskIndex;
      var currentLastestFocusTaskIndex;
      var currentFocusNoteIndex;
      var searchResults;
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var clients = $$props.clients;
      var projects = $$props.projects;
      var tasks = $$props.tasks;
      var latestSearchEntries = $$props.latestSearchEntries;
      var localeOptions = Helpers.getDateLocaleOptions();
      var initialDate = format$2(new Date(), dateFormat$1, localeOptions);
      var extraOpts = {
        modifiers: [{
          name: "offset",
          options: {
            offset: [0, 8]
          }
        }]
      };
      var _createPopperActions = createPopperActions({
          placement: "bottom-end",
          strategy: "fixed"
        }),
        _createPopperActions2 = _slicedToArray(_createPopperActions, 2),
        taskSelectorPopperRef = _createPopperActions2[0],
        taskSelectorPopperContent = _createPopperActions2[1];
      var _createPopperActions3 = createPopperActions({
          placement: "bottom-start",
          strategy: "fixed"
        }),
        _createPopperActions4 = _slicedToArray(_createPopperActions3, 2),
        noteSuggestPopperRef = _createPopperActions4[0],
        noteSuggestPopperContent = _createPopperActions4[1];
      var _createPopperActions5 = createPopperActions({
          placement: "bottom-end",
          strategy: "fixed"
        }),
        _createPopperActions6 = _slicedToArray(_createPopperActions5, 2),
        durationSelectorPopperRef = _createPopperActions6[0],
        durationSelectorPopperContent = _createPopperActions6[1];
      var showTaskSelector = false;
      var showNoteAutosuggest = false;
      var showDurationSelector = false;
      var tasksButtons = [];
      var lastUsedTasksButtons = [];
      var noteAutosuggestList = [];
      var noteAutosuggestButtons = [];
      var duration = 1;
      var startTime = new Date().toTimeString().substring(0, 5);
      var endTime = Helpers.calculateEndTime(startTime, duration);
      var date = initialDate;
      var note;
      var noteInput;
      var searchInput;
      var searchValue;
      var durationInput;
      var durationTrigger;
      var latestEntriesByTask = {};
      latestSearchEntries.map(function (entry) {
        var _entry$task;
        latestEntriesByTask[entry === null || entry === void 0 || (_entry$task = entry.task) === null || _entry$task === void 0 ? void 0 : _entry$task.uuid] = entry;
      });
      var lastUsed = ((_Object$values = Object.values(latestEntriesByTask)) !== null && _Object$values !== void 0 ? _Object$values : []).slice(0, 3);
      var latestTimeEntries = latestSearchEntries.map(function (entry) {
        var _entry$time, _entry$time2;
        return _objectSpread2(_objectSpread2({}, entry), {}, {
          label: entry === null || entry === void 0 || (_entry$time = entry.time) === null || _entry$time === void 0 ? void 0 : _entry$time.note,
          value: entry === null || entry === void 0 || (_entry$time2 = entry.time) === null || _entry$time2 === void 0 ? void 0 : _entry$time2.uuid
        });
      });
      var groupedData = clients.map(function (client) {
        var clientProjects = projects.filter(function (project) {
          return project.clientUuid === client.value;
        }).map(function (project) {
          var projectTasks = tasks.filter(function (task) {
            return project.value === task.projectUuid;
          });
          return _objectSpread2(_objectSpread2({}, project), {}, {
            tasks: projectTasks
          });
        });
        return _objectSpread2(_objectSpread2({}, client), {}, {
          projects: clientProjects
        });
      });

      /**
      * Handles keyboard navigation for popovers
      */
      function handleKeyDown(e) {
        var _searchResults, _searchResults2;
        if (!showDurationSelector && !showTaskSelector && !showNoteAutosuggest) {
          return;
        }
        switch (e.key) {
          case "Escape":
            e.preventDefault();
            handleHidePopovers();
            break;
          case "ArrowDown":
            e.preventDefault();
            if (showNoteAutosuggest) {
              var _noteAutosuggestList, _noteAutosuggestButto;
              var reachedEnd = currentFocusNoteIndex + 1 >= ((_noteAutosuggestList = noteAutosuggestList) === null || _noteAutosuggestList === void 0 ? void 0 : _noteAutosuggestList.length);
              if (reachedEnd) {
                $$invalidate(22, currentFocusNoteIndex = 0);
              } else {
                $$invalidate(22, currentFocusNoteIndex++, currentFocusNoteIndex);
              }
              (_noteAutosuggestButto = noteAutosuggestButtons[currentFocusNoteIndex]) === null || _noteAutosuggestButto === void 0 ? void 0 : _noteAutosuggestButto.focus();
              break;
            }
            if (lastUsed !== null && lastUsed !== void 0 && lastUsed.length && !searchValue) {
              var _lastUsedTasksButtons;
              var _reachedEnd = currentLastestFocusTaskIndex + 1 >= (lastUsed === null || lastUsed === void 0 ? void 0 : lastUsed.length);
              if (_reachedEnd) {
                $$invalidate(20, currentLastestFocusTaskIndex = 0);
              } else {
                $$invalidate(20, currentLastestFocusTaskIndex++, currentLastestFocusTaskIndex);
              }
              (_lastUsedTasksButtons = lastUsedTasksButtons[currentLastestFocusTaskIndex]) === null || _lastUsedTasksButtons === void 0 ? void 0 : _lastUsedTasksButtons.focus();
              break;
            }
            if ((_searchResults = searchResults) !== null && _searchResults !== void 0 && _searchResults.length) {
              var _tasksButtons$current;
              var _reachedEnd2 = currentFocusTaskIndex + 1 >= searchResultsNumTasks;
              if (_reachedEnd2) {
                $$invalidate(21, currentFocusTaskIndex = 0);
              } else {
                $$invalidate(21, currentFocusTaskIndex++, currentFocusTaskIndex);
              }
              (_tasksButtons$current = tasksButtons[currentFocusTaskIndex]) === null || _tasksButtons$current === void 0 ? void 0 : _tasksButtons$current.focus();
              break;
            }
          case "ArrowUp":
            e.preventDefault();
            if (showNoteAutosuggest) {
              var _noteAutosuggestButto2;
              var reachedStart = currentFocusNoteIndex - 1 < 0;
              if (reachedStart) {
                var _noteAutosuggestList2;
                $$invalidate(22, currentFocusNoteIndex = ((_noteAutosuggestList2 = noteAutosuggestList) === null || _noteAutosuggestList2 === void 0 ? void 0 : _noteAutosuggestList2.length) - 1);
              } else {
                $$invalidate(22, currentFocusNoteIndex--, currentFocusNoteIndex);
              }
              (_noteAutosuggestButto2 = noteAutosuggestButtons[currentFocusNoteIndex]) === null || _noteAutosuggestButto2 === void 0 ? void 0 : _noteAutosuggestButto2.focus();
              break;
            }
            if (lastUsed !== null && lastUsed !== void 0 && lastUsed.length && !searchValue) {
              var _lastUsedTasksButtons2;
              var _reachedStart = currentLastestFocusTaskIndex - 1 < 0;
              if (_reachedStart) {
                $$invalidate(20, currentLastestFocusTaskIndex = (lastUsed === null || lastUsed === void 0 ? void 0 : lastUsed.length) - 1);
              } else {
                $$invalidate(20, currentLastestFocusTaskIndex--, currentLastestFocusTaskIndex);
              }
              (_lastUsedTasksButtons2 = lastUsedTasksButtons[currentLastestFocusTaskIndex]) === null || _lastUsedTasksButtons2 === void 0 ? void 0 : _lastUsedTasksButtons2.focus();
              break;
            }
            if ((_searchResults2 = searchResults) !== null && _searchResults2 !== void 0 && _searchResults2.length) {
              var _tasksButtons$current2;
              var _reachedStart2 = currentFocusTaskIndex - 1 < 0;
              if (_reachedStart2) {
                $$invalidate(21, currentFocusTaskIndex = searchResultsNumTasks - 1);
              } else {
                $$invalidate(21, currentFocusTaskIndex--, currentFocusTaskIndex);
              }
              (_tasksButtons$current2 = tasksButtons[currentFocusTaskIndex]) === null || _tasksButtons$current2 === void 0 ? void 0 : _tasksButtons$current2.focus();
              break;
            }
            break;
        }
      }
      var searchOptions = {
        keys: ["label"],
        threshold: 0.4,
        //  A score of 0 indicates a perfect match, while a score of 1 indicates a complete mismatch.
        includeScore: true
      };
      var clientsFuse = new Fuse(clients, searchOptions);
      var projectsFuse = new Fuse(projects, searchOptions);
      var tasksFuse = new Fuse(tasks, searchOptions);
      var latestEntriesFuse = new Fuse(latestTimeEntries, _objectSpread2(_objectSpread2({}, searchOptions), {}, {
        sort: true
      }));
      var scoreSort = function scoreSort(a, b) {
        return parseFloat(a.score) < parseFloat(b.score) ? -1 : parseFloat(a.score) > parseFloat(b.score) ? 1 : 0;
      };
      var search = function search(q) {
        if (!q) {
          $$invalidate(23, searchResults = []);
          return;
        }
        var clientsResults = clientsFuse.search(q);
        var projectsResults = projectsFuse.search(q);
        var tasksResults = tasksFuse.search(q);
        var taskIndex = -1;
        $$invalidate(23, searchResults = _toConsumableArray(groupedData).map(function (client) {
          var _clientFound$score;
          if (!client) {
            return {
              client: undefined
            };
          }
          var clientProjects = client.projects,
            clientId = client.value;
          var clientFound = clientsResults.find(function (result) {
            return result.item.value === clientId;
          });
          var clientScore = parseFloat((_clientFound$score = clientFound === null || clientFound === void 0 ? void 0 : clientFound.score) !== null && _clientFound$score !== void 0 ? _clientFound$score : 1);
          var projectsScore = 1;
          var tasksScore = 1;
          var projects = clientProjects === null || clientProjects === void 0 ? void 0 : clientProjects.map(function (project) {
            var _projectFound$score, _project$tasks, _projectFound$score2;
            var projectFound = projectsResults.find(function (result) {
              return result.item.value === (project === null || project === void 0 ? void 0 : project.value);
            });
            projectsScore = Math.min(projectsScore, parseFloat((_projectFound$score = projectFound === null || projectFound === void 0 ? void 0 : projectFound.score) !== null && _projectFound$score !== void 0 ? _projectFound$score : 1));
            var tasksPerProjectScore = 1;
            var tasks = project === null || project === void 0 || (_project$tasks = project.tasks) === null || _project$tasks === void 0 ? void 0 : _project$tasks.map(function (task) {
              var _taskFound$score;
              var taskFound = tasksResults.find(function (result) {
                return result.item.value === (task === null || task === void 0 ? void 0 : task.value);
              });
              var score = parseFloat((_taskFound$score = taskFound === null || taskFound === void 0 ? void 0 : taskFound.score) !== null && _taskFound$score !== void 0 ? _taskFound$score : 1);
              tasksScore = Math.min(tasksScore, score);
              tasksPerProjectScore = Math.min(tasksPerProjectScore, score);
              return clientFound || projectFound || taskFound ? _objectSpread2(_objectSpread2({}, task), {}, {
                score
              }) : undefined;
            }).filter(function (task) {
              return task !== undefined;
            }).sort(scoreSort);
            return tasks.length || projectFound ? _objectSpread2(_objectSpread2({}, project), {}, {
              score: Math.min(parseFloat((_projectFound$score2 = projectFound === null || projectFound === void 0 ? void 0 : projectFound.score) !== null && _projectFound$score2 !== void 0 ? _projectFound$score2 : 1), tasksPerProjectScore),
              tasks
            }) : undefined;
          }).filter(function (project) {
            return project !== undefined;
          }).sort(scoreSort);
          return projects !== null && projects !== void 0 && projects.length || clientFound ? _objectSpread2(_objectSpread2({}, client), {}, {
            projects,
            score: Math.min(parseFloat(clientScore), parseFloat(projectsScore), parseFloat(tasksScore))
          }) : undefined;
        }).filter(function (client) {
          return client !== undefined;
        }).sort(scoreSort).
        // Add index to each task for keyboard navigation
        map(function (client) {
          return _objectSpread2(_objectSpread2({}, client), {}, {
            projects: client.projects.map(function (project) {
              return _objectSpread2(_objectSpread2({}, project), {}, {
                tasks: project.tasks.map(function (task) {
                  taskIndex++;
                  return _objectSpread2(_objectSpread2({}, task), {}, {
                    taskIndex
                  });
                })
              });
            })
          });
        }));
        searchResultsNumTasks = taskIndex + 1;
      };
      var handleShowTaskSelector = function handleShowTaskSelector(event) {
        var _searchInput;
        event.stopPropagation();
        event.preventDefault();
        $$invalidate(0, showTaskSelector = true);

        // We want to use the task input as a button
        // and then focus the actual search input
        (_searchInput = searchInput) === null || _searchInput === void 0 ? void 0 : _searchInput.focus();
        $$invalidate(21, currentFocusTaskIndex = -1);
        $$invalidate(20, currentLastestFocusTaskIndex = -1);
        $$invalidate(1, showNoteAutosuggest = false);
        $$invalidate(22, currentFocusNoteIndex = -1);
        $$invalidate(2, showDurationSelector = false);
      };
      var handleHidePopovers = function handleHidePopovers(event) {
        var _event$target2, _event$target2$getAtt;
        // Fix inputs triggering the hide event
        if ((event === null || event === void 0 || (_event$target2 = event.target) === null || _event$target2 === void 0 || (_event$target2$getAtt = _event$target2.getAttribute) === null || _event$target2$getAtt === void 0 ? void 0 : _event$target2$getAtt.call(_event$target2, "data-hideEvent")) === "skip") {
          return;
        }
        $$invalidate(0, showTaskSelector = false);
        $$invalidate(1, showNoteAutosuggest = false);
        $$invalidate(2, showDurationSelector = false);
        $$invalidate(21, currentFocusTaskIndex = -1);
        $$invalidate(20, currentLastestFocusTaskIndex = -1);
        $$invalidate(22, currentFocusNoteIndex = -1);
      };
      var handleShowDurationSelector = function handleShowDurationSelector(event) {
        event.preventDefault();
        event.stopPropagation();
        $$invalidate(2, showDurationSelector = true);
        $$invalidate(1, showNoteAutosuggest = false);
        $$invalidate(22, currentFocusNoteIndex = -1);
        $$invalidate(0, showTaskSelector = false);
        $$invalidate(21, currentFocusTaskIndex = -1);
        $$invalidate(20, currentLastestFocusTaskIndex = -1);
        setTimeout(function () {
          var _durationInput;
          (_durationInput = durationInput) === null || _durationInput === void 0 ? void 0 : _durationInput.focus();
        }, 250);
      };
      onMount(function () {
        document.addEventListener("DOMContentLoaded", function () {
          // This fixes the "duration" input being focused automatically
          // for some reason in some browsers
          if (noteInput) {
            noteInput.focus();
            setTimeout(function () {
              $$invalidate(16, durationTrigger.disabled = false, durationTrigger);
            }, 500);
          }
        });
        if (noteInput) {
          noteInput.focus();
          setTimeout(function () {
            $$invalidate(16, durationTrigger.disabled = false, durationTrigger);
          }, 500);
        }
        document.addEventListener("click", handleHidePopovers);
        return function () {
          document.removeEventListener("click", handleHidePopovers);
        };
      });
      var save = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var _selected;
          var startDateFormat, startDate, entry, response;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                $$invalidate(17, loading = true);
                $$invalidate(19, taskError = false);
                if ((_selected = selected) !== null && _selected !== void 0 && (_selected = _selected.task) !== null && _selected !== void 0 && _selected.value) {
                  _context.next = 6;
                  break;
                }
                $$invalidate(17, loading = false);
                $$invalidate(19, taskError = true);
                return _context.abrupt("return");
              case 6:
                startDateFormat = "yyyy-MM-dd HH:mm:ss";
                startDate = "".concat(date, "T").concat(startTime, ":00");
                _context.prev = 8;
                entry = {
                  duration,
                  date: format$2(Helpers.toUTC(parseISO(startDate)), startDateFormat, localeOptions),
                  note,
                  task: selected.task.value
                };
                _context.next = 12;
                return fetch(action, {
                  method: "POST",
                  body: JSON.stringify(entry),
                  headers: {
                    requesttoken: requestToken,
                    "content-type": "application/json"
                  }
                });
              case 12:
                response = _context.sent;
                if (response && response.ok) {
                  document.querySelector(".app-timemanager [data-current-link]").click();
                }
                _context.next = 19;
                break;
              case 16:
                _context.prev = 16;
                _context.t0 = _context["catch"](8);
                console.error(_context.t0);
              case 19:
                $$invalidate(17, loading = false);
              case 20:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[8, 16]]);
        }));
        return function save() {
          return _ref.apply(this, arguments);
        };
      }();
      function input0_input_handler() {
        note = this.value;
        $$invalidate(11, note);
      }
      function input0_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          noteInput = $$value;
          $$invalidate(12, noteInput);
        });
      }
      var input_handler = function input_handler(event) {
        var _event$target$value, _event$target3;
        var filterText = (_event$target$value = event === null || event === void 0 || (_event$target3 = event.target) === null || _event$target3 === void 0 ? void 0 : _event$target3.value) !== null && _event$target$value !== void 0 ? _event$target$value : "";
        if (filterText.length > 2) {
          $$invalidate(1, showNoteAutosuggest = true);
          var searchResult = latestEntriesFuse.search(filterText);
          $$invalidate(5, noteAutosuggestList = searchResult.slice(0, 10).map(function (result) {
            return result.item;
          }));
        } else {
          $$invalidate(1, showNoteAutosuggest = false);
          $$invalidate(5, noteAutosuggestList = []);
        }
      };
      var focus_handler = function focus_handler(event) {
        var _event$target$value2, _event$target4;
        event.preventDefault();
        event.stopPropagation();
        var filterText = (_event$target$value2 = event === null || event === void 0 || (_event$target4 = event.target) === null || _event$target4 === void 0 ? void 0 : _event$target4.value) !== null && _event$target$value2 !== void 0 ? _event$target$value2 : "";
        if (filterText.length > 2) {
          var searchResult = latestEntriesFuse.search(filterText);
          $$invalidate(5, noteAutosuggestList = searchResult.slice(0, 10).map(function (result) {
            return result.item;
          }));
          $$invalidate(1, showNoteAutosuggest = true);
        }
        $$invalidate(0, showTaskSelector = false);
        $$invalidate(21, currentFocusTaskIndex = -1);
        $$invalidate(20, currentLastestFocusTaskIndex = -1);
        $$invalidate(2, showDurationSelector = false);
      };
      function a_binding($$value, index) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          noteAutosuggestButtons[index] = $$value;
          $$invalidate(6, noteAutosuggestButtons);
        });
      }
      var click_handler_1 = function click_handler_1(suggestion, event) {
        var _time$note, _suggestion$task, _suggestion$task2, _suggestion$project, _suggestion$project2, _suggestion$client, _suggestion$client2;
        event.stopPropagation();
        event.preventDefault();
        var time = suggestion.time;
        if (!time) {
          return;
        }
        $$invalidate(11, note = (_time$note = time.note) !== null && _time$note !== void 0 ? _time$note : note);
        var startDate = parseISO(time.start);
        var endDate = parseISO(time.end);
        $$invalidate(7, duration = Helpers.calculateDuration(format$2(startDate, "HH:mm", startDate), format$2(endDate, "HH:mm", endDate)));
        $$invalidate(18, selected = {
          task: {
            label: suggestion === null || suggestion === void 0 || (_suggestion$task = suggestion.task) === null || _suggestion$task === void 0 ? void 0 : _suggestion$task.name,
            value: suggestion === null || suggestion === void 0 || (_suggestion$task2 = suggestion.task) === null || _suggestion$task2 === void 0 ? void 0 : _suggestion$task2.uuid
          },
          project: {
            label: suggestion === null || suggestion === void 0 || (_suggestion$project = suggestion.project) === null || _suggestion$project === void 0 ? void 0 : _suggestion$project.name,
            value: suggestion === null || suggestion === void 0 || (_suggestion$project2 = suggestion.project) === null || _suggestion$project2 === void 0 ? void 0 : _suggestion$project2.uuid
          },
          client: {
            label: suggestion === null || suggestion === void 0 || (_suggestion$client = suggestion.client) === null || _suggestion$client === void 0 ? void 0 : _suggestion$client.name,
            value: suggestion === null || suggestion === void 0 || (_suggestion$client2 = suggestion.client) === null || _suggestion$client2 === void 0 ? void 0 : _suggestion$client2.uuid
          }
        });
        $$invalidate(1, showNoteAutosuggest = false);
        $$invalidate(22, currentFocusNoteIndex = -1);
      };
      var focus_handler_1 = function focus_handler_1(index) {
        $$invalidate(22, currentFocusNoteIndex = index);
      };
      function input1_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          durationTrigger = $$value;
          $$invalidate(16, durationTrigger);
        });
      }
      function input0_input_handler_1() {
        duration = this.value;
        $$invalidate(7, duration);
      }
      var input_handler_1 = function input_handler_1() {
        $$invalidate(7, duration = Helpers.normalizeDuration(duration));
        $$invalidate(9, endTime = Helpers.calculateEndTime(startTime, parseFloat(duration)));
      };
      function input0_binding_1($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          durationInput = $$value;
          $$invalidate(15, durationInput);
        });
      }
      function input1_input_handler() {
        startTime = this.value;
        $$invalidate(8, startTime);
      }
      var input_handler_2 = function input_handler_2() {
        return $$invalidate(7, duration = Helpers.calculateDuration(startTime, endTime));
      };
      function input2_input_handler() {
        endTime = this.value;
        $$invalidate(9, endTime);
      }
      var input_handler_3 = function input_handler_3() {
        return $$invalidate(7, duration = Helpers.calculateDuration(startTime, endTime));
      };
      function input3_input_handler() {
        date = this.value;
        $$invalidate(10, date);
      }
      var blur_handler = function blur_handler() {
        if (!date || !isDate$1(parse$3(date, dateFormat$1, new Date()))) {
          $$invalidate(10, date = format$2(startOfDay(new Date(), localeOptions), dateFormat$1, new Date()));
        }
      };
      function input_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          searchInput = $$value;
          $$invalidate(13, searchInput);
        });
      }
      function input_input_handler() {
        searchValue = this.value;
        $$invalidate(14, searchValue);
      }
      var input_handler_4 = function input_handler_4() {
        return search(searchValue);
      };
      function a_binding_1($$value, index) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          lastUsedTasksButtons[index] = $$value;
          $$invalidate(4, lastUsedTasksButtons);
        });
      }
      var click_handler_3 = function click_handler_3(entry, event) {
        var _entry$task2, _entry$task3, _entry$project, _entry$project2, _entry$client, _entry$client2;
        event.stopPropagation();
        event.preventDefault();
        $$invalidate(18, selected = {
          task: {
            label: entry === null || entry === void 0 || (_entry$task2 = entry.task) === null || _entry$task2 === void 0 ? void 0 : _entry$task2.name,
            value: entry === null || entry === void 0 || (_entry$task3 = entry.task) === null || _entry$task3 === void 0 ? void 0 : _entry$task3.uuid
          },
          project: {
            label: entry === null || entry === void 0 || (_entry$project = entry.project) === null || _entry$project === void 0 ? void 0 : _entry$project.name,
            value: entry === null || entry === void 0 || (_entry$project2 = entry.project) === null || _entry$project2 === void 0 ? void 0 : _entry$project2.uuid
          },
          client: {
            label: entry === null || entry === void 0 || (_entry$client = entry.client) === null || _entry$client === void 0 ? void 0 : _entry$client.name,
            value: entry === null || entry === void 0 || (_entry$client2 = entry.client) === null || _entry$client2 === void 0 ? void 0 : _entry$client2.uuid
          }
        });
        $$invalidate(0, showTaskSelector = false);
      };
      var focus_handler_2 = function focus_handler_2(index) {
        $$invalidate(20, currentLastestFocusTaskIndex = index);
      };
      function a_binding_2($$value, task) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          tasksButtons[task.taskIndex] = $$value;
          $$invalidate(3, tasksButtons);
        });
      }
      var click_handler_4 = function click_handler_4(client, project, task, event) {
        event.stopPropagation();
        event.preventDefault();
        $$invalidate(18, selected = {
          client: {
            label: client.label,
            value: client.value
          },
          project: {
            label: project.label,
            value: project.value
          },
          task
        });
        $$invalidate(0, showTaskSelector = false);
      };
      var focus_handler_3 = function focus_handler_3(task) {
        $$invalidate(21, currentFocusTaskIndex = task.taskIndex);
      };
      var submit_handler = function submit_handler(event) {
        event.stopPropagation();
        event.preventDefault();
        save();
      };
      $$self.$$set = function ($$props) {
        if ('action' in $$props) $$invalidate(39, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(40, requestToken = $$props.requestToken);
        if ('clients' in $$props) $$invalidate(41, clients = $$props.clients);
        if ('projects' in $$props) $$invalidate(42, projects = $$props.projects);
        if ('tasks' in $$props) $$invalidate(43, tasks = $$props.tasks);
        if ('latestSearchEntries' in $$props) $$invalidate(44, latestSearchEntries = $$props.latestSearchEntries);
      };
      $$invalidate(17, loading = false);
      $$invalidate(19, taskError = false);
      $$invalidate(18, selected = null);
      searchResultsNumTasks = 0;
      $$invalidate(21, currentFocusTaskIndex = -1);
      $$invalidate(20, currentLastestFocusTaskIndex = -1);
      $$invalidate(22, currentFocusNoteIndex = -1);
      $$invalidate(23, searchResults = []);
      return [showTaskSelector, showNoteAutosuggest, showDurationSelector, tasksButtons, lastUsedTasksButtons, noteAutosuggestList, noteAutosuggestButtons, duration, startTime, endTime, date, note, noteInput, searchInput, searchValue, durationInput, durationTrigger, loading, selected, taskError, currentLastestFocusTaskIndex, currentFocusTaskIndex, currentFocusNoteIndex, searchResults, localeOptions, extraOpts, taskSelectorPopperRef, taskSelectorPopperContent, noteSuggestPopperRef, noteSuggestPopperContent, durationSelectorPopperRef, durationSelectorPopperContent, lastUsed, handleKeyDown, latestEntriesFuse, search, handleShowTaskSelector, handleShowDurationSelector, save, action, requestToken, clients, projects, tasks, latestSearchEntries, input0_input_handler, input0_binding, input_handler, focus_handler, a_binding, click_handler_1, focus_handler_1, input1_binding, input0_input_handler_1, input_handler_1, input0_binding_1, input1_input_handler, input_handler_2, input2_input_handler, input_handler_3, input3_input_handler, blur_handler, input_binding, input_input_handler, input_handler_4, a_binding_1, click_handler_3, focus_handler_2, a_binding_2, click_handler_4, focus_handler_3, submit_handler];
    }
    var QuickAdd = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(QuickAdd, _SvelteComponent);
      var _super = _createSuper$1(QuickAdd);
      function QuickAdd(options) {
        var _this;
        _classCallCheck$1(this, QuickAdd);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$7, create_fragment$7, safe_not_equal, {
          action: 39,
          requestToken: 40,
          clients: 41,
          projects: 42,
          tasks: 43,
          latestSearchEntries: 44
        }, null, [-1, -1, -1, -1]);
        return _this;
      }
      return _createClass$1(QuickAdd);
    }(SvelteComponent);

    function create_fragment$6(ctx) {
      var span0;
      var input;
      var input_id_value;
      var input_checked_value;
      var t0;
      var label;
      var label_for_value;
      var t1;
      var span1;
      var span1_class_value;
      var mounted;
      var dispose;
      return {
        c() {
          span0 = element("span");
          input = element("input");
          t0 = space$1();
          label = element("label");
          t1 = space$1();
          span1 = element("span");
          attr(input, "type", "checkbox");
          attr(input, "id", input_id_value = "check_".concat( /*uuid*/ctx[0]));
          attr(input, "class", "checkbox");
          input.checked = input_checked_value = /*initialState*/ctx[1] === 'paid';
          input.disabled = /*loading*/ctx[3];
          attr(label, "for", label_for_value = "check_".concat( /*uuid*/ctx[0]));
          attr(span0, "class", "checkbox-action");
          attr(span1, "class", span1_class_value = "checkbox-action-loading".concat( /*loading*/ctx[3] ? ' icon-loading' : ''));
        },
        m(target, anchor) {
          insert(target, span0, anchor);
          append(span0, input);
          append(span0, t0);
          append(span0, label);
          insert(target, t1, anchor);
          insert(target, span1, anchor);
          if (!mounted) {
            dispose = listen(input, "change", prevent_default( /*change_handler*/ctx[7]));
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if (dirty & /*uuid*/1 && input_id_value !== (input_id_value = "check_".concat( /*uuid*/ctx[0]))) {
            attr(input, "id", input_id_value);
          }
          if (dirty & /*initialState*/2 && input_checked_value !== (input_checked_value = /*initialState*/ctx[1] === 'paid')) {
            input.checked = input_checked_value;
          }
          if (dirty & /*loading*/8) {
            input.disabled = /*loading*/ctx[3];
          }
          if (dirty & /*uuid*/1 && label_for_value !== (label_for_value = "check_".concat( /*uuid*/ctx[0]))) {
            attr(label, "for", label_for_value);
          }
          if (dirty & /*loading*/8 && span1_class_value !== (span1_class_value = "checkbox-action-loading".concat( /*loading*/ctx[3] ? ' icon-loading' : ''))) {
            attr(span1, "class", span1_class_value);
          }
        },
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(span0);
            detach(t1);
            detach(span1);
          }
          mounted = false;
          dispose();
        }
      };
    }
    function instance$6($$self, $$props, $$invalidate) {
      var loading;
      var uuid = $$props.uuid;
      var initialState = $$props.initialState;
      var action = $$props.action;
      var requestToken = $$props.requestToken;
      var state = initialState;
      onMount(function () {
        Helpers.hideFallbacks("Checkmark.svelte");
      });
      var save = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var response;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                $$invalidate(3, loading = true);
                _context.prev = 1;
                _context.next = 4;
                return fetch("".concat(action, "/").concat(state), {
                  method: "POST",
                  body: JSON.stringify({
                    uuid
                  }),
                  headers: {
                    requesttoken: requestToken,
                    "content-type": "application/json"
                  }
                });
              case 4:
                response = _context.sent;
                if (!response || !response.ok) {
                  // Roll back selection
                  $$invalidate(2, state = state === "paid" ? "unpaid" : "paid");
                }
                _context.next = 11;
                break;
              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](1);
                console.error(_context.t0);
              case 11:
                $$invalidate(3, loading = false);
              case 12:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[1, 8]]);
        }));
        return function save() {
          return _ref3.apply(this, arguments);
        };
      }();
      var change_handler = function change_handler() {
        $$invalidate(2, state = state === 'paid' ? 'unpaid' : 'paid');
        save();
      };
      $$self.$$set = function ($$props) {
        if ('uuid' in $$props) $$invalidate(0, uuid = $$props.uuid);
        if ('initialState' in $$props) $$invalidate(1, initialState = $$props.initialState);
        if ('action' in $$props) $$invalidate(5, action = $$props.action);
        if ('requestToken' in $$props) $$invalidate(6, requestToken = $$props.requestToken);
      };
      $$invalidate(3, loading = false);
      return [uuid, initialState, state, loading, save, action, requestToken, change_handler];
    }
    var Checkmark = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(Checkmark, _SvelteComponent);
      var _super = _createSuper$1(Checkmark);
      function Checkmark(options) {
        var _this;
        _classCallCheck$1(this, Checkmark);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$6, create_fragment$6, safe_not_equal, {
          uuid: 0,
          initialState: 1,
          action: 5,
          requestToken: 6
        });
        return _this;
      }
      return _createClass$1(Checkmark);
    }(SvelteComponent);

    const subscriber_queue = [];

    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     *
     * https://svelte.dev/docs/svelte-store#writable
     * @template T
     * @param {T} [value] initial value
     * @param {import('./public.js').StartStopNotifier<T>} [start]
     * @returns {import('./public.js').Writable<T>}
     */
    function writable(value, start = noop$1) {
      /** @type {import('./public.js').Unsubscriber} */
      let stop;
      /** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
      const subscribers = new Set();
      /** @param {T} new_value
       * @returns {void}
       */
      function set(new_value) {
        if (safe_not_equal(value, new_value)) {
          value = new_value;
          if (stop) {
            // store is ready
            const run_queue = !subscriber_queue.length;
            for (const subscriber of subscribers) {
              subscriber[1]();
              subscriber_queue.push(subscriber, value);
            }
            if (run_queue) {
              for (let i = 0; i < subscriber_queue.length; i += 2) {
                subscriber_queue[i][0](subscriber_queue[i + 1]);
              }
              subscriber_queue.length = 0;
            }
          }
        }
      }

      /**
       * @param {import('./public.js').Updater<T>} fn
       * @returns {void}
       */
      function update(fn) {
        set(fn(value));
      }

      /**
       * @param {import('./public.js').Subscriber<T>} run
       * @param {import('./private.js').Invalidator<T>} [invalidate]
       * @returns {import('./public.js').Unsubscriber}
       */
      function subscribe(run, invalidate = noop$1) {
        /** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
          stop = start(set, update) || noop$1;
        }
        run(value);
        return () => {
          subscribers.delete(subscriber);
          if (subscribers.size === 0 && stop) {
            stop();
            stop = null;
          }
        };
      }
      return {
        set,
        update,
        subscribe
      };
    }

    var isFilterSet = writable(false);

    function create_if_block$2(ctx) {
      var label;
      var t0_value = translate("timemanager", "Created by") + "";
      var t0;
      var t1;
      var select;
      var current;
      select = new Select({
        props: {
          noOptionsMessage: /*loading*/ctx[3] ? translate("timemanager", "Loading...") : translate("timemanager", "No options"),
          placeholder: translate("timemanager", "Search..."),
          inputAttributes: {
            id: "sharee-filter-select",
            form: /*form*/ctx[1]
          },
          loadOptions: /*search*/ctx[6],
          value: /*selectedSharee*/ctx[2]
        }
      });
      select.$on("select", /*handleSelectSharee*/ctx[4]);
      select.$on("clear", /*handleClearSharee*/ctx[5]);
      return {
        c() {
          label = element("label");
          t0 = text$1(t0_value);
          t1 = space$1();
          create_component(select.$$.fragment);
          attr(label, "for", "sharee-filter-select");
          attr(label, "class", "sharee-filter-label");
        },
        m(target, anchor) {
          insert(target, label, anchor);
          append(label, t0);
          append(label, t1);
          mount_component(select, label, null);
          current = true;
        },
        p(ctx, dirty) {
          var select_changes = {};
          if (dirty & /*loading*/8) select_changes.noOptionsMessage = /*loading*/ctx[3] ? translate("timemanager", "Loading...") : translate("timemanager", "No options");
          if (dirty & /*form*/2) select_changes.inputAttributes = {
            id: "sharee-filter-select",
            form: /*form*/ctx[1]
          };
          if (dirty & /*selectedSharee*/4) select_changes.value = /*selectedSharee*/ctx[2];
          select.$set(select_changes);
        },
        i(local) {
          if (current) return;
          transition_in(select.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(select.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(label);
          }
          destroy_component(select);
        }
      };
    }
    function create_fragment$5(ctx) {
      var if_block_anchor;
      var current;
      var if_block = /*isVisible*/ctx[0] && create_if_block$2(ctx);
      return {
        c() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        m(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if ( /*isVisible*/ctx[0]) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty & /*isVisible*/1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$2(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(if_block_anchor);
          }
          if (if_block) if_block.d(detaching);
        }
      };
    }
    function instance$5($$self, $$props, $$invalidate) {
      var loading;
      var requestToken = $$props.requestToken;
      var _$$props$isVisible = $$props.isVisible,
        isVisible = _$$props$isVisible === void 0 ? true : _$$props$isVisible;
      var _$$props$form = $$props.form,
        form = _$$props$form === void 0 ? undefined : _$$props$form;
      var selectedSharee;
      var handleSelectSharee = function handleSelectSharee(event) {
        if (selectedSharee && selectedSharee.value.shareWith === event.detail.value.shareWith) {
          return;
        }
        $$invalidate(2, selectedSharee = event.detail);

        // Prepare a link with get attributes
        var filterLinkElement = Helpers.getLinkEl();

        // Base off current url
        var newUrl = document.location.href;

        // Add filter attributes to url
        newUrl = Helpers.getUpdatedFilterUrl("userFilter", selectedSharee ? selectedSharee.value.shareWith : "", newUrl);

        // Attach url to hidden pjax link
        filterLinkElement.href = newUrl;

        // Navigate
        filterLinkElement.click();
      };
      var handleClearSharee = function handleClearSharee() {
        handleSelectSharee({
          detail: {
            value: {
              shareWith: ""
            },
            label: ""
          }
        });
        isFilterSet.set(false);
      };
      var search = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(query) {
          var response, _yield$response$json$, users, exact;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!(typeof query === "undefined")) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return");
              case 2:
                $$invalidate(3, loading = true);
                _context.next = 5;
                return fetch(dist_3("apps/files_sharing/api/v1/sharees?search=".concat(query, "&format=json&perPage=20&itemType=[0]")), {
                  headers: {
                    requesttoken: requestToken,
                    "content-type": "application/json"
                  }
                });
              case 5:
                response = _context.sent;
                $$invalidate(3, loading = false);
                if (!response.ok) {
                  _context.next = 14;
                  break;
                }
                _context.next = 10;
                return response.json();
              case 10:
                _yield$response$json$ = _context.sent.ocs.data;
                users = _yield$response$json$.users;
                exact = _yield$response$json$.exact;
                return _context.abrupt("return", [].concat(_toConsumableArray(users), _toConsumableArray(exact.users)));
              case 14:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function search(_x) {
          return _ref3.apply(this, arguments);
        };
      }();
      onMount( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var urlParts, queryString, queryStringParts, _iterator, _step, part, partParts, _partParts, name, value, result;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              // Parse current URL
              urlParts = document.location.href.split("?");
              if (!(urlParts.length > 1)) {
                _context2.next = 26;
                break;
              }
              queryString = urlParts[1];
              queryStringParts = queryString.split("&"); // Map over all query params
              _iterator = _createForOfIteratorHelper$1(queryStringParts);
              _context2.prev = 5;
              _iterator.s();
            case 7:
              if ((_step = _iterator.n()).done) {
                _context2.next = 18;
                break;
              }
              part = _step.value;
              // Split query params
              partParts = part.split("=");
              _partParts = _slicedToArray(partParts, 2), name = _partParts[0], value = _partParts[1]; // Apply filters from query params
              if (!(name === "userFilter" && value)) {
                _context2.next = 16;
                break;
              }
              _context2.next = 14;
              return search(value);
            case 14:
              result = _context2.sent;
              if (result && result.length) {
                $$invalidate(2, selectedSharee = result[0]);
                isFilterSet.set(true);
              }
            case 16:
              _context2.next = 7;
              break;
            case 18:
              _context2.next = 23;
              break;
            case 20:
              _context2.prev = 20;
              _context2.t0 = _context2["catch"](5);
              _iterator.e(_context2.t0);
            case 23:
              _context2.prev = 23;
              _iterator.f();
              return _context2.finish(23);
            case 26:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[5, 20, 23, 26]]);
      })));
      $$self.$$set = function ($$props) {
        if ('requestToken' in $$props) $$invalidate(7, requestToken = $$props.requestToken);
        if ('isVisible' in $$props) $$invalidate(0, isVisible = $$props.isVisible);
        if ('form' in $$props) $$invalidate(1, form = $$props.form);
      };
      $$invalidate(3, loading = false);
      return [isVisible, form, selectedSharee, loading, handleSelectSharee, handleClearSharee, search, requestToken];
    }
    var UserFilterSelect = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(UserFilterSelect, _SvelteComponent);
      var _super = _createSuper$1(UserFilterSelect);
      function UserFilterSelect(options) {
        var _this;
        _classCallCheck$1(this, UserFilterSelect);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$5, create_fragment$5, safe_not_equal, {
          requestToken: 7,
          isVisible: 0,
          form: 1
        });
        return _this;
      }
      return _createClass$1(UserFilterSelect);
    }(SvelteComponent);

    function create_fragment$4(ctx) {
      var div;
      var userfilterselect;
      var t0;
      var label0;
      var t1_value = translate("timemanager", "From") + "";
      var t1;
      var t2;
      var input0;
      var t3;
      var label1;
      var t4_value = translate("timemanager", "To") + "";
      var t4;
      var t5;
      var input1;
      var t6;
      var label2;
      var t7_value = translate("timemanager", "Presets") + "";
      var t7;
      var t8;
      var select;
      var t9;
      var span;
      var button;
      var t10_value = translate("timemanager", "Apply") + "";
      var t10;
      var div_class_value;
      var current;
      var mounted;
      var dispose;
      userfilterselect = new UserFilterSelect({
        props: {
          requestToken: /*requestToken*/ctx[0],
          form: "filters-form"
        }
      });
      select = new Select({
        props: {
          noOptionsMessage: translate("timemanager", "No options"),
          placeholder: translate("timemanager", "Select..."),
          inputAttributes: {
            id: "preset-select",
            form: "filters-form"
          },
          items: /*presets*/ctx[4]
        }
      });
      select.$on("select", /*handleSelectPreset*/ctx[6]);
      return {
        c() {
          div = element("div");
          create_component(userfilterselect.$$.fragment);
          t0 = space$1();
          label0 = element("label");
          t1 = text$1(t1_value);
          t2 = space$1();
          input0 = element("input");
          t3 = space$1();
          label1 = element("label");
          t4 = text$1(t4_value);
          t5 = space$1();
          input1 = element("input");
          t6 = space$1();
          label2 = element("label");
          t7 = text$1(t7_value);
          t8 = space$1();
          create_component(select.$$.fragment);
          t9 = space$1();
          span = element("span");
          button = element("button");
          t10 = text$1(t10_value);
          attr(input0, "id", "start");
          attr(input0, "type", "date");
          attr(input0, "pattern", "Y-m-d");
          attr(input0, "form", "filters-form");
          attr(label0, "for", "start");
          attr(label0, "class", "start");
          attr(input1, "id", "end");
          attr(input1, "type", "date");
          attr(input1, "pattern", "Y-m-d");
          attr(input1, "form", "filters-form");
          attr(label1, "for", "end");
          attr(label1, "class", "end");
          attr(label2, "for", "preset-select");
          attr(label2, "class", "status");
          button.disabled = /*loading*/ctx[3];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(button, "form", "filters-form");
          attr(span, "class", "actions");
          attr(div, "class", div_class_value = "reports-timerange".concat( /*loading*/ctx[3] ? " icon-loading" : ""));
        },
        m(target, anchor) {
          insert(target, div, anchor);
          mount_component(userfilterselect, div, null);
          append(div, t0);
          append(div, label0);
          append(label0, t1);
          append(label0, t2);
          append(label0, input0);
          set_input_value(input0, /*start*/ctx[2]);
          append(div, t3);
          append(div, label1);
          append(label1, t4);
          append(label1, t5);
          append(label1, input1);
          set_input_value(input1, /*end*/ctx[1]);
          append(div, t6);
          append(div, label2);
          append(label2, t7);
          append(label2, t8);
          mount_component(select, label2, null);
          append(div, t9);
          append(div, span);
          append(span, button);
          append(button, t10);
          current = true;
          if (!mounted) {
            dispose = [listen(input0, "input", /*input0_input_handler*/ctx[10]), listen(input0, "change", /*setUrlWithTimerange*/ctx[5]), listen(input1, "input", /*input1_input_handler*/ctx[11]), listen(input1, "change", /*setUrlWithTimerange*/ctx[5])];
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          var userfilterselect_changes = {};
          if (dirty & /*requestToken*/1) userfilterselect_changes.requestToken = /*requestToken*/ctx[0];
          userfilterselect.$set(userfilterselect_changes);
          if (dirty & /*start*/4) {
            set_input_value(input0, /*start*/ctx[2]);
          }
          if (dirty & /*end*/2) {
            set_input_value(input1, /*end*/ctx[1]);
          }
          if (!current || dirty & /*loading*/8) {
            button.disabled = /*loading*/ctx[3];
          }
          if (!current || dirty & /*loading*/8 && div_class_value !== (div_class_value = "reports-timerange".concat( /*loading*/ctx[3] ? " icon-loading" : ""))) {
            attr(div, "class", div_class_value);
          }
        },
        i(local) {
          if (current) return;
          transition_in(userfilterselect.$$.fragment, local);
          transition_in(select.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(userfilterselect.$$.fragment, local);
          transition_out(select.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          destroy_component(userfilterselect);
          destroy_component(select);
          mounted = false;
          run_all(dispose);
        }
      };
    }
    var dateFormat = "yyyy-MM-dd";
    function instance$4($$self, $$props, $$invalidate) {
      var loading;
      var start;
      var end;
      var requestToken = $$props.requestToken;
      var startOfMonth$1 = $$props.startOfMonth;
      var endOfMonth$1 = $$props.endOfMonth;
      var updateUrlWithTimerange = $$props.updateUrlWithTimerange;
      var presets = [{
        label: translate("timemanager", "Today"),
        value: "today"
      }, {
        label: translate("timemanager", "Yesterday"),
        value: "yesterday"
      }, {
        label: translate("timemanager", "This Week"),
        value: "week"
      }, {
        label: translate("timemanager", "Last week"),
        value: "week-1"
      }, {
        label: translate("timemanager", "This month"),
        value: "month"
      }, {
        label: translate("timemanager", "Last month"),
        value: "month-1"
      }, {
        label: translate("timemanager", "This year"),
        value: "year"
      }, {
        label: translate("timemanager", "Last year"),
        value: "year-1"
      }];
      var setUrlWithTimerange = function setUrlWithTimerange() {
        // Base off current url
        var newUrl = document.location.href;

        // Add filter attributes to url
        newUrl = Helpers.getUpdatedFilterUrl("start", start ? start : "", newUrl);
        newUrl = Helpers.getUpdatedFilterUrl("end", end ? end : "", newUrl);
        updateUrlWithTimerange(newUrl);
      };
      var handleSelectPreset = function handleSelectPreset(selectedValue) {
        var preset = selectedValue.detail.value;
        switch (preset) {
          case "today":
            $$invalidate(2, start = format$2(startOfToday(), dateFormat));
            $$invalidate(1, end = format$2(startOfToday(), dateFormat));
            break;
          case "yesterday":
            $$invalidate(2, start = format$2(startOfYesterday(), dateFormat));
            $$invalidate(1, end = format$2(startOfYesterday(), dateFormat));
            break;
          case "week":
            $$invalidate(2, start = format$2(startOfWeek(startOfToday(), {
              weekStartsOn: getFirstDay()
            }), dateFormat));
            $$invalidate(1, end = format$2(endOfWeek(startOfToday(), {
              weekStartsOn: getFirstDay()
            }), dateFormat));
            break;
          case "week-1":
            $$invalidate(2, start = format$2(startOfWeek(sub(startOfToday(), {
              weeks: 1
            }), {
              weekStartsOn: getFirstDay()
            }), dateFormat));
            $$invalidate(1, end = format$2(endOfWeek(sub(startOfToday(), {
              weeks: 1
            }), {
              weekStartsOn: getFirstDay()
            }), dateFormat));
            break;
          case "month":
            $$invalidate(2, start = format$2(startOfMonth(startOfToday()), dateFormat));
            $$invalidate(1, end = format$2(endOfMonth(startOfToday()), dateFormat));
            break;
          case "month-1":
            $$invalidate(2, start = format$2(startOfMonth(sub(startOfToday(), {
              months: 1
            })), dateFormat));
            $$invalidate(1, end = format$2(endOfMonth(sub(startOfToday(), {
              months: 1
            })), dateFormat));
            break;
          case "year":
            $$invalidate(2, start = format$2(startOfYear(startOfToday()), dateFormat));
            $$invalidate(1, end = format$2(endOfYear(startOfToday()), dateFormat));
            break;
          case "year-1":
            $$invalidate(2, start = format$2(startOfYear(sub(startOfToday(), {
              years: 1
            })), dateFormat));
            $$invalidate(1, end = format$2(endOfYear(sub(startOfToday(), {
              years: 1
            })), dateFormat));
            break;
        }
        setUrlWithTimerange();
      };
      onMount(function () {
        // Parse current URL
        var urlParts = document.location.href.split("?");
        if (urlParts.length > 1) {
          var queryString = urlParts[1];
          var queryStringParts = queryString.split("&");

          // Map over all query params
          queryStringParts.map(function (part) {
            // Split query params
            var partParts = part.split("=");
            var _partParts = _slicedToArray(partParts, 2),
              name = _partParts[0],
              value = _partParts[1];

            // Apply filters from query params
            if (name === "start" && value) {
              $$invalidate(2, start = value);
            }
            if (name === "end" && value) {
              $$invalidate(1, end = value);
            }
          });
        }
      });
      function input0_input_handler() {
        start = this.value;
        $$invalidate(2, start), $$invalidate(7, startOfMonth$1);
      }
      function input1_input_handler() {
        end = this.value;
        $$invalidate(1, end), $$invalidate(8, endOfMonth$1);
      }
      $$self.$$set = function ($$props) {
        if ('requestToken' in $$props) $$invalidate(0, requestToken = $$props.requestToken);
        if ('startOfMonth' in $$props) $$invalidate(7, startOfMonth$1 = $$props.startOfMonth);
        if ('endOfMonth' in $$props) $$invalidate(8, endOfMonth$1 = $$props.endOfMonth);
        if ('updateUrlWithTimerange' in $$props) $$invalidate(9, updateUrlWithTimerange = $$props.updateUrlWithTimerange);
      };
      $$self.$$.update = function () {
        if ($$self.$$.dirty & /*startOfMonth*/128) {
          $$invalidate(2, start = startOfMonth$1);
        }
        if ($$self.$$.dirty & /*endOfMonth*/256) {
          $$invalidate(1, end = endOfMonth$1);
        }
      };
      $$invalidate(3, loading = false);
      return [requestToken, end, start, loading, presets, setUrlWithTimerange, handleSelectPreset, startOfMonth$1, endOfMonth$1, updateUrlWithTimerange, input0_input_handler, input1_input_handler];
    }
    var Timerange = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(Timerange, _SvelteComponent);
      var _super = _createSuper$1(Timerange);
      function Timerange(options) {
        var _this;
        _classCallCheck$1(this, Timerange);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$4, create_fragment$4, safe_not_equal, {
          requestToken: 0,
          startOfMonth: 7,
          endOfMonth: 8,
          updateUrlWithTimerange: 9
        });
        return _this;
      }
      return _createClass$1(Timerange);
    }(SvelteComponent);

    function create_fragment$3(ctx) {
      var form;
      var label0;
      var t0_value = translate("timemanager", "Clients") + "";
      var t0;
      var t1;
      var select0;
      var t2;
      var label1;
      var t3_value = translate("timemanager", "Projects") + "";
      var t3;
      var t4;
      var select1;
      var t5;
      var label2;
      var t6_value = translate("timemanager", "Tasks") + "";
      var t6;
      var t7;
      var select2;
      var t8;
      var label3;
      var t9_value = translate("timemanager", "Status") + "";
      var t9;
      var t10;
      var select3;
      var form_class_value;
      var t11;
      var timerange;
      var current;
      var mounted;
      var dispose;
      select0 = new Select({
        props: {
          noOptionsMessage: translate("timemanager", "No options"),
          placeholder: translate("timemanager", "Select..."),
          inputAttributes: {
            id: "client-select"
          },
          items: /*clients*/ctx[0],
          value: /*selectedClients*/ctx[2],
          isMulti: true
        }
      });
      select0.$on("select", /*handleSelectClients*/ctx[12]);
      select1 = new Select({
        props: {
          noOptionsMessage: translate("timemanager", "No options"),
          placeholder: translate("timemanager", "Select..."),
          inputAttributes: {
            id: "projects-select"
          },
          items: /*availableProjects*/ctx[7],
          value: /*selectedProjects*/ctx[3],
          isMulti: true
        }
      });
      select1.$on("select", /*handleSelectProjects*/ctx[13]);
      select2 = new Select({
        props: {
          noOptionsMessage: translate("timemanager", "No options"),
          placeholder: translate("timemanager", "Select..."),
          inputAttributes: {
            id: "tasks-select"
          },
          items: /*availableTasks*/ctx[6],
          value: /*selectedTasks*/ctx[4],
          isMulti: true
        }
      });
      select2.$on("select", /*handleSelectTasks*/ctx[14]);
      select3 = new Select({
        props: {
          noOptionsMessage: translate("timemanager", "No options"),
          placeholder: translate("timemanager", "Select..."),
          inputAttributes: {
            id: "status-select"
          },
          items: /*availableStatus*/ctx[10],
          value: /*selectedStatus*/ctx[5]
        }
      });
      select3.$on("select", /*handleSelectStatus*/ctx[15]);
      select3.$on("clear", /*handleClearStatus*/ctx[16]);
      timerange = new Timerange({
        props: {
          updateUrlWithTimerange: /*updateUrlWithTimerange*/ctx[9],
          requestToken: /*requestToken*/ctx[1]
        }
      });
      return {
        c() {
          form = element("form");
          label0 = element("label");
          t0 = text$1(t0_value);
          t1 = space$1();
          create_component(select0.$$.fragment);
          t2 = space$1();
          label1 = element("label");
          t3 = text$1(t3_value);
          t4 = space$1();
          create_component(select1.$$.fragment);
          t5 = space$1();
          label2 = element("label");
          t6 = text$1(t6_value);
          t7 = space$1();
          create_component(select2.$$.fragment);
          t8 = space$1();
          label3 = element("label");
          t9 = text$1(t9_value);
          t10 = space$1();
          create_component(select3.$$.fragment);
          t11 = space$1();
          create_component(timerange.$$.fragment);
          attr(label0, "for", "client-select");
          attr(label0, "class", "clients");
          attr(label1, "for", "projects-select");
          attr(label1, "class", "projects");
          attr(label2, "for", "tasks-select");
          attr(label2, "class", "tasks");
          attr(label3, "for", "status-select");
          attr(label3, "class", "status");
          attr(form, "class", form_class_value = "reports-filters".concat( /*loading*/ctx[8] ? " icon-loading" : ""));
          attr(form, "id", "filters-form");
        },
        m(target, anchor) {
          insert(target, form, anchor);
          append(form, label0);
          append(label0, t0);
          append(label0, t1);
          mount_component(select0, label0, null);
          append(form, t2);
          append(form, label1);
          append(label1, t3);
          append(label1, t4);
          mount_component(select1, label1, null);
          append(form, t5);
          append(form, label2);
          append(label2, t6);
          append(label2, t7);
          mount_component(select2, label2, null);
          append(form, t8);
          append(form, label3);
          append(label3, t9);
          append(label3, t10);
          mount_component(select3, label3, null);
          insert(target, t11, anchor);
          mount_component(timerange, target, anchor);
          current = true;
          if (!mounted) {
            dispose = listen(form, "submit", prevent_default( /*apply*/ctx[11]));
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          var select0_changes = {};
          if (dirty & /*clients*/1) select0_changes.items = /*clients*/ctx[0];
          if (dirty & /*selectedClients*/4) select0_changes.value = /*selectedClients*/ctx[2];
          select0.$set(select0_changes);
          var select1_changes = {};
          if (dirty & /*availableProjects*/128) select1_changes.items = /*availableProjects*/ctx[7];
          if (dirty & /*selectedProjects*/8) select1_changes.value = /*selectedProjects*/ctx[3];
          select1.$set(select1_changes);
          var select2_changes = {};
          if (dirty & /*availableTasks*/64) select2_changes.items = /*availableTasks*/ctx[6];
          if (dirty & /*selectedTasks*/16) select2_changes.value = /*selectedTasks*/ctx[4];
          select2.$set(select2_changes);
          var select3_changes = {};
          if (dirty & /*selectedStatus*/32) select3_changes.value = /*selectedStatus*/ctx[5];
          select3.$set(select3_changes);
          if (!current || dirty & /*loading*/256 && form_class_value !== (form_class_value = "reports-filters".concat( /*loading*/ctx[8] ? " icon-loading" : ""))) {
            attr(form, "class", form_class_value);
          }
          var timerange_changes = {};
          if (dirty & /*requestToken*/2) timerange_changes.requestToken = /*requestToken*/ctx[1];
          timerange.$set(timerange_changes);
        },
        i(local) {
          if (current) return;
          transition_in(select0.$$.fragment, local);
          transition_in(select1.$$.fragment, local);
          transition_in(select2.$$.fragment, local);
          transition_in(select3.$$.fragment, local);
          transition_in(timerange.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(select0.$$.fragment, local);
          transition_out(select1.$$.fragment, local);
          transition_out(select2.$$.fragment, local);
          transition_out(select3.$$.fragment, local);
          transition_out(timerange.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(form);
            detach(t11);
          }
          destroy_component(select0);
          destroy_component(select1);
          destroy_component(select2);
          destroy_component(select3);
          destroy_component(timerange, detaching);
          mounted = false;
          dispose();
        }
      };
    }
    function instance$3($$self, $$props, $$invalidate) {
      var loading;
      var availableProjects;
      var availableTasks;
      var clients = $$props.clients;
      var projects = $$props.projects;
      var tasks = $$props.tasks;
      var requestToken = $$props.requestToken;
      var selectedClients;
      var selectedProjects;
      var selectedTasks;
      var selectedStatus;
      var urlWithTimerange = "";
      var updateUrlWithTimerange = function updateUrlWithTimerange(url) {
        return urlWithTimerange = url;
      };
      var availableStatus = [{
        value: "unpaid",
        label: translate("timemanager", "Unresolved")
      }, {
        value: "paid",
        label: translate("timemanager", "Resolved")
      }];
      var apply = function apply(e) {
        // Prepare a link with get attributes
        var filterLinkElement = Helpers.getLinkEl();

        // Base off current url
        var newUrl = urlWithTimerange || document.location.href;

        // Add filter attributes to url
        newUrl = Helpers.getUpdatedFilterUrl("clients", selectedClients ? selectedClients.map(function (c) {
          return c.value;
        }).join(",") : "", newUrl);
        newUrl = Helpers.getUpdatedFilterUrl("projects", selectedProjects ? selectedProjects.map(function (p) {
          return p.value;
        }).join(",") : "", newUrl);
        newUrl = Helpers.getUpdatedFilterUrl("tasks", selectedTasks ? selectedTasks.map(function (t) {
          return t.value;
        }).join(",") : "", newUrl);
        newUrl = Helpers.getUpdatedFilterUrl("status", selectedStatus ? selectedStatus.value : "", newUrl);

        // Attach url to hidden pjax link
        filterLinkElement.href = newUrl;

        // Navigate
        filterLinkElement.click();
      };
      var handleSelectClients = function handleSelectClients(event) {
        $$invalidate(2, selectedClients = event.detail);
        if (selectedClients && selectedClients.length) {
          $$invalidate(7, availableProjects = projects.filter(function (project) {
            return selectedClients.find(function (client) {
              return project.clientUuid === client.value;
            });
          }));
        } else {
          $$invalidate(7, availableProjects = projects);
        }
        if (selectedProjects && selectedProjects.length) {
          $$invalidate(6, availableTasks = tasks.filter(function (task) {
            return selectedProjects.find(function (project) {
              return task.projectUuid === project.value;
            });
          }));
        } else {
          $$invalidate(6, availableTasks = tasks);
        }
      };
      var handleSelectProjects = function handleSelectProjects(event) {
        $$invalidate(3, selectedProjects = event.detail);
        if (selectedClients && selectedClients.length) {
          $$invalidate(7, availableProjects = projects.filter(function (project) {
            return selectedClients.find(function (client) {
              return project.clientUuid === client.value;
            });
          }));
        } else {
          $$invalidate(7, availableProjects = projects);
        }
        if (selectedProjects && selectedProjects.length) {
          $$invalidate(6, availableTasks = tasks.filter(function (task) {
            return selectedProjects.find(function (project) {
              return task.projectUuid === project.value;
            });
          }));
        } else {
          $$invalidate(6, availableTasks = tasks);
        }
      };
      var handleSelectTasks = function handleSelectTasks(event) {
        $$invalidate(4, selectedTasks = event.detail);
      };
      var handleSelectStatus = function handleSelectStatus(event) {
        $$invalidate(5, selectedStatus = event.detail);
      };
      var handleClearStatus = function handleClearStatus() {
        $$invalidate(5, selectedStatus = "");
      };
      onMount(function () {
        // Parse current URL
        var urlParts = document.location.href.split("?");
        if (urlParts.length > 1) {
          var queryString = urlParts[1];
          var queryStringParts = queryString.split("&");

          // Map over all query params
          queryStringParts.map(function (part) {
            // Split query params
            var partParts = part.split("=");
            var _partParts = _slicedToArray(partParts, 2),
              name = _partParts[0],
              value = _partParts[1];

            // Apply filters from query params
            if (name === "status" && value) {
              $$invalidate(5, selectedStatus = availableStatus.find(function (status) {
                return status.value === value;
              }));
            }
            if (name === "tasks" && value && value.length) {
              $$invalidate(4, selectedTasks = value.split(",").map(function (taskId) {
                return tasks.find(function (task) {
                  return task.value === taskId;
                });
              }));
            }
            if (name === "projects" && value && value.length) {
              handleSelectProjects({
                detail: value.split(",").map(function (projectId) {
                  return projects.find(function (project) {
                    return project.value === projectId;
                  });
                })
              });
            }
            if (name === "clients" && value && value.length) {
              handleSelectClients({
                detail: value.split(",").map(function (clientId) {
                  return clients.find(function (client) {
                    return client.value === clientId;
                  });
                })
              });
            }
          });
        } else {
          // Apply timezone and empty filters when a user
          // happens to land on /reports without params
          apply();
        }
      });
      $$self.$$set = function ($$props) {
        if ('clients' in $$props) $$invalidate(0, clients = $$props.clients);
        if ('projects' in $$props) $$invalidate(17, projects = $$props.projects);
        if ('tasks' in $$props) $$invalidate(18, tasks = $$props.tasks);
        if ('requestToken' in $$props) $$invalidate(1, requestToken = $$props.requestToken);
      };
      $$self.$$.update = function () {
        if ($$self.$$.dirty & /*projects*/131072) {
          $$invalidate(7, availableProjects = projects);
        }
        if ($$self.$$.dirty & /*tasks*/262144) {
          $$invalidate(6, availableTasks = tasks);
        }
      };
      $$invalidate(8, loading = false);
      return [clients, requestToken, selectedClients, selectedProjects, selectedTasks, selectedStatus, availableTasks, availableProjects, loading, updateUrlWithTimerange, availableStatus, apply, handleSelectClients, handleSelectProjects, handleSelectTasks, handleSelectStatus, handleClearStatus, projects, tasks];
    }
    var Filters = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(Filters, _SvelteComponent);
      var _super = _createSuper$1(Filters);
      function Filters(options) {
        var _this;
        _classCallCheck$1(this, Filters);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$3, create_fragment$3, safe_not_equal, {
          clients: 0,
          projects: 17,
          tasks: 18,
          requestToken: 1
        });
        return _this;
      }
      return _createClass$1(Filters);
    }(SvelteComponent);

    function create_fragment$2(ctx) {
      var button;
      var mounted;
      var dispose;
      return {
        c() {
          button = element("button");
          button.textContent = "".concat(translate('timemanager', 'Print report'));
          attr(button, "type", "button");
          attr(button, "class", "button secondary");
        },
        m(target, anchor) {
          insert(target, button, anchor);
          if (!mounted) {
            dispose = listen(button, "click", /*click_handler*/ctx[0]);
            mounted = true;
          }
        },
        p: noop$1,
        i: noop$1,
        o: noop$1,
        d(detaching) {
          if (detaching) {
            detach(button);
          }
          mounted = false;
          dispose();
        }
      };
    }
    function instance$2($$self) {
      onMount(function () {
        var openDetailsBeforePrint = function openDetailsBeforePrint() {
          var details = document.querySelectorAll("details");
          details && details.length && details.forEach(function (details) {
            if (!details.open) {
              details.setAttribute("open", "open");
              details.setAttribute("data-print", "true");
            }
          });
        };
        var closeDetailsAfterPrint = function closeDetailsAfterPrint() {
          var details = document.querySelectorAll("details[data-print=true]");
          details && details.length && details.forEach(function (details) {
            details.removeAttribute("open");
            details.removeAttribute("data-print");
          });
        };
        window.addEventListener("beforeprint", openDetailsBeforePrint);
        window.addEventListener("afterprint", closeDetailsAfterPrint);
        return function () {
          window.removeEventListener("beforeprint", openDetailsBeforePrint);
          window.removeEventListener("afterprint", closeDetailsAfterPrint);
        };
      });
      var click_handler = function click_handler() {
        return window.print();
      };
      return [click_handler];
    }
    var PrintButton = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(PrintButton, _SvelteComponent);
      var _super = _createSuper$1(PrintButton);
      function PrintButton(options) {
        var _this;
        _classCallCheck$1(this, PrintButton);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$2, create_fragment$2, safe_not_equal, {});
        return _this;
      }
      return _createClass$1(PrintButton);
    }(SvelteComponent);

    var $entries = objectToArray.entries;

    // `Object.entries` method
    // https://tc39.es/ecma262/#sec-object.entries
    _export({
      target: 'Object',
      stat: true
    }, {
      entries: function entries(O) {
        return $entries(O);
      }
    });

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;
    function init$1 () {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray (b64) {
      if (!inited) {
        init$1();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

      // base64 is 4/3 + up to two characters of the original data
      arr = new Arr(len * 3 / 4 - placeHolders);

      // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len;

      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      if (!inited) {
        init$1();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }

      parts.push(output);

      return parts.join('')
    }

    function read (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    function write (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString = {}.toString;

    var isArray$1 = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    /* eslint-disable no-proto */


    var INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

    /*
     * Export kMaxLength after typed array support is determined.
     */
    kMaxLength();

    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }
        that.length = length;
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr
    };

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
      if (typeof Symbol !== 'undefined' && Symbol.species &&
          Buffer[Symbol.species] === Buffer) ;
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    };

    function allocUnsafe (that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    };

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that
    }

    function fromObject (that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len);
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray$1(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    Buffer.isBuffer = isBuffer;
    function internalIsBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function compare (a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!isArray$1(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.equals = function equals (b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf)
      } else {
        return fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }


    function base64ToBytes (str) {
      return toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }


    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    function isBuffer(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    }

    function isFastBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
    }

    var domain;

    // This constructor is used to store event handlers. Instantiating this is
    // faster than explicitly calling `Object.create(null)` to get a "clean" empty
    // object (tested with v8 v4.9).
    function EventHandlers() {}
    EventHandlers.prototype = Object.create(null);

    function EventEmitter() {
      EventEmitter.init.call(this);
    }

    // nodejs oddity
    // require('events') === require('events').EventEmitter
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.usingDomains = false;

    EventEmitter.prototype.domain = undefined;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;

    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;

    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        // if there is an active domain, then attach to it.
        if (domain.active) ;
      }

      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }

      this._maxListeners = this._maxListeners || undefined;
    };

    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };

    function $getMaxListeners(that) {
      if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }

    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };

    // These standalone emit* functions are used to optimize calling of event
    // handlers for fast cases because emit() itself often has a variable number of
    // arguments and can be deoptimized because of that. These functions always have
    // the same number of arguments and thus do not get deoptimized, so the code
    // inside them can execute faster.
    function emitNone(handler, isFn, self) {
      if (isFn)
        handler.call(self);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self);
      }
    }
    function emitOne(handler, isFn, self, arg1) {
      if (isFn)
        handler.call(self, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1);
      }
    }
    function emitTwo(handler, isFn, self, arg1, arg2) {
      if (isFn)
        handler.call(self, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2, arg3);
      }
    }

    function emitMany(handler, isFn, self, args) {
      if (isFn)
        handler.apply(self, args);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self, args);
      }
    }

    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain;
      var doError = (type === 'error');

      events = this._events;
      if (events)
        doError = (doError && events.error == null);
      else if (!doError)
        return false;

      domain = this.domain;

      // If there is no 'error' event listener then throw.
      if (doError) {
        er = arguments[1];
        if (domain) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain;
          er.domainThrown = false;
          domain.emit('error', er);
        } else if (er instanceof Error) {
          throw er; // Unhandled 'error' event
        } else {
          // At least give some kind of context to the user
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
          err.context = er;
          throw err;
        }
        return false;
      }

      handler = events[type];

      if (!handler)
        return false;

      var isFn = typeof handler === 'function';
      len = arguments.length;
      switch (len) {
        // fast cases
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        // slower
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }

      return true;
    };

    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener) {
          target.emit('newListener', type,
                      listener.listener ? listener.listener : listener);

          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }

      if (!existing) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] = prepend ? [listener, existing] :
                                              [existing, listener];
        } else {
          // If we've already got an array, just append.
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }

        // Check for listener leak
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error('Possible EventEmitter memory leak detected. ' +
                                existing.length + ' ' + type + ' listeners added. ' +
                                'Use emitter.setMaxListeners() to increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }

      return target;
    }
    function emitWarning(e) {
      typeof console.warn === 'function' ? console.warn(e) : console.log(e);
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.prependListener =
        function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };

    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }

    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };

    EventEmitter.prototype.prependOnceListener =
        function prependOnceListener(type, listener) {
          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };

    // emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener =
        function removeListener(type, listener) {
          var list, events, position, i, originalListener;

          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');

          events = this._events;
          if (!events)
            return this;

          list = events[type];
          if (!list)
            return this;

          if (list === listener || (list.listener && list.listener === listener)) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else {
              delete events[type];
              if (events.removeListener)
                this.emit('removeListener', type, list.listener || listener);
            }
          } else if (typeof list !== 'function') {
            position = -1;

            for (i = list.length; i-- > 0;) {
              if (list[i] === listener ||
                  (list[i].listener && list[i].listener === listener)) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0)
              return this;

            if (list.length === 1) {
              list[0] = undefined;
              if (--this._eventsCount === 0) {
                this._events = new EventHandlers();
                return this;
              } else {
                delete events[type];
              }
            } else {
              spliceOne(list, position);
            }

            if (events.removeListener)
              this.emit('removeListener', type, originalListener || listener);
          }

          return this;
        };
        
    // Alias for removeListener added in NodeJS 10.0
    // https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
    EventEmitter.prototype.off = function(type, listener){
        return this.removeListener(type, listener);
    };

    EventEmitter.prototype.removeAllListeners =
        function removeAllListeners(type) {
          var listeners, events;

          events = this._events;
          if (!events)
            return this;

          // not listening for removeListener, no need to emit
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = new EventHandlers();
              this._eventsCount = 0;
            } else if (events[type]) {
              if (--this._eventsCount === 0)
                this._events = new EventHandlers();
              else
                delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            for (var i = 0, key; i < keys.length; ++i) {
              key = keys[i];
              if (key === 'removeListener') continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = new EventHandlers();
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
          } else if (listeners) {
            // LIFO order
            do {
              this.removeListener(type, listeners[listeners.length - 1]);
            } while (listeners[0]);
          }

          return this;
        };

    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;

      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === 'function')
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }

      return ret;
    };

    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount$1.call(emitter, type);
      }
    };

    EventEmitter.prototype.listenerCount = listenerCount$1;
    function listenerCount$1(type) {
      var events = this._events;

      if (events) {
        var evlistener = events[type];

        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }

      return 0;
    }

    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };

    // About 1.5x faster than the two-arg version of Array#splice().
    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }

    function arrayClone(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }

    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }

    var inherits;
    if (typeof Object.create === 'function'){
      inherits = function inherits(ctor, superCtor) {
        // implementation from standard node.js 'util' module
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }

    var formatRegExp = /%[sdj%]/g;
    function format(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s': return String(args[i++]);
          case '%d': return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    }

    // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.
    function deprecate(fn, msg) {
      // Allow for deprecating things in the process of starting up.
      if (isUndefined(global$1.process)) {
        return function() {
          return deprecate(fn, msg).apply(this, arguments);
        };
      }

      if (browser$1.noDeprecation === true) {
        return fn;
      }

      var warned = false;
      function deprecated() {
        if (!warned) {
          if (browser$1.throwDeprecation) {
            throw new Error(msg);
          } else if (browser$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }

      return deprecated;
    }

    var debugs = {};
    var debugEnviron;
    function debuglog(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = browser$1.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = 0;
          debugs[set] = function() {
            var msg = format.apply(null, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    }

    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        _extend(ctx, opts);
      }
      // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }

    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };

    // Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };


    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
               '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }


    function stylizeNoColor(str, styleType) {
      return str;
    }


    function arrayToHash(array) {
      var hash = {};

      array.forEach(function(val, idx) {
        hash[val] = true;
      });

      return hash;
    }


    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
          value &&
          isFunction(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '', array = false, braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }


    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }


    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }


    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }


    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }


    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    function isString(arg) {
      return typeof arg === 'string';
    }

    function isUndefined(arg) {
      return arg === void 0;
    }

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }

    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }

    function _extend(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject(add)) return origin;

      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    function BufferList() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }

    BufferList.prototype.push = function (v) {
      var entry = { data: v, next: null };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    };

    BufferList.prototype.unshift = function (v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    };

    BufferList.prototype.shift = function () {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    };

    BufferList.prototype.clear = function () {
      this.head = this.tail = null;
      this.length = 0;
    };

    BufferList.prototype.join = function (s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }return ret;
    };

    BufferList.prototype.concat = function (n) {
      if (this.length === 0) return Buffer.alloc(0);
      if (this.length === 1) return this.head.data;
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };

    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    var isBufferEncoding = Buffer.isEncoding
      || function(encoding) {
           switch (encoding && encoding.toLowerCase()) {
             case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
             default: return false;
           }
         };


    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }

    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters. CESU-8 is handled as part of the UTF-8 encoding.
    //
    // @TODO Handling all encodings inside a single object makes it very difficult
    // to reason about this code, so it should be split up in the future.
    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
    // points as used by CESU-8.
    function StringDecoder(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          // CESU-8 represents each of Surrogate Pair by 3-bytes
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          // UTF-16 represents each of Surrogate Pair by 2-bytes
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }

      // Enough space to store all bytes of a single character. UTF-8 needs 4
      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
      this.charBuffer = new Buffer(6);
      // Number of bytes received for the current incomplete multi-byte character.
      this.charReceived = 0;
      // Number of bytes expected for the current incomplete multi-byte character.
      this.charLength = 0;
    }

    // write decodes the given buffer and returns it as JS string that is
    // guaranteed to not contain any partial multi-byte characters. Any partial
    // character found at the end of the buffer is buffered up, and will be
    // returned when calling write again with the remaining bytes.
    //
    // Note: Converting a Buffer containing an orphan surrogate to a String
    // currently works, but converting a String to a Buffer (via `new Buffer`, or
    // Buffer#write) will replace incomplete surrogates with the unicode
    // replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      // if our last write ended with an incomplete multibyte character
      while (this.charLength) {
        // determine how many remaining bytes this buffer has to offer for this char
        var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
            buffer.length;

        // add the new bytes to the char buffer
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;

        if (this.charReceived < this.charLength) {
          // still not enough chars in this buffer? wait for more ...
          return '';
        }

        // remove bytes belonging to the current character from the buffer
        buffer = buffer.slice(available, buffer.length);

        // get the character that was split
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;

        // if there are no more bytes in this buffer, just emit our char
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }

      // determine and set charLength / charReceived
      this.detectIncompleteChar(buffer);

      var end = buffer.length;
      if (this.charLength) {
        // buffer the incomplete character bytes we got
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }

      charStr += buffer.toString(this.encoding, 0, end);

      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }

      // or just emit the charStr
      return charStr;
    };

    // detectIncompleteChar determines if there is an incomplete UTF-8 character at
    // the end of the given buffer. If so, it sets this.charLength to the byte
    // length that character, and sets this.charReceived to the number of bytes
    // that are available for this character.
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      // determine how many bytes we have to check at the end of this buffer
      var i = (buffer.length >= 3) ? 3 : buffer.length;

      // Figure out if one of the last i bytes of our buffer announces an
      // incomplete char.
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];

        // See http://en.wikipedia.org/wiki/UTF-8#Description

        // 110XXXXX
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }

        // 1110XXXX
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }

        // 11110XXX
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };

    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);

      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }

      return res;
    };

    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }

    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }

    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }

    Readable.ReadableState = ReadableState;

    var debug$1 = debuglog('stream');
    inherits(Readable, EventEmitter);

    function prependListener(emitter, event, fn) {
      // Sadly this is not cacheable as some libraries bundle their own
      // event emitter implementation with them.
      if (typeof emitter.prependListener === 'function') {
        return emitter.prependListener(event, fn);
      } else {
        // This is a hack to make sure that our error handler is attached before any
        // userland ones.  NEVER DO THIS. This is here only because this code needs
        // to continue to work with older versions of Node.js that do not include
        // the prependListener() method. The goal is to eventually remove this hack.
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
    }
    function listenerCount (emitter, type) {
      return emitter.listeners(type).length;
    }
    function ReadableState(options, stream) {

      options = options || {};

      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;

      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

      // cast to ints.
      this.highWaterMark = ~ ~this.highWaterMark;

      // A linked list is used to store data chunks instead of an array because the
      // linked list can remove elements from the beginning faster than
      // array.shift()
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;

      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;

      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;

      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';

      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;

      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;

      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;

      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {

      if (!(this instanceof Readable)) return new Readable(options);

      this._readableState = new ReadableState(options, this);

      // legacy
      this.readable = true;

      if (options && typeof options.read === 'function') this._read = options.read;

      EventEmitter.call(this);
    }

    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState;

      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = '';
        }
      }

      return readableAddChunk(this, state, chunk, encoding, false);
    };

    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function (chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };

    Readable.prototype.isPaused = function () {
      return this._readableState.flowing === false;
    };

    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var _e = new Error('stream.unshift() after end event');
          stream.emit('error', _e);
        } else {
          var skipAdd;
          if (state.decoder && !addToFront && !encoding) {
            chunk = state.decoder.write(chunk);
            skipAdd = !state.objectMode && chunk.length === 0;
          }

          if (!addToFront) state.reading = false;

          // Don't add to the buffer if we've decoded to an empty string chunk and
          // we're not in object mode
          if (!skipAdd) {
            // if we want the data now, just emit it.
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk);
              stream.read(0);
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

              if (state.needReadable) emitReadable(stream);
            }
          }

          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }

      return needMoreData(state);
    }

    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }

    // backwards compatibility.
    Readable.prototype.setEncoding = function (enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };

    // Don't raise the hwm > 8MB
    var MAX_HWM = 0x800000;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }

    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
      }
      // If we're asking for more than the current hwm, then raise the hwm.
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      // Don't have enough
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }

    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function (n) {
      debug$1('read', n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;

      if (n !== 0) state.emittedReadable = false;

      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug$1('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
        return null;
      }

      n = howMuchToRead(n, state);

      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }

      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.

      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
      debug$1('need readable', doRead);

      // if we currently have less than the highWaterMark, then also read some
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug$1('length less than watermark', doRead);
      }

      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading) {
        doRead = false;
        debug$1('reading or ended', doRead);
      } else if (doRead) {
        debug$1('do read');
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }

      var ret;
      if (n > 0) ret = fromList(n, state);else ret = null;

      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }

      if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;

        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
      }

      if (ret !== null) this.emit('data', ret);

      return ret;
    };

    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }

    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;

      // emit 'readable' now to make sure it gets picked up.
      emitReadable(stream);
    }

    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug$1('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
      }
    }

    function emitReadable_(stream) {
      debug$1('emit readable');
      stream.emit('readable');
      flow(stream);
    }

    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        nextTick(maybeReadMore_, stream, state);
      }
    }

    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug$1('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;else len = state.length;
      }
      state.readingMore = false;
    }

    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function (n) {
      this.emit('error', new Error('not implemented'));
    };

    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this;
      var state = this._readableState;

      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug$1('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

      var doEnd = (!pipeOpts || pipeOpts.end !== false);

      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug$1('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }

      function onend() {
        debug$1('onend');
        dest.end();
      }

      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);

      var cleanedUp = false;
      function cleanup() {
        debug$1('cleanup');
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);

        cleanedUp = true;

        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }

      // If the user pushes more data while we're writing to dest then we'll end up
      // in ondata again. However, we only want to increase awaitDrain once because
      // dest will only emit one 'drain' event for the multiple writes.
      // => Introduce a guard on increasing awaitDrain.
      var increasedAwaitDrain = false;
      src.on('data', ondata);
      function ondata(chunk) {
        debug$1('ondata');
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          // If the user unpiped during `dest.write()`, it is possible
          // to get stuck in a permanently paused state if that write
          // also returned false.
          // => Check whether `dest` is still a piping destination.
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug$1('false write response, pause', src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }

      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        debug$1('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
      }

      // Make sure our error handler is attached before userland ones.
      prependListener(dest, 'error', onerror);

      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug$1('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);

      function unpipe() {
        debug$1('unpipe');
        src.unpipe(dest);
      }

      // tell the dest that it's being piped to
      dest.emit('pipe', src);

      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        debug$1('pipe resume');
        src.resume();
      }

      return dest;
    };

    function pipeOnDrain(src) {
      return function () {
        var state = src._readableState;
        debug$1('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && src.listeners('data').length) {
          state.flowing = true;
          flow(src);
        }
      };
    }

    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState;

      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0) return this;

      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;

        if (!dest) dest = state.pipes;

        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this);
        return this;
      }

      // slow case. multiple pipe destinations.

      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;

        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit('unpipe', this);
        }return this;
      }

      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1) return this;

      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];

      dest.emit('unpipe', this);

      return this;
    };

    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function (ev, fn) {
      var res = EventEmitter.prototype.on.call(this, ev, fn);

      if (ev === 'data') {
        // Start flowing on next tick if stream isn't explicitly paused
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === 'readable') {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }

      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;

    function nReadingNextTick(self) {
      debug$1('readable nexttick read 0');
      self.read(0);
    }

    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function () {
      var state = this._readableState;
      if (!state.flowing) {
        debug$1('resume');
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };

    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick(resume_, stream, state);
      }
    }

    function resume_(stream, state) {
      if (!state.reading) {
        debug$1('resume read 0');
        stream.read(0);
      }

      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }

    Readable.prototype.pause = function () {
      debug$1('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug$1('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };

    function flow(stream) {
      var state = stream._readableState;
      debug$1('flow', state.flowing);
      while (state.flowing && stream.read() !== null) {}
    }

    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function (stream) {
      var state = this._readableState;
      var paused = false;

      var self = this;
      stream.on('end', function () {
        debug$1('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) self.push(chunk);
        }

        self.push(null);
      });

      stream.on('data', function (chunk) {
        debug$1('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk);

        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });

      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function (method) {
            return function () {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }

      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function (ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });

      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function (n) {
        debug$1('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };

      return self;
    };

    // exposed for testing purposes only.
    Readable._fromList = fromList;

    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function fromList(n, state) {
      // nothing buffered
      if (state.length === 0) return null;

      var ret;
      if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        // read part of list
        ret = fromListPartial(n, state.buffer, state.decoder);
      }

      return ret;
    }

    // Extracts only enough buffered data to satisfy the amount requested.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        // slice is the same for buffers and strings
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        // first chunk is a perfect match
        ret = list.shift();
      } else {
        // result spans more than one buffer
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }

    // Copies a specified amount of characters from the list of buffered data
    // chunks.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }

    // Copies a specified amount of bytes from the list of buffered data chunks.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function copyFromBuffer(n, list) {
      var ret = Buffer.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }

    function endReadable(stream) {
      var state = stream._readableState;

      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

      if (!state.endEmitted) {
        state.ended = true;
        nextTick(endReadableNT, state, stream);
      }
    }

    function endReadableNT(state, stream) {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    }

    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }

    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }

    // A bit simpler than readable streams.
    // Implement an async ._write(chunk, encoding, cb), and it'll handle all
    // the drain event emission and buffering.

    Writable.WritableState = WritableState;
    inherits(Writable, EventEmitter);

    function nop() {}

    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }

    function WritableState(options, stream) {
      Object.defineProperty(this, 'buffer', {
        get: deprecate(function () {
          return this.getBuffer();
        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
      });
      options = options || {};

      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;

      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

      // cast to ints.
      this.highWaterMark = ~ ~this.highWaterMark;

      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;

      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;

      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';

      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;

      // a flag to see when we're in the middle of a write.
      this.writing = false;

      // when true all writes will be buffered until .uncork() call
      this.corked = 0;

      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;

      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;

      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function (er) {
        onwrite(stream, er);
      };

      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;

      // the amount that is being written when _write is called.
      this.writelen = 0;

      this.bufferedRequest = null;
      this.lastBufferedRequest = null;

      // number of pending user-supplied write callbacks
      // this must be 0 before 'finish' can be emitted
      this.pendingcb = 0;

      // emit prefinish if the only thing we're waiting for is _write cbs
      // This is relevant for synchronous Transform streams
      this.prefinished = false;

      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;

      // count buffered requests
      this.bufferedRequestCount = 0;

      // allocate the first CorkedRequest, there is always
      // one allocated and free to use, and we maintain at most two
      this.corkedRequestsFree = new CorkedRequest(this);
    }

    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    function Writable(options) {

      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

      this._writableState = new WritableState(options, this);

      // legacy.
      this.writable = true;

      if (options) {
        if (typeof options.write === 'function') this._write = options.write;

        if (typeof options.writev === 'function') this._writev = options.writev;
      }

      EventEmitter.call(this);
    }

    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function () {
      this.emit('error', new Error('Cannot pipe, not readable'));
    };

    function writeAfterEnd(stream, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      nextTick(cb, er);
    }

    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      // Always throw error if a null is written
      // if we are not in object mode then throw
      // if it is not a buffer, string, or undefined.
      if (chunk === null) {
        er = new TypeError('May not write null values to stream');
      } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      if (er) {
        stream.emit('error', er);
        nextTick(cb, er);
        valid = false;
      }
      return valid;
    }

    Writable.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;

      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

      if (typeof cb !== 'function') cb = nop;

      if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }

      return ret;
    };

    Writable.prototype.cork = function () {
      var state = this._writableState;

      state.corked++;
    };

    Writable.prototype.uncork = function () {
      var state = this._writableState;

      if (state.corked) {
        state.corked--;

        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };

    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string') encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };

    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = Buffer.from(chunk, encoding);
      }
      return chunk;
    }

    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);

      if (Buffer.isBuffer(chunk)) encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;

      state.length += len;

      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret) state.needDrain = true;

      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }

      return ret;
    }

    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }

    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) nextTick(cb, er);else cb(er);

      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }

    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }

    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;

      onwriteStateUpdate(state);

      if (er) onwriteError(stream, state, sync, er, cb);else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);

        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }

        if (sync) {
          /*<replacement>*/
            nextTick(afterWrite, stream, state, finished, cb);
          /*</replacement>*/
        } else {
            afterWrite(stream, state, finished, cb);
          }
      }
    }

    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }

    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }

    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;

      if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;

        var count = 0;
        while (entry) {
          buffer[count] = entry;
          entry = entry.next;
          count += 1;
        }

        doWrite(stream, state, true, state.length, buffer, '', holder.finish);

        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
      } else {
        // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;

          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          // if we didn't call the onwrite immediately, then
          // it means that we need to wait until it does.
          // also, that means that the chunk and cb are currently
          // being processed, so move the buffer counter past them.
          if (state.writing) {
            break;
          }
        }

        if (entry === null) state.lastBufferedRequest = null;
      }

      state.bufferedRequestCount = 0;
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }

    Writable.prototype._write = function (chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };

    Writable.prototype._writev = null;

    Writable.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState;

      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

      // .end() fully uncorks
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }

      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished) endWritable(this, state, cb);
    };

    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }

    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }

    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish(stream, state);
        }
      }
      return need;
    }

    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) nextTick(cb);else stream.once('finish', cb);
      }
      state.ended = true;
      stream.writable = false;
    }

    // It seems a linked list but it is not
    // there will be only 2 of these for each stream
    function CorkedRequest(state) {
      var _this = this;

      this.next = null;
      this.entry = null;

      this.finish = function (err) {
        var entry = _this.entry;
        _this.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        if (state.corkedRequestsFree) {
          state.corkedRequestsFree.next = _this;
        } else {
          state.corkedRequestsFree = _this;
        }
      };
    }

    inherits(Duplex, Readable);

    var keys = Object.keys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);

      Readable.call(this, options);
      Writable.call(this, options);

      if (options && options.readable === false) this.readable = false;

      if (options && options.writable === false) this.writable = false;

      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

      this.once('end', onend);
    }

    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended) return;

      // no more data can be written.
      // But allow more writes to happen in this tick.
      nextTick(onEndNT, this);
    }

    function onEndNT(self) {
      self.end();
    }

    // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.

    inherits(Transform, Duplex);

    function TransformState(stream) {
      this.afterTransform = function (er, data) {
        return afterTransform(stream, er, data);
      };

      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
      this.writeencoding = null;
    }

    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;

      var cb = ts.writecb;

      if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

      ts.writechunk = null;
      ts.writecb = null;

      if (data !== null && data !== undefined) stream.push(data);

      cb(er);

      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);

      Duplex.call(this, options);

      this._transformState = new TransformState(this);

      // when the writable side finishes, then flush out anything remaining.
      var stream = this;

      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;

      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;

      if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;

        if (typeof options.flush === 'function') this._flush = options.flush;
      }

      this.once('prefinish', function () {
        if (typeof this._flush === 'function') this._flush(function (er) {
          done(stream, er);
        });else done(stream);
      });
    }

    Transform.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };

    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function (chunk, encoding, cb) {
      throw new Error('Not implemented');
    };

    Transform.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };

    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function (n) {
      var ts = this._transformState;

      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };

    function done(stream, er) {
      if (er) return stream.emit('error', er);

      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var ts = stream._transformState;

      if (ws.length) throw new Error('Calling transform done when ws.length != 0');

      if (ts.transforming) throw new Error('Calling transform done when still transforming');

      return stream.push(null);
    }

    const is_object = function (obj) {
      return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
    };

    class CsvError extends Error {
      constructor(code, message, options, ...contexts) {
        if (Array.isArray(message)) message = message.join(' ').trim();
        super(message);
        if (Error.captureStackTrace !== undefined) {
          Error.captureStackTrace(this, CsvError);
        }
        this.code = code;
        for (const context of contexts) {
          for (const key in context) {
            const value = context[key];
            this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));
          }
        }
      }
    }

    const normalize_columns_array = function (columns) {
      const normalizedColumns = [];
      for (let i = 0, l = columns.length; i < l; i++) {
        const column = columns[i];
        if (column === undefined || column === null || column === false) {
          normalizedColumns[i] = {
            disabled: true
          };
        } else if (typeof column === 'string') {
          normalizedColumns[i] = {
            name: column
          };
        } else if (is_object(column)) {
          if (typeof column.name !== 'string') {
            throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', ['Option columns missing name:', `property "name" is required at position ${i}`, 'when column is an object literal']);
          }
          normalizedColumns[i] = column;
        } else {
          throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', ['Invalid column definition:', 'expect a string or a literal object,', `got ${JSON.stringify(column)} at position ${i}`]);
        }
      }
      return normalizedColumns;
    };

    class ResizeableBuffer {
      constructor(size = 100) {
        this.size = size;
        this.length = 0;
        this.buf = Buffer.allocUnsafe(size);
      }
      prepend(val) {
        if (Buffer.isBuffer(val)) {
          const length = this.length + val.length;
          if (length >= this.size) {
            this.resize();
            if (length >= this.size) {
              throw Error('INVALID_BUFFER_STATE');
            }
          }
          const buf = this.buf;
          this.buf = Buffer.allocUnsafe(this.size);
          val.copy(this.buf, 0);
          buf.copy(this.buf, val.length);
          this.length += val.length;
        } else {
          const length = this.length++;
          if (length === this.size) {
            this.resize();
          }
          const buf = this.clone();
          this.buf[0] = val;
          buf.copy(this.buf, 1, 0, length);
        }
      }
      append(val) {
        const length = this.length++;
        if (length === this.size) {
          this.resize();
        }
        this.buf[length] = val;
      }
      clone() {
        return Buffer.from(this.buf.slice(0, this.length));
      }
      resize() {
        const length = this.length;
        this.size = this.size * 2;
        const buf = Buffer.allocUnsafe(this.size);
        this.buf.copy(buf, 0, 0, length);
        this.buf = buf;
      }
      toString(encoding) {
        if (encoding) {
          return this.buf.slice(0, this.length).toString(encoding);
        } else {
          return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
        }
      }
      toJSON() {
        return this.toString('utf8');
      }
      reset() {
        this.length = 0;
      }
    }

    // white space characters
    // https://en.wikipedia.org/wiki/Whitespace_character
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types
    // \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff
    const np = 12;
    const cr$1 = 13; // `\r`, carriage return, 0x0D in hexadécimal, 13 in decimal
    const nl$1 = 10; // `\n`, newline, 0x0A in hexadecimal, 10 in decimal
    const space = 32;
    const tab = 9;
    const init_state = function (options) {
      return {
        bomSkipped: false,
        bufBytesStart: 0,
        castField: options.cast_function,
        commenting: false,
        // Current error encountered by a record
        error: undefined,
        enabled: options.from_line === 1,
        escaping: false,
        escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,
        // columns can be `false`, `true`, `Array`
        expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,
        field: new ResizeableBuffer(20),
        firstLineToHeaders: options.cast_first_line_to_header,
        needMoreDataSize: Math.max(
        // Skip if the remaining buffer smaller than comment
        options.comment !== null ? options.comment.length : 0,
        // Skip if the remaining buffer can be delimiter
        ...options.delimiter.map(delimiter => delimiter.length),
        // Skip if the remaining buffer can be escape sequence
        options.quote !== null ? options.quote.length : 0),
        previousBuf: undefined,
        quoting: false,
        stop: false,
        rawBuffer: new ResizeableBuffer(100),
        record: [],
        recordHasError: false,
        record_length: 0,
        recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 0 : Math.max(...options.record_delimiter.map(v => v.length)),
        trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\t', options.encoding)[0]],
        wasQuoting: false,
        wasRowDelimiter: false,
        timchars: [Buffer.from(Buffer.from([cr$1], 'utf8').toString(), options.encoding), Buffer.from(Buffer.from([nl$1], 'utf8').toString(), options.encoding), Buffer.from(Buffer.from([np], 'utf8').toString(), options.encoding), Buffer.from(Buffer.from([space], 'utf8').toString(), options.encoding), Buffer.from(Buffer.from([tab], 'utf8').toString(), options.encoding)]
      };
    };

    const underscore = function (str) {
      return str.replace(/([A-Z])/g, function (_, match) {
        return '_' + match.toLowerCase();
      });
    };

    const normalize_options = function (opts) {
      const options = {};
      // Merge with user options
      for (const opt in opts) {
        options[underscore(opt)] = opts[opt];
      }
      // Normalize option `encoding`
      // Note: defined first because other options depends on it
      // to convert chars/strings into buffers.
      if (options.encoding === undefined || options.encoding === true) {
        options.encoding = 'utf8';
      } else if (options.encoding === null || options.encoding === false) {
        options.encoding = null;
      } else if (typeof options.encoding !== 'string' && options.encoding !== null) {
        throw new CsvError('CSV_INVALID_OPTION_ENCODING', ['Invalid option encoding:', 'encoding must be a string or null to return a buffer,', `got ${JSON.stringify(options.encoding)}`], options);
      }
      // Normalize option `bom`
      if (options.bom === undefined || options.bom === null || options.bom === false) {
        options.bom = false;
      } else if (options.bom !== true) {
        throw new CsvError('CSV_INVALID_OPTION_BOM', ['Invalid option bom:', 'bom must be true,', `got ${JSON.stringify(options.bom)}`], options);
      }
      // Normalize option `cast`
      options.cast_function = null;
      if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === '') {
        options.cast = undefined;
      } else if (typeof options.cast === 'function') {
        options.cast_function = options.cast;
        options.cast = true;
      } else if (options.cast !== true) {
        throw new CsvError('CSV_INVALID_OPTION_CAST', ['Invalid option cast:', 'cast must be true or a function,', `got ${JSON.stringify(options.cast)}`], options);
      }
      // Normalize option `cast_date`
      if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === '') {
        options.cast_date = false;
      } else if (options.cast_date === true) {
        options.cast_date = function (value) {
          const date = Date.parse(value);
          return !isNaN(date) ? new Date(date) : value;
        };
      } else if (typeof options.cast_date !== 'function') {
        throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', ['Invalid option cast_date:', 'cast_date must be true or a function,', `got ${JSON.stringify(options.cast_date)}`], options);
      }
      // Normalize option `columns`
      options.cast_first_line_to_header = null;
      if (options.columns === true) {
        // Fields in the first line are converted as-is to columns
        options.cast_first_line_to_header = undefined;
      } else if (typeof options.columns === 'function') {
        options.cast_first_line_to_header = options.columns;
        options.columns = true;
      } else if (Array.isArray(options.columns)) {
        options.columns = normalize_columns_array(options.columns);
      } else if (options.columns === undefined || options.columns === null || options.columns === false) {
        options.columns = false;
      } else {
        throw new CsvError('CSV_INVALID_OPTION_COLUMNS', ['Invalid option columns:', 'expect an array, a function or true,', `got ${JSON.stringify(options.columns)}`], options);
      }
      // Normalize option `group_columns_by_name`
      if (options.group_columns_by_name === undefined || options.group_columns_by_name === null || options.group_columns_by_name === false) {
        options.group_columns_by_name = false;
      } else if (options.group_columns_by_name !== true) {
        throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', ['Invalid option group_columns_by_name:', 'expect an boolean,', `got ${JSON.stringify(options.group_columns_by_name)}`], options);
      } else if (options.columns === false) {
        throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', ['Invalid option group_columns_by_name:', 'the `columns` mode must be activated.'], options);
      }
      // Normalize option `comment`
      if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === '') {
        options.comment = null;
      } else {
        if (typeof options.comment === 'string') {
          options.comment = Buffer.from(options.comment, options.encoding);
        }
        if (!Buffer.isBuffer(options.comment)) {
          throw new CsvError('CSV_INVALID_OPTION_COMMENT', ['Invalid option comment:', 'comment must be a buffer or a string,', `got ${JSON.stringify(options.comment)}`], options);
        }
      }
      // Normalize option `delimiter`
      const delimiter_json = JSON.stringify(options.delimiter);
      if (!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];
      if (options.delimiter.length === 0) {
        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', `got ${delimiter_json}`], options);
      }
      options.delimiter = options.delimiter.map(function (delimiter) {
        if (delimiter === undefined || delimiter === null || delimiter === false) {
          return Buffer.from(',', options.encoding);
        }
        if (typeof delimiter === 'string') {
          delimiter = Buffer.from(delimiter, options.encoding);
        }
        if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {
          throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', `got ${delimiter_json}`], options);
        }
        return delimiter;
      });
      // Normalize option `escape`
      if (options.escape === undefined || options.escape === true) {
        options.escape = Buffer.from('"', options.encoding);
      } else if (typeof options.escape === 'string') {
        options.escape = Buffer.from(options.escape, options.encoding);
      } else if (options.escape === null || options.escape === false) {
        options.escape = null;
      }
      if (options.escape !== null) {
        if (!Buffer.isBuffer(options.escape)) {
          throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);
        }
      }
      // Normalize option `from`
      if (options.from === undefined || options.from === null) {
        options.from = 1;
      } else {
        if (typeof options.from === 'string' && /\d+/.test(options.from)) {
          options.from = parseInt(options.from);
        }
        if (Number.isInteger(options.from)) {
          if (options.from < 0) {
            throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);
          }
        } else {
          throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);
        }
      }
      // Normalize option `from_line`
      if (options.from_line === undefined || options.from_line === null) {
        options.from_line = 1;
      } else {
        if (typeof options.from_line === 'string' && /\d+/.test(options.from_line)) {
          options.from_line = parseInt(options.from_line);
        }
        if (Number.isInteger(options.from_line)) {
          if (options.from_line <= 0) {
            throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);
          }
        } else {
          throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);
        }
      }
      // Normalize options `ignore_last_delimiters`
      if (options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null) {
        options.ignore_last_delimiters = false;
      } else if (typeof options.ignore_last_delimiters === 'number') {
        options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);
        if (options.ignore_last_delimiters === 0) {
          options.ignore_last_delimiters = false;
        }
      } else if (typeof options.ignore_last_delimiters !== 'boolean') {
        throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', ['Invalid option `ignore_last_delimiters`:', 'the value must be a boolean value or an integer,', `got ${JSON.stringify(options.ignore_last_delimiters)}`], options);
      }
      if (options.ignore_last_delimiters === true && options.columns === false) {
        throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', ['The option `ignore_last_delimiters`', 'requires the activation of the `columns` option'], options);
      }
      // Normalize option `info`
      if (options.info === undefined || options.info === null || options.info === false) {
        options.info = false;
      } else if (options.info !== true) {
        throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);
      }
      // Normalize option `max_record_size`
      if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {
        options.max_record_size = 0;
      } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) ; else if (typeof options.max_record_size === 'string' && /\d+/.test(options.max_record_size)) {
        options.max_record_size = parseInt(options.max_record_size);
      } else {
        throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);
      }
      // Normalize option `objname`
      if (options.objname === undefined || options.objname === null || options.objname === false) {
        options.objname = undefined;
      } else if (Buffer.isBuffer(options.objname)) {
        if (options.objname.length === 0) {
          throw new Error(`Invalid Option: objname must be a non empty buffer`);
        }
        if (options.encoding === null) ; else {
          options.objname = options.objname.toString(options.encoding);
        }
      } else if (typeof options.objname === 'string') {
        if (options.objname.length === 0) {
          throw new Error(`Invalid Option: objname must be a non empty string`);
        }
        // Great, nothing to do
      } else if (typeof options.objname === 'number') ; else {
        throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);
      }
      if (options.objname !== undefined) {
        if (typeof options.objname === 'number') {
          if (options.columns !== false) {
            throw Error('Invalid Option: objname index cannot be combined with columns or be defined as a field');
          }
        } else {
          // A string or a buffer
          if (options.columns === false) {
            throw Error('Invalid Option: objname field must be combined with columns or be defined as an index');
          }
        }
      }
      // Normalize option `on_record`
      if (options.on_record === undefined || options.on_record === null) {
        options.on_record = undefined;
      } else if (typeof options.on_record !== 'function') {
        throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', ['Invalid option `on_record`:', 'expect a function,', `got ${JSON.stringify(options.on_record)}`], options);
      }
      // Normalize option `quote`
      if (options.quote === null || options.quote === false || options.quote === '') {
        options.quote = null;
      } else {
        if (options.quote === undefined || options.quote === true) {
          options.quote = Buffer.from('"', options.encoding);
        } else if (typeof options.quote === 'string') {
          options.quote = Buffer.from(options.quote, options.encoding);
        }
        if (!Buffer.isBuffer(options.quote)) {
          throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);
        }
      }
      // Normalize option `raw`
      if (options.raw === undefined || options.raw === null || options.raw === false) {
        options.raw = false;
      } else if (options.raw !== true) {
        throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);
      }
      // Normalize option `record_delimiter`
      if (options.record_delimiter === undefined) {
        options.record_delimiter = [];
      } else if (typeof options.record_delimiter === 'string' || Buffer.isBuffer(options.record_delimiter)) {
        if (options.record_delimiter.length === 0) {
          throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a non empty string or buffer,', `got ${JSON.stringify(options.record_delimiter)}`], options);
        }
        options.record_delimiter = [options.record_delimiter];
      } else if (!Array.isArray(options.record_delimiter)) {
        throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a string, a buffer or array of string|buffer,', `got ${JSON.stringify(options.record_delimiter)}`], options);
      }
      options.record_delimiter = options.record_delimiter.map(function (rd, i) {
        if (typeof rd !== 'string' && !Buffer.isBuffer(rd)) {
          throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a string, a buffer or array of string|buffer', `at index ${i},`, `got ${JSON.stringify(rd)}`], options);
        } else if (rd.length === 0) {
          throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a non empty string or buffer', `at index ${i},`, `got ${JSON.stringify(rd)}`], options);
        }
        if (typeof rd === 'string') {
          rd = Buffer.from(rd, options.encoding);
        }
        return rd;
      });
      // Normalize option `relax_column_count`
      if (typeof options.relax_column_count === 'boolean') ; else if (options.relax_column_count === undefined || options.relax_column_count === null) {
        options.relax_column_count = false;
      } else {
        throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);
      }
      if (typeof options.relax_column_count_less === 'boolean') ; else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {
        options.relax_column_count_less = false;
      } else {
        throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);
      }
      if (typeof options.relax_column_count_more === 'boolean') ; else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {
        options.relax_column_count_more = false;
      } else {
        throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);
      }
      // Normalize option `relax_quotes`
      if (typeof options.relax_quotes === 'boolean') ; else if (options.relax_quotes === undefined || options.relax_quotes === null) {
        options.relax_quotes = false;
      } else {
        throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);
      }
      // Normalize option `skip_empty_lines`
      if (typeof options.skip_empty_lines === 'boolean') ; else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {
        options.skip_empty_lines = false;
      } else {
        throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);
      }
      // Normalize option `skip_records_with_empty_values`
      if (typeof options.skip_records_with_empty_values === 'boolean') ; else if (options.skip_records_with_empty_values === undefined || options.skip_records_with_empty_values === null) {
        options.skip_records_with_empty_values = false;
      } else {
        throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);
      }
      // Normalize option `skip_records_with_error`
      if (typeof options.skip_records_with_error === 'boolean') ; else if (options.skip_records_with_error === undefined || options.skip_records_with_error === null) {
        options.skip_records_with_error = false;
      } else {
        throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);
      }
      // Normalize option `rtrim`
      if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {
        options.rtrim = false;
      } else if (options.rtrim !== true) {
        throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);
      }
      // Normalize option `ltrim`
      if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {
        options.ltrim = false;
      } else if (options.ltrim !== true) {
        throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);
      }
      // Normalize option `trim`
      if (options.trim === undefined || options.trim === null || options.trim === false) {
        options.trim = false;
      } else if (options.trim !== true) {
        throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);
      }
      // Normalize options `trim`, `ltrim` and `rtrim`
      if (options.trim === true && opts.ltrim !== false) {
        options.ltrim = true;
      } else if (options.ltrim !== true) {
        options.ltrim = false;
      }
      if (options.trim === true && opts.rtrim !== false) {
        options.rtrim = true;
      } else if (options.rtrim !== true) {
        options.rtrim = false;
      }
      // Normalize option `to`
      if (options.to === undefined || options.to === null) {
        options.to = -1;
      } else {
        if (typeof options.to === 'string' && /\d+/.test(options.to)) {
          options.to = parseInt(options.to);
        }
        if (Number.isInteger(options.to)) {
          if (options.to <= 0) {
            throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);
          }
        } else {
          throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);
        }
      }
      // Normalize option `to_line`
      if (options.to_line === undefined || options.to_line === null) {
        options.to_line = -1;
      } else {
        if (typeof options.to_line === 'string' && /\d+/.test(options.to_line)) {
          options.to_line = parseInt(options.to_line);
        }
        if (Number.isInteger(options.to_line)) {
          if (options.to_line <= 0) {
            throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);
          }
        } else {
          throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);
        }
      }
      return options;
    };

    const isRecordEmpty = function (record) {
      return record.every(field => field == null || field.toString && field.toString().trim() === '');
    };
    const cr = 13; // `\r`, carriage return, 0x0D in hexadécimal, 13 in decimal
    const nl = 10; // `\n`, newline, 0x0A in hexadecimal, 10 in decimal

    const boms = {
      // Note, the following are equals:
      // Buffer.from("\ufeff")
      // Buffer.from([239, 187, 191])
      // Buffer.from('EFBBBF', 'hex')
      'utf8': Buffer.from([239, 187, 191]),
      // Note, the following are equals:
      // Buffer.from "\ufeff", 'utf16le
      // Buffer.from([255, 254])
      'utf16le': Buffer.from([255, 254])
    };
    const transform = function (original_options = {}) {
      const info = {
        bytes: 0,
        comment_lines: 0,
        empty_lines: 0,
        invalid_field_length: 0,
        lines: 1,
        records: 0
      };
      const options = normalize_options(original_options);
      return {
        info: info,
        original_options: original_options,
        options: options,
        state: init_state(options),
        __needMoreData: function (i, bufLen, end) {
          if (end) return false;
          const {
            encoding,
            escape,
            quote
          } = this.options;
          const {
            quoting,
            needMoreDataSize,
            recordDelimiterMaxLength
          } = this.state;
          const numOfCharLeft = bufLen - i - 1;
          const requiredLength = Math.max(needMoreDataSize,
          // Skip if the remaining buffer smaller than record delimiter
          // If "record_delimiter" is yet to be discovered:
          // 1. It is equals to `[]` and "recordDelimiterMaxLength" equals `0`
          // 2. We set the length to windows line ending in the current encoding
          // Note, that encoding is known from user or bom discovery at that point
          // recordDelimiterMaxLength,
          recordDelimiterMaxLength === 0 ? Buffer.from('\r\n', encoding).length : recordDelimiterMaxLength,
          // Skip if remaining buffer can be an escaped quote
          quoting ? (escape === null ? 0 : escape.length) + quote.length : 0,
          // Skip if remaining buffer can be record delimiter following the closing quote
          quoting ? quote.length + recordDelimiterMaxLength : 0);
          return numOfCharLeft < requiredLength;
        },
        // Central parser implementation
        parse: function (nextBuf, end, push, close) {
          const {
            bom,
            encoding,
            from_line,
            ltrim,
            max_record_size,
            raw,
            relax_quotes,
            rtrim,
            skip_empty_lines,
            to,
            to_line
          } = this.options;
          let {
            comment,
            escape,
            quote,
            record_delimiter
          } = this.options;
          const {
            bomSkipped,
            previousBuf,
            rawBuffer,
            escapeIsQuote
          } = this.state;
          let buf;
          if (previousBuf === undefined) {
            if (nextBuf === undefined) {
              // Handle empty string
              close();
              return;
            } else {
              buf = nextBuf;
            }
          } else if (previousBuf !== undefined && nextBuf === undefined) {
            buf = previousBuf;
          } else {
            buf = Buffer.concat([previousBuf, nextBuf]);
          }
          // Handle UTF BOM
          if (bomSkipped === false) {
            if (bom === false) {
              this.state.bomSkipped = true;
            } else if (buf.length < 3) {
              // No enough data
              if (end === false) {
                // Wait for more data
                this.state.previousBuf = buf;
                return;
              }
            } else {
              for (const encoding in boms) {
                if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {
                  // Skip BOM
                  const bomLength = boms[encoding].length;
                  this.state.bufBytesStart += bomLength;
                  buf = buf.slice(bomLength);
                  // Renormalize original options with the new encoding
                  this.options = normalize_options({
                    ...this.original_options,
                    encoding: encoding
                  });
                  // Options will re-evaluate the Buffer with the new encoding
                  ({
                    comment,
                    escape,
                    quote
                  } = this.options);
                  break;
                }
              }
              this.state.bomSkipped = true;
            }
          }
          const bufLen = buf.length;
          let pos;
          for (pos = 0; pos < bufLen; pos++) {
            // Ensure we get enough space to look ahead
            // There should be a way to move this out of the loop
            if (this.__needMoreData(pos, bufLen, end)) {
              break;
            }
            if (this.state.wasRowDelimiter === true) {
              this.info.lines++;
              this.state.wasRowDelimiter = false;
            }
            if (to_line !== -1 && this.info.lines > to_line) {
              this.state.stop = true;
              close();
              return;
            }
            // Auto discovery of record_delimiter, unix, mac and windows supported
            if (this.state.quoting === false && record_delimiter.length === 0) {
              const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);
              if (record_delimiterCount) {
                record_delimiter = this.options.record_delimiter;
              }
            }
            const chr = buf[pos];
            if (raw === true) {
              rawBuffer.append(chr);
            }
            if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {
              this.state.wasRowDelimiter = true;
            }
            // Previous char was a valid escape char
            // treat the current char as a regular char
            if (this.state.escaping === true) {
              this.state.escaping = false;
            } else {
              // Escape is only active inside quoted fields
              // We are quoting, the char is an escape chr and there is a chr to escape
              // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){
              if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {
                if (escapeIsQuote) {
                  if (this.__isQuote(buf, pos + escape.length)) {
                    this.state.escaping = true;
                    pos += escape.length - 1;
                    continue;
                  }
                } else {
                  this.state.escaping = true;
                  pos += escape.length - 1;
                  continue;
                }
              }
              // Not currently escaping and chr is a quote
              // TODO: need to compare bytes instead of single char
              if (this.state.commenting === false && this.__isQuote(buf, pos)) {
                if (this.state.quoting === true) {
                  const nextChr = buf[pos + quote.length];
                  const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos + quote.length);
                  const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);
                  const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);
                  const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length);
                  // Escape a quote
                  // Treat next char as a regular character
                  if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {
                    pos += escape.length - 1;
                  } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {
                    this.state.quoting = false;
                    this.state.wasQuoting = true;
                    pos += quote.length - 1;
                    continue;
                  } else if (relax_quotes === false) {
                    const err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', ['Invalid Closing Quote:', `got "${String.fromCharCode(nextChr)}"`, `at line ${this.info.lines}`, 'instead of delimiter, record delimiter, trimable character', '(if activated) or comment'], this.options, this.__infoField()));
                    if (err !== undefined) return err;
                  } else {
                    this.state.quoting = false;
                    this.state.wasQuoting = true;
                    this.state.field.prepend(quote);
                    pos += quote.length - 1;
                  }
                } else {
                  if (this.state.field.length !== 0) {
                    // In relax_quotes mode, treat opening quote preceded by chrs as regular
                    if (relax_quotes === false) {
                      const info = this.__infoField();
                      const bom = Object.keys(boms).map(b => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];
                      const err = this.__error(new CsvError('INVALID_OPENING_QUOTE', ['Invalid Opening Quote:', `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`, bom ? `(${bom} bom)` : undefined], this.options, info, {
                        field: this.state.field
                      }));
                      if (err !== undefined) return err;
                    }
                  } else {
                    this.state.quoting = true;
                    pos += quote.length - 1;
                    continue;
                  }
                }
              }
              if (this.state.quoting === false) {
                const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);
                if (recordDelimiterLength !== 0) {
                  // Do not emit comments which take a full line
                  const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;
                  if (skipCommentLine) {
                    this.info.comment_lines++;
                    // Skip full comment line
                  } else {
                    // Activate records emition if above from_line
                    if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {
                      this.state.enabled = true;
                      this.__resetField();
                      this.__resetRecord();
                      pos += recordDelimiterLength - 1;
                      continue;
                    }
                    // Skip if line is empty and skip_empty_lines activated
                    if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {
                      this.info.empty_lines++;
                      pos += recordDelimiterLength - 1;
                      continue;
                    }
                    this.info.bytes = this.state.bufBytesStart + pos;
                    const errField = this.__onField();
                    if (errField !== undefined) return errField;
                    this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;
                    const errRecord = this.__onRecord(push);
                    if (errRecord !== undefined) return errRecord;
                    if (to !== -1 && this.info.records >= to) {
                      this.state.stop = true;
                      close();
                      return;
                    }
                  }
                  this.state.commenting = false;
                  pos += recordDelimiterLength - 1;
                  continue;
                }
                if (this.state.commenting) {
                  continue;
                }
                const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);
                if (commentCount !== 0) {
                  this.state.commenting = true;
                  continue;
                }
                const delimiterLength = this.__isDelimiter(buf, pos, chr);
                if (delimiterLength !== 0) {
                  this.info.bytes = this.state.bufBytesStart + pos;
                  const errField = this.__onField();
                  if (errField !== undefined) return errField;
                  pos += delimiterLength - 1;
                  continue;
                }
              }
            }
            if (this.state.commenting === false) {
              if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {
                return this.__error(new CsvError('CSV_MAX_RECORD_SIZE', ['Max Record Size:', 'record exceed the maximum number of tolerated bytes', `of ${max_record_size}`, `at line ${this.info.lines}`], this.options, this.__infoField()));
              }
            }
            const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);
            // rtrim in non quoting is handle in __onField
            const rappend = rtrim === false || this.state.wasQuoting === false;
            if (lappend === true && rappend === true) {
              this.state.field.append(chr);
            } else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {
              return this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', ['Invalid Closing Quote:', 'found non trimable byte after quote', `at line ${this.info.lines}`], this.options, this.__infoField()));
            } else {
              if (lappend === false) {
                pos += this.__isCharTrimable(buf, pos) - 1;
              }
              continue;
            }
          }
          if (end === true) {
            // Ensure we are not ending in a quoting state
            if (this.state.quoting === true) {
              const err = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', ['Quote Not Closed:', `the parsing is finished with an opening quote at line ${this.info.lines}`], this.options, this.__infoField()));
              if (err !== undefined) return err;
            } else {
              // Skip last line if it has no characters
              if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {
                this.info.bytes = this.state.bufBytesStart + pos;
                const errField = this.__onField();
                if (errField !== undefined) return errField;
                const errRecord = this.__onRecord(push);
                if (errRecord !== undefined) return errRecord;
              } else if (this.state.wasRowDelimiter === true) {
                this.info.empty_lines++;
              } else if (this.state.commenting === true) {
                this.info.comment_lines++;
              }
            }
          } else {
            this.state.bufBytesStart += pos;
            this.state.previousBuf = buf.slice(pos);
          }
          if (this.state.wasRowDelimiter === true) {
            this.info.lines++;
            this.state.wasRowDelimiter = false;
          }
        },
        __onRecord: function (push) {
          const {
            columns,
            group_columns_by_name,
            encoding,
            info,
            from,
            relax_column_count,
            relax_column_count_less,
            relax_column_count_more,
            raw,
            skip_records_with_empty_values
          } = this.options;
          const {
            enabled,
            record
          } = this.state;
          if (enabled === false) {
            return this.__resetRecord();
          }
          // Convert the first line into column names
          const recordLength = record.length;
          if (columns === true) {
            if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
              this.__resetRecord();
              return;
            }
            return this.__firstLineToColumns(record);
          }
          if (columns === false && this.info.records === 0) {
            this.state.expectedRecordLength = recordLength;
          }
          if (recordLength !== this.state.expectedRecordLength) {
            const err = columns === false ? new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', ['Invalid Record Length:', `expect ${this.state.expectedRecordLength},`, `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {
              record: record
            }) : new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', ['Invalid Record Length:', `columns length is ${columns.length},`,
            // rename columns
            `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {
              record: record
            });
            if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {
              this.info.invalid_field_length++;
              this.state.error = err;
              // Error is undefined with skip_records_with_error
            } else {
              const finalErr = this.__error(err);
              if (finalErr) return finalErr;
            }
          }
          if (skip_records_with_empty_values === true && isRecordEmpty(record)) {
            this.__resetRecord();
            return;
          }
          if (this.state.recordHasError === true) {
            this.__resetRecord();
            this.state.recordHasError = false;
            return;
          }
          this.info.records++;
          if (from === 1 || this.info.records >= from) {
            const {
              objname
            } = this.options;
            // With columns, records are object
            if (columns !== false) {
              const obj = {};
              // Transform record array to an object
              for (let i = 0, l = record.length; i < l; i++) {
                if (columns[i] === undefined || columns[i].disabled) continue;
                // Turn duplicate columns into an array
                if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {
                  if (Array.isArray(obj[columns[i].name])) {
                    obj[columns[i].name] = obj[columns[i].name].concat(record[i]);
                  } else {
                    obj[columns[i].name] = [obj[columns[i].name], record[i]];
                  }
                } else {
                  obj[columns[i].name] = record[i];
                }
              }
              // Without objname (default)
              if (raw === true || info === true) {
                const extRecord = Object.assign({
                  record: obj
                }, raw === true ? {
                  raw: this.state.rawBuffer.toString(encoding)
                } : {}, info === true ? {
                  info: this.__infoRecord()
                } : {});
                const err = this.__push(objname === undefined ? extRecord : [obj[objname], extRecord], push);
                if (err) {
                  return err;
                }
              } else {
                const err = this.__push(objname === undefined ? obj : [obj[objname], obj], push);
                if (err) {
                  return err;
                }
              }
              // Without columns, records are array
            } else {
              if (raw === true || info === true) {
                const extRecord = Object.assign({
                  record: record
                }, raw === true ? {
                  raw: this.state.rawBuffer.toString(encoding)
                } : {}, info === true ? {
                  info: this.__infoRecord()
                } : {});
                const err = this.__push(objname === undefined ? extRecord : [record[objname], extRecord], push);
                if (err) {
                  return err;
                }
              } else {
                const err = this.__push(objname === undefined ? record : [record[objname], record], push);
                if (err) {
                  return err;
                }
              }
            }
          }
          this.__resetRecord();
        },
        __firstLineToColumns: function (record) {
          const {
            firstLineToHeaders
          } = this.state;
          try {
            const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);
            if (!Array.isArray(headers)) {
              return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', ['Invalid Column Mapping:', 'expect an array from column function,', `got ${JSON.stringify(headers)}`], this.options, this.__infoField(), {
                headers: headers
              }));
            }
            const normalizedHeaders = normalize_columns_array(headers);
            this.state.expectedRecordLength = normalizedHeaders.length;
            this.options.columns = normalizedHeaders;
            this.__resetRecord();
            return;
          } catch (err) {
            return err;
          }
        },
        __resetRecord: function () {
          if (this.options.raw === true) {
            this.state.rawBuffer.reset();
          }
          this.state.error = undefined;
          this.state.record = [];
          this.state.record_length = 0;
        },
        __onField: function () {
          const {
            cast,
            encoding,
            rtrim,
            max_record_size
          } = this.options;
          const {
            enabled,
            wasQuoting
          } = this.state;
          // Short circuit for the from_line options
          if (enabled === false) {
            return this.__resetField();
          }
          let field = this.state.field.toString(encoding);
          if (rtrim === true && wasQuoting === false) {
            field = field.trimRight();
          }
          if (cast === true) {
            const [err, f] = this.__cast(field);
            if (err !== undefined) return err;
            field = f;
          }
          this.state.record.push(field);
          // Increment record length if record size must not exceed a limit
          if (max_record_size !== 0 && typeof field === 'string') {
            this.state.record_length += field.length;
          }
          this.__resetField();
        },
        __resetField: function () {
          this.state.field.reset();
          this.state.wasQuoting = false;
        },
        __push: function (record, push) {
          const {
            on_record
          } = this.options;
          if (on_record !== undefined) {
            const info = this.__infoRecord();
            try {
              record = on_record.call(null, record, info);
            } catch (err) {
              return err;
            }
            if (record === undefined || record === null) {
              return;
            }
          }
          push(record);
        },
        // Return a tuple with the error and the casted value
        __cast: function (field) {
          const {
            columns,
            relax_column_count
          } = this.options;
          const isColumns = Array.isArray(columns);
          // Dont loose time calling cast
          // because the final record is an object
          // and this field can't be associated to a key present in columns
          if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {
            return [undefined, undefined];
          }
          if (this.state.castField !== null) {
            try {
              const info = this.__infoField();
              return [undefined, this.state.castField.call(null, field, info)];
            } catch (err) {
              return [err];
            }
          }
          if (this.__isFloat(field)) {
            return [undefined, parseFloat(field)];
          } else if (this.options.cast_date !== false) {
            const info = this.__infoField();
            return [undefined, this.options.cast_date.call(null, field, info)];
          }
          return [undefined, field];
        },
        // Helper to test if a character is a space or a line delimiter
        __isCharTrimable: function (buf, pos) {
          const isTrim = (buf, pos) => {
            const {
              timchars
            } = this.state;
            loop1: for (let i = 0; i < timchars.length; i++) {
              const timchar = timchars[i];
              for (let j = 0; j < timchar.length; j++) {
                if (timchar[j] !== buf[pos + j]) continue loop1;
              }
              return timchar.length;
            }
            return 0;
          };
          return isTrim(buf, pos);
        },
        // Keep it in case we implement the `cast_int` option
        // __isInt(value){
        //   // return Number.isInteger(parseInt(value))
        //   // return !isNaN( parseInt( obj ) );
        //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
        // }
        __isFloat: function (value) {
          return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery
        },

        __compareBytes: function (sourceBuf, targetBuf, targetPos, firstByte) {
          if (sourceBuf[0] !== firstByte) return 0;
          const sourceLength = sourceBuf.length;
          for (let i = 1; i < sourceLength; i++) {
            if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;
          }
          return sourceLength;
        },
        __isDelimiter: function (buf, pos, chr) {
          const {
            delimiter,
            ignore_last_delimiters
          } = this.options;
          if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {
            return 0;
          } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1) {
            return 0;
          }
          loop1: for (let i = 0; i < delimiter.length; i++) {
            const del = delimiter[i];
            if (del[0] === chr) {
              for (let j = 1; j < del.length; j++) {
                if (del[j] !== buf[pos + j]) continue loop1;
              }
              return del.length;
            }
          }
          return 0;
        },
        __isRecordDelimiter: function (chr, buf, pos) {
          const {
            record_delimiter
          } = this.options;
          const recordDelimiterLength = record_delimiter.length;
          loop1: for (let i = 0; i < recordDelimiterLength; i++) {
            const rd = record_delimiter[i];
            const rdLength = rd.length;
            if (rd[0] !== chr) {
              continue;
            }
            for (let j = 1; j < rdLength; j++) {
              if (rd[j] !== buf[pos + j]) {
                continue loop1;
              }
            }
            return rd.length;
          }
          return 0;
        },
        __isEscape: function (buf, pos, chr) {
          const {
            escape
          } = this.options;
          if (escape === null) return false;
          const l = escape.length;
          if (escape[0] === chr) {
            for (let i = 0; i < l; i++) {
              if (escape[i] !== buf[pos + i]) {
                return false;
              }
            }
            return true;
          }
          return false;
        },
        __isQuote: function (buf, pos) {
          const {
            quote
          } = this.options;
          if (quote === null) return false;
          const l = quote.length;
          for (let i = 0; i < l; i++) {
            if (quote[i] !== buf[pos + i]) {
              return false;
            }
          }
          return true;
        },
        __autoDiscoverRecordDelimiter: function (buf, pos) {
          const {
            encoding
          } = this.options;
          // Note, we don't need to cache this information in state,
          // It is only called on the first line until we find out a suitable
          // record delimiter.
          const rds = [
          // Important, the windows line ending must be before mac os 9
          Buffer.from('\r\n', encoding), Buffer.from('\n', encoding), Buffer.from('\r', encoding)];
          loop: for (let i = 0; i < rds.length; i++) {
            const l = rds[i].length;
            for (let j = 0; j < l; j++) {
              if (rds[i][j] !== buf[pos + j]) {
                continue loop;
              }
            }
            this.options.record_delimiter.push(rds[i]);
            this.state.recordDelimiterMaxLength = rds[i].length;
            return rds[i].length;
          }
          return 0;
        },
        __error: function (msg) {
          const {
            encoding,
            raw,
            skip_records_with_error
          } = this.options;
          const err = typeof msg === 'string' ? new Error(msg) : msg;
          if (skip_records_with_error) {
            this.state.recordHasError = true;
            if (this.options.on_skip !== undefined) {
              this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);
            }
            // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);
            return undefined;
          } else {
            return err;
          }
        },
        __infoDataSet: function () {
          return {
            ...this.info,
            columns: this.options.columns
          };
        },
        __infoRecord: function () {
          const {
            columns,
            raw,
            encoding
          } = this.options;
          return {
            ...this.__infoDataSet(),
            error: this.state.error,
            header: columns === true,
            index: this.state.record.length,
            raw: raw ? this.state.rawBuffer.toString(encoding) : undefined
          };
        },
        __infoField: function () {
          const {
            columns
          } = this.options;
          const isColumns = Array.isArray(columns);
          return {
            ...this.__infoRecord(),
            column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,
            quoting: this.state.wasQuoting
          };
        }
      };
    };

    class Parser extends Transform {
      constructor(opts = {}) {
        super({
          ...{
            readableObjectMode: true
          },
          ...opts,
          encoding: null
        });
        this.api = transform(opts);
        this.api.options.on_skip = (err, chunk) => {
          this.emit('skip', err, chunk);
        };
        // Backward compatibility
        this.state = this.api.state;
        this.options = this.api.options;
        this.info = this.api.info;
      }
      // Implementation of `Transform._transform`
      _transform(buf, encoding, callback) {
        if (this.state.stop === true) {
          return;
        }
        const err = this.api.parse(buf, false, record => {
          this.push(record);
        }, () => {
          this.push(null);
          this.on('end', this.destroy);
        });
        if (err !== undefined) {
          this.state.stop = true;
        }
        callback(err);
      }
      // Implementation of `Transform._flush`
      _flush(callback) {
        if (this.state.stop === true) {
          return;
        }
        const err = this.api.parse(undefined, true, record => {
          this.push(record);
        }, () => {
          this.push(null);
          this.on('end', this.destroy);
        });
        callback(err);
      }
    }
    const parse$1 = function () {
      let data, options, callback;
      for (const i in arguments) {
        const argument = arguments[i];
        const type = typeof argument;
        if (data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))) {
          data = argument;
        } else if (options === undefined && is_object(argument)) {
          options = argument;
        } else if (callback === undefined && type === 'function') {
          callback = argument;
        } else {
          throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', `got ${JSON.stringify(argument)} at index ${i}`], options || {});
        }
      }
      const parser = new Parser(options);
      if (callback) {
        const records = options === undefined || options.objname === undefined ? [] : {};
        parser.on('readable', function () {
          let record;
          while ((record = this.read()) !== null) {
            if (options === undefined || options.objname === undefined) {
              records.push(record);
            } else {
              records[record[0]] = record[1];
            }
          }
        });
        parser.on('error', function (err) {
          callback(err, undefined, parser.api.__infoDataSet());
        });
        parser.on('end', function () {
          callback(undefined, records, parser.api.__infoDataSet());
        });
      }
      if (data !== undefined) {
        const writer = function () {
          parser.write(data);
          parser.end();
        };
        // Support Deno, Rollup doesnt provide a shim for setImmediate
        if (typeof setImmediate === 'function') {
          setImmediate(writer);
        } else {
          setTimeout(writer, 0);
        }
      }
      return parser;
    };

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    let getRandomValues;
    const rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }
      return getRandomValues(rnds8);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    const byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    }

    const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var native = {
      randomUUID
    };

    function v4(options, buf, offset) {
      if (native.randomUUID && !buf && !options) {
        return native.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
      return unsafeStringify(rnds);
    }

    function get_each_context(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[24] = list[i];
      return child_ctx;
    }
    function get_each_context_1(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[27] = list[i];
      return child_ctx;
    }
    function get_each_context_2(ctx, list, i) {
      var child_ctx = ctx.slice();
      child_ctx[30] = list[i];
      return child_ctx;
    }

    // (229:0) {#if parseError}
    function create_if_block_6(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot_2]
          },
          $$scope: {
            ctx
          }
        }
      });
      return {
        c() {
          create_component(overlay.$$.fragment);
        },
        m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty[0] & /*parseError*/512 | dirty[1] & /*$$scope*/4) {
            overlay_changes.$$scope = {
              dirty,
              ctx
            };
          }
          overlay.$set(overlay_changes);
        },
        i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    }

    // (230:1) <Overlay>
    function create_default_slot_2(ctx) {
      var div2;
      var h3;
      var t1;
      var div0;
      var t2_value = translate('timemanager', 'CSV parse error:') + "";
      var t2;
      var t3;
      var t4;
      var t5;
      var div1;
      var button;
      var mounted;
      var dispose;
      return {
        c() {
          div2 = element("div");
          h3 = element("h3");
          h3.textContent = "".concat(translate('timemanager', 'Error reading CSV file'));
          t1 = space$1();
          div0 = element("div");
          t2 = text$1(t2_value);
          t3 = space$1();
          t4 = text$1( /*parseError*/ctx[9]);
          t5 = space$1();
          div1 = element("div");
          button = element("button");
          button.textContent = "".concat(translate('timemanager', 'Close'));
          attr(div0, "class", "error");
          attr(button, "class", "button");
          attr(div1, "class", "oc-dialog-buttonrow onebutton");
          attr(div2, "class", "inner");
        },
        m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, h3);
          append(div2, t1);
          append(div2, div0);
          append(div0, t2);
          append(div0, t3);
          append(div0, t4);
          append(div2, t5);
          append(div2, div1);
          append(div1, button);
          if (!mounted) {
            dispose = listen(button, "click", prevent_default( /*click_handler*/ctx[17]));
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*parseError*/512) set_data(t4, /*parseError*/ctx[9]);
        },
        d(detaching) {
          if (detaching) {
            detach(div2);
          }
          mounted = false;
          dispose();
        }
      };
    }

    // (247:0) {#if importError}
    function create_if_block_5(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot_1]
          },
          $$scope: {
            ctx
          }
        }
      });
      return {
        c() {
          create_component(overlay.$$.fragment);
        },
        m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty[0] & /*importError*/64 | dirty[1] & /*$$scope*/4) {
            overlay_changes.$$scope = {
              dirty,
              ctx
            };
          }
          overlay.$set(overlay_changes);
        },
        i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    }

    // (248:1) <Overlay>
    function create_default_slot_1(ctx) {
      var div2;
      var h3;
      var t1;
      var div0;
      var t2_value = translate('timemanager', 'Import API error:') + "";
      var t2;
      var t3;
      var t4;
      var t5;
      var div1;
      var button;
      var mounted;
      var dispose;
      return {
        c() {
          div2 = element("div");
          h3 = element("h3");
          h3.textContent = "".concat(translate('timemanager', 'Error importing entries'));
          t1 = space$1();
          div0 = element("div");
          t2 = text$1(t2_value);
          t3 = space$1();
          t4 = text$1( /*importError*/ctx[6]);
          t5 = space$1();
          div1 = element("div");
          button = element("button");
          button.textContent = "".concat(translate('timemanager', 'Close'));
          attr(div0, "class", "error");
          attr(button, "class", "button");
          attr(div1, "class", "oc-dialog-buttonrow onebutton");
          attr(div2, "class", "inner");
        },
        m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, h3);
          append(div2, t1);
          append(div2, div0);
          append(div0, t2);
          append(div0, t3);
          append(div0, t4);
          append(div2, t5);
          append(div2, div1);
          append(div1, button);
          if (!mounted) {
            dispose = listen(button, "click", prevent_default( /*click_handler_1*/ctx[18]));
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*importError*/64) set_data(t4, /*importError*/ctx[6]);
        },
        d(detaching) {
          if (detaching) {
            detach(div2);
          }
          mounted = false;
          dispose();
        }
      };
    }

    // (265:0) {#if successMessage}
    function create_if_block_4(ctx) {
      var overlay;
      var current;
      overlay = new Overlay({
        props: {
          $$slots: {
            default: [create_default_slot]
          },
          $$scope: {
            ctx
          }
        }
      });
      return {
        c() {
          create_component(overlay.$$.fragment);
        },
        m(target, anchor) {
          mount_component(overlay, target, anchor);
          current = true;
        },
        p(ctx, dirty) {
          var overlay_changes = {};
          if (dirty[0] & /*successMessage*/128 | dirty[1] & /*$$scope*/4) {
            overlay_changes.$$scope = {
              dirty,
              ctx
            };
          }
          overlay.$set(overlay_changes);
        },
        i(local) {
          if (current) return;
          transition_in(overlay.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(overlay.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          destroy_component(overlay, detaching);
        }
      };
    }

    // (266:1) <Overlay>
    function create_default_slot(ctx) {
      var div2;
      var h3;
      var t1;
      var div0;
      var t2_value = translate('timemanager', 'Done:') + "";
      var t2;
      var t3;
      var t4;
      var t5;
      var div1;
      var button;
      var mounted;
      var dispose;
      return {
        c() {
          div2 = element("div");
          h3 = element("h3");
          h3.textContent = "".concat(translate('timemanager', 'Import successful'));
          t1 = space$1();
          div0 = element("div");
          t2 = text$1(t2_value);
          t3 = space$1();
          t4 = text$1( /*successMessage*/ctx[7]);
          t5 = space$1();
          div1 = element("div");
          button = element("button");
          button.textContent = "".concat(translate('timemanager', 'Close'));
          attr(div0, "class", "error");
          attr(button, "class", "button");
          attr(div1, "class", "oc-dialog-buttonrow onebutton");
          attr(div2, "class", "inner");
        },
        m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, h3);
          append(div2, t1);
          append(div2, div0);
          append(div0, t2);
          append(div0, t3);
          append(div0, t4);
          append(div2, t5);
          append(div2, div1);
          append(div1, button);
          if (!mounted) {
            dispose = listen(button, "click", prevent_default( /*click_handler_2*/ctx[19]));
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*successMessage*/128) set_data(t4, /*successMessage*/ctx[7]);
        },
        d(detaching) {
          if (detaching) {
            detach(div2);
          }
          mounted = false;
          dispose();
        }
      };
    }

    // (283:0) {#if importPreviewData.length}
    function create_if_block_3(ctx) {
      var div0;
      var p;
      var strong;
      var t1;
      var button0;
      var t3;
      var button1;
      var t5;
      var div1;
      var dl;
      var dt0;
      var dd0;
      var t7_value = /*preparedClients*/ctx[2].length + "";
      var t7;
      var dt1;
      var dd1;
      var t9_value = /*preparedProjects*/ctx[3].length + "";
      var t9;
      var dt2;
      var dd2;
      var t11_value = /*preparedTasks*/ctx[4].length + "";
      var t11;
      var mounted;
      var dispose;
      return {
        c() {
          div0 = element("div");
          p = element("p");
          strong = element("strong");
          strong.textContent = "".concat(translate('timemanager', 'Preview'));
          t1 = space$1();
          button0 = element("button");
          button0.textContent = "".concat(translate('timemanager', 'Collapse all'));
          t3 = space$1();
          button1 = element("button");
          button1.textContent = "".concat(translate('timemanager', 'Expand all'));
          t5 = space$1();
          div1 = element("div");
          dl = element("dl");
          dt0 = element("dt");
          dt0.textContent = "".concat(translate('timemanager', 'Clients'));
          dd0 = element("dd");
          t7 = text$1(t7_value);
          dt1 = element("dt");
          dt1.textContent = "".concat(translate('timemanager', 'Projects'));
          dd1 = element("dd");
          t9 = text$1(t9_value);
          dt2 = element("dt");
          dt2.textContent = "".concat(translate('timemanager', 'Tasks'));
          dd2 = element("dd");
          t11 = text$1(t11_value);
          attr(button0, "class", "button");
          attr(button1, "class", "button");
          attr(div0, "class", "tm_object-details-item");
          attr(div1, "class", "tm_object-details-item");
        },
        m(target, anchor) {
          insert(target, div0, anchor);
          append(div0, p);
          append(p, strong);
          append(div0, t1);
          append(div0, button0);
          append(div0, t3);
          append(div0, button1);
          insert(target, t5, anchor);
          insert(target, div1, anchor);
          append(div1, dl);
          append(dl, dt0);
          append(dl, dd0);
          append(dd0, t7);
          append(dl, dt1);
          append(dl, dd1);
          append(dd1, t9);
          append(dl, dt2);
          append(dl, dd2);
          append(dd2, t11);
          if (!mounted) {
            dispose = [listen(button0, "click", prevent_default( /*click_handler_3*/ctx[20])), listen(button1, "click", prevent_default( /*click_handler_4*/ctx[21]))];
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*preparedClients*/4 && t7_value !== (t7_value = /*preparedClients*/ctx[2].length + "")) set_data(t7, t7_value);
          if (dirty[0] & /*preparedProjects*/8 && t9_value !== (t9_value = /*preparedProjects*/ctx[3].length + "")) set_data(t9, t9_value);
          if (dirty[0] & /*preparedTasks*/16 && t11_value !== (t11_value = /*preparedTasks*/ctx[4].length + "")) set_data(t11, t11_value);
        },
        d(detaching) {
          if (detaching) {
            detach(div0);
            detach(t5);
            detach(div1);
          }
          mounted = false;
          run_all(dispose);
        }
      };
    }

    // (318:2) {#if client.projects}
    function create_if_block_1(ctx) {
      var details;
      var summary;
      var t1;
      var each_value_1 = ensure_array_like( /*client*/ctx[24].projects);
      var each_blocks = [];
      for (var i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
      }
      return {
        c() {
          details = element("details");
          summary = element("summary");
          summary.textContent = "".concat(translate('timemanager', 'Projects'));
          t1 = space$1();
          for (var _i = 0; _i < each_blocks.length; _i += 1) {
            each_blocks[_i].c();
          }
          details.open = /*allOpen*/ctx[10];
        },
        m(target, anchor) {
          insert(target, details, anchor);
          append(details, summary);
          append(details, t1);
          for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
            if (each_blocks[_i2]) {
              each_blocks[_i2].m(details, null);
            }
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*allOpen, importPreviewData*/1280) {
            each_value_1 = ensure_array_like( /*client*/ctx[24].projects);
            var _i3;
            for (_i3 = 0; _i3 < each_value_1.length; _i3 += 1) {
              var child_ctx = get_each_context_1(ctx, each_value_1, _i3);
              if (each_blocks[_i3]) {
                each_blocks[_i3].p(child_ctx, dirty);
              } else {
                each_blocks[_i3] = create_each_block_1(child_ctx);
                each_blocks[_i3].c();
                each_blocks[_i3].m(details, null);
              }
            }
            for (; _i3 < each_blocks.length; _i3 += 1) {
              each_blocks[_i3].d(1);
            }
            each_blocks.length = each_value_1.length;
          }
          if (dirty[0] & /*allOpen*/1024) {
            details.open = /*allOpen*/ctx[10];
          }
        },
        d(detaching) {
          if (detaching) {
            detach(details);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }

    // (331:6) {#if project.tasks}
    function create_if_block_2(ctx) {
      var details;
      var summary;
      var t1;
      var each_value_2 = ensure_array_like( /*project*/ctx[27].tasks);
      var each_blocks = [];
      for (var i = 0; i < each_value_2.length; i += 1) {
        each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
      }
      return {
        c() {
          details = element("details");
          summary = element("summary");
          summary.textContent = "".concat(translate('timemanager', 'Tasks'));
          t1 = space$1();
          for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {
            each_blocks[_i4].c();
          }
          details.open = /*allOpen*/ctx[10];
        },
        m(target, anchor) {
          insert(target, details, anchor);
          append(details, summary);
          append(details, t1);
          for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
            if (each_blocks[_i5]) {
              each_blocks[_i5].m(details, null);
            }
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*importPreviewData*/256) {
            each_value_2 = ensure_array_like( /*project*/ctx[27].tasks);
            var _i6;
            for (_i6 = 0; _i6 < each_value_2.length; _i6 += 1) {
              var child_ctx = get_each_context_2(ctx, each_value_2, _i6);
              if (each_blocks[_i6]) {
                each_blocks[_i6].p(child_ctx, dirty);
              } else {
                each_blocks[_i6] = create_each_block_2(child_ctx);
                each_blocks[_i6].c();
                each_blocks[_i6].m(details, null);
              }
            }
            for (; _i6 < each_blocks.length; _i6 += 1) {
              each_blocks[_i6].d(1);
            }
            each_blocks.length = each_value_2.length;
          }
          if (dirty[0] & /*allOpen*/1024) {
            details.open = /*allOpen*/ctx[10];
          }
        },
        d(detaching) {
          if (detaching) {
            detach(details);
          }
          destroy_each(each_blocks, detaching);
        }
      };
    }

    // (334:8) {#each project.tasks as task}
    function create_each_block_2(ctx) {
      var div2;
      var div0;
      var span0;
      var t1;
      var h3;
      var t2_value = /*task*/ctx[30].name + "";
      var t2;
      var t3;
      var div1;
      var span1;
      var t5;
      var t6_value = /*task*/ctx[30].note + "";
      var t6;
      return {
        c() {
          div2 = element("div");
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "".concat(translate('timemanager', 'Task name'));
          t1 = space$1();
          h3 = element("h3");
          t2 = text$1(t2_value);
          t3 = space$1();
          div1 = element("div");
          span1 = element("span");
          span1.textContent = "".concat(translate('timemanager', 'Note'));
          t5 = space$1();
          t6 = text$1(t6_value);
          attr(span0, "class", "tm_label");
          attr(span1, "class", "tm_label");
          attr(div2, "class", "tm_item-row");
        },
        m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, div0);
          append(div0, span0);
          append(div0, t1);
          append(div0, h3);
          append(h3, t2);
          append(div2, t3);
          append(div2, div1);
          append(div1, span1);
          append(div1, t5);
          append(div1, t6);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*importPreviewData*/256 && t2_value !== (t2_value = /*task*/ctx[30].name + "")) set_data(t2, t2_value);
          if (dirty[0] & /*importPreviewData*/256 && t6_value !== (t6_value = /*task*/ctx[30].note + "")) set_data(t6, t6_value);
        },
        d(detaching) {
          if (detaching) {
            detach(div2);
          }
        }
      };
    }

    // (321:4) {#each client.projects as project}
    function create_each_block_1(ctx) {
      var div2;
      var div0;
      var span0;
      var t1;
      var h3;
      var t2_value = /*project*/ctx[27].name + "";
      var t2;
      var t3;
      var div1;
      var span1;
      var t5;
      var t6_value = /*project*/ctx[27].note + "";
      var t6;
      var t7;
      var if_block = /*project*/ctx[27].tasks && create_if_block_2(ctx);
      return {
        c() {
          div2 = element("div");
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "".concat(translate('timemanager', 'Project name'));
          t1 = space$1();
          h3 = element("h3");
          t2 = text$1(t2_value);
          t3 = space$1();
          div1 = element("div");
          span1 = element("span");
          span1.textContent = "".concat(translate('timemanager', 'Note'));
          t5 = space$1();
          t6 = text$1(t6_value);
          t7 = space$1();
          if (if_block) if_block.c();
          attr(span0, "class", "tm_label");
          attr(span1, "class", "tm_label");
          attr(div2, "class", "tm_item-row");
        },
        m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, div0);
          append(div0, span0);
          append(div0, t1);
          append(div0, h3);
          append(h3, t2);
          append(div2, t3);
          append(div2, div1);
          append(div1, span1);
          append(div1, t5);
          append(div1, t6);
          append(div2, t7);
          if (if_block) if_block.m(div2, null);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*importPreviewData*/256 && t2_value !== (t2_value = /*project*/ctx[27].name + "")) set_data(t2, t2_value);
          if (dirty[0] & /*importPreviewData*/256 && t6_value !== (t6_value = /*project*/ctx[27].note + "")) set_data(t6, t6_value);
          if ( /*project*/ctx[27].tasks) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_2(ctx);
              if_block.c();
              if_block.m(div2, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(div2);
          }
          if (if_block) if_block.d();
        }
      };
    }

    // (308:0) {#each importPreviewData as client}
    function create_each_block(ctx) {
      var div2;
      var div0;
      var span0;
      var t1;
      var h3;
      var t2_value = /*client*/ctx[24].name + "";
      var t2;
      var t3;
      var div1;
      var span1;
      var t5;
      var t6_value = /*client*/ctx[24].note + "";
      var t6;
      var t7;
      var if_block = /*client*/ctx[24].projects && create_if_block_1(ctx);
      return {
        c() {
          div2 = element("div");
          div0 = element("div");
          span0 = element("span");
          span0.textContent = "".concat(translate('timemanager', 'Client'));
          t1 = space$1();
          h3 = element("h3");
          t2 = text$1(t2_value);
          t3 = space$1();
          div1 = element("div");
          span1 = element("span");
          span1.textContent = "".concat(translate('timemanager', 'Note'));
          t5 = space$1();
          t6 = text$1(t6_value);
          t7 = space$1();
          if (if_block) if_block.c();
          attr(span0, "class", "tm_label");
          attr(span1, "class", "tm_label");
          attr(div2, "class", "tm_item-row");
        },
        m(target, anchor) {
          insert(target, div2, anchor);
          append(div2, div0);
          append(div0, span0);
          append(div0, t1);
          append(div0, h3);
          append(h3, t2);
          append(div2, t3);
          append(div2, div1);
          append(div1, span1);
          append(div1, t5);
          append(div1, t6);
          append(div2, t7);
          if (if_block) if_block.m(div2, null);
        },
        p(ctx, dirty) {
          if (dirty[0] & /*importPreviewData*/256 && t2_value !== (t2_value = /*client*/ctx[24].name + "")) set_data(t2, t2_value);
          if (dirty[0] & /*importPreviewData*/256 && t6_value !== (t6_value = /*client*/ctx[24].note + "")) set_data(t6, t6_value);
          if ( /*client*/ctx[24].projects) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_1(ctx);
              if_block.c();
              if_block.m(div2, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d(detaching) {
          if (detaching) {
            detach(div2);
          }
          if (if_block) if_block.d();
        }
      };
    }

    // (355:0) {#if importPreviewData.length}
    function create_if_block$1(ctx) {
      var form;
      var button;
      var t_value = translate('timemanager', 'Import now') + "";
      var t;
      var form_class_value;
      var mounted;
      var dispose;
      return {
        c() {
          form = element("form");
          button = element("button");
          t = text$1(t_value);
          button.disabled = /*loading*/ctx[5];
          attr(button, "type", "submit");
          attr(button, "class", "button primary");
          attr(form, "class", form_class_value = /*loading*/ctx[5] ? ' icon-loading' : '');
        },
        m(target, anchor) {
          insert(target, form, anchor);
          append(form, button);
          append(button, t);
          if (!mounted) {
            dispose = listen(form, "submit", prevent_default( /*doImport*/ctx[12]));
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if (dirty[0] & /*loading*/32) {
            button.disabled = /*loading*/ctx[5];
          }
          if (dirty[0] & /*loading*/32 && form_class_value !== (form_class_value = /*loading*/ctx[5] ? ' icon-loading' : '')) {
            attr(form, "class", form_class_value);
          }
        },
        d(detaching) {
          if (detaching) {
            detach(form);
          }
          mounted = false;
          dispose();
        }
      };
    }
    function create_fragment$1(ctx) {
      var form;
      var label0;
      var t0_value = translate('timemanager', 'Select delimiter') + "";
      var t0;
      var t1;
      var select;
      var option0;
      var option1;
      var t4;
      var label1;
      var t5_value = translate('timemanager', 'Select CSV file') + "";
      var t5;
      var t6;
      var br;
      var t7;
      var input;
      var t8;
      var button;
      var t10;
      var t11;
      var t12;
      var t13;
      var t14;
      var t15;
      var if_block4_anchor;
      var current;
      var mounted;
      var dispose;
      var if_block0 = /*parseError*/ctx[9] && create_if_block_6(ctx);
      var if_block1 = /*importError*/ctx[6] && create_if_block_5(ctx);
      var if_block2 = /*successMessage*/ctx[7] && create_if_block_4(ctx);
      var if_block3 = /*importPreviewData*/ctx[8].length && create_if_block_3(ctx);
      var each_value = ensure_array_like( /*importPreviewData*/ctx[8]);
      var each_blocks = [];
      for (var i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
      }
      var if_block4 = /*importPreviewData*/ctx[8].length && create_if_block$1(ctx);
      return {
        c() {
          form = element("form");
          label0 = element("label");
          t0 = text$1(t0_value);
          t1 = space$1();
          select = element("select");
          option0 = element("option");
          option0.textContent = ",";
          option1 = element("option");
          option1.textContent = ";";
          t4 = space$1();
          label1 = element("label");
          t5 = text$1(t5_value);
          t6 = space$1();
          br = element("br");
          t7 = space$1();
          input = element("input");
          t8 = space$1();
          button = element("button");
          button.textContent = "".concat(translate('timemanager', 'Generate preview from file'));
          t10 = space$1();
          if (if_block0) if_block0.c();
          t11 = space$1();
          if (if_block1) if_block1.c();
          t12 = space$1();
          if (if_block2) if_block2.c();
          t13 = space$1();
          if (if_block3) if_block3.c();
          t14 = space$1();
          for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {
            each_blocks[_i7].c();
          }
          t15 = space$1();
          if (if_block4) if_block4.c();
          if_block4_anchor = empty();
          option0.selected = true;
          option0.__value = ",";
          set_input_value(option0, option0.__value);
          option1.__value = ";";
          set_input_value(option1, option1.__value);
          attr(select, "name", "delimiter");
          attr(input, "type", "file");
          attr(button, "type", "submit");
        },
        m(target, anchor) {
          insert(target, form, anchor);
          append(form, label0);
          append(label0, t0);
          append(label0, t1);
          append(label0, select);
          append(select, option0);
          append(select, option1);
          /*select_binding*/
          ctx[15](select);
          append(form, t4);
          append(form, label1);
          append(label1, t5);
          append(label1, t6);
          append(label1, br);
          append(label1, t7);
          append(label1, input);
          /*input_binding*/
          ctx[16](input);
          append(form, t8);
          append(form, button);
          insert(target, t10, anchor);
          if (if_block0) if_block0.m(target, anchor);
          insert(target, t11, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert(target, t12, anchor);
          if (if_block2) if_block2.m(target, anchor);
          insert(target, t13, anchor);
          if (if_block3) if_block3.m(target, anchor);
          insert(target, t14, anchor);
          for (var _i8 = 0; _i8 < each_blocks.length; _i8 += 1) {
            if (each_blocks[_i8]) {
              each_blocks[_i8].m(target, anchor);
            }
          }
          insert(target, t15, anchor);
          if (if_block4) if_block4.m(target, anchor);
          insert(target, if_block4_anchor, anchor);
          current = true;
          if (!mounted) {
            dispose = listen(form, "submit", prevent_default( /*previewFile*/ctx[11]));
            mounted = true;
          }
        },
        p(ctx, dirty) {
          if ( /*parseError*/ctx[9]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
              if (dirty[0] & /*parseError*/512) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_6(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t11.parentNode, t11);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, function () {
              if_block0 = null;
            });
            check_outros();
          }
          if ( /*importError*/ctx[6]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
              if (dirty[0] & /*importError*/64) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_5(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(t12.parentNode, t12);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, function () {
              if_block1 = null;
            });
            check_outros();
          }
          if ( /*successMessage*/ctx[7]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);
              if (dirty[0] & /*successMessage*/128) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_4(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(t13.parentNode, t13);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, function () {
              if_block2 = null;
            });
            check_outros();
          }
          if ( /*importPreviewData*/ctx[8].length) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
            } else {
              if_block3 = create_if_block_3(ctx);
              if_block3.c();
              if_block3.m(t14.parentNode, t14);
            }
          } else if (if_block3) {
            if_block3.d(1);
            if_block3 = null;
          }
          if (dirty[0] & /*allOpen, importPreviewData*/1280) {
            each_value = ensure_array_like( /*importPreviewData*/ctx[8]);
            var _i9;
            for (_i9 = 0; _i9 < each_value.length; _i9 += 1) {
              var child_ctx = get_each_context(ctx, each_value, _i9);
              if (each_blocks[_i9]) {
                each_blocks[_i9].p(child_ctx, dirty);
              } else {
                each_blocks[_i9] = create_each_block(child_ctx);
                each_blocks[_i9].c();
                each_blocks[_i9].m(t15.parentNode, t15);
              }
            }
            for (; _i9 < each_blocks.length; _i9 += 1) {
              each_blocks[_i9].d(1);
            }
            each_blocks.length = each_value.length;
          }
          if ( /*importPreviewData*/ctx[8].length) {
            if (if_block4) {
              if_block4.p(ctx, dirty);
            } else {
              if_block4 = create_if_block$1(ctx);
              if_block4.c();
              if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
            }
          } else if (if_block4) {
            if_block4.d(1);
            if_block4 = null;
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(if_block2);
          current = true;
        },
        o(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(if_block2);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(form);
            detach(t10);
            detach(t11);
            detach(t12);
            detach(t13);
            detach(t14);
            detach(t15);
            detach(if_block4_anchor);
          }

          /*select_binding*/
          ctx[15](null);
          /*input_binding*/
          ctx[16](null);
          if (if_block0) if_block0.d(detaching);
          if (if_block1) if_block1.d(detaching);
          if (if_block2) if_block2.d(detaching);
          if (if_block3) if_block3.d(detaching);
          destroy_each(each_blocks, detaching);
          if (if_block4) if_block4.d(detaching);
          mounted = false;
          dispose();
        }
      };
    }
    function instance$1($$self, $$props, $$invalidate) {
      var parseError;
      var importError;
      var successMessage;
      var importPreviewData;
      var loading;
      var allOpen;
      var syncApiUrl = $$props.syncApiUrl;
      var requestToken = $$props.requestToken;
      var fileInput;
      var delimiterInput;

      // Collect updated objects in here
      var preparedClients = [];
      var preparedProjects = [];
      var preparedTasks = [];

      // Converts all keys of an object to lowercase
      var keysToLowerCase = function keysToLowerCase(object) {
        var result = {};
        if (object) {
          for (var _i10 = 0, _Object$entries = Object.entries(object); _i10 < _Object$entries.length; _i10++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i10], 2),
              key = _Object$entries$_i[0],
              value = _Object$entries$_i[1];
            result[key.toLowerCase()] = value;
          }
        }
        return result;
      };

      // Filters a list of records for type, converts all keys to lowercase and applies a uuid to each record
      var filter = function filter(records, type) {
        return records.map(keysToLowerCase).filter(function (record) {
          return record.type && record.type.toLowerCase() === type;
        }).map(function (record) {
          return _objectSpread2(_objectSpread2({}, record), {}, {
            uuid: v4()
          });
        });
      };

      // Previews a given file
      var previewFile = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var _fileInput$files, file, fileReader, contents, clients, projects, tasks, associated;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!(fileInput && fileInput.files && fileInput.files.length)) {
                  _context.next = 33;
                  break;
                }
                $$invalidate(8, importPreviewData = []);
                $$invalidate(9, parseError = "");
                _fileInput$files = _slicedToArray(fileInput.files, 1), file = _fileInput$files[0];
                fileReader = new FileReader();
                fileReader.readAsText(file);
                _context.next = 8;
                return new Promise(function (resolve, reject) {
                  fileReader.onload = function () {
                    resolve(null);
                  };
                  fileReader.onerror = function (error) {
                    reject(error);
                  };
                });
              case 8:
                contents = [];
                _context.prev = 9;
                _context.next = 12;
                return new Promise(function (resolve, reject) {
                  return parse$1(fileReader.result, {
                    delimiter: delimiterInput && delimiterInput.value ? delimiterInput.value : ",",
                    // @TODO: Make encoding configurable
                    encoding: "utf-8",
                    columns: true
                  }, function (err, records) {
                    if (err) {
                      reject(err);
                    }
                    resolve(records);
                  });
                });
              case 12:
                contents = _context.sent;
                _context.next = 19;
                break;
              case 15:
                _context.prev = 15;
                _context.t0 = _context["catch"](9);
                $$invalidate(9, parseError = _context.t0);
                return _context.abrupt("return");
              case 19:
                if (!(!contents || !contents.length)) {
                  _context.next = 22;
                  break;
                }
                $$invalidate(9, parseError = translate("timemanager", "It looks like this file is not a CSV file or doesn't contain any clients, projects or tasks."));
                return _context.abrupt("return");
              case 22:
                // Filter by type and assign uuids
                clients = filter(contents, "client");
                projects = filter(contents, "project");
                tasks = filter(contents, "task");
                if (!(!clients.length && !projects.length && !tasks.length)) {
                  _context.next = 28;
                  break;
                }
                $$invalidate(9, parseError = translate("timemanager", "It looks like this file is not a CSV file or doesn't contain any clients, projects or tasks."));
                return _context.abrupt("return");
              case 28:
                // Empty arrays
                $$invalidate(2, preparedClients = []);
                $$invalidate(3, preparedProjects = []);
                $$invalidate(4, preparedTasks = []);

                // Group entities
                associated = clients.map(function (client) {
                  client.projects = projects.filter(function (project) {
                    return project.client === client.name && !preparedProjects.find(function (oneProject) {
                      return oneProject.uuid === project.uuid;
                    });
                  }).map(function (project) {
                    return _objectSpread2(_objectSpread2({}, project), {}, {
                      client_uuid: client.uuid
                    });
                  }).map(function (project) {
                    project.tasks = tasks.filter(function (task) {
                      return task.project === project.name && !preparedTasks.find(function (oneTask) {
                        return oneTask.uuid === task.uuid;
                      });
                    }).map(function (task) {
                      return _objectSpread2(_objectSpread2({}, task), {}, {
                        project_uuid: project.uuid
                      });
                    });

                    // Add tasks if not exists
                    project.tasks.forEach(function (task) {
                      if (!preparedTasks.find(function (oneTask) {
                        return oneTask.uuid === task.uuid;
                      })) {
                        preparedTasks.push(task);
                      }
                    });

                    // Add project if not exists
                    if (!preparedProjects.find(function (oneProject) {
                      return oneProject.uuid === project.uuid;
                    })) {
                      preparedProjects.push(project);
                    }
                    return project;
                  });

                  // Add client
                  preparedClients.push(client);
                  return client;
                });
                $$invalidate(8, importPreviewData = associated);
              case 33:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[9, 15]]);
        }));
        return function previewFile() {
          return _ref.apply(this, arguments);
        };
      }(); // @TODO: LOW: List unassociated elements (not in import & not in store)

      // Post data to JSON API
      var doImport = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var convertedImportData, response;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                $$invalidate(5, loading = true);
                $$invalidate(6, importError = "");
                convertedImportData = {
                  lastCommit: "",
                  data: {
                    clients: {
                      created: preparedClients.map(function (client) {
                        delete client.type;
                        delete client.projects;
                        return client;
                      }),
                      updated: [],
                      deleted: []
                    },
                    projects: {
                      created: preparedProjects.map(function (project) {
                        delete project.type;
                        delete project.tasks;
                        return project;
                      }),
                      updated: [],
                      deleted: []
                    },
                    tasks: {
                      created: preparedTasks.map(function (task) {
                        delete task.type;
                        return task;
                      }),
                      updated: [],
                      deleted: []
                    },
                    times: {
                      created: [],
                      updated: [],
                      deleted: []
                    }
                  }
                };
                _context2.prev = 3;
                _context2.next = 6;
                return fetch(syncApiUrl, {
                  method: "POST",
                  headers: {
                    requesttoken: requestToken,
                    "content-type": "application/json"
                  },
                  body: JSON.stringify(convertedImportData)
                });
              case 6:
                response = _context2.sent;
                if (response.ok) {
                  $$invalidate(8, importPreviewData = []);
                  $$invalidate(7, successMessage = translate("timemanager", "Imported {clientsCount} client(s), {projectsCount} project(s), {tasksCount} task(s)", {
                    clientsCount: preparedClients.length,
                    projectsCount: preparedProjects.length,
                    tasksCount: preparedTasks.length
                  }));
                }
                _context2.next = 13;
                break;
              case 10:
                _context2.prev = 10;
                _context2.t0 = _context2["catch"](3);
                $$invalidate(6, importError = _context2.t0);
              case 13:
                $$invalidate(5, loading = false);
              case 14:
              case "end":
                return _context2.stop();
            }
          }, _callee2, null, [[3, 10]]);
        }));
        return function doImport() {
          return _ref2.apply(this, arguments);
        };
      }();
      function select_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          delimiterInput = $$value;
          $$invalidate(1, delimiterInput);
        });
      }
      function input_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](function () {
          fileInput = $$value;
          $$invalidate(0, fileInput);
        });
      }
      var click_handler = function click_handler() {
        $$invalidate(9, parseError = '');
      };
      var click_handler_1 = function click_handler_1() {
        $$invalidate(6, importError = '');
      };
      var click_handler_2 = function click_handler_2() {
        $$invalidate(7, successMessage = '');
      };
      var click_handler_3 = function click_handler_3() {
        return $$invalidate(10, allOpen = false);
      };
      var click_handler_4 = function click_handler_4() {
        return $$invalidate(10, allOpen = true);
      };
      $$self.$$set = function ($$props) {
        if ('syncApiUrl' in $$props) $$invalidate(13, syncApiUrl = $$props.syncApiUrl);
        if ('requestToken' in $$props) $$invalidate(14, requestToken = $$props.requestToken);
      };
      $$invalidate(9, parseError = "");
      $$invalidate(6, importError = "");
      $$invalidate(7, successMessage = "");
      $$invalidate(8, importPreviewData = []);
      $$invalidate(5, loading = false);
      $$invalidate(10, allOpen = false);
      return [fileInput, delimiterInput, preparedClients, preparedProjects, preparedTasks, loading, importError, successMessage, importPreviewData, parseError, allOpen, previewFile, doImport, syncApiUrl, requestToken, select_binding, input_binding, click_handler, click_handler_1, click_handler_2, click_handler_3, click_handler_4];
    }
    var Import = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(Import, _SvelteComponent);
      var _super = _createSuper$1(Import);
      function Import(options) {
        var _this;
        _classCallCheck$1(this, Import);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance$1, create_fragment$1, safe_not_equal, {
          syncApiUrl: 13,
          requestToken: 14
        }, null, [-1, -1]);
        return _this;
      }
      return _createClass$1(Import);
    }(SvelteComponent);

    function create_if_block(ctx) {
      var div;
      var userfilterselect;
      var current;
      var mounted;
      var dispose;
      userfilterselect = new UserFilterSelect({
        props: {
          isVisible: /*showTooltip*/ctx[1],
          requestToken: /*requestToken*/ctx[0]
        }
      });
      return {
        c() {
          div = element("div");
          create_component(userfilterselect.$$.fragment);
          attr(div, "class", "popover");
        },
        m(target, anchor) {
          insert(target, div, anchor);
          mount_component(userfilterselect, div, null);
          current = true;
          if (!mounted) {
            dispose = action_destroyer(/*popperContent*/ctx[4].call(null, div, /*extraOpts*/ctx[5]));
            mounted = true;
          }
        },
        p(ctx, dirty) {
          var userfilterselect_changes = {};
          if (dirty & /*showTooltip*/2) userfilterselect_changes.isVisible = /*showTooltip*/ctx[1];
          if (dirty & /*requestToken*/1) userfilterselect_changes.requestToken = /*requestToken*/ctx[0];
          userfilterselect.$set(userfilterselect_changes);
        },
        i(local) {
          if (current) return;
          transition_in(userfilterselect.$$.fragment, local);
          current = true;
        },
        o(local) {
          transition_out(userfilterselect.$$.fragment, local);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(div);
          }
          destroy_component(userfilterselect);
          mounted = false;
          dispose();
        }
      };
    }
    function create_fragment(ctx) {
      var button;
      var t0_value = translate('timemanager', 'Filter by person') + "";
      var t0;
      var button_class_value;
      var t1;
      var if_block_anchor;
      var current;
      var mounted;
      var dispose;
      var if_block = /*showTooltip*/ctx[1] && create_if_block(ctx);
      return {
        c() {
          button = element("button");
          t0 = text$1(t0_value);
          t1 = space$1();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr(button, "class", button_class_value = "filter-button icon-filter button-w-icon ".concat( /*$isFilterSet*/ctx[2] ? 'active' : ''));
        },
        m(target, anchor) {
          insert(target, button, anchor);
          append(button, t0);
          insert(target, t1, anchor);
          if (if_block) if_block.m(target, anchor);
          insert(target, if_block_anchor, anchor);
          current = true;
          if (!mounted) {
            dispose = [action_destroyer(/*popperRef*/ctx[3].call(null, button)), listen(button, "click", /*click_handler*/ctx[6])];
            mounted = true;
          }
        },
        p(ctx, _ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];
          if (!current || dirty & /*$isFilterSet*/4 && button_class_value !== (button_class_value = "filter-button icon-filter button-w-icon ".concat( /*$isFilterSet*/ctx[2] ? 'active' : ''))) {
            attr(button, "class", button_class_value);
          }
          if ( /*showTooltip*/ctx[1]) {
            if (if_block) {
              if_block.p(ctx, dirty);
              if (dirty & /*showTooltip*/2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, function () {
              if_block = null;
            });
            check_outros();
          }
        },
        i(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o(local) {
          transition_out(if_block);
          current = false;
        },
        d(detaching) {
          if (detaching) {
            detach(button);
            detach(t1);
            detach(if_block_anchor);
          }
          if (if_block) if_block.d(detaching);
          mounted = false;
          run_all(dispose);
        }
      };
    }
    function instance($$self, $$props, $$invalidate) {
      var $isFilterSet;
      component_subscribe($$self, isFilterSet, function ($$value) {
        return $$invalidate(2, $isFilterSet = $$value);
      });
      var requestToken = $$props.requestToken;
      var _createPopperActions = createPopperActions({
          placement: "bottom",
          strategy: "fixed"
        }),
        _createPopperActions2 = _slicedToArray(_createPopperActions, 2),
        popperRef = _createPopperActions2[0],
        popperContent = _createPopperActions2[1];
      var extraOpts = {
        modifiers: [{
          name: "offset",
          options: {
            offset: [0, 8]
          }
        }]
      };
      var showTooltip = false;
      onMount(function () {
        var hideTooltip = function hideTooltip(e) {
          if (e.key === "Escape") {
            $$invalidate(1, showTooltip = false);
          }
        };
        document.addEventListener("keyup", hideTooltip);
        isFilterSet.set(false);

        // Parse current URL
        var urlParts = document.location.href.split("?");
        if (urlParts.length > 1) {
          var queryString = urlParts[1];
          var queryStringParts = queryString.split("&");

          // Map over all query params
          var _iterator = _createForOfIteratorHelper$1(queryStringParts),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var part = _step.value;
              // Split query params
              var partParts = part.split("=");
              var _partParts = _slicedToArray(partParts, 2),
                name = _partParts[0],
                value = _partParts[1];

              // Apply filters from query params
              if (name === "userFilter" && value) {
                isFilterSet.set(true);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        return function () {
          document.removeEventListener("keyup", hideTooltip);
          isFilterSet.set(false);
        };
      });
      var click_handler = function click_handler() {
        $$invalidate(1, showTooltip = !showTooltip);
      };
      $$self.$$set = function ($$props) {
        if ('requestToken' in $$props) $$invalidate(0, requestToken = $$props.requestToken);
      };
      return [requestToken, showTooltip, $isFilterSet, popperRef, popperContent, extraOpts, click_handler];
    }
    var UserFilterButton = /*#__PURE__*/function (_SvelteComponent) {
      _inherits$1(UserFilterButton, _SvelteComponent);
      var _super = _createSuper$1(UserFilterButton);
      function UserFilterButton(options) {
        var _this;
        _classCallCheck$1(this, UserFilterButton);
        _this = _super.call(this);
        init$2(_assertThisInitialized$1(_this), options, instance, create_fragment, safe_not_equal, {
          requestToken: 0
        });
        return _this;
      }
      return _createClass$1(UserFilterButton);
    }(SvelteComponent);

    /* global HTMLCollection: true */

    var foreachEls = function (els, fn, context) {
      if (els instanceof HTMLCollection || els instanceof NodeList || els instanceof Array) {
        return Array.prototype.forEach.call(els, fn, context);
      }
      // assume simple DOM element
      return fn.call(context, els);
    };

    var evalScript = function (el) {
      var code = el.text || el.textContent || el.innerHTML || "";
      var src = el.src || "";
      var parent = el.parentNode || document.querySelector("head") || document.documentElement;
      var script = document.createElement("script");
      if (code.match("document.write")) {
        if (console && console.log) {
          console.log("Script contains document.write. Can’t be executed correctly. Code skipped ", el);
        }
        return false;
      }
      script.type = "text/javascript";
      script.id = el.id;

      /* istanbul ignore if */
      if (src !== "") {
        script.src = src;
        script.async = false; // force synchronous loading of peripheral JS
      }

      if (code !== "") {
        try {
          script.appendChild(document.createTextNode(code));
        } catch (e) {
          /* istanbul ignore next */
          // old IEs have funky script nodes
          script.text = code;
        }
      }

      // execute
      parent.appendChild(script);
      // avoid pollution only in head or body tags
      if ((parent instanceof HTMLHeadElement || parent instanceof HTMLBodyElement) && parent.contains(script)) {
        parent.removeChild(script);
      }
      return true;
    };

    // Finds and executes scripts (used for newly added elements)
    // Needed since innerHTML does not run scripts
    var executeScripts = function (el) {
      if (el.tagName.toLowerCase() === "script") {
        evalScript(el);
      }
      foreachEls(el.querySelectorAll("script"), function (script) {
        if (!script.type || script.type.toLowerCase() === "text/javascript") {
          if (script.parentNode) {
            script.parentNode.removeChild(script);
          }
          evalScript(script);
        }
      });
    };

    var on = function (els, events, listener, useCapture) {
      events = typeof events === "string" ? events.split(" ") : events;
      events.forEach(function (e) {
        foreachEls(els, function (el) {
          el.addEventListener(e, listener, useCapture);
        });
      });
    };

    var switches = {
      outerHTML: function (oldEl, newEl) {
        oldEl.outerHTML = newEl.outerHTML;
        this.onSwitch();
      },
      innerHTML: function (oldEl, newEl) {
        oldEl.innerHTML = newEl.innerHTML;
        if (newEl.className === "") {
          oldEl.removeAttribute("class");
        } else {
          oldEl.className = newEl.className;
        }
        this.onSwitch();
      },
      switchElementsAlt: function (oldEl, newEl) {
        oldEl.innerHTML = newEl.innerHTML;

        // Copy attributes from the new element to the old one
        if (newEl.hasAttributes()) {
          var attrs = newEl.attributes;
          for (var i = 0; i < attrs.length; i++) {
            oldEl.attributes.setNamedItem(attrs[i].cloneNode());
          }
        }
        this.onSwitch();
      },
      // Equivalent to outerHTML(), but doesn't require switchElementsAlt() for <head> and <body>
      replaceNode: function (oldEl, newEl) {
        oldEl.parentNode.replaceChild(newEl, oldEl);
        this.onSwitch();
      },
      sideBySide: function (oldEl, newEl, options, switchOptions) {
        var forEach = Array.prototype.forEach;
        var elsToRemove = [];
        var elsToAdd = [];
        var fragToAppend = document.createDocumentFragment();
        var animationEventNames = "animationend webkitAnimationEnd MSAnimationEnd oanimationend";
        var animatedElsNumber = 0;
        var sexyAnimationEnd = function (e) {
          if (e.target !== e.currentTarget) {
            // end triggered by an animation on a child
            return;
          }
          animatedElsNumber--;
          if (animatedElsNumber <= 0 && elsToRemove) {
            elsToRemove.forEach(function (el) {
              // browsing quickly can make the el
              // already removed by last page update ?
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
            });
            elsToAdd.forEach(function (el) {
              el.className = el.className.replace(el.getAttribute("data-pjax-classes"), "");
              el.removeAttribute("data-pjax-classes");
            });
            elsToAdd = null; // free memory
            elsToRemove = null; // free memory

            // this is to trigger some repaint (example: picturefill)
            this.onSwitch();
          }
        }.bind(this);
        switchOptions = switchOptions || {};
        forEach.call(oldEl.childNodes, function (el) {
          elsToRemove.push(el);
          if (el.classList && !el.classList.contains("js-Pjax-remove")) {
            // for fast switch, clean element that just have been added, & not cleaned yet.
            if (el.hasAttribute("data-pjax-classes")) {
              el.className = el.className.replace(el.getAttribute("data-pjax-classes"), "");
              el.removeAttribute("data-pjax-classes");
            }
            el.classList.add("js-Pjax-remove");
            if (switchOptions.callbacks && switchOptions.callbacks.removeElement) {
              switchOptions.callbacks.removeElement(el);
            }
            if (switchOptions.classNames) {
              el.className += " " + switchOptions.classNames.remove + " " + (options.backward ? switchOptions.classNames.backward : switchOptions.classNames.forward);
            }
            animatedElsNumber++;
            on(el, animationEventNames, sexyAnimationEnd, true);
          }
        });
        forEach.call(newEl.childNodes, function (el) {
          if (el.classList) {
            var addClasses = "";
            if (switchOptions.classNames) {
              addClasses = " js-Pjax-add " + switchOptions.classNames.add + " " + (options.backward ? switchOptions.classNames.forward : switchOptions.classNames.backward);
            }
            if (switchOptions.callbacks && switchOptions.callbacks.addElement) {
              switchOptions.callbacks.addElement(el);
            }
            el.className += addClasses;
            el.setAttribute("data-pjax-classes", addClasses);
            elsToAdd.push(el);
            fragToAppend.appendChild(el);
            animatedElsNumber++;
            on(el, animationEventNames, sexyAnimationEnd, true);
          }
        });

        // pass all className of the parent
        oldEl.className = newEl.className;
        oldEl.appendChild(fragToAppend);
      }
    };
    switches.outerHTML;
    switches.innerHTML;
    switches.switchElementsAlt;
    switches.replaceNode;
    switches.sideBySide;

    /* global _gaq: true, ga: true */


    var parseOptions$1 = function (options) {
      options = options || {};
      options.elements = options.elements || "a[href], form[action]";
      options.selectors = options.selectors || ["title", ".js-Pjax"];
      options.switches = options.switches || {};
      options.switchesOptions = options.switchesOptions || {};
      options.history = typeof options.history === "undefined" ? true : options.history;
      options.analytics = typeof options.analytics === "function" || options.analytics === false ? options.analytics : defaultAnalytics;
      options.scrollTo = typeof options.scrollTo === "undefined" ? 0 : options.scrollTo;
      options.scrollRestoration = typeof options.scrollRestoration !== "undefined" ? options.scrollRestoration : true;
      options.cacheBust = typeof options.cacheBust === "undefined" ? true : options.cacheBust;
      options.debug = options.debug || false;
      options.timeout = options.timeout || 0;
      options.currentUrlFullReload = typeof options.currentUrlFullReload === "undefined" ? false : options.currentUrlFullReload;

      // We can’t replace body.outerHTML or head.outerHTML.
      // It creates a bug where a new body or head are created in the DOM.
      // If you set head.outerHTML, a new body tag is appended, so the DOM has 2 body nodes, and vice versa
      if (!options.switches.head) {
        options.switches.head = switches.switchElementsAlt;
      }
      if (!options.switches.body) {
        options.switches.body = switches.switchElementsAlt;
      }
      return options;
    };

    /* istanbul ignore next */
    function defaultAnalytics() {
      if (window._gaq) {
        _gaq.push(["_trackPageview"]);
      }
      if (window.ga) {
        ga("send", "pageview", {
          page: location.pathname,
          title: document.title
        });
      }
    }

    var uniqueid = function () {
      var counter = 0;
      return function () {
        var id = "pjax" + new Date().getTime() + "_" + counter;
        counter++;
        return id;
      };
    }();

    var trigger = function (els, events, opts) {
      events = typeof events === "string" ? events.split(" ") : events;
      events.forEach(function (e) {
        var event;
        event = document.createEvent("HTMLEvents");
        event.initEvent(e, true, true);
        event.eventName = e;
        if (opts) {
          Object.keys(opts).forEach(function (key) {
            event[key] = opts[key];
          });
        }
        foreachEls(els, function (el) {
          var domFix = false;
          if (!el.parentNode && el !== document && el !== window) {
            // THANK YOU IE (9/10/11)
            // dispatchEvent doesn't work if the element is not in the DOM
            domFix = true;
            document.body.appendChild(el);
          }
          el.dispatchEvent(event);
          if (domFix) {
            el.parentNode.removeChild(el);
          }
        });
      });
    };

    var clone = function (obj) {
      /* istanbul ignore if */
      if (null === obj || "object" !== typeof obj) {
        return obj;
      }
      var copy = obj.constructor();
      for (var attr in obj) {
        if (obj.hasOwnProperty(attr)) {
          copy[attr] = obj[attr];
        }
      }
      return copy;
    };

    var contains = function contains(doc, selectors, el) {
      for (var i = 0; i < selectors.length; i++) {
        var selectedEls = doc.querySelectorAll(selectors[i]);
        for (var j = 0; j < selectedEls.length; j++) {
          if (selectedEls[j].contains(el)) {
            return true;
          }
        }
      }
      return false;
    };

    var extend = function (target) {
      if (target == null) {
        return null;
      }
      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        if (source != null) {
          for (var key in source) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              to[key] = source[key];
            }
          }
        }
      }
      return to;
    };

    var noop = function () {};

    var log = function () {
      if (this.options.debug && console) {
        if (typeof console.log === "function") {
          console.log.apply(console, arguments);
        }
        // IE is weird
        else if (console.log) {
          console.log(arguments);
        }
      }
    };

    var attrState$2 = "data-pjax-state";
    var parseElement = function (el) {
      switch (el.tagName.toLowerCase()) {
        case "a":
          // only attach link if el does not already have link attached
          if (!el.hasAttribute(attrState$2)) {
            this.attachLink(el);
          }
          break;
        case "form":
          // only attach link if el does not already have link attached
          if (!el.hasAttribute(attrState$2)) {
            this.attachForm(el);
          }
          break;
        default:
          throw "Pjax can only be applied on <a> or <form> submit";
      }
    };

    var attrState$1 = "data-pjax-state";
    var linkAction = function (el, event) {
      if (isDefaultPrevented$1(event)) {
        return;
      }

      // Since loadUrl modifies options and we may add our own modifications below,
      // clone it so the changes don't persist
      var options = clone(this.options);
      var attrValue = checkIfShouldAbort$1(el, event);
      if (attrValue) {
        el.setAttribute(attrState$1, attrValue);
        return;
      }
      event.preventDefault();

      // don’t do "nothing" if user try to reload the page by clicking the same link twice
      if (this.options.currentUrlFullReload && el.href === window.location.href.split("#")[0]) {
        el.setAttribute(attrState$1, "reload");
        this.reload();
        return;
      }
      el.setAttribute(attrState$1, "load");
      options.triggerElement = el;
      this.loadUrl(el.href, options);
    };
    function checkIfShouldAbort$1(el, event) {
      // Don’t break browser special behavior on links (like page in new window)
      if (event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {
        return "modifier";
      }

      // we do test on href now to prevent unexpected behavior if for some reason
      // user have href that can be dynamically updated

      // Ignore external links.
      if (el.protocol !== window.location.protocol || el.host !== window.location.host) {
        return "external";
      }

      // Ignore anchors on the same page (keep native behavior)
      if (el.hash && el.href.replace(el.hash, "") === window.location.href.replace(location.hash, "")) {
        return "anchor";
      }

      // Ignore empty anchor "foo.html#"
      if (el.href === window.location.href.split("#")[0] + "#") {
        return "anchor-empty";
      }
    }
    var isDefaultPrevented$1 = function (event) {
      return event.defaultPrevented || event.returnValue === false;
    };
    var attachLink = function (el) {
      var that = this;
      el.setAttribute(attrState$1, "");
      on(el, "click", function (event) {
        linkAction.call(that, el, event);
      });
      on(el, "keyup", function (event) {
        if (event.keyCode === 13) {
          linkAction.call(that, el, event);
        }
      }.bind(this));
    };

    var attrState = "data-pjax-state";
    var formAction = function (el, event) {
      if (isDefaultPrevented(event)) {
        return;
      }

      // Since loadUrl modifies options and we may add our own modifications below,
      // clone it so the changes don't persist
      var options = clone(this.options);

      // Initialize requestOptions
      options.requestOptions = {
        requestUrl: el.getAttribute("action") || window.location.href,
        requestMethod: el.getAttribute("method") || "GET"
      };

      // create a testable virtual link of the form action
      var virtLinkElement = document.createElement("a");
      virtLinkElement.setAttribute("href", options.requestOptions.requestUrl);
      var attrValue = checkIfShouldAbort(virtLinkElement, options);
      if (attrValue) {
        el.setAttribute(attrState, attrValue);
        return;
      }
      event.preventDefault();
      if (el.enctype === "multipart/form-data") {
        options.requestOptions.formData = new FormData(el);
      } else {
        options.requestOptions.requestParams = parseFormElements(el);
      }
      el.setAttribute(attrState, "submit");
      options.triggerElement = el;
      this.loadUrl(virtLinkElement.href, options);
    };
    function parseFormElements(el) {
      var requestParams = [];
      var formElements = el.elements;
      for (var i = 0; i < formElements.length; i++) {
        var element = formElements[i];
        var tagName = element.tagName.toLowerCase();
        // jscs:disable disallowImplicitTypeConversion
        if (!!element.name && element.attributes !== undefined && tagName !== "button") {
          // jscs:enable disallowImplicitTypeConversion
          var type = element.attributes.type;
          if (!type || type.value !== "checkbox" && type.value !== "radio" || element.checked) {
            // Build array of values to submit
            var values = [];
            if (tagName === "select") {
              var opt;
              for (var j = 0; j < element.options.length; j++) {
                opt = element.options[j];
                if (opt.selected && !opt.disabled) {
                  values.push(opt.hasAttribute("value") ? opt.value : opt.text);
                }
              }
            } else {
              values.push(element.value);
            }
            for (var k = 0; k < values.length; k++) {
              requestParams.push({
                name: encodeURIComponent(element.name),
                value: encodeURIComponent(values[k])
              });
            }
          }
        }
      }
      return requestParams;
    }
    function checkIfShouldAbort(virtLinkElement, options) {
      // Ignore external links.
      if (virtLinkElement.protocol !== window.location.protocol || virtLinkElement.host !== window.location.host) {
        return "external";
      }

      // Ignore click if we are on an anchor on the same page
      if (virtLinkElement.hash && virtLinkElement.href.replace(virtLinkElement.hash, "") === window.location.href.replace(location.hash, "")) {
        return "anchor";
      }

      // Ignore empty anchor "foo.html#"
      if (virtLinkElement.href === window.location.href.split("#")[0] + "#") {
        return "anchor-empty";
      }

      // if declared as a full reload, just normally submit the form
      if (options.currentUrlFullReload && virtLinkElement.href === window.location.href.split("#")[0]) {
        return "reload";
      }
    }
    var isDefaultPrevented = function (event) {
      return event.defaultPrevented || event.returnValue === false;
    };
    var attachForm = function (el) {
      var that = this;
      el.setAttribute(attrState, "");
      on(el, "submit", function (event) {
        formAction.call(that, el, event);
      });
    };

    var foreachSelectors = function (selectors, cb, context, DOMcontext) {
      DOMcontext = DOMcontext || document;
      selectors.forEach(function (selector) {
        foreachEls(DOMcontext.querySelectorAll(selector), cb, context);
      });
    };

    var switchesSelectors = function (switches$1, switchesOptions, selectors, fromEl, toEl, options) {
      var switchesQueue = [];
      selectors.forEach(function (selector) {
        var newEls = fromEl.querySelectorAll(selector);
        var oldEls = toEl.querySelectorAll(selector);
        if (this.log) {
          this.log("Pjax switch", selector, newEls, oldEls);
        }
        if (newEls.length !== oldEls.length) {
          throw "DOM doesn’t look the same on new loaded page: ’" + selector + "’ - new " + newEls.length + ", old " + oldEls.length;
        }
        foreachEls(newEls, function (newEl, i) {
          var oldEl = oldEls[i];
          if (this.log) {
            this.log("newEl", newEl, "oldEl", oldEl);
          }
          var callback = switches$1[selector] ? switches$1[selector].bind(this, oldEl, newEl, options, switchesOptions[selector]) : switches.outerHTML.bind(this, oldEl, newEl, options);
          switchesQueue.push(callback);
        }, this);
      }, this);
      this.state.numPendingSwitches = switchesQueue.length;
      switchesQueue.forEach(function (queuedSwitch) {
        queuedSwitch();
      });
    };

    var abortRequest = function (request) {
      if (request && request.readyState < 4) {
        request.onreadystatechange = noop;
        request.abort();
      }
    };

    var updateQueryString = function (uri, key, value) {
      var re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
      var separator = uri.indexOf("?") !== -1 ? "&" : "?";
      if (uri.match(re)) {
        return uri.replace(re, "$1" + key + "=" + value + "$2");
      } else {
        return uri + separator + key + "=" + value;
      }
    };

    var sendRequest = function (location, options, callback) {
      options = options || {};
      var queryString;
      var requestOptions = options.requestOptions || {};
      var requestMethod = (requestOptions.requestMethod || "GET").toUpperCase();
      var requestParams = requestOptions.requestParams || null;
      var formData = requestOptions.formData || null;
      var requestPayload = null;
      var request = new XMLHttpRequest();
      var timeout = options.timeout || 0;
      request.onreadystatechange = function () {
        if (request.readyState === 4) {
          if (request.status === 200) {
            callback(request.responseText, request, location, options);
          } else if (request.status !== 0) {
            callback(null, request, location, options);
          }
        }
      };
      request.onerror = function (e) {
        console.log(e);
        callback(null, request, location, options);
      };
      request.ontimeout = function () {
        callback(null, request, location, options);
      };

      // Prepare the request payload for forms, if available
      if (requestParams && requestParams.length) {
        // Build query string
        queryString = requestParams.map(function (param) {
          return param.name + "=" + param.value;
        }).join("&");
        switch (requestMethod) {
          case "GET":
            // Reset query string to avoid an issue with repeat submissions where checkboxes that were
            // previously checked are incorrectly preserved
            location = location.split("?")[0];

            // Append new query string
            location += "?" + queryString;
            break;
          case "POST":
            // Send query string as request payload
            requestPayload = queryString;
            break;
        }
      } else if (formData) {
        requestPayload = formData;
      }

      // Add a timestamp as part of the query string if cache busting is enabled
      if (options.cacheBust) {
        location = updateQueryString(location, "t", Date.now());
      }
      request.open(requestMethod, location, true);
      request.timeout = timeout;
      request.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      request.setRequestHeader("X-PJAX", "true");
      request.setRequestHeader("X-PJAX-Selectors", JSON.stringify(options.selectors));

      // Send the proper header information for POST forms
      if (requestPayload && requestMethod === "POST" && !formData) {
        request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      }
      request.send(requestPayload);
      return request;
    };

    var handleResponse = function (responseText, request, href, options) {
      options = clone(options || this.options);
      options.request = request;

      // Fail if unable to load HTML via AJAX
      if (responseText === false) {
        trigger(document, "pjax:complete pjax:error", options);
        return;
      }

      // push scroll position to history
      var currentState = window.history.state || {};
      window.history.replaceState({
        url: currentState.url || window.location.href,
        title: currentState.title || document.title,
        uid: currentState.uid || uniqueid(),
        scrollPos: [document.documentElement.scrollLeft || document.body.scrollLeft, document.documentElement.scrollTop || document.body.scrollTop]
      }, document.title, window.location.href);

      // Check for redirects
      var oldHref = href;
      if (request.responseURL) {
        if (href !== request.responseURL) {
          href = request.responseURL;
        }
      } else if (request.getResponseHeader("X-PJAX-URL")) {
        href = request.getResponseHeader("X-PJAX-URL");
      } else if (request.getResponseHeader("X-XHR-Redirected-To")) {
        href = request.getResponseHeader("X-XHR-Redirected-To");
      }

      // Add back the hash if it was removed
      var a = document.createElement("a");
      a.href = oldHref;
      var oldHash = a.hash;
      a.href = href;
      if (oldHash && !a.hash) {
        a.hash = oldHash;
        href = a.href;
      }
      this.state.href = href;
      this.state.options = options;
      try {
        this.loadContent(responseText, options);
      } catch (e) {
        trigger(document, "pjax:error", options);
        if (!this.options.debug) {
          if (console && console.error) {
            console.error("Pjax switch fail: ", e);
          }
          return this.latestChance(href);
        } else {
          throw e;
        }
      }
    };

    var isSupported = function () {
      // Borrowed wholesale from https://github.com/defunkt/jquery-pjax
      return window.history && window.history.pushState && window.history.replaceState &&
      // pushState isn’t reliable on iOS until 5.
      !navigator.userAgent.match(/((iPod|iPhone|iPad).+\bOS\s+[1-4]\D|WebApps\/.+CFNetwork)/);
    };

    var pjax$1 = createCommonjsModule(function (module) {
    var Pjax = function (options) {
      this.state = {
        numPendingSwitches: 0,
        href: null,
        options: null
      };
      this.options = parseOptions$1(options);
      this.log("Pjax options", this.options);
      if (this.options.scrollRestoration && "scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }
      this.maxUid = this.lastUid = uniqueid();
      this.parseDOM(document);
      on(window, "popstate", function (st) {
        if (st.state) {
          var opt = clone(this.options);
          opt.url = st.state.url;
          opt.title = st.state.title;
          // Since state already exists, prevent it from being pushed again
          opt.history = false;
          opt.scrollPos = st.state.scrollPos;
          if (st.state.uid < this.lastUid) {
            opt.backward = true;
          } else {
            opt.forward = true;
          }
          this.lastUid = st.state.uid;

          // @todo implement history cache here, based on uid
          this.loadUrl(st.state.url, opt);
        }
      }.bind(this));
    };
    Pjax.switches = switches;
    Pjax.prototype = {
      log: log,
      getElements: function (el) {
        return el.querySelectorAll(this.options.elements);
      },
      parseDOM: function (el) {
        var parseElement$1 = parseElement;
        foreachEls(this.getElements(el), parseElement$1, this);
      },
      refresh: function (el) {
        this.parseDOM(el || document);
      },
      reload: function () {
        window.location.reload();
      },
      attachLink: attachLink,
      attachForm: attachForm,
      forEachSelectors: function (cb, context, DOMcontext) {
        return foreachSelectors.bind(this)(this.options.selectors, cb, context, DOMcontext);
      },
      switchSelectors: function (selectors, fromEl, toEl, options) {
        return switchesSelectors.bind(this)(this.options.switches, this.options.switchesOptions, selectors, fromEl, toEl, options);
      },
      latestChance: function (href) {
        window.location = href;
      },
      onSwitch: function () {
        trigger(window, "resize scroll");
        this.state.numPendingSwitches--;

        // debounce calls, so we only run this once after all switches are finished.
        if (this.state.numPendingSwitches === 0) {
          this.afterAllSwitches();
        }
      },
      loadContent: function (html, options) {
        if (typeof html !== "string") {
          trigger(document, "pjax:complete pjax:error", options);
          return;
        }
        var tmpEl = document.implementation.createHTMLDocument("pjax");

        // parse HTML attributes to copy them
        // since we are forced to use documentElement.innerHTML (outerHTML can't be used for <html>)
        var htmlRegex = /<html[^>]+>/gi;
        var htmlAttribsRegex = /\s?[a-z:]+(?:=['"][^'">]+['"])*/gi;
        var matches = html.match(htmlRegex);
        if (matches && matches.length) {
          matches = matches[0].match(htmlAttribsRegex);
          if (matches.length) {
            matches.shift();
            matches.forEach(function (htmlAttrib) {
              var attr = htmlAttrib.trim().split("=");
              if (attr.length === 1) {
                tmpEl.documentElement.setAttribute(attr[0], true);
              } else {
                tmpEl.documentElement.setAttribute(attr[0], attr[1].slice(1, -1));
              }
            });
          }
        }
        tmpEl.documentElement.innerHTML = html;
        this.log("load content", tmpEl.documentElement.attributes, tmpEl.documentElement.innerHTML.length);

        // Clear out any focused controls before inserting new page contents.
        if (document.activeElement && contains(document, this.options.selectors, document.activeElement)) {
          try {
            document.activeElement.blur();
          } catch (e) {} // eslint-disable-line no-empty
        }

        this.switchSelectors(this.options.selectors, tmpEl, document, options);
      },
      abortRequest: abortRequest,
      doRequest: sendRequest,
      handleResponse: handleResponse,
      loadUrl: function (href, options) {
        options = typeof options === "object" ? extend({}, this.options, options) : clone(this.options);
        this.log("load href", href, options);

        // Abort any previous request
        this.abortRequest(this.request);
        trigger(document, "pjax:send", options);

        // Do the request
        this.request = this.doRequest(href, options, this.handleResponse.bind(this));
      },
      afterAllSwitches: function () {
        // FF bug: Won’t autofocus fields that are inserted via JS.
        // This behavior is incorrect. So if theres no current focus, autofocus
        // the last field.
        //
        // http://www.w3.org/html/wg/drafts/html/master/forms.html
        var autofocusEl = Array.prototype.slice.call(document.querySelectorAll("[autofocus]")).pop();
        if (autofocusEl && document.activeElement !== autofocusEl) {
          autofocusEl.focus();
        }

        // execute scripts when DOM have been completely updated
        this.options.selectors.forEach(function (selector) {
          foreachEls(document.querySelectorAll(selector), function (el) {
            executeScripts(el);
          });
        });
        var state = this.state;
        if (state.options.history) {
          if (!window.history.state) {
            this.lastUid = this.maxUid = uniqueid();
            window.history.replaceState({
              url: window.location.href,
              title: document.title,
              uid: this.maxUid,
              scrollPos: [0, 0]
            }, document.title);
          }

          // Update browser history
          this.lastUid = this.maxUid = uniqueid();
          window.history.pushState({
            url: state.href,
            title: state.options.title,
            uid: this.maxUid,
            scrollPos: [0, 0]
          }, state.options.title, state.href);
        }
        this.forEachSelectors(function (el) {
          this.parseDOM(el);
        }, this);

        // Fire Events
        trigger(document, "pjax:complete pjax:success", state.options);
        if (typeof state.options.analytics === "function") {
          state.options.analytics();
        }
        if (state.options.history) {
          // First parse url and check for hash to override scroll
          var a = document.createElement("a");
          a.href = this.state.href;
          if (a.hash) {
            var name = a.hash.slice(1);
            name = decodeURIComponent(name);
            var curtop = 0;
            var target = document.getElementById(name) || document.getElementsByName(name)[0];
            if (target) {
              // http://stackoverflow.com/questions/8111094/cross-browser-javascript-function-to-find-actual-position-of-an-element-in-page
              if (target.offsetParent) {
                do {
                  curtop += target.offsetTop;
                  target = target.offsetParent;
                } while (target);
              }
            }
            window.scrollTo(0, curtop);
          } else if (state.options.scrollTo !== false) {
            // Scroll page to top on new page load
            if (state.options.scrollTo.length > 1) {
              window.scrollTo(state.options.scrollTo[0], state.options.scrollTo[1]);
            } else {
              window.scrollTo(0, state.options.scrollTo);
            }
          }
        } else if (state.options.scrollRestoration && state.options.scrollPos) {
          window.scrollTo(state.options.scrollPos[0], state.options.scrollPos[1]);
        }
        this.state = {
          numPendingSwitches: 0,
          href: null,
          options: null
        };
      }
    };
    Pjax.isSupported = isSupported;

    // arguably could do `if( require("./lib/is-supported")()) {` but that might be a little to simple
    if (Pjax.isSupported()) {
      module.exports = Pjax;
    }
    // if there isn’t required browser functions, returning stupid api
    else {
      var stupidPjax = noop;
      for (var key in Pjax.prototype) {
        if (Pjax.prototype.hasOwnProperty(key) && typeof Pjax.prototype[key] === "function") {
          stupidPjax[key] = noop;
        }
      }
      module.exports = stupidPjax;
    }
    });

    var PagePjax = /*#__PURE__*/_createClass$1(function PagePjax(reload) {
      _classCallCheck$1(this, PagePjax);
      /**
       * Enable seamless page navigation with pjax.
       */
      this.pjaxInstance = new pjax$1({
        elements: [".timemanager-pjax-link"],
        selectors: [".app-timemanager #app-navigation ul", ".app-timemanager #app-content .container"],
        cacheBust: false,
        scrollTo: true
      });
      document.addEventListener("pjax:send", function () {
        document.body.classList.add("loading");
        document.body.classList.remove("loading-error");
        document.body.classList.remove("tm_ready");
      });
      document.addEventListener("pjax:success", function () {
        setTimeout(function () {
          document.body.classList.remove("loading");
          reload();
        }, 300);
      });
      document.addEventListener("pjax:error", function (error) {
        // Catch session timeout and redirect to login
        if (error && error.request && error.request.status === 401) {
          document.location.href = "".concat(dist_1("login"), "?redirect_url=").concat(dist_1("timemanager", "index"));
        }
        document.body.classList.remove("loading");
        document.body.classList.add("loading-error");
      });
    });

    const debug = typeof browser$1 === 'object' && browser$1.env && browser$1.env.NODE_DEBUG && /\bsemver\b/i.test(browser$1.env.NODE_DEBUG) ? (...args) => console.error('SEMVER', ...args) : () => {};
    var debug_1 = debug;

    // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.
    const SEMVER_SPEC_VERSION = '2.0.0';
    const MAX_LENGTH$1 = 256;
    const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */9007199254740991;

    // Max safe segment length for coercion.
    const MAX_SAFE_COMPONENT_LENGTH = 16;

    // Max safe length for a build identifier. The max length minus 6 characters for
    // the shortest version with a build 0.0.0+BUILD.
    const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
    const RELEASE_TYPES = ['major', 'premajor', 'minor', 'preminor', 'patch', 'prepatch', 'prerelease'];
    var constants = {
      MAX_LENGTH: MAX_LENGTH$1,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 0b001,
      FLAG_LOOSE: 0b010
    };

    var re_1 = createCommonjsModule(function (module, exports) {
    const {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = constants;

    exports = module.exports = {};

    // The actual regexps go on exports.re
    const re = exports.re = [];
    const safeRe = exports.safeRe = [];
    const src = exports.src = [];
    const t = exports.t = {};
    let R = 0;
    const LETTERDASHNUMBER = '[a-zA-Z0-9-]';

    // Replace some greedy regex tokens to prevent regex dos issues. These regex are
    // used internally via the safeRe object since all inputs in this library get
    // normalized first to trim and collapse all extra whitespace. The original
    // regexes are exported for userland consumption and lower level usage. A
    // future breaking change could export the safer regex only with a note that
    // all input should have extra whitespace removed.
    const safeRegexReplacements = [['\\s', 1], ['\\d', MAX_LENGTH], [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]];
    const makeSafeRegex = value => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    const createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug_1(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
      safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
    };

    // The following Regular Expressions can be used for tokenizing,
    // validating, and parsing SemVer version strings.

    // ## Numeric Identifier
    // A single `0`, or a non-zero digit followed by zero or more digits.

    createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
    createToken('NUMERICIDENTIFIERLOOSE', '\\d+');

    // ## Non-numeric Identifier
    // Zero or more digits, followed by a letter or hyphen, and then zero or
    // more letters, digits, or hyphens.

    createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);

    // ## Main Version
    // Three dot-separated numeric identifiers.

    createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
    createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

    // ## Pre-release Version Identifier
    // A numeric identifier, or a non-numeric identifier.

    createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);

    // ## Pre-release Version
    // Hyphen, followed by one or more dot-separated pre-release version
    // identifiers.

    createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

    // ## Build Metadata Identifier
    // Any combination of digits, letters, or hyphens.

    createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);

    // ## Build Metadata
    // Plus sign, followed by one or more period-separated build metadata
    // identifiers.

    createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

    // ## Full Version String
    // A main version, followed optionally by a pre-release version and
    // build metadata.

    // Note that the only major, minor, patch, and pre-release sections of
    // the version string are capturing groups.  The build metadata is not a
    // capturing group, because it should not ever be used in version
    // comparison.

    createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken('FULL', `^${src[t.FULLPLAIN]}$`);

    // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
    // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
    // common in the npm registry.
    createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
    createToken('GTLT', '((?:<|>)?=?)');

    // Something like "2.*" or "1.2.x".
    // Note that "x.x" is a valid xRange identifer, meaning "any version"
    // Only the first item is strictly required.
    createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
    createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
    createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

    // Coercion.
    // Extract anything that could conceivably be a part of a valid semver
    createToken('COERCEPLAIN', `${'(^|[^\\d])' + '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken('COERCEFULL', src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
    createToken('COERCERTL', src[t.COERCE], true);
    createToken('COERCERTLFULL', src[t.COERCEFULL], true);

    // Tilde ranges.
    // Meaning is "reasonably at or greater than"
    createToken('LONETILDE', '(?:~>?)');
    createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = '$1~';
    createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

    // Caret ranges.
    // Meaning is "at least and backwards compatible with"
    createToken('LONECARET', '(?:\\^)');
    createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = '$1^';
    createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

    // A simple gt/lt/eq thing, or just "" to indicate "any version"
    createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

    // An expression to strip any whitespace between the gtlt and the thing
    // it modifies, so that `> 1.2.3` ==> `>1.2.3`
    createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = '$1$2$3';

    // Something like `1.2.3 - 1.2.4`
    // Note that these all use the loose form, because they'll be
    // checked against either the strict or loose comparator form
    // later.
    createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
    createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);

    // Star ranges basically just allow anything at all.
    createToken('STAR', '(<|>)?=?\\s*\\*');
    // >=0.0.0 is like a star
    createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
    createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
    });
    re_1.re;
    re_1.safeRe;
    re_1.src;
    re_1.t;
    re_1.tildeTrimReplace;
    re_1.caretTrimReplace;
    re_1.comparatorTrimReplace;

    // parse out just the options we care about
    const looseOption = Object.freeze({
      loose: true
    });
    const emptyOpts = Object.freeze({});
    const parseOptions = options => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== 'object') {
        return looseOption;
      }
      return options;
    };
    var parseOptions_1 = parseOptions;

    const numeric = /^[0-9]+$/;
    const compareIdentifiers$1 = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
    var identifiers = {
      compareIdentifiers: compareIdentifiers$1,
      rcompareIdentifiers
    };

    const {
      MAX_LENGTH,
      MAX_SAFE_INTEGER
    } = constants;
    const {
      safeRe: re,
      t
    } = re_1;

    const {
      compareIdentifiers
    } = identifiers;
    class SemVer {
      constructor(version, options) {
        options = parseOptions_1(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== 'string') {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug_1('SemVer', version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;

        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError('Invalid major version');
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError('Invalid minor version');
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError('Invalid patch version');
        }

        // numberify any prerelease numeric ids
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split('.').map(id => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split('.') : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join('.')}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug_1('SemVer.compare', this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === 'string' && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }

        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug_1('prerelease compare', i, a, b);
          if (a === undefined && b === undefined) {
            return 0;
          } else if (b === undefined) {
            return 1;
          } else if (a === undefined) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug_1('build compare', i, a, b);
          if (a === undefined && b === undefined) {
            return 0;
          } else if (b === undefined) {
            return 1;
          } else if (a === undefined) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }

      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case 'premajor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc('pre', identifier, identifierBase);
            break;
          case 'preminor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc('pre', identifier, identifierBase);
            break;
          case 'prepatch':
            // If this is already a prerelease, it will bump to the next version
            // drop any prereleases that might already exist, since they are not
            // relevant at this point.
            this.prerelease.length = 0;
            this.inc('patch', identifier, identifierBase);
            this.inc('pre', identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case 'prerelease':
            if (this.prerelease.length === 0) {
              this.inc('patch', identifier, identifierBase);
            }
            this.inc('pre', identifier, identifierBase);
            break;
          case 'major':
            // If this is a pre-major version, bump up to the same major version.
            // Otherwise increment major.
            // 1.0.0-5 bumps to 1.0.0
            // 1.1.0 bumps to 2.0.0
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case 'minor':
            // If this is a pre-minor version, bump up to the same minor version.
            // Otherwise increment minor.
            // 1.2.0-5 bumps to 1.2.0
            // 1.2.1 bumps to 1.3.0
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case 'patch':
            // If this is not a pre-release version, it will increment the patch.
            // If it is a pre-release it will bump up to the same patch version.
            // 1.2.0-5 patches to 1.2.0
            // 1.2.0 patches to 1.2.1
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case 'pre':
            {
              const base = Number(identifierBase) ? 1 : 0;
              if (!identifier && identifierBase === false) {
                throw new Error('invalid increment argument: identifier is empty');
              }
              if (this.prerelease.length === 0) {
                this.prerelease = [base];
              } else {
                let i = this.prerelease.length;
                while (--i >= 0) {
                  if (typeof this.prerelease[i] === 'number') {
                    this.prerelease[i]++;
                    i = -2;
                  }
                }
                if (i === -1) {
                  // didn't increment anything
                  if (identifier === this.prerelease.join('.') && identifierBase === false) {
                    throw new Error('invalid increment argument: identifier already exists');
                  }
                  this.prerelease.push(base);
                }
              }
              if (identifier) {
                // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                let prerelease = [identifier, base];
                if (identifierBase === false) {
                  prerelease = [identifier];
                }
                if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = prerelease;
                  }
                } else {
                  this.prerelease = prerelease;
                }
              }
              break;
            }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join('.')}`;
        }
        return this;
      }
    }
    var semver = SemVer;

    const parse = (version, options, throwErrors = false) => {
      if (version instanceof semver) {
        return version;
      }
      try {
        return new semver(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    var parse_1 = parse;

    const valid = (version, options) => {
      const v = parse_1(version, options);
      return v ? v.version : null;
    };
    var valid_1 = valid;

    const major = (a, loose) => new semver(a, loose).major;
    var major_1 = major;

    class ProxyBus {
      bus;
      constructor(bus) {
        if (typeof bus.getVersion !== 'function' || !valid_1(bus.getVersion())) {
          console.warn('Proxying an event bus with an unknown or invalid version');
        } else if (major_1(bus.getVersion()) !== major_1(this.getVersion())) {
          console.warn('Proxying an event bus of version ' + bus.getVersion() + ' with ' + this.getVersion());
        }
        this.bus = bus;
      }
      getVersion() {
        return "3.0.2";
      }
      subscribe(name, handler) {
        this.bus.subscribe(name, handler);
      }
      unsubscribe(name, handler) {
        this.bus.unsubscribe(name, handler);
      }
      emit(name, event) {
        this.bus.emit(name, event);
      }
    }
    class SimpleBus {
      handlers = new Map();
      getVersion() {
        return "3.0.2";
      }
      subscribe(name, handler) {
        this.handlers.set(name, (this.handlers.get(name) || []).concat(handler));
      }
      unsubscribe(name, handler) {
        this.handlers.set(name, (this.handlers.get(name) || []).filter(h => h != handler));
      }
      emit(name, event) {
        (this.handlers.get(name) || []).forEach(h => {
          try {
            h(event);
          } catch (e) {
            console.error('could not invoke event listener', e);
          }
        });
      }
    }
    function getBus() {
      if (typeof window.OC !== 'undefined' && window.OC._eventBus && typeof window._nc_event_bus === 'undefined') {
        console.warn('found old event bus instance at OC._eventBus. Update your version!');
        window._nc_event_bus = window.OC._eventBus;
      }
      // Either use an existing event bus instance or create one
      if (typeof window._nc_event_bus !== 'undefined') {
        return new ProxyBus(window._nc_event_bus);
      } else {
        return window._nc_event_bus = new SimpleBus();
      }
    }
    const bus = getBus();
    /**
     * Register an event listener
     *
     * @param name name of the event
     * @param handler callback invoked for every matching event emitted on the bus
     */
    function subscribe(name, handler) {
      bus.subscribe(name, handler);
    }

    const tokenElement = document.getElementsByTagName('head')[0];
    let token$1 = tokenElement ? tokenElement.getAttribute('data-requesttoken') : null;
    const observers = [];
    function getRequestToken() {
      return token$1;
    }
    // Listen to server event and keep token in sync
    subscribe('csrf-token-update', e => {
      token$1 = e.token;
      observers.forEach(observer => {
        try {
          observer(e.token);
        } catch (e) {
          console.error('error updating CSRF token observer', e);
        }
      });
    });

    /// <reference types="@nextcloud/typings" />
    const getAttribute = (el, attribute) => {
      if (el) {
        return el.getAttribute(attribute);
      }
      return null;
    };
    const head = document.getElementsByTagName('head')[0];
    getAttribute(head, 'data-user');
    getAttribute(head, 'data-user-displayname');
    typeof OC === 'undefined' ? false : OC.isUserAdmin();

    var token = getRequestToken();
    var components = [];
    var pjax = [];
    var defaultDateFormat = "EEEE, MMMM d, y";
    var localeOptions = Helpers.getDateLocaleOptions();
    $(document).ready(function () {
      if ($('input[name="duration"]').length > 0) {
        $('input[name="duration"]')[0].focus();
      }
    });
    var safelyCreateComponent = function safelyCreateComponent(_ref) {
      var Component = _ref.component,
        selector = _ref.selector,
        _ref$props = _ref.props,
        props = _ref$props === void 0 ? {} : _ref$props;
      var node = document.querySelector(selector);
      if (node) {
        return new Component({
          target: Helpers.replaceNode(node),
          props
        });
      }
    };
    var init = function init() {
      // Destroy all previous components
      while (components.length) {
        var component = components.pop();
        if (!component) {
          continue;
        }
        try {
          component.$destroy();
        } catch (error) {
          console.error(error);
        }
      }
      var store = {};
      var storeElement = document.querySelector("#content.app-timemanager [data-store]");
      if (storeElement) {
        try {
          store = JSON.parse(storeElement.getAttribute("data-store"));
        } catch (error) {
          console.error(error);
        }
      }
      components.push(safelyCreateComponent({
        component: Statistics,
        selector: "#content.app-timemanager [data-svelte='Statistics.svelte']",
        props: _objectSpread2({}, store)
      }));
      components.push(safelyCreateComponent({
        component: Filters,
        selector: "#content.app-timemanager [data-svelte='Filters.svelte']",
        props: _objectSpread2({}, store)
      }));
      components.push(safelyCreateComponent({
        component: ClientEditorDialog,
        selector: "#content.app-timemanager [data-svelte='ClientEditorDialog.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          action: "",
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: ProjectEditorDialog,
        selector: "#content.app-timemanager [data-svelte='ProjectEditorDialog.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: TaskEditorDialog,
        selector: "#content.app-timemanager [data-svelte='TaskEditorDialog.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: TimeEditorDialog,
        selector: "#content.app-timemanager [data-svelte='TimeEditorDialog.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: DeleteButton,
        selector: "#content.app-timemanager [data-svelte='DeleteButton.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: ShareDialog,
        selector: "#content.app-timemanager [data-svelte='ShareDialog.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: ShareStatus,
        selector: "#content.app-timemanager [data-svelte='ShareStatus.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      var deleteTimeEntryButtons = document.querySelectorAll("#content.app-timemanager [data-svelte='DeleteTimeEntryButton.svelte']");
      if (deleteTimeEntryButtons && deleteTimeEntryButtons.length > 0) {
        deleteTimeEntryButtons.forEach(function (button) {
          components.push(new DeleteTimeEntryButton({
            target: Helpers.replaceNode(button),
            props: _objectSpread2(_objectSpread2({}, store), {}, {
              deleteTimeEntryUuid: button.getAttribute("data-uuid"),
              requestToken: token
            })
          }));
        });
      }
      var editTimeEntryButtons = document.querySelectorAll("#content.app-timemanager [data-svelte='EditTimeEntryButton.svelte']");
      if (editTimeEntryButtons && editTimeEntryButtons.length > 0) {
        editTimeEntryButtons.forEach(function (button) {
          components.push(new TimeEditorDialog({
            target: Helpers.replaceNode(button),
            props: _objectSpread2(_objectSpread2({}, store), {}, {
              timeUuid: button.getAttribute("data-uuid"),
              editTimeEntryData: JSON.parse(button.getAttribute("data-edit-data")),
              timeEditorButtonCaption: translate("timemanager", "Edit"),
              timeEditorCaption: translate("timemanager", "Edit time entry"),
              requestToken: token
            })
          }));
        });
      }
      components.push(safelyCreateComponent({
        component: QuickAdd,
        selector: "#content.app-timemanager [data-svelte='QuickAdd.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      var checkmarkButtons = document.querySelectorAll("#content.app-timemanager [data-svelte='Checkmark.svelte']");
      if (checkmarkButtons && checkmarkButtons.length > 0) {
        checkmarkButtons.forEach(function (button) {
          components.push(new Checkmark({
            target: Helpers.replaceNode(button),
            props: _objectSpread2(_objectSpread2({}, store), {}, {
              uuid: button.getAttribute("data-uuid"),
              action: button.getAttribute("data-action"),
              initialState: button.getAttribute("data-initialState"),
              requestToken: token
            })
          }));
        });
      }
      components.push(safelyCreateComponent({
        component: PrintButton,
        selector: "#content.app-timemanager [data-svelte='PrintButton.svelte']"
      }));
      components.push(safelyCreateComponent({
        component: Import,
        selector: "#content.app-timemanager [data-svelte='Import.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));
      components.push(safelyCreateComponent({
        component: UserFilterButton,
        selector: "#content.app-timemanager [data-svelte='UserFilterButton.svelte']",
        props: _objectSpread2(_objectSpread2({}, store), {}, {
          requestToken: token
        })
      }));

      // components.push(
      // 	new Settings({
      // 		target: Helpers.replaceNode(document.querySelector("#content.app-timemanager [data-svelte='Settings.svelte']")),
      // 		props: {
      // 			...store,
      // 			requestToken: token,
      // 		},
      // 	})
      // );

      var dateTimeElements = document.querySelectorAll("[data-datetime]");
      if (dateTimeElements && dateTimeElements.length > 0) {
        dateTimeElements.forEach(function (element) {
          var _store$settings$fullD, _store;
          var datetime = element.getAttribute("data-datetime");
          if (!datetime) {
            return;
          }
          element.innerText = format$2(parseISO(datetime), (_store$settings$fullD = (_store = store) === null || _store === void 0 || (_store = _store.settings) === null || _store === void 0 ? void 0 : _store.fullDateFormat) !== null && _store$settings$fullD !== void 0 ? _store$settings$fullD : defaultDateFormat, localeOptions);
        });
      }
      var addTimezoneLinkElements = document.querySelectorAll("[data-add-timezone-link]");
      if (addTimezoneLinkElements && addTimezoneLinkElements.length > 0) {
        addTimezoneLinkElements.forEach(function (element) {
          if (element.href.includes("?")) {
            element.href += "&timezone=".concat(Helpers.getTimezone());
          } else {
            element.href += "?timezone=".concat(Helpers.getTimezone());
          }
        });
      }
      document.body.classList.add("tm_ready");
    };
    init();
    pjax.push(new PagePjax(init));

})();
